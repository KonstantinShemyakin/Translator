
S_                       
                         ::= Program                  
                         
Program                  
                         ::= Defines                  
                         
DefParInit               
                         ::= =                           { CODE(BegParVarAssign); }                           Assign                      { MAKE(ParVarAssign); }  
                         |   
                         
DefParVar                
                         ::= Syntax_DefVar               { YACC(DefType); }          Ident_lexeme                { MAKE(DefParVar); }        DefParInit                  { NODE(DefVar,(2,1)); }  
                         
DefParArr                
                         ::= Syntax_DefArr               { YACC(DefType); }          Syntax_IdentArr             { MAKE(DefParArr); }        DefArrDA                    { NODE(DefArr,(3,0,1)); }   DefParInit                  { NODE(DefArr,(1,2),2); }
                         
DefPar                   
                         ::= DefParArr                
                         |   DefParVar                
                         
DefParItem               
                         ::= DefPar                      { TREE(AddToList); }     
                         
DefParList               
                         ::= ,                           DefParItem                  { YACC(AddToList,6); }      DefParList               
                         |   
                         
DefParams                
                         ::= { TREE(Define,2); }         DefParItem                  { NODE(Define,(1,2),1); }   DefParList                  { TREE(EndParams); }     
                         
BodyFunc                 
                         ::= ;                           { MAKE(BodyFunc); }      
                         |   Syntax_EmptyCramp           { MAKE(BodyFunc,1); }       { NODE(Null,(1)); }      
                         |   '{'                         { CODE(EndParams); }        StmExpr                     { NODE(None,(1)); }         '}'                         { MAKE(BodyFunc,2); }    
                         
DefFunc_                 
                         ::= Syntax_EmptyBracket         { TREE(EndParams,2); }   
                         |   (                           DefParams                   { NODE(None,(1)); }         )                        
                         
DefFunc                  
                         ::= Syntax_DefFunc              { NODE(DefFunc,(0)); }      Syntax_IdentFunc            { NODE(DefFunc,(0),1); }    { MAKE(FuncIdent); }        DefFunc_                    { NODE(DefFunc,(0),2); }    BodyFunc                    { NODE(DefFunc,(0),3); } 
                         
AInitialList             
                         ::= ,                           AInitItem                   { YACC(AddToList,6); }      { TREE(AddToList); }        AInitialList             
                         |   
                         
AInitial                 
                         ::= AInitItem                   { TREE(AddToList); }        { YACC(AddToList,6); }      AInitialList             
                         
Initializer              
                         ::= Syntax_EmptyCramp           { CODE(BegInitial); }       { TREE(NodeListLL); }       { NODE(List,(0)); }      
                         |   '{'                         { CODE(BegInitial,1); }     { TREE(NodeListLL); }       { NODE(List,(0,2)); }       AInitial                    '}'                         { CODE(EndInitial); }    
                         
AInitItem                
                         ::= Initializer              
                         |   Assign                      { CODE(AInitItem); }     
                         
DefAInit                 
                         ::= =                           { CODE(BegAInit); }         Initializer                 { MAKE(EndAInit); }      
                         |   
                         
DRanges                  
                         ::= [                           Assign                      { YACC(AddToList,10); }     ]                           { MAKE(DRange); }           DRanges                  
                         |   
                         
DefArrD1A                
                         ::= Syntax_EmptyScrape          { MAKE(DefArrD1AEmpty); }   { NODE(Ranges,(0),5); }  
                         |   [                           Assign                      { NODE(Ranges,(1),2); }     ]                           { MAKE(DRange); }        
                         
DefArrDA                 
                         ::= DefArrD1A                   { NODE(None,(1,2)); }       DRanges                     { CODE(EndRanges); }     
                         
DefArr                   
                         ::= Syntax_IdentArr             { MAKE(DefArray); }         DefArrDA                    { NODE(DefArr,(0,0,1)); }   DefAInit                    { NODE(DefArr,(1,2),2); }
                         
DefVarAssign             
                         ::= =                           { CODE(BegDefVarAssign); }                           Assign                      { MAKE(DefVarAssign); }  
                         
DefVarInit               
                         ::= DefVarAssign             
                         |   
                         
DefVar                   
                         ::= Ident_lexeme                { MAKE(DefIdent); }         DefVarInit                  { NODE(DefVar,(0,1)); }  
                         
DefIAV                   
                         ::= DefArr                   
                         |   DefVar                   
                         
DefItem                  
                         ::= Priority_And                DefIAV                      { TREE(RefDef); }           { NODE(RefDef,(1)); }    
                         |   DefIAV                   
                         
DefType                  
                         ::= Syntax_DefArr            
                         |   Syntax_DefVar            
                         
DefineList               
                         ::= ,                           DefItem                     { YACC(AddToList,6); }      { TREE(AddToList); }        DefineList               
                         |   
                         
Define                   
                         ::= DefType                     { MAKE(Define); }           { NODE(Define,(4)); }       DefItem                     { YACC(AddToList,2); }      { TREE(AddToList); }        DefineList                  { CODE(EndDefine); }     
                         
ConditionDef             
                         ::= Priority_And                DefVar                      { TREE(RefDef); }           { NODE(RefDef,(1)); }    
                         |   DefVar                   
                         
Condition                
                         ::= Syntax_DefVar               { MAKE(Define); }           ConditionDef                { MAKE(PushDef); }          { NODE(None,(1)); }      
                         |   ExpressionCondition      
                         
ExprList                 
                         ::= ,                           Assign                      { YACC(AddToList,6); }      { TREE(AddToList); }        { CODE(AddToExpr); }        ExprList                 
                         |   
                         
Expressions              
                         ::= Assign                      { MAKE(ExpressionsLL); }    { NODE(Expressions,(2,3),1); }                       ExprList                    { CODE(ExpressionSLL); } 
                         
PriorAssign              
                         ::= Priority_Assign          
                         
AssignList               
                         ::= PriorAssign                 { NODE(None,(2),2); }       Assign                      { MAKE(Binary); }           { NODE(Binary,(2,1)); }  
                         |   
                         
Assign                   
                         ::= Question                    { NODE(None,(1,2)); }       AssignList               
                         
QuestionList             
                         ::= Priority_Question           { CODE(BegQuestion); }      ExpressionValue             { NODE(Trio,(0)); }         :                           { CODE(MidQuestion); }      Question                    { NODE(Trio,(0),1); }       { MAKE(Question); }      
                         |   
                         
Question                 
                         ::= OrOr                        { NODE(None,(1,2)); }       QuestionList             
                         
OrOr                     
                         ::= AndAnd                      { NODE(None,(1,2)); }       OrOr_                    
                         
OrOr_                    
                         ::= Priority_OrOr               AndAnd                      { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   OrOr_                    
                         |   
                         
AndAnd                   
                         ::= Or                          { NODE(None,(1,2)); }       AndAnd_                  
                         
AndAnd_                  
                         ::= Priority_AndAnd             Or                          { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   AndAnd_                  
                         |   
                         
Or                       
                         ::= XOr                         { NODE(None,(1,2)); }       Or_                      
                         
Or_                      
                         ::= Priority_Or                 XOr                         { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   Or_                      
                         |   
                         
XOr                      
                         ::= And                         { NODE(None,(1,2)); }       XOr_                     
                         
XOr_                     
                         ::= Priority_XOr                And                         { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   XOr_                     
                         |   
                         
And                      
                         ::= Equ                         { NODE(None,(1,2)); }       And_                     
                         
And_                     
                         ::= Priority_And                Equ                         { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   And_                     
                         |   
                         
Equ                      
                         ::= Compare                     { NODE(None,(1,2)); }       Equ_                     
                         
Equ_                     
                         ::= Priority_Equ                Compare                     { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   Equ_                     
                         |   
                         
Compare                  
                         ::= Shift                       { NODE(None,(1,2)); }       Compare_                 
                         
Compare_                 
                         ::= Priority_Compare            Shift                       { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   Compare_                 
                         |   
                         
Shift                    
                         ::= Term                        { NODE(None,(1,2)); }       Shift_                   
                         
Shift_                   
                         ::= Priority_Shift              Term                        { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   Shift_                   
                         |   
                         
Term                     
                         ::= Factor                      { NODE(None,(1,2)); }       Term_                    
                         
Term_                    
                         ::= Priority_Term               Factor                      { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   Term_                    
                         |   
                         
Factor                   
                         ::= Unary                       { NODE(None,(1,2)); }       Factor_                  
                         
Factor_                  
                         ::= Priority_Factor             Unary                       { MAKE(Binary); }           { NODE(Binary,(3,1,2)); }   Factor_                  
                         |   
                         
UnaryIncDec              
                         ::= Priority_IncDec             { MAKE(IncDec); }           { NODE(Unary,(2),1); }   
                         |   
                         
Unary                    
                         ::= Priority_Unary              Unary                       { MAKE(Unary); }            { NODE(Unary,(1,2)); }   
                         |   Priority_Term               Unary                       { MAKE(Unary); }            { NODE(Unary,(1,2),1); } 
                         |   Priority_IncDec             Unary                       { MAKE(Unary); }            { NODE(Unary,(1,2)); }   
                         |   Syntax_CastUnary            Unary                       { MAKE(Cast); }             { NODE(Cast,(1,2)); }    
                         |   PrimaryExpr                 { NODE(None,(1,2)); }       UnaryIncDec              
                         
Primary                  
                         ::= (                           ExpressionNone              { NODE(None,(1)); }         )                           { TREE(Primary); }       
                         
PrimaryExpr              
                         ::= Integer_lexeme              { MAKE(Number); }           { NODE(Number,(1)); }    
                         |   Number_lexeme               { MAKE(Number); }           { NODE(Number,(1)); }    
                         |   Syntax_IdentArr             Ranges                      { NODE(Index,(1)); }     
                         |   Syntax_IdentFunc            CallParams                  { NODE(Call,(1)); }      
                         |   Syntax_Cast                 Primary                     { MAKE(Cast); }             { NODE(Cast,(1)); }      
                         |   Ident_lexeme                { MAKE(Ident); }            { NODE(Var,(1)); }       
                         |   Primary                  
                         
RangesList               
                         ::= [                           ExpressionValue             { YACC(AddToList,10); }     ]                           { MAKE(IndexLL); }          RangesList               
                         |   
                         
Ranges                   
                         ::= { MAKE(BegIndexLL); }       { NODE(List,(2,3)); }       RangesList                  { MAKE(EndIndex); }      
                         
CallParams               
                         ::= Syntax_EmptyBracket         { MAKE(Params); }           { NODE(List,(0)); }      
                         |   (                           ExpressionValueList         { NODE(None,(1)); }         )                           { MAKE(Params,1); }      
                         
CompaundStmnt            
                         ::= Syntax_EmptyCramp           { MAKE(Compaund); }         { CODE(EndBlock); }         { NODE(Null,(1)); }      
                         |   '{'                         { MAKE(Compaund); }         StmExpr                     { NODE(None,(1)); }         '}'                         { CODE(EndBlock); }         { TREE(AddToList); }     
                         
IfStmnt_                 
                         ::= else                        { CODE(Else); }             DefExpr                     { MAKE(If,1); }          
                         |   { MAKE(If); }            
                         
IfStmnt                  
                         ::= if                          (                           { CODE(BegIf); }            Condition                   { NODE(If,(1)); }           )                           { CODE(Then); }             DefExpr                     { NODE(If,(1),1); }         IfStmnt_                    { NODE(If,(1),2); }      
                         
ForPrefix                
                         ::= ;                           { TREE(NodeNull); }         { NODE(Null,(1)); }      
                         |   DefineSemi               
                         |   ExprSemi                 
                         
ForCondition             
                         ::= ;                           { MAKE(NodeNull); }         { NODE(Null,(1)); }      
                         |   Condition                   { NODE(None,(1)); }         ;                        
                         
ForPosfix                
                         ::= )                           { TREE(NodeNull); }         { NODE(Null,(1)); }      
                         |   ExpressionExpression        { NODE(None,(1)); }         )                        
                         
ForStmnt                 
                         ::= for                         (                           { MAKE(BegFor); }           ForPrefix                   { CODE(PrefFor); }          { NODE(For,(1)); }          ForCondition                { CODE(ConditionFor); }     { NODE(For,(1),1); }        ForPosfix                   { CODE(PostFor); }          { NODE(For,(1),2); }        DefExpr                     { NODE(For,(1),3); }        { MAKE(For); }           
                         
DoStmnt                  
                         ::= do                          { MAKE(BegDo); }            DefExpr                     { NODE(None,(1)); }         while                       (                           { CODE(MidDo); }            Condition                   { NODE(Do,(1,4)); }         )                           ;                           { MAKE(Do); }            
                         
WhileStmnt               
                         ::= while                       { MAKE(BegWhile); }         (                           Condition                   { NODE(None,(1)); }         )                           { CODE(MidWhile); }         DefExpr                     { MAKE(While); }            { NODE(While,(2,1)); }   
                         
GoToStmnt                
                         ::= goto                        Ident_lexeme                ;                           { NODE(GoTo,(1)); }         { MAKE(GoTo); }          
                         
BreakStmnt               
                         ::= break                       ;                           { MAKE(Break); }            { NODE(Break,(1)); }     
                         
ContinueStmnt            
                         ::= continue                    ;                           { MAKE(Continue); }         { NODE(Continue,(1)); }  
                         
ReturnVal                
                         ::= ExpressionValue             { MAKE(Return,1); }      
                         |   { MAKE(Return); }        
                         
ReturnStmnt              
                         ::= return                      ReturnVal                   { NODE(Return,(1)); }       ;                        
                         
Statement                
                         ::= Syntax_Label                :                           { CODE(Label); }            DefExpr                     { NODE(Label,(1)); }        { TREE(Label); }         
                         |   IfStmnt                  
                         |   DoStmnt                  
                         |   WhileStmnt               
                         |   ForStmnt                 
                         |   GoToStmnt                
                         |   BreakStmnt               
                         |   ContinueStmnt            
                         |   ReturnStmnt              
                         |   CompaundStmnt            
                         
DefineSemi               
                         ::= Define                      { NODE(None,(1)); }         ;                        
                         
ExprSemi                 
                         ::= ExpressionExpression        { NODE(None,(1)); }         ;                        
                         
DefExpr                  
                         ::= ;                           { TREE(NodeNull); }         { NODE(Null,(1)); }      
                         |   DefineSemi               
                         |   Statement                
                         |   ExprSemi                 
                         
StmExprList              
                         ::= DefExpr                     { YACC(AddToList,6); }      { TREE(AddToList); }        StmExprList              
                         |   
                         
StmExpr                  
                         ::= { MAKE(BegStmExprLL); }     { NODE(Statements,(2,3)); }                          StmExprList                 { CODE(EndBlock); }      
                         
DefFAV                   
                         ::= ;                           { TREE(NodeNull); }         { NODE(Null,(1)); }      
                         |   DefFunc                  
                         |   DefineSemi               
                         
DefinesList              
                         ::= DefFAV                      { YACC(AddToList,6); }      { TREE(AddToList); }        DefinesList              
                         |   
                         
Defines                  
                         ::= { MAKE(BegStmExprLL); }     { NODE(Statements,(2,3)); }                          DefinesList                 { CODE(EndBlock); }      
                         
ExpressionExpression     
                         ::= { CODE(Part,16); }          Expressions                 { TREE(ExpressionSLL,16); }                          { YACC(ExpressionSLL,16); }                       
                         
ExpressionCondition      
                         ::= { CODE(Part,241); }         Expressions                 { TREE(ExpressionSLL,241); }                         { YACC(ExpressionSLL,241); }                      
                         
ExpressionNone           
                         ::= { CODE(Part); }             Expressions                 { TREE(ExpressionSLL); }    { YACC(ExpressionSLL); } 
                         
ExpressionValue          
                         ::= { CODE(Part,256); }         Expressions                 { TREE(ExpressionSLL,256); }                         { YACC(ExpressionSLL,256); }                      
                         
ExpressionValueList      
                         ::= { CODE(Part,512); }         Expressions                 { TREE(ExpressionSLL,512); }                         { YACC(ExpressionSLL,512); }                      
                         
