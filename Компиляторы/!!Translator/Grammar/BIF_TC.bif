
S_             
               ::= Program              
               
Program        ::= Defines              
               
DefinesList    ::= DefFAV               /. TREE(BegStmExpr,1);   ./   [  DefFAV        /. TREE(AddToList); ./    ]...
               
Defines        ::= /. CODE(BegStmExpr); ./       DefinesList        /. CODE(EndBlock); ./      
                         
DefBegParVar   ::= Ident_lexeme         /. MAKE(DefParVar); ./        
               
DefParVar      ::= DefBegParVar         [   =                       /. CODE(BegParVarAssign); ./  Assign                      /. MAKE(ParVarAssign); ./     ]
               
DefBegParArr   ::= Syntax_IdentArr      /. MAKE(DefParArr); ./      DefRanges                
               
DefParArr      ::= DefBegParArr         [   =                       /. CODE(BegParVarAssign); ./  Assign                      /. MAKE(ParVarAssign); ./     ]
               
DefParItem     ::= { Syntax_DefArr      DefParArr               |   Syntax_DefVar        DefParVar   }
               
DefParams      ::= DefParItem           /. TREE(AddToList); ./  [    ,    DefParItem           /. TREE(AddToList); ./       ]...
               
BodyFunc       ::= {
                   ;                    /. MAKE(BodyFunc); ./         
               |   Syntax_EmptyCramp    /. MAKE(BodyFunc,1); ./       
               |   '{'                  /. CODE(EndParams); ./      /. MAKE(BegStmExpr); ./       StmExpr                  '}'                         /. MAKE(BodyFunc,2); ./    
                   }
               
DefFunc_       ::= {
                   Syntax_EmptyBracket  
               |   (                    /. TREE(Define,2); ./       DefParams                   )                           /. TREE(EndParams); ./        
                   }
               
DefFunc        ::= Syntax_DefFunc       Syntax_IdentFunc            /. MAKE(FuncIdent); ./        DefFunc_                    BodyFunc                    
               
AInitItem      ::= {   Initializer      |   Assign                  /. CODE(AInitItem); ./      }
               
AInitial       ::= AInitItem            /. TREE(AddToList); ./      [   AInitial        ,       AInitItem                   /. TREE(AddToList); ./        ]...
               
Initializer    ::= {
                   Syntax_EmptyCramp    /. CODE(BegInitial); ./     /. TREE(NodeList); ./         
               |   '{'                  /. CODE(BegInitial,1); ./   /. TREE(NodeList); ./       AInitial           '}'    /. CODE(EndInitial); ./    
                   }
               
DefRanges      ::= {   Syntax_EmptyScrape   /. MAKE(DefArrD1AEmpty); ./   |   '['  Assign   ']'    /. MAKE(DRange); ./    }   [   '['  Assign   ']'    /. MAKE(DRange); ./   ]...
               
DefBegArr      ::= Syntax_IdentArr      /. MAKE(DefArray); ./    DefRanges                  /. CODE(EndRanges); ./        
               
DefArr         ::= DefBegArr            [  =                     /. CODE(BegAInit); ./         Initializer                 /. MAKE(EndAInit); ./         ]
               
DefVarIdent    ::= Ident_lexeme         /. MAKE(DefIdent); ./         
               
DefVarAssign   ::= DefVarIdent          =                        /. CODE(BegDefVarAssign); ./  Assign                      /. MAKE(DefVarAssign); ./     
               
DefVar         ::= {    DefVarAssign    |   DefVarIdent          }
               
DefIAV         ::= {    DefArr          |   DefVar               }
               
RefDefIAV      ::= Priority_And         DefIAV                   /. TREE(RefDef); ./           
               
DefItem        ::= {    RefDefIAV       |   DefIAV               }
               
DefType        ::= {    Syntax_DefArr   |   Syntax_DefVar        }
               
DefineComma    ::= DefItem              /. TREE(AddToList); ./   [  ,   DefItem     /. TREE(AddToList); ./        ]...
               
Define         ::= DefType              /. MAKE(Define); ./      DefineComma                 /. CODE(EndDefine); ./     
               
CompaundStmnt  ::= {
                   Syntax_EmptyCramp    /. MAKE(Compaund); ./    /. CODE(EndBlock); ./         
               |   '{'                  /. MAKE(Compaund); ./    StmExpr                     '}'  
                   }
               
Condition_V    ::= {   Priority_And     DefVarAssign             /. TREE(RefDef); ./    |   DefVarAssign         }
               
Condition      ::= {   Syntax_DefVar    /. MAKE(Define); ./      Condition_V            /. MAKE(PushDef); ./     |   ExpressionCondition  }
               
For_Prefix     ::= {   ;                /. TREE(NodeNull); ./   |   DefineSemi          |   ExprSemi             }
               
For_Condition  ::= {   ;                /. MAKE(NodeNull); ./   |   Condition           ;                        }
               
For_Postfix    ::= {   )                /. TREE(NodeNull); ./   |   ExpressionExpression )                       }
               
ForStmnt       ::= for                  (                       /. CODE(BegFor); ./      For_Prefix               /. CODE(PrefFor); ./          For_Condition               /. CODE(ConditionFor); ./     For_Postfix                 /. CODE(PostFor); ./          DefExpr                     /. MAKE(For); ./              
               
ReturnValue    ::= {   ;                /. MAKE(Return); ./     |   ExpressionValue     ;   /. MAKE(Return,1); ./ }
               
ReturnStmnt    ::= return               ReturnValue             
               
BegIfStmnt     ::= if                   (                       /. CODE(BegIf); ./          Condition             )                           /. CODE(Then); ./             DefExpr                     
               
Statement      ::= {
                   BegIfStmnt           else                    /. CODE(Else); ./           DefExpr               /. MAKE(If,1); ./             
               |   BegIfStmnt           /. MAKE(If); ./         
               |   Syntax_Label         :                       /. CODE(Label); ./          DefExpr               /. TREE(Label); ./            
               |   do                   DefExpr                 while                       (                     Condition                   )                           ;                           /. MAKE(Do); ./               
               |   while                (                       Condition                   )                     DefExpr                     /. MAKE(While); ./            
               |   ForStmnt             
               |   switch               (                       )                        
               |   goto                 Ident_lexeme            ;                           /. MAKE(GoTo); ./             
               |   break                ;                       /. MAKE(Break); ./            
               |   continue             ;                       /. MAKE(Continue); ./         
               |   ReturnStmnt          
               |   CompaundStmnt        
                   }
               
DefineSemi     ::= Define               ;                       
               
ExprSemi       ::= ExpressionExpression ;                       
               
DefExpr        ::= {
                   ;               /. TREE(NodeNull); ./     
               |   DefineSemi      
               |   Statement       
               |   ExprSemi        
                   }
               
StmExpr        ::= DefExpr         /. TREE(AddToList); ./   [    DefExpr         /. TREE(AddToList); ./        ]...      /. CODE(EndBlock); ./   
               
DefFAV         ::= {
                   ;               /. TREE(NodeNull); ./      
               |   DefFunc                  
               |   DefineSemi               
                   }                         

Expressions    ::= Assign         /. MAKE(Expressions); ./  [     ,   Assign     /. TREE(AddToList); ./        /. CODE(AddToExpr); ./    ]...    


#ifdef PRIOR_ASSOCIATION
   #ifdef PRIOR_ASSIGN
       #define ASSIGN_ASSOCIATION
   #endif
#endif

#ifdef ASSIGN_ASSOCIATION
Assign         ::= { Assign       Priority_Assign    Assign               /. MAKE(Binary); ./   |   Question       }
#else
Assign         ::= Question //      [   PriorAssign    Assign               /. MAKE(Binary); ./   ]
#endif
               

PriorAssign    ::=
#ifdef PRIOR_ASSIGN
               Priority_Assign        
#else
               {  Oper_AddAssign  |  Oper_SubAssign  |  Oper_MultiAssign  |  Oper_DivAssign     |  Oper_ModAssign    |  Oper_Assign             
               |  Oper_OrAssign   |  Oper_XOrAssign  |  Oper_AndAssign    |  Oper_LShiftAssign  |  Oper_RShiftAssign      
               }
#endif
                         

#ifdef PRIOR_ASSOCIATION
Question       ::=
               {   Binary          Priority_Question  /. CODE(BegQuestion); ./      Question    :   /. CODE(MidQuestion); ./      Question    /. MAKE(Question); ./
               |   Binary          
               }
               
Binary         ::=
               {   Binary          Priority_OrOr      Binary   /. MAKE(Binary); ./
               |   Binary          Priority_AndAnd    Binary   /. MAKE(Binary); ./
               |   Binary          Priority_Or        Binary   /. MAKE(Binary); ./
               |   Binary          Priority_XOr       Binary   /. MAKE(Binary); ./
               |   Binary          Priority_And       Binary   /. MAKE(Binary); ./
               |   Binary          Priority_Equ       Binary   /. MAKE(Binary); ./
               |   Binary          Priority_Compare   Binary   /. MAKE(Binary); ./
               |   Binary          Priority_Shift     Binary   /. MAKE(Binary); ./
               |   Binary          Priority_Term      Binary   /. MAKE(Binary); ./
               |   Binary          Priority_Factor    Binary   /. MAKE(Binary); ./
               |   Unary                    
               }
#else
Question       ::=  OrOr  //  [ Priority_Question    /. CODE(BegQuestion); ./    Question      :    /. CODE(MidQuestion); ./    Question   /. MAKE(Question); ./   ]   
               
OrOr           ::=  AndAnd  [ Priority_OrOr        AndAnd     /. MAKE(Binary); ./ ]...
AndAnd         ::=  Or      [ Priority_AndAnd      Or         /. MAKE(Binary); ./ ]...
Or             ::=  XOr     [ Priority_Or          XOr        /. MAKE(Binary); ./ ]...
XOr            ::=  And     [ Priority_XOr         And        /. MAKE(Binary); ./ ]...
And            ::=  Equ     [ Priority_And         Equ        /. MAKE(Binary); ./ ]...
Equ            ::=  Compare [ Priority_Equ         Compare    /. MAKE(Binary); ./ ]...
Compare        ::=  Shift   [ Priority_Compare     Shift      /. MAKE(Binary); ./ ]...
Shift          ::=  Term    [ Priority_Shift       Term       /. MAKE(Binary); ./ ]...
Term           ::=  Factor  [ Priority_Term        Factor     /. MAKE(Binary); ./ ]...
//Factor         ::=  Unary   [ Priority_Factor      Unary      /. MAKE(Binary); ./ ]...
#endif
#ifdef TTTTT
Unary          ::= {  
                      {  Priority_Unary |   Priority_Term   |  Priority_IncDec   }  Unary  /. MAKE(Unary); ./
                   |   Syntax_CastUnary     Unary              /. MAKE(Cast);  ./              
                   |   UnaryIncDec 
//                   |   PrimaryExpr        [  Priority_IncDec      /. MAKE(IncDec); ./     ]
                   }       
               
UnaryIncDec    ::= { PrimaryExpr   //     [  Priority_IncDec      /. MAKE(IncDec); ./     ]
               |   PrimaryExpr        Priority_IncDec      /. MAKE(IncDec); ./  }
               
PrimaryExpr    ::= {
                   Integer_lexeme     /. MAKE(Number); ./        
               |   Number_lexeme      /. MAKE(Number); ./        
               |   Ident_lexeme       /. MAKE(Ident); ./        
               |   Syntax_IdentArr    Ranges                   /. MAKE(EndIndex); ./         
               |   Syntax_IdentFunc   CallParams               
               |   Syntax_Cast        Primary                  /. MAKE(Cast);     ./             
               |   Primary
                   }            
               
Primary        ::= ( ExpressionNone  )    /. TREE(Primary); ./          
#endif               

Factor                   
                         ::= {Factor                      Priority_Factor             Unary                       /. MAKE(Binary); ./           
                         |   Unary}                    
                         
UnaryIncDec              
                         ::= {PrimaryExpr                 Priority_IncDec             /. MAKE(IncDec); ./           
                     |       PrimaryExpr}              
                         
Unary                    
                         ::= {Priority_Unary              Unary                       /. MAKE(Unary); ./            
//                         |   Priority_Term               Unary                       /. MAKE(Unary); ./            
//                         |   Priority_IncDec             Unary                       /. MAKE(Unary); ./            
                         |   Syntax_CastUnary            Unary                       /. MAKE(Cast); ./             
                         |   UnaryIncDec              }
                         
Primary                  
                         ::= (                           ExpressionNone              )                           /. TREE(Primary); ./          
                         
PrimaryExpr              
                         ::= {Integer_lexeme              /. MAKE(Number); ./           
                         |   Number_lexeme               /. MAKE(Number); ./           
                         |   Syntax_IdentArr             Ranges                      /. MAKE(EndIndex); ./         
                         |   Syntax_IdentFunc            CallParams                    
                         |   Syntax_Cast                 Primary                     /. MAKE(Cast); ./               
                         |   Ident_lexeme                /. MAKE(Ident); ./                  
                         |   Primary}                  
                         


Range          ::= '['                ExpressionValue          ']'                        
               
Ranges         ::= Range              /. MAKE(BegIndex); ./    [  Range            /. MAKE(Index); ./  ]...
               
CallParams     ::= { Syntax_EmptyBracket    /. MAKE(Params);   ./    |   ( ExpressionValueList )   /. MAKE(Params,1); ./      }
                  
                                              
ExpressionExpression  ::= Expressions                /. MAKE(ExpressionS,16);  ./   
                      
ExpressionCondition   ::= Expressions                /. MAKE(ExpressionS,241); ./                            
                      
ExpressionNone        ::= Expressions                /. MAKE(ExpressionS);     ./   
                      
ExpressionValue       ::= Expressions                /. MAKE(ExpressionS,256); ./                            
                      
ExpressionValueList   ::= Expressions                /. MAKE(ExpressionS,512); ./                            
                         
