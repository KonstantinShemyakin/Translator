
#include "stdafx.h"

#include "Parse.h"
#include "ASyntax.h"
#include "TNodes.h"

// --------------------------- TError ---------------------------
bool TError::error(T_Error code, const T_Lexeme &l, int value)
{
  	printf("\nError:%-14s, error=%02d, value=%02d", syntax_error_title(code), code, value);
   if (code == T_Error::erSymbol) {
   	const char* text = symbol_table().Text(T_Symbol::T_Type(value));
   	printf(", symbol=%s", text);
   }
   printf("\n");
   l.print(Scan);
   return false;
}

void TErrorTable::Add(T_Error code, const T_Lexeme &l, int value)
{
   push_back(TErrorItem(code, l, value));
}

void TErrorTable::print() const
{
	printf("\n--- ErrorTable ---- %d ----\n",(int)size());
   for (const TErrorItem item : *this) {
      syntax->Error.error(item.code,item.lexeme,item.value);
   }
}

// ------------------------- A_Syntax -------------------------
A_Syntax::~A_Syntax()
{
}

bool A_Syntax::MatchMust(T_Symbol::T_Type t)
{
	if (Match(t)) return true;
	return error(T_Error::erSymbol,lex,t);
}

bool A_Syntax::error(T_Error code, const T_Lexeme &l, int value) 
{ 
   ErrorTable.Add(code,l,value);
   return false; //  Error.error(code, l, value);
}

// (result & mode): -1 - error, 0, 0x01 - define, 0x02 - const, 0x04 - static, 0x08 - &, 0x10 - after define, 0x20 - void
int  A_Syntax::SCDefine(T_Lexeme &l, int mode) 
{
   int def = 0;
   bool next;
   T_Lexeme l_;
   do {
      next = false;
		if (Match(l_, T_Lexeme::W_Type::rwDefine)) {
         l = l_;
         next = true;
         if (def & 0x21) { def = -1; break; }
         def |= 0x01;
         }
      if (Match(T_Lexeme::W_Type::rwVoid)) {
         l = l_;
         next = true;
         if (def & 0x21) { def = -1; break; }
         def |= 0x20;
         }
      if (Match(T_Lexeme::W_Type::rwConst)) {
         next = true;
         if ((def & 0x02) || !(mode & 0x02)) { def = -1; break; }
         def |= 0x02;
         if (def & 0x01) def |= 0x10;
         }
      if (Match(T_Lexeme::W_Type::rwStatic)) {
         next = true;
         if ((def & 0x04) || !(mode & 0x04)) { def = -1; break; }
         def |= 0x04;
         if (def & 0x01) def |= 0x10;
      }
   } while (next);

   if ((def > 0) && !(def & 0x21)) def = -1; // not define
   if ((def > 0) && (mode & 0x08) && Match(T_Symbol::T_Type::lxAnd)) def |= 0x08; // reference
   if (def < 0) { error(erDefine); }

   return def;
}

T_Lexeme::T_Group A_Syntax::Lexeme(T_Lexeme &l)
{
	SkipSpace();
   l = lex;
   if (!(syntax_lexeme & T_SyntaxLexeme::slSyntax)) {
      if (!(syntax_lexeme & T_SyntaxLexeme::slNoDefType) && (l.group == T_Lexeme::T_Group::grReserv) && (l.type >= T_Lexeme::W_Type::rwShort) && (l.type <= T_Lexeme::W_Type::rwDouble)) {
         l.value = l.type;
         l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxDefType;
      } else if ((syntax_lexeme & T_SyntaxLexeme::slPrior) && (l.group == T_Lexeme::grOper)) {
         const T_Symbol& symbol = symbol_table().Symbol(l.value);
         bool prior = !!symbol.priority;
         if ((symbol.priority == T_Symbol::prAssign) && !(syntax_lexeme & T_SyntaxLexeme::slPriorAssign)) prior = false;
         if (prior) {
            l.group = T_Lexeme::grPriority; l.type = symbol.priority;
         }
      }
      forward = l;
      Next();
   	if (option & T_OptionMode::omPrintLexeme) l.print(&this->Scan());
      return l.group;
   }
   int def = 0;
	if (Match(T_Lexeme::T_Group::grIdent)) {
      T_ScanStore store_ident; T_Parse::Store(store_ident);
		if (Match(T_Symbol::lxLeftBracket) || Match(T_Symbol::lxLeftScrape) || Match(T_Symbol::lxColon)) {
         int type = (forward.type == T_Symbol::lxLeftBracket) ? T_Lexeme::T_Syntax::sxIdentFunc : (
                    (forward.type == T_Symbol::lxLeftScrape ) ? T_Lexeme::T_Syntax::sxIdentArr  : T_Lexeme::T_Syntax::sxLabel);
         forward = l;
         l.group = T_Lexeme::T_Group::grSyntax; 
         l.type = type;
         T_Parse::Restore(store_ident);
      }
   } else if (l.Match(T_Lexeme::T_Group::grReserv)) {
      def = SCDefine(l,0x026); // 0x02 - const, 0x04 - static, 0x20 - void
      if (def < 0) { 
         l.group = T_Lexeme::T_Group::grError; 
      	if (option & T_OptionMode::omPrintLexeme) l.print(&this->Scan());
         return l.group;
      }
      T_ScanStore store_ref; T_Parse::Store(store_ref);
      if ((def > 0) && Match(T_Symbol::T_Type::lxAnd)) def |= 0x08; // reference
      if (def > 0) { // 0x02 - const, 0x04 - static, 0x08 - &, 0x20 - void
         T_ScanStore store_func; T_Parse::Store(store_func);
         if (Match(T_Lexeme::grIdent)) {
            int type ;
            if (Match(T_Symbol::lxLeftBracket)) {
               type = T_Lexeme::T_Syntax::sxDefFunc;
            } else if ((def > 0) && Match(T_Symbol::lxLeftScrape)) {
               type = !(syntax_lexeme & T_SyntaxLexeme::slNoDefArrVar) ? T_Lexeme::T_Syntax::sxDefArr : T_Lexeme::T_Syntax::sxDefType;
            } else {
               type = !(syntax_lexeme & T_SyntaxLexeme::slNoDefArrVar) ? T_Lexeme::T_Syntax::sxDefVar : T_Lexeme::T_Syntax::sxDefType;
            }
            forward = l;
            l.value = (def << 16) | l.type;
            l.group = T_Lexeme::T_Group::grSyntax; 
            l.type = type;
            T_Parse::Restore(store_func);
         } else {
            if ((def == 0x01) && Match(T_Symbol::lxLeftBracket)) { // only define
               forward = l;
               l.value = (def << 16) | l.type;
               l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxCast;
               T_Parse::Restore(store_func);
            } else if (def > 0) { 
               forward = l;
               l.value = (def << 16) | l.type;
               l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxDefType;
               if (def & 0x08) { // reference
                  def &= ~0x08;
               } 
               T_Parse::Restore(store_ref);
            } else { // void
               l.group = T_Lexeme::T_Group::grError; 
            }
         }
      } else {
         forward = lex;
         Next();
      }
   } else if (Match(T_Symbol::lxLeftBracket)) { // cast, ()
      T_Lexeme lexeme = forward;
      if (Match(T_Symbol::lxRightBracket)) { 
         l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxEmptyBracket;
      	if (option & T_OptionMode::omPrintLexeme) l.print(&this->Scan());
         return l.group;
      }
      T_ScanStore store; T_Parse::Store(store);
      def = SCDefine(l,0x02); // 0x02 - const
      if (def < 0) { 
         l.group = T_Lexeme::T_Group::grError; 
      	if (option & T_OptionMode::omPrintLexeme) l.print(&this->Scan());
         return l.group;
      } else if ((def > 0) && Match(T_Symbol::lxRightBracket)) { 
         forward = l;
         l.value = (def << 16) | l.type;
         l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxCastUnary;
      } else {
         T_Parse::Restore(store);
         forward = lexeme;
         l = lexeme;
      }
   } else if (Match(T_Symbol::lxLeftCramp))  { // {}
      T_Lexeme lexeme = forward;
      if (Match(T_Symbol::lxRightCramp)) { 
         l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxEmptyCramp;
         forward = lexeme;
      	if (option & T_OptionMode::omPrintLexeme) l.print(&this->Scan());
         return l.group;
      }
      l = lexeme;
   } else if (Match(T_Symbol::lxLeftScrape)) { // []
      T_Lexeme lexeme = forward;
      if (Match(T_Symbol::lxRightScrape)) { 
         l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxEmptyScrape;
         forward = lexeme;
      	if (option & T_OptionMode::omPrintLexeme) l.print(&this->Scan());
         return l.group;
      }
      l = lexeme;
   } else if (Match(T_Symbol::lxRightScrape)) { // ]
      l = forward;
   } else if ((syntax_lexeme & T_SyntaxLexeme::slPrior) && (Match(T_Lexeme::grOper))) {
      const T_Symbol& symbol = symbol_table().Symbol(l.value);
      bool prior = !!symbol.priority;
      if ((symbol.priority == T_Symbol::prAssign) && !(syntax_lexeme & T_SyntaxLexeme::slPriorAssign)) prior = false;
      if (prior) {
         l.group = T_Lexeme::grPriority; l.type = symbol.priority;
         forward = l;
      }
   } else {
      forward = lex;
      Next();
   }
 	if (option & T_OptionMode::omPrintLexeme) l.print(&this->Scan());
   return l.group;
}

bool A_Syntax::MatchSyntax(T_Lexeme &l, const T_Lexeme &lexeme)
{
   bool ret = true;
   if (lexeme.group == T_Lexeme::T_Group::grSyntax) {
      T_ScanStore store; T_Parse::Store(store);
      Lexeme(l);
      if (l.group == T_Lexeme::T_Group::grError) {
         ret = false;
      } else if (l.group == T_Lexeme::T_Group::grSyntax) {
         if ((l.type == T_Lexeme::T_Syntax::sxDefArr) && (lexeme.type == T_Lexeme::T_Syntax::sxDefType)) {
            l.type = lexeme.type;
         } else if ((l.type == T_Lexeme::T_Syntax::sxDefVar) && (lexeme.type == T_Lexeme::T_Syntax::sxDefType)) {
            l.type = lexeme.type;
         } else if ((l.type == T_Lexeme::T_Syntax::sxDefType) && (lexeme.type == T_Lexeme::T_Syntax::sxDefVar)) {
            l.type = lexeme.type;
            if (Match(T_Symbol::T_Type::lxAnd)) l.value |= (0x08 << 16); // reference
         }
         if (l.type != lexeme.type) {
            T_Parse::Restore(store);
            ret = false;
         }
      } else {
         T_Parse::Restore(store);
         ret = false;
      }
   } else {
      ret = T_Parse::Match(lexeme);
      l = forward;
   }
	return ret;
}

bool A_Syntax::MatchLexeme(const T_Lexeme &lexeme)
{
   bool ret = true;
   if (lexeme.group == T_Lexeme::T_Group::grSyntax) {
      T_Lexeme l;
      ret = MatchSyntax(l,lexeme);
      if (ret) PushLexeme(l);
   } else {
      ret = Match(lexeme);
      if (ret) PushLexeme(lexeme);
   }
   return ret;
}

TNodeType* A_Syntax::BaseType(const T_Lexeme &l, int detail)
{
   TNodeType *type = TBaseType::BaseType(l, detail); // new TNodeType(*)
   return type;
}

void A_Syntax::print_store(FILE* file) const
{
   fprintf(file, "\nstore_parse=%d, restore_parse=%d, store_syntax=%d, restore_syntax=%d\n",T_Parse::store_count, T_Parse::restore_count,store_count, restore_count);
}

bool A_Syntax::Source(T_SourceFile& source, const char* file, const T_WordTable* word_table)
{
	if (!source.Open(file)) {
      printf("\nfile error : %s\n", file);
      return false;
   }
	
   T_Lexeme::print_scan = &Scan();
   T_Lexeme::print_scan->word_table = word_table;
   T_Lexeme::word_table = word_table;

   if (option & T_OptionMode::omPrintSource) {
	   print_source(source);
	   source.Reset();
   }
   return true;
}
#ifndef TRN_ASYNTAX_H
#define TRN_ASYNTAX_H
 
#include "Parse.h"
#include <stack>

class TNode;
class TNodeType;
class SNode;
class T_SyntaxNode;
class TSyntaxTree;
class A_Syntax;
class TData;

class TError 
{
public:
   TError(T_Scan* s) :Scan(s) {} 
	bool error(T_Error code, const T_Lexeme &l, int value = 0);
protected:
   T_Scan* Scan;
};

struct TErrorItem {
   TErrorItem() :code(erNone), value(0) {}
   TErrorItem(T_Error c, const T_Lexeme &l, int v) :lexeme(l), code(c), value(v) {}
public:
   T_Lexeme lexeme;
   T_Error  code;
   int      value;
};

class TErrorTable : public std::vector<TErrorItem> {
public:
   TErrorTable(A_Syntax *s) : syntax(s) {}
public:
   void Add(T_Error code, const T_Lexeme &l, int value = 0);
public:
   void print() const;
protected:
   A_Syntax *syntax;
};

// ------------------------- T_GrammarType ------------------------
enum T_Grammar { 
   gtNone = 0x0000, gtLL        = 0x00000001, gtLR     = 0x00000002,
   slNone = 0x0000, slSyntax    = 0x00000010, slPrior  = 0x00000020, slPriorAssign = 0x00000040,
   mtNone = 0x0000, mtTree      = 0x00000100, mtCode   = 0x00000200, mtSNode       = 0x00000400, mtYacc      = 0x00000800, 
                    mtTurn      = 0x00001000, mtEmpty  = 0x00002000, mtHead        = 0x00004000, slSimple    = 0x00008000,
                    slNoDefType = 0x00010000, slNoSave = 0x00020000, slNoDefArrVar = 0x00040000
};
typedef T_Grammar T_SyntaxLexeme;

// --------------------------- A_Syntax ---------------------------
class A_Syntax : public T_Parse
{
public:
   enum T_SyntaxMode   { smNone, smParseStackRule, smParseStackFormula, smParseRule, smParseFormula, smParseLL1, smParseLR0, smParseLR0_Core, smParseLR1, smParseLR1_Core, smParseLALR, smParseLALR_Tab, smParseLALR_Full, smParseLALR_Core, smParseYACC };
public:
	A_Syntax(T_Scan *s) :T_Parse(s), Error(s), ErrorTable(this), syntax_lexeme(slSyntax), syntax_mode(smNone), data(NULL), store_count(0), restore_count(0), error_recovery(0), make_mode(mmNone) 
                       { WordTable(&T_KeyWordTable::key_word_table); }
   ~A_Syntax();
public:
   virtual T_Lexeme::T_Group Lexeme(T_Lexeme &l);
	bool MatchSyntax(T_Lexeme &l, const T_Lexeme &match);
   bool MatchLexeme(const T_Lexeme &lexeme);
   virtual void PushLexeme(const T_Lexeme& lexeme) {}
	virtual bool MatchMust(T_Symbol::T_Type t);
   virtual bool Translate() { return false; }
   virtual void clear(TNode* node) {}
   virtual void ClearProgram() {}
   virtual TNode* Program() { return NULL; }
   virtual SNode* Tree() { return NULL; }
   virtual void Tree(SNode* node) {}
   virtual TSyntaxTree* Auto() { return NULL; }
   virtual void Auto(T_SyntaxNode* node) {}
   int  SCDefine(T_Lexeme &l, int mode); // -1 - error, 0, 0x01 - define, 0x02 - const, 0x04 - static, 0x08 - &, 0x10 - after define, 0x20 - void
   TNodeType* BaseType(const T_Lexeme &l, int detail = 0x00);
   bool LRMaker() const { return (syntax_lexeme & T_Grammar::gtLR) != 0; }
public:
   virtual void Store(T_ScanStore& store) { T_Parse::Store(store); store_count++; }
   virtual bool Restore(const T_ScanStore& store) { if (!T_Parse::Restore(store)) return false; restore_count++; return true; }
   virtual void print_store(FILE* file) const; 
   bool Source(T_SourceFile& source, const char* file, const T_WordTable* word_table = &T_KeyWordTable::key_word_table);
public:
	bool error(T_Error code, int value = 0)        { return error(code,forward,value); }
   bool error_true(T_Error code, int value = 0)   { error(code,value); return true; }
	bool error(T_Error code, const T_Lexeme &l, int value = 0);

   TErrorTable    ErrorTable;
   TError         Error;
   int            error_recovery;
public:
   enum M_Mode { mmNone = 0x00, mmTree, mmCode, mmNode, mmTurn, mmMade };
   void set_make_mode(M_Mode m) { make_mode = m; }
public:
   M_Mode         make_mode;
public:
   T_SyntaxMode   syntax_mode;
   T_SyntaxLexeme syntax_lexeme;
public:
   TData*         data;
protected:
   int store_count, restore_count;
};

#endif


void make_actions(TGrammar& grammar)
{
static const int A[][16] = {
{11,0,0,0,0,1,1,0,0,0,4,11,1,0,0,0},
{11,0,0,0,0,4,3,0,0,0,2,2,1,1,0,0},
{11,0,0,0,0,5,0,0,0,0,2,2,1,1,0,0},
{11,1,0,0,0,1,2,0,0,0,4,11,2,0,0,0},
{11,1,0,0,0,1,3,0,0,0,4,11,3,0,0,0},
{11,1,0,0,0,4,3,0,0,0,1,11,4,0,0,0},
{11,1,0,0,0,5,0,0,0,0,3,0,0,0,0,0},
{11,2,0,0,0,4,0,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,4,3,0,0,0,2,2,1,0,0,0},
{11,2,0,0,0,4,5,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,4,6,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,5,0,0,0,0,2,2,1,0,0,0},
{11,3,0,0,0,4,0,0,0,0,2,2,2,0,0,0},
{11,3,0,0,0,4,3,0,0,0,2,2,2,0,0,0},
{11,3,0,0,0,4,5,0,0,0,2,2,2,0,0,0},
{11,3,0,0,0,4,6,0,0,0,2,2,2,0,0,0},
{11,3,0,0,0,5,0,0,0,0,2,2,2,0,0,0},
{11,4,0,0,0,4,1,0,0,0,1,11,6,0,0,0},
{11,4,0,0,0,4,8,0,0,0,1,11,6,0,0,0},
{11,4,0,0,0,4,9,0,0,0,1,11,6,0,0,0},
{11,5,0,0,0,1,4,0,0,0,4,11,7,0,0,0},
{11,5,0,0,0,4,0,0,0,0,2,2,4,1,0,0},
{11,5,0,0,0,4,2,0,0,0,2,2,4,1,0,0},
{11,5,0,0,0,4,3,0,0,0,2,2,4,1,0,0},
{11,5,0,0,0,4,4,0,0,0,2,2,4,1,0,0},
{11,5,0,0,0,4,5,0,0,0,2,2,4,1,0,0},
{11,5,0,0,0,4,6,0,0,0,2,2,4,1,0,0},
{11,5,0,0,0,4,7,0,0,0,2,2,4,1,0,0},
{11,5,0,0,0,5,0,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,1,4,0,0,0,4,11,8,0,0,0},
{11,6,0,0,0,4,0,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,4,2,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,4,3,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,4,4,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,4,5,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,4,6,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,4,7,0,0,0,2,2,4,1,0,0},
{11,6,0,0,0,5,0,0,0,0,2,2,4,1,0,0},
{11,7,0,0,0,4,0,0,0,0,2,2,2,1,0,0},
{11,7,0,0,0,4,2,0,0,0,1,11,9,0,0,0},
{11,7,0,0,0,4,3,0,0,0,2,2,2,1,0,0},
{11,7,0,0,0,4,4,0,0,0,1,11,9,0,0,0},
{11,7,0,0,0,4,5,0,0,0,2,2,2,1,0,0},
{11,7,0,0,0,4,6,0,0,0,2,2,2,1,0,0},
{11,7,0,0,0,4,7,0,0,0,1,11,9,0,0,0},
{11,7,0,0,0,5,0,0,0,0,2,2,2,1,0,0},
{11,8,0,0,0,4,0,0,0,0,2,2,3,0,0,0},
{11,8,0,0,0,4,2,0,0,0,1,11,9,0,0,0},
{11,8,0,0,0,4,3,0,0,0,2,2,3,0,0,0},
{11,8,0,0,0,4,4,0,0,0,1,11,9,0,0,0},
{11,8,0,0,0,4,5,0,0,0,2,2,3,0,0,0},
{11,8,0,0,0,4,6,0,0,0,2,2,3,0,0,0},
{11,8,0,0,0,4,7,0,0,0,1,11,9,0,0,0},
{11,8,0,0,0,5,0,0,0,0,2,2,3,0,0,0},
{11,9,0,0,0,4,0,0,0,0,2,2,4,0,0,0},
{11,9,0,0,0,4,2,0,0,0,2,2,4,0,0,0},
{11,9,0,0,0,4,3,0,0,0,2,2,4,0,0,0},
{11,9,0,0,0,4,4,0,0,0,2,2,4,0,0,0},
{11,9,0,0,0,4,5,0,0,0,2,2,4,0,0,0},
{11,9,0,0,0,4,6,0,0,0,2,2,4,0,0,0},
{11,9,0,0,0,4,7,0,0,0,2,2,4,0,0,0},
{11,9,0,0,0,5,0,0,0,0,2,2,4,0,0,0}
};
grammar.AddActions(62,A);
}

void make_formulas(TGrammar& grammar)
{
grammar.type = T_Grammar(335872); grammar.look_ahead = 2;
grammar.AddFormula("S_");
{ static const int I[][5] = {{1,1,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("bnf");
{ static const int I[][5] = {{1,1,0,0,0},{1,2,0,0,0}}; grammar.AddProduce(2, I); }
{ static const int I[][5] = {{5,0,0,0,0}}; grammar.AddProduce(0, I); }
grammar.AddFormula("rules");
{ static const int I[][5] = {{1,3,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{1,2,0,0,0},{3,1,15,0,0},{1,4,0,0,0}}; grammar.AddProduce(3, I); }
grammar.AddFormula("rule");
{ static const int I[][5] = {{3,8,0,0,0},{3,2,59,0,0},{1,4,0,0,0}}; grammar.AddProduce(3, I); }
grammar.AddFormula("symbol_list");
{ static const int I[][5] = {{1,4,0,0,0},{3,8,0,0,0}}; grammar.AddProduce(2, I); }
{ static const int I[][5] = {{5,0,0,0,0}}; grammar.AddProduce(0, I); }
}

void make_vectors(TGrammar& grammar)
{
{ static const int I[][5] = {{3,1,15,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,59,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,8,0,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,2,59,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,1,15,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,1,15,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,59,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,59,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
}

void make_grammar(TGrammar& grammar) { make_actions(grammar); make_formulas(grammar); make_vectors(grammar); }


void make_actions(TGrammar& grammar)
{
static const int A[][16] = {
{11,0,0,0,0,1,1,0,0,0,4,11,1,0,0,0},
{11,0,0,0,0,4,21,0,0,0,2,2,1,1,2,0},
{11,0,0,0,0,5,0,0,0,0,2,2,1,1,2,0},
{11,1,0,0,0,1,2,0,0,0,4,11,2,0,0,0},
{11,1,0,0,0,1,3,0,0,0,4,11,3,0,0,0},
{11,1,0,0,0,4,21,0,0,0,1,11,4,0,0,0},
{11,1,0,0,0,5,0,0,0,0,3,2,0,0,0,0},
{11,2,0,0,0,4,2,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,4,21,0,0,0,2,2,1,0,1,0},
{11,2,0,0,0,4,41,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,4,42,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,4,43,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,4,48,0,0,0,1,11,5,0,0,0},
{11,2,0,0,0,5,0,0,0,0,2,2,1,0,1,0},
{11,3,0,0,0,4,2,0,0,0,2,2,2,0,3,0},
{11,3,0,0,0,4,21,0,0,0,2,2,2,0,3,0},
{11,3,0,0,0,4,41,0,0,0,2,2,2,0,3,0},
{11,3,0,0,0,4,42,0,0,0,2,2,2,0,3,0},
{11,3,0,0,0,4,43,0,0,0,2,2,2,0,3,0},
{11,3,0,0,0,4,48,0,0,0,2,2,2,0,3,0},
{11,3,0,0,0,5,0,0,0,0,2,2,2,0,3,0},
{11,4,0,0,0,4,10,0,0,0,1,11,6,0,0,0},
{11,4,0,0,0,4,53,0,0,0,1,11,6,0,0,0},
{11,4,0,0,0,4,54,0,0,0,1,11,6,0,0,0},
{11,4,0,0,0,4,55,0,0,0,1,11,6,0,0,0},
{11,4,0,0,0,4,56,0,0,0,1,11,6,0,0,0},
{11,5,0,0,0,1,4,0,0,0,4,11,7,0,0,0},
{11,5,0,0,0,4,2,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,11,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,20,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,21,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,22,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,25,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,26,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,27,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,28,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,29,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,30,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,31,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,35,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,36,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,37,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,38,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,39,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,40,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,41,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,42,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,43,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,48,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,51,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,4,52,0,0,0,2,2,4,1,7,0},
{11,5,0,0,0,5,0,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,1,4,0,0,0,4,11,8,0,0,0},
{11,6,0,0,0,4,2,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,11,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,20,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,21,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,22,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,25,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,26,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,27,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,28,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,29,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,30,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,31,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,35,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,36,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,37,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,38,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,39,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,40,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,41,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,42,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,43,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,48,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,51,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,4,52,0,0,0,2,2,4,1,7,0},
{11,6,0,0,0,5,0,0,0,0,2,2,4,1,7,0},
{11,7,0,0,0,1,5,0,0,0,4,11,9,0,0,0},
{11,7,0,0,0,1,6,0,0,0,4,11,10,0,0,0},
{11,7,0,0,0,1,8,0,0,0,4,11,11,0,0,0},
{11,7,0,0,0,1,11,0,0,0,4,11,12,0,0,0},
{11,7,0,0,0,4,2,0,0,0,2,2,2,1,4,0},
{11,7,0,0,0,4,11,0,0,0,1,11,14,0,0,0},
{11,7,0,0,0,4,20,0,0,0,1,11,15,0,0,0},
{11,7,0,0,0,4,21,0,0,0,2,2,2,1,4,0},
{11,7,0,0,0,4,22,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,25,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,26,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,27,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,28,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,29,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,30,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,31,0,0,0,1,11,13,0,0,0},
{11,7,0,0,0,4,35,0,0,0,1,11,14,0,0,0},
{11,7,0,0,0,4,36,0,0,0,1,11,14,0,0,0},
{11,7,0,0,0,4,37,0,0,0,1,11,14,0,0,0},
{11,7,0,0,0,4,38,0,0,0,1,11,15,0,0,0},
{11,7,0,0,0,4,39,0,0,0,1,11,15,0,0,0},
{11,7,0,0,0,4,40,0,0,0,1,11,15,0,0,0},
{11,7,0,0,0,4,41,0,0,0,2,2,2,1,4,0},
{11,7,0,0,0,4,42,0,0,0,2,2,2,1,4,0},
{11,7,0,0,0,4,43,0,0,0,2,2,2,1,4,0},
{11,7,0,0,0,4,48,0,0,0,2,2,2,1,4,0},
{11,7,0,0,0,4,51,0,0,0,1,11,14,0,0,0},
{11,7,0,0,0,4,52,0,0,0,1,11,15,0,0,0},
{11,7,0,0,0,5,0,0,0,0,2,2,2,1,4,0},
{11,8,0,0,0,1,5,0,0,0,4,11,9,0,0,0},
{11,8,0,0,0,1,6,0,0,0,4,11,10,0,0,0},
{11,8,0,0,0,1,8,0,0,0,4,11,11,0,0,0},
{11,8,0,0,0,1,11,0,0,0,4,11,12,0,0,0},
{11,8,0,0,0,4,2,0,0,0,2,2,3,0,5,0},
{11,8,0,0,0,4,11,0,0,0,1,11,14,0,0,0},
{11,8,0,0,0,4,20,0,0,0,1,11,15,0,0,0},
{11,8,0,0,0,4,21,0,0,0,2,2,3,0,5,0},
{11,8,0,0,0,4,22,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,25,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,26,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,27,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,28,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,29,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,30,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,31,0,0,0,1,11,13,0,0,0},
{11,8,0,0,0,4,35,0,0,0,1,11,14,0,0,0},
{11,8,0,0,0,4,36,0,0,0,1,11,14,0,0,0},
{11,8,0,0,0,4,37,0,0,0,1,11,14,0,0,0},
{11,8,0,0,0,4,38,0,0,0,1,11,15,0,0,0},
{11,8,0,0,0,4,39,0,0,0,1,11,15,0,0,0},
{11,8,0,0,0,4,40,0,0,0,1,11,15,0,0,0},
{11,8,0,0,0,4,41,0,0,0,2,2,3,0,5,0},
{11,8,0,0,0,4,42,0,0,0,2,2,3,0,5,0},
{11,8,0,0,0,4,43,0,0,0,2,2,3,0,5,0},
{11,8,0,0,0,4,48,0,0,0,2,2,3,0,5,0},
{11,8,0,0,0,4,51,0,0,0,1,11,14,0,0,0},
{11,8,0,0,0,4,52,0,0,0,1,11,15,0,0,0},
{11,8,0,0,0,5,0,0,0,0,2,2,3,0,5,0},
{11,9,0,0,0,4,2,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,11,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,20,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,21,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,22,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,25,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,26,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,27,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,28,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,29,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,30,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,31,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,35,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,36,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,37,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,38,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,39,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,40,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,41,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,42,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,43,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,48,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,51,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,4,52,0,0,0,2,2,4,0,6,0},
{11,9,0,0,0,5,0,0,0,0,2,2,4,0,6,0},
{11,10,0,0,0,4,2,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,11,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,20,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,21,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,22,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,25,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,26,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,27,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,28,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,29,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,30,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,31,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,35,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,36,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,37,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,38,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,39,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,40,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,41,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,42,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,43,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,48,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,51,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,4,52,0,0,0,2,2,5,0,8,0},
{11,10,0,0,0,5,0,0,0,0,2,2,5,0,8,0},
{11,11,0,0,0,4,2,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,11,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,20,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,21,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,22,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,25,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,26,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,27,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,28,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,29,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,30,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,31,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,35,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,36,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,37,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,38,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,39,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,40,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,41,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,42,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,43,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,48,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,51,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,4,52,0,0,0,2,2,5,1,9,0},
{11,11,0,0,0,5,0,0,0,0,2,2,5,1,9,0},
{11,12,0,0,0,4,2,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,11,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,20,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,21,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,22,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,25,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,26,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,27,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,28,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,29,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,30,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,31,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,35,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,36,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,37,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,38,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,39,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,40,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,41,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,42,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,43,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,48,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,51,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,4,52,0,0,0,2,2,5,2,10,0},
{11,12,0,0,0,5,0,0,0,0,2,2,5,2,10,0},
{11,13,0,0,0,1,7,0,0,0,4,11,16,0,0,0},
{11,13,0,0,0,4,57,0,0,0,1,11,20,0,0,0},
{11,13,0,0,0,4,58,0,0,0,1,11,24,0,0,0},
{11,13,0,0,0,4,59,0,0,0,1,11,17,0,0,0},
{11,13,0,0,0,4,60,0,0,0,1,11,18,0,0,0},
{11,13,0,0,0,4,61,0,0,0,1,11,19,0,0,0},
{11,13,0,0,0,4,62,0,0,0,1,11,21,0,0,0},
{11,13,0,0,0,4,63,0,0,0,1,11,22,0,0,0},
{11,13,0,0,0,4,64,0,0,0,1,11,23,0,0,0},
{11,14,0,0,0,4,2,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,11,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,20,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,21,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,22,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,25,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,26,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,27,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,28,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,29,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,30,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,31,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,35,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,36,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,37,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,38,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,39,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,40,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,41,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,42,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,43,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,48,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,51,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,4,52,0,0,0,2,2,5,3,11,0},
{11,14,0,0,0,5,0,0,0,0,2,2,5,3,11,0},
{11,15,0,0,0,4,2,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,11,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,20,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,21,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,22,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,25,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,26,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,27,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,28,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,29,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,30,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,31,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,35,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,36,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,37,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,38,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,39,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,40,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,41,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,42,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,43,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,48,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,51,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,4,52,0,0,0,2,2,5,4,12,0},
{11,15,0,0,0,5,0,0,0,0,2,2,5,4,12,0},
{11,16,0,0,0,4,33,0,0,0,1,11,25,0,0,0},
{11,17,0,0,0,4,33,0,0,0,1,11,26,0,0,0},
{11,18,0,0,0,4,33,0,0,0,2,2,7,0,15,0},
{11,19,0,0,0,4,33,0,0,0,2,2,7,1,16,0},
{11,20,0,0,0,4,33,0,0,0,1,11,27,0,0,0},
{11,21,0,0,0,4,33,0,0,0,2,2,7,2,17,0},
{11,22,0,0,0,4,33,0,0,0,2,2,7,3,18,0},
{11,23,0,0,0,4,33,0,0,0,2,2,7,4,19,0},
{11,24,0,0,0,4,33,0,0,0,1,11,28,0,0,0},
{11,25,0,0,0,4,65,0,0,0,1,11,29,0,0,0},
{11,25,0,0,0,4,66,0,0,0,1,11,29,0,0,0},
{11,26,0,0,0,4,65,0,0,0,1,11,30,0,0,0},
{11,27,0,0,0,4,65,0,0,0,1,11,31,0,0,0},
{11,28,0,0,0,4,65,0,0,0,1,11,32,0,0,0},
{11,29,0,0,0,4,44,0,0,0,1,11,33,0,0,0},
{11,29,0,0,0,4,45,0,0,0,1,11,34,0,0,0},
{11,29,0,0,0,4,46,0,0,0,1,11,34,0,0,0},
{11,29,0,0,0,4,47,0,0,0,1,11,34,0,0,0},
{11,30,0,0,0,4,46,0,0,0,1,11,35,0,0,0},
{11,31,0,0,0,4,67,0,0,0,1,11,36,0,0,0},
{11,32,0,0,0,4,46,0,0,0,1,11,37,0,0,0},
{11,33,0,0,0,4,68,0,0,0,1,11,38,0,0,0},
{11,34,0,0,0,1,10,0,0,0,4,11,39,0,0,0},
{11,34,0,0,0,4,23,0,0,0,1,11,42,0,0,0},
{11,34,0,0,0,4,24,0,0,0,1,11,40,0,0,0},
{11,34,0,0,0,4,66,0,0,0,1,11,42,0,0,0},
{11,34,0,0,0,4,69,0,0,0,1,11,41,0,0,0},
{11,35,0,0,0,4,66,0,0,0,1,11,43,0,0,0},
{11,36,0,0,0,1,9,0,0,0,4,11,44,0,0,0},
{11,36,0,0,0,4,32,0,0,0,1,11,45,0,0,0},
{11,36,0,0,0,4,33,0,0,0,1,11,45,0,0,0},
{11,36,0,0,0,4,34,0,0,0,1,11,45,0,0,0},
{11,37,0,0,0,4,65,0,0,0,1,11,46,0,0,0},
{11,38,0,0,0,4,4,0,0,0,1,11,47,0,0,0},
{11,38,0,0,0,4,70,0,0,0,1,11,47,0,0,0},
{11,38,0,0,0,4,71,0,0,0,1,11,47,0,0,0},
{11,38,0,0,0,4,72,0,0,0,1,11,47,0,0,0},
{11,38,0,0,0,4,73,0,0,0,1,11,47,0,0,0},
{11,39,0,0,0,4,44,0,0,0,1,11,48,0,0,0},
{11,40,0,0,0,4,69,0,0,0,1,11,49,0,0,0},
{11,41,0,0,0,4,44,0,0,0,2,2,10,0,27,0},
{11,42,0,0,0,4,44,0,0,0,2,2,10,1,28,0},
{11,42,0,0,0,4,74,0,0,0,1,11,50,0,0,0},
{11,43,0,0,0,4,44,0,0,0,1,11,51,0,0,0},
{11,44,0,0,0,4,44,0,0,0,1,11,52,0,0,0},
{11,44,0,0,0,4,45,0,0,0,1,11,53,0,0,0},
{11,44,0,0,0,4,46,0,0,0,1,11,53,0,0,0},
{11,44,0,0,0,4,47,0,0,0,1,11,53,0,0,0},
{11,45,0,0,0,1,10,0,0,0,4,11,54,0,0,0},
{11,45,0,0,0,4,23,0,0,0,1,11,57,0,0,0},
{11,45,0,0,0,4,24,0,0,0,1,11,55,0,0,0},
{11,45,0,0,0,4,65,0,0,0,1,11,57,0,0,0},
{11,45,0,0,0,4,66,0,0,0,1,11,57,0,0,0},
{11,45,0,0,0,4,69,0,0,0,1,11,56,0,0,0},
{11,45,0,0,0,4,75,0,0,0,1,11,56,0,0,0},
{11,46,0,0,0,4,45,0,0,0,1,11,58,0,0,0},
{11,46,0,0,0,4,46,0,0,0,1,11,58,0,0,0},
{11,46,0,0,0,4,47,0,0,0,1,11,58,0,0,0},
{11,47,0,0,0,4,2,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,11,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,20,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,21,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,22,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,25,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,26,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,27,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,28,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,29,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,30,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,31,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,35,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,36,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,37,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,38,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,39,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,40,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,41,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,42,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,43,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,48,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,51,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,4,52,0,0,0,2,2,6,1,14,0},
{11,47,0,0,0,5,0,0,0,0,2,2,6,1,14,0},
{11,48,0,0,0,4,68,0,0,0,1,11,59,0,0,0},
{11,49,0,0,0,4,44,0,0,0,2,2,10,3,30,0},
{11,50,0,0,0,4,66,0,0,0,1,11,60,0,0,0},
{11,51,0,0,0,4,68,0,0,0,1,11,61,0,0,0},
{11,52,0,0,0,4,68,0,0,0,1,11,62,0,0,0},
{11,53,0,0,0,1,10,0,0,0,4,11,63,0,0,0},
{11,53,0,0,0,4,23,0,0,0,1,11,42,0,0,0},
{11,53,0,0,0,4,24,0,0,0,1,11,40,0,0,0},
{11,53,0,0,0,4,66,0,0,0,1,11,42,0,0,0},
{11,53,0,0,0,4,69,0,0,0,1,11,41,0,0,0},
{11,54,0,0,0,4,45,0,0,0,1,11,65,0,0,0},
{11,54,0,0,0,4,46,0,0,0,1,11,65,0,0,0},
{11,54,0,0,0,4,47,0,0,0,1,11,65,0,0,0},
{11,54,0,0,0,4,49,0,0,0,1,11,64,0,0,0},
{11,54,0,0,0,4,50,0,0,0,1,11,64,0,0,0},
{11,55,0,0,0,4,69,0,0,0,1,11,66,0,0,0},
{11,55,0,0,0,4,75,0,0,0,1,11,66,0,0,0},
{11,56,0,0,0,4,45,0,0,0,2,2,10,0,27,0},
{11,56,0,0,0,4,46,0,0,0,2,2,10,0,27,0},
{11,56,0,0,0,4,47,0,0,0,2,2,10,0,27,0},
{11,56,0,0,0,4,49,0,0,0,2,2,10,0,27,0},
{11,56,0,0,0,4,50,0,0,0,2,2,10,0,27,0},
{11,57,0,0,0,4,45,0,0,0,2,2,10,1,28,0},
{11,57,0,0,0,4,46,0,0,0,2,2,10,1,28,0},
{11,57,0,0,0,4,47,0,0,0,2,2,10,1,28,0},
{11,57,0,0,0,4,49,0,0,0,2,2,10,1,28,0},
{11,57,0,0,0,4,50,0,0,0,2,2,10,1,28,0},
{11,57,0,0,0,4,74,0,0,0,1,11,67,0,0,0},
{11,58,0,0,0,1,10,0,0,0,4,11,68,0,0,0},
{11,58,0,0,0,4,23,0,0,0,1,11,42,0,0,0},
{11,58,0,0,0,4,24,0,0,0,1,11,40,0,0,0},
{11,58,0,0,0,4,66,0,0,0,1,11,42,0,0,0},
{11,58,0,0,0,4,69,0,0,0,1,11,41,0,0,0},
{11,59,0,0,0,4,4,0,0,0,1,11,69,0,0,0},
{11,59,0,0,0,4,70,0,0,0,1,11,69,0,0,0},
{11,59,0,0,0,4,71,0,0,0,1,11,69,0,0,0},
{11,59,0,0,0,4,72,0,0,0,1,11,69,0,0,0},
{11,59,0,0,0,4,73,0,0,0,1,11,69,0,0,0},
{11,60,0,0,0,4,44,0,0,0,2,2,10,2,29,0},
{11,61,0,0,0,4,4,0,0,0,1,11,70,0,0,0},
{11,61,0,0,0,4,70,0,0,0,1,11,70,0,0,0},
{11,61,0,0,0,4,71,0,0,0,1,11,70,0,0,0},
{11,61,0,0,0,4,72,0,0,0,1,11,70,0,0,0},
{11,61,0,0,0,4,73,0,0,0,1,11,70,0,0,0},
{11,62,0,0,0,4,4,0,0,0,1,11,71,0,0,0},
{11,62,0,0,0,4,70,0,0,0,1,11,71,0,0,0},
{11,62,0,0,0,4,71,0,0,0,1,11,71,0,0,0},
{11,62,0,0,0,4,72,0,0,0,1,11,71,0,0,0},
{11,62,0,0,0,4,73,0,0,0,1,11,71,0,0,0},
{11,63,0,0,0,4,44,0,0,0,1,11,72,0,0,0},
{11,64,0,0,0,4,44,0,0,0,2,2,9,0,22,0},
{11,64,0,0,0,4,45,0,0,0,2,2,9,0,22,0},
{11,64,0,0,0,4,46,0,0,0,2,2,9,0,22,0},
{11,64,0,0,0,4,47,0,0,0,2,2,9,0,22,0},
{11,65,0,0,0,1,10,0,0,0,4,11,73,0,0,0},
{11,65,0,0,0,4,23,0,0,0,1,11,57,0,0,0},
{11,65,0,0,0,4,24,0,0,0,1,11,55,0,0,0},
{11,65,0,0,0,4,65,0,0,0,1,11,57,0,0,0},
{11,65,0,0,0,4,66,0,0,0,1,11,57,0,0,0},
{11,65,0,0,0,4,69,0,0,0,1,11,56,0,0,0},
{11,65,0,0,0,4,75,0,0,0,1,11,56,0,0,0},
{11,66,0,0,0,4,45,0,0,0,2,2,10,3,30,0},
{11,66,0,0,0,4,46,0,0,0,2,2,10,3,30,0},
{11,66,0,0,0,4,47,0,0,0,2,2,10,3,30,0},
{11,66,0,0,0,4,49,0,0,0,2,2,10,3,30,0},
{11,66,0,0,0,4,50,0,0,0,2,2,10,3,30,0},
{11,67,0,0,0,4,65,0,0,0,1,11,74,0,0,0},
{11,67,0,0,0,4,66,0,0,0,1,11,74,0,0,0},
{11,68,0,0,0,4,44,0,0,0,1,11,75,0,0,0},
{11,69,0,0,0,4,2,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,11,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,20,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,21,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,22,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,25,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,26,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,27,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,28,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,29,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,30,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,31,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,35,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,36,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,37,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,38,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,39,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,40,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,41,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,42,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,43,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,48,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,51,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,4,52,0,0,0,2,2,6,0,13,0},
{11,69,0,0,0,5,0,0,0,0,2,2,6,0,13,0},
{11,70,0,0,0,4,2,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,11,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,20,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,21,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,22,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,25,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,26,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,27,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,28,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,29,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,30,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,31,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,35,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,36,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,37,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,38,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,39,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,40,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,41,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,42,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,43,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,48,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,51,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,4,52,0,0,0,2,2,11,1,32,0},
{11,70,0,0,0,5,0,0,0,0,2,2,11,1,32,0},
{11,71,0,0,0,4,2,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,11,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,20,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,21,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,22,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,25,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,26,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,27,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,28,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,29,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,30,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,31,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,35,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,36,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,37,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,38,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,39,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,40,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,41,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,42,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,43,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,48,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,51,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,4,52,0,0,0,2,2,8,1,21,0},
{11,71,0,0,0,5,0,0,0,0,2,2,8,1,21,0},
{11,72,0,0,0,4,68,0,0,0,1,11,76,0,0,0},
{11,73,0,0,0,4,45,0,0,0,1,11,78,0,0,0},
{11,73,0,0,0,4,46,0,0,0,1,11,78,0,0,0},
{11,73,0,0,0,4,47,0,0,0,1,11,78,0,0,0},
{11,73,0,0,0,4,49,0,0,0,1,11,77,0,0,0},
{11,73,0,0,0,4,50,0,0,0,1,11,77,0,0,0},
{11,74,0,0,0,4,45,0,0,0,2,2,10,2,29,0},
{11,74,0,0,0,4,46,0,0,0,2,2,10,2,29,0},
{11,74,0,0,0,4,47,0,0,0,2,2,10,2,29,0},
{11,74,0,0,0,4,49,0,0,0,2,2,10,2,29,0},
{11,74,0,0,0,4,50,0,0,0,2,2,10,2,29,0},
{11,75,0,0,0,4,68,0,0,0,1,11,79,0,0,0},
{11,76,0,0,0,4,4,0,0,0,1,11,80,0,0,0},
{11,76,0,0,0,4,70,0,0,0,1,11,80,0,0,0},
{11,76,0,0,0,4,71,0,0,0,1,11,80,0,0,0},
{11,76,0,0,0,4,72,0,0,0,1,11,80,0,0,0},
{11,76,0,0,0,4,73,0,0,0,1,11,80,0,0,0},
{11,77,0,0,0,4,44,0,0,0,2,2,9,1,23,0},
{11,77,0,0,0,4,45,0,0,0,2,2,9,1,23,0},
{11,77,0,0,0,4,46,0,0,0,2,2,9,1,23,0},
{11,77,0,0,0,4,47,0,0,0,2,2,9,1,23,0},
{11,78,0,0,0,1,10,0,0,0,4,11,81,0,0,0},
{11,78,0,0,0,4,23,0,0,0,1,11,57,0,0,0},
{11,78,0,0,0,4,24,0,0,0,1,11,55,0,0,0},
{11,78,0,0,0,4,65,0,0,0,1,11,57,0,0,0},
{11,78,0,0,0,4,66,0,0,0,1,11,57,0,0,0},
{11,78,0,0,0,4,69,0,0,0,1,11,56,0,0,0},
{11,78,0,0,0,4,75,0,0,0,1,11,56,0,0,0},
{11,79,0,0,0,4,4,0,0,0,1,11,82,0,0,0},
{11,79,0,0,0,4,70,0,0,0,1,11,82,0,0,0},
{11,79,0,0,0,4,71,0,0,0,1,11,82,0,0,0},
{11,79,0,0,0,4,72,0,0,0,1,11,82,0,0,0},
{11,79,0,0,0,4,73,0,0,0,1,11,82,0,0,0},
{11,80,0,0,0,4,2,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,11,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,20,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,21,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,22,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,25,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,26,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,27,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,28,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,29,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,30,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,31,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,35,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,36,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,37,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,38,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,39,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,40,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,41,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,42,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,43,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,48,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,51,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,4,52,0,0,0,2,2,8,0,20,0},
{11,80,0,0,0,5,0,0,0,0,2,2,8,0,20,0},
{11,81,0,0,0,4,45,0,0,0,1,11,84,0,0,0},
{11,81,0,0,0,4,46,0,0,0,1,11,84,0,0,0},
{11,81,0,0,0,4,47,0,0,0,1,11,84,0,0,0},
{11,81,0,0,0,4,49,0,0,0,1,11,83,0,0,0},
{11,81,0,0,0,4,50,0,0,0,1,11,83,0,0,0},
{11,82,0,0,0,4,2,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,11,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,20,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,21,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,22,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,25,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,26,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,27,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,28,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,29,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,30,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,31,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,35,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,36,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,37,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,38,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,39,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,40,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,41,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,42,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,43,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,48,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,51,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,4,52,0,0,0,2,2,11,0,31,0},
{11,82,0,0,0,5,0,0,0,0,2,2,11,0,31,0},
{11,83,0,0,0,4,44,0,0,0,2,2,9,2,24,0},
{11,83,0,0,0,4,45,0,0,0,2,2,9,2,24,0},
{11,83,0,0,0,4,46,0,0,0,2,2,9,2,24,0},
{11,83,0,0,0,4,47,0,0,0,2,2,9,2,24,0},
{11,84,0,0,0,1,10,0,0,0,4,11,85,0,0,0},
{11,84,0,0,0,4,23,0,0,0,1,11,57,0,0,0},
{11,84,0,0,0,4,24,0,0,0,1,11,55,0,0,0},
{11,84,0,0,0,4,65,0,0,0,1,11,57,0,0,0},
{11,84,0,0,0,4,66,0,0,0,1,11,57,0,0,0},
{11,84,0,0,0,4,69,0,0,0,1,11,56,0,0,0},
{11,84,0,0,0,4,75,0,0,0,1,11,56,0,0,0},
{11,85,0,0,0,4,45,0,0,0,1,11,87,0,0,0},
{11,85,0,0,0,4,46,0,0,0,1,11,87,0,0,0},
{11,85,0,0,0,4,47,0,0,0,1,11,87,0,0,0},
{11,85,0,0,0,4,49,0,0,0,1,11,86,0,0,0},
{11,85,0,0,0,4,50,0,0,0,1,11,86,0,0,0},
{11,86,0,0,0,4,44,0,0,0,2,2,9,3,25,0},
{11,86,0,0,0,4,45,0,0,0,2,2,9,3,25,0},
{11,86,0,0,0,4,46,0,0,0,2,2,9,3,25,0},
{11,86,0,0,0,4,47,0,0,0,2,2,9,3,25,0},
{11,87,0,0,0,1,10,0,0,0,4,11,88,0,0,0},
{11,87,0,0,0,4,23,0,0,0,1,11,91,0,0,0},
{11,87,0,0,0,4,24,0,0,0,1,11,89,0,0,0},
{11,87,0,0,0,4,66,0,0,0,1,11,91,0,0,0},
{11,87,0,0,0,4,69,0,0,0,1,11,90,0,0,0},
{11,88,0,0,0,4,49,0,0,0,1,11,92,0,0,0},
{11,88,0,0,0,4,50,0,0,0,1,11,92,0,0,0},
{11,89,0,0,0,4,69,0,0,0,1,11,93,0,0,0},
{11,90,0,0,0,4,49,0,0,0,2,2,10,0,27,0},
{11,90,0,0,0,4,50,0,0,0,2,2,10,0,27,0},
{11,91,0,0,0,4,49,0,0,0,2,2,10,1,28,0},
{11,91,0,0,0,4,50,0,0,0,2,2,10,1,28,0},
{11,91,0,0,0,4,74,0,0,0,1,11,94,0,0,0},
{11,92,0,0,0,4,44,0,0,0,2,2,9,4,26,0},
{11,92,0,0,0,4,45,0,0,0,2,2,9,4,26,0},
{11,92,0,0,0,4,46,0,0,0,2,2,9,4,26,0},
{11,92,0,0,0,4,47,0,0,0,2,2,9,4,26,0},
{11,93,0,0,0,4,49,0,0,0,2,2,10,3,30,0},
{11,93,0,0,0,4,50,0,0,0,2,2,10,3,30,0},
{11,94,0,0,0,4,66,0,0,0,1,11,95,0,0,0},
{11,95,0,0,0,4,49,0,0,0,2,2,10,2,29,0},
{11,95,0,0,0,4,50,0,0,0,2,2,10,2,29,0}
};
grammar.AddActions(652,A);
}

void make_formulas(TGrammar& grammar)
{
grammar.type = T_Grammar(336896); grammar.look_ahead = 2;
grammar.AddFormula("S_");
{ static const int I[][5] = {{1,1,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("bnf");
{ static const int I[][5] = {{1,1,0,0,0},{1,2,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,1,8256,512), 2, I); }
{ static const int I[][5] = {{5,0,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,6,0,512), 0, I); }
grammar.AddFormula("rules");
{ static const int I[][5] = {{1,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,7,64,512), 1, I); }
{ static const int I[][5] = {{1,2,0,0,0},{3,1,15,0,0},{1,4,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,1,12352,512), 3, I); }
grammar.AddFormula("rule");
{ static const int I[][5] = {{3,8,0,0,0},{3,2,59,0,0},{1,4,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,2,193,512), 3, I); }
grammar.AddFormula("symbol_list");
{ static const int I[][5] = {{1,4,0,0,0},{1,5,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,42,7,66,512), 2, I); }
{ static const int I[][5] = {{5,0,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,42,6,0,512), 0, I); }
grammar.AddFormula("produce_item");
{ static const int I[][5] = {{1,6,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{1,8,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{1,11,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,46,0,1,512), 1, I); }
{ static const int I[][5] = {{3,8,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("Maker_Make");
{ static const int I[][5] = {{3,2,34,0,0},{1,7,0,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,0,24834,512), 9, I); }
{ static const int I[][5] = {{3,2,34,0,0},{1,7,0,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,0,258,512), 7, I); }
grammar.AddFormula("Ident_Maker");
{ static const int I[][5] = {{3,7,42,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,43,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,45,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,46,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,47,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("Maker_Node");
{ static const int I[][5] = {{3,2,34,0,0},{3,7,44,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,9,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,1,33156,512), 11, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,44,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,9,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,1,388,512), 9, I); }
grammar.AddFormula("node_body");
{ static const int I[][5] = {{3,2,36,0,0},{1,10,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,2,512), 3, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,258,512), 5, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,24834,512), 7, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,2121986,512), 9, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,169894146,512), 11, I); }
grammar.AddFormula("int_body");
{ static const int I[][5] = {{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,3,1,512), 1, I); }
{ static const int I[][5] = {{3,6,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,3,1,512), 1, I); }
{ static const int I[][5] = {{3,6,0,0,0},{3,2,41,0,0},{3,6,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,3,193,512), 3, I); }
{ static const int I[][5] = {{3,1,2,0,0},{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,4,2,512), 2, I); }
grammar.AddFormula("Maker_Turn");
{ static const int I[][5] = {{3,2,34,0,0},{3,7,48,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,10,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,5,33156,512), 11, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,0,0,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{3,6,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,5,388,512), 9, I); }
}

void make_vectors(TGrammar& grammar)
{
{ static const int I[][5] = {{3,0,0,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,1,2,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,1,15,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,34,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,35,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,36,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,37,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,41,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,44,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,45,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,2,59,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,3,0,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,6,0,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,7,42,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,7,43,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,7,44,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,7,45,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,7,46,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,7,47,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,7,48,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,8,0,0,0}}; grammar.AddVector(1, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,2,59,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,44,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,6,0,0,0},{3,2,41,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,1,2,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,48,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,0,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,42,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,43,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,45,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,46,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,47,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,36,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,36,0,0},{3,6,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,36,0,0},{3,1,2,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,3,0,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,3,0,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,3,0,0,0},{3,2,34,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,2,34,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,1,15,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,1,15,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,1,15,0,0},{3,2,34,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,37,0,0},{3,2,45,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,44,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,44,0,0},{3,6,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,44,0,0},{3,1,2,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,1,15,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,37,0,0},{3,2,44,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,37,0,0},{3,2,37,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,3,0,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,8,0,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,59,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,59,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,59,0,0},{3,2,34,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,59,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,7,44,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,7,48,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,0,0,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,7,42,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,7,43,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,7,45,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,7,46,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,7,47,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,6,0,0,0},{3,2,44,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,6,0,0,0},{3,2,37,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,44,0,0},{3,2,36,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,3,0,0,0},{3,2,37,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,35,0,0},{3,1,15,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,35,0,0},{3,3,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,35,0,0},{3,8,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,35,0,0},{3,2,34,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,2,41,0,0},{3,6,0,0,0}}; grammar.AddVector(2, I); }
{ static const int I[][5] = {{3,3,0,0,0},{3,2,44,0,0}}; grammar.AddVector(2, I); }
}

void make_grammar(TGrammar& grammar) { make_actions(grammar); make_formulas(grammar); make_vectors(grammar); }
#include "stdafx.h"

#include "C99_Lexer.h"

void yyerror(const char *s);
void error(const char *s) { yyerror(s); }

#include "C99_Lexer.lex.c"

void yyerror(char const *s)
{
//   fflush(stdout);
//   printf("\n%*s\n%*s\n", column, "^", column, s);
}

#include "Parse.h"

// ------------ T_FlexLexer -----------
class myFlexLexer : public yyFlexLexer {
public:
   myFlexLexer(T_Source *s) :source(s) {}
   virtual int LexerInput(char* buf, int max_size);
public:
   T_Source* source;
};

T_FlexLexer::T_FlexLexer(T_Source *s) : TScanArray(s), lexer(NULL), source(s)
{}

T_FlexLexer::~T_FlexLexer()
{
   if (lexer) delete lexer; lexer = NULL;
}

bool T_FlexLexer::Open()
{
   lexer = new myFlexLexer(source);
   lexer->column = 0;
   lexer->unterminated_comment = false;
   return true;
}

int myFlexLexer::LexerInput(char* buf, int max_size)
{
   int sym;
   int len = 0;
   while (max_size-- > 0) {
      T_Source::T_Sym type = source->Read(sym);
      if (type == T_Source::slEof) break;
      buf[len++] = sym;
   }
   return len;
}

static int char_value(const char* buf)
{
   int value = 0;
   buf++;
   char sym = buf[0];
   if (sym == '\'') {
      return value; // error ''
   } else {
      if (sym == '\\') {
         buf++; sym = buf[0];
         switch (sym) {
         case 't': sym = 0x09; break;
         case 'n': sym = 0x0A; break;
         case 'r': sym = 0x0D; break;
         case 'v': sym = 0x0B; break;
         case '0': sym = 0x00; break;
         }
      }
      value = sym;
      buf++; sym = buf[0];
      if (sym == '\'') {
         // 'X'
      } else {
         // error 'X
      }
   }
   return value;
}

T_Lexeme::T_Group T_FlexLexer::LexMake(T_Lexeme &l)
{
   int token = lexer->yylex();
   l.line = lexer->lineno() - 1; l.len = lexer->YYLeng(); l.text = lexer->YYText();
   T_Lexeme::T_Group group = T_Lexeme::T_Group((token & 0xFF00) >> 8);
   int type = token & 0x00FF; 
   l.group = group; l.type = type;

   if ((group == T_Lexeme::grOper) || (group == T_Lexeme::grSeparator)) {
      l.value = symbol_table().Symbol(type).index;
      const T_Symbol& symbol = symbol_table().Symbol(l.value);
      l.text = symbol.text;
   } else if (group == T_Lexeme::grIdent) {
      if (!T_KeyWordTable::key_word_table.Find(l)) {
         l.value = names.Add(l.text, l);
      }
   } else if (group == T_Lexeme::grInteger) {
      // CONSTANT  = 0x0300, CONST_DEC = 0x0301, CONST_OCT = 0x0302, CONST_HEX = 0x0303, CONST_CHAR = 0x0304
      long l_val; char* str_end;
      if (type == 0x01) {
         l_val = atoi(l.text);
      } else if (type == 0x02) {
         l_val = strtol(l.text, &str_end, 8);
      } else if (type == 0x03) {
         l_val = strtol(l.text, &str_end, 16);
      } else if (type == 0x04) {
         l_val = char_value(l.text);
      }
      names.Add(l.text, l);
      l.type = 0;
      l.value = Integer(l_val);
   } else if (group == T_Lexeme::grNumber) {
      // CONST_NUM = 0x0400, CONST_NUM_1 = 0x0401, CONST_NUM_2 = 0x0402, CONST_NUM_HEX = 0x0403, CONST_NUM_HEX_1 = 0x0404, CONST_NUM_HEX_2 = 0x0405
      double number = atof(l.text);
      names.Add(l.text, l);
      l.type = 0;
      l.value = Number(number);
   } else if (group == T_Lexeme::grString) {
      l.value = names.Add(l.text, l);
   } else if (group == T_Lexeme::grReserv) {
      l.value = T_KeyWordTable::key_word_table.Index((T_Lexeme::W_Type)type);
      const T_Word& word = T_KeyWordTable::key_word_table.Word(l.value);
      if (!(word.mask & mask) || (word.mask & (mask << 16))) {
         l.value = names.Add(l.text, l);
         l.group = T_Lexeme::grIdent; l.type = 0;
      } else {
         l.text = word.text;
      }
   } else if (group == T_Lexeme::grNone) {
      if (lexer->unterminated_comment) {
         l.group = T_Lexeme::grError;
         lexer->unterminated_comment = false;
      } else {
         l.group = T_Lexeme::grEof;
      }
      l.len = 0;
   } else {
   }
   l.column = lexer->column - l.len;

   return l.group;
}

#ifndef TRN_LEXER_H
#define TRN_LEXER_H

#include "Parse.h"
#include <fstream>      // std::ifstream

class myFlexLexer;
class T_FlexLexer : public TScanArray
{
public:
   T_FlexLexer(T_Source *s = NULL);
   ~T_FlexLexer();
   virtual T_Lexeme::T_Group LexMake(T_Lexeme &l);
   bool Open();
protected:
   myFlexLexer* lexer;
   T_Source*    source;
};

#endif#include "stdafx.h"

#include "Rules.h"
#include "CGrammar.h"

int C_GrammarIdentTable::Find(const char* name) const
{
   TNameIndex::const_iterator ip = names.find(name); 
   if (ip != names.end()) {
      const std::pair<const Key, const int> item = (*ip);
      return item.second;
   } else {
      return 0;
   }
}

bool C_GrammarIdentTable::Add(const char* name, int type)
{
   TNameIndex::const_iterator ip = names.find(name); 
   if (ip != names.end()) {
      return false;
   } else {
      const std::pair<const Key, const int> item(name,type);
      names.insert(item); 
      return true;
   }
}

bool C_GrammarIdentTable::Copy(const C_GrammarIdentTable& join)
{
   int ret = 0;
   for (std::pair<const Key, const int> item : join.names) {
      if (!Add(item.first.key, item.second)) ret++;
   }
   return !ret;
}

int C_GrammarBlockTable::Find(const char* name) const
{
   int sign = -1;
   for (int i = (int)blocks.size() -1 ; i >= 0; i--) {
      int type = blocks[i].Find(name);
      if (type) return sign * type; 
      sign = 1;
   }
   return 0;
}

void C_GrammarBlockTable::Down()
{
   int master = (int)blocks.size() - 2 ;
   blocks[master].Copy(blocks.back());
}

void C_GrammarBlockTable::Pop()
{
/*
   for (const std::pair<const C_GrammarIdentTable::Key, const int> item : blocks.back().names) {
      printf("\n%d %s", item.second, item.first.key);
   }
   printf("\n");
*/
   blocks.pop_back(); 
}

void C_GrammarBlockTable::SaveParam()
{
   ClearParam();
   if ((blocks.size() == 2) && (blocks.back().Type() == C_GrammarIdentTable::T_Block::Param)) {
      ParamIdentTable = blocks.back();
   }
}

enum T_Lex { None, Declare, TypeDef, Comma, Semicolon, DeclComma, DeclSemicolon, ExprSemicolon, StmtSemicolon, 
             BegBlock, EndBlock, BegFunc, EndFunc, 
             StructBeg, StructEnd, EnumBeg, EnumEnd, EnumComma, 
             ParamBeg, ParamEnd, ParamComma, ListBeg, ListEnd, ListComma 
           };

bool C_Grammar_Syntax::Command(int command)
{
   switch (command) {
      case T_Lex::None           : break;
      case T_Lex::Declare        : break;
      case T_Lex::TypeDef        : Typedef(true); break;
      case T_Lex::DeclComma      : blocks.ClearParam(); break;
      case T_Lex::DeclSemicolon  : blocks.ClearParam(); Typedef(false); break;
      case T_Lex::BegBlock       : blocks.Push(C_GrammarIdentTable::T_Block::None); break;
      case T_Lex::EndBlock       : blocks.Pop();  break;
      case T_Lex::BegFunc        : blocks.PushParam(); blocks.Push(C_GrammarIdentTable::T_Block::Func); break;
      case T_Lex::EndFunc        : blocks.Pop();  blocks.Pop(); break;
      case T_Lex::StructBeg      : blocks.Push(C_GrammarIdentTable::T_Block::Struct); break;
      case T_Lex::StructEnd      : blocks.Pop();  break;
      case T_Lex::EnumBeg        : blocks.Push(C_GrammarIdentTable::T_Block::Enumer); break;
      case T_Lex::EnumEnd        : blocks.Down(); blocks.Pop(); break;
      case T_Lex::ParamBeg       : blocks.Push(C_GrammarIdentTable::T_Block::Param); break;
      case T_Lex::ParamEnd       : blocks.SaveParam(); blocks.Pop();  break;
      case T_Lex::ListBeg        : blocks.Push(); break;
      case T_Lex::ListEnd        : blocks.Pop();  break;
   }
//   printf("\nLevel %d Ident %d Typedef %d ",(int)blocks.blocks.size(),(int)blocks.blocks.back().names.size(),(int)Typedef()); 
   return true;
}

void C_Grammar_Syntax::UpdateLexeme(T_Lexeme &current_lexeme)
{
   if (current_lexeme.Match(T_Lexeme::grNumber)) {
      current_lexeme.group = T_Lexeme::grInteger;
   } else if (current_lexeme.Match(T_Lexeme::grString)) {
      current_lexeme.group = T_Lexeme::grInteger;
   } else if (current_lexeme.Match(T_Lexeme::grIdent)) {
      GSymbol ident(GSymbol::gsTerminal,T_Lexeme::grIdent,3); // Enumerator
      if (VerifyAction(ident)) {
         current_lexeme.type = 3; // ENUMERATOR
         IdentType(0x03); 
      } else {
         ident.lexeme_type = 2; // DECLARATOR
         bool declarator = VerifyAction(ident);
         ident.lexeme_type = 0; // IDENTIFIER
         bool identifier = VerifyAction(ident);
         if (declarator && !identifier) {
            current_lexeme.type = 2; // DECLARATOR
            if (Typedef()) {
               IdentType(0x01); // typedef_declarator 
            } else {
               IdentType(0x02); // declarator 
            }
         } else {
            if (abs(IdentType()) == 0x01) { // typedef
               current_lexeme.type = 1; // TYPE_NAME
            }
         }
      }
   }
//   printf("\nlevel %d ident %d typedef %d ",(int)blocks.blocks.size(),(int)blocks.blocks.back().names.size(),(int)Typedef()); 
}

int  C_Grammar_Syntax::IdentType(const T_Lexeme& l) const
{
   const char* text = syntax->Scan().Text(l);
   return text ? blocks.Find(text) : 0;
}

bool C_Grammar_Syntax::IdentType(const T_Lexeme& l, int type)
{
   bool add = false;
   const char* text = syntax->Scan().Text(l);
   if (text) {
      add = blocks.Add(text,type);
      if (!add) {
         syntax->error(T_Error::erDuplicateIdent);
      }
   }
   return add;
}
#ifndef TRN_C_GRAMMAR_H
#define TRN_C_GRAMMAR_H

#include "Parse.h"
#include "ASyntax.h"

// --------------------------- C_GrammarSyntax ---------------------------

class C_GrammarIdentTable {
public:
   enum T_Block { None, Global, Func, Param, List, Struct, Enumer };
public:
   C_GrammarIdentTable(T_Block t = T_Block::None) :type_name(false) { type = t; }
   bool Add(const char* name, int type);
   int  Find(const char* name) const;
   bool Copy(const C_GrammarIdentTable& join);
   void Clear() { names.clear(); }
   T_Block Type() { return type; }
   void Type(T_Block t) { type = t; }
public:
   struct Key {
      Key(const char* k) :key(k) {}
      const char* key;
      bool operator == (const Key& k) const { return strcmp(key,k.key) == 0; }
      bool operator <  (const Key& k) const { return strcmp(key,k.key) <  0; }
   };
   class TNameIndex : public std::map<const Key, const int> {
   } names;
public:
   bool Typedef() const { return type_name; }
   void Typedef(bool x) { type_name = x; }
protected:
   T_Block type;
   bool type_name;
};

class C_GrammarBlockTable {
public:
   C_GrammarBlockTable() {}
   bool Add(const char* name, int type) { return blocks.back().Add(name, type); }
   int  Find(const char* name) const;
   void Push(C_GrammarIdentTable::T_Block t = C_GrammarIdentTable::T_Block::None) { blocks.push_back(C_GrammarIdentTable(t)); }
   void PushParam() { blocks.push_back(ParamIdentTable); ClearParam(); }
   void Pop();
   void Down(); 
   void SaveParam(); 
   void ClearParam() { ParamIdentTable.Clear(); } 
public:
   std::vector<C_GrammarIdentTable> blocks;
public:
   C_GrammarIdentTable ParamIdentTable;
};

class C_Grammar_Syntax 
{
public:
   enum T_Terminal_Mask { qualifier = 0x01, specifier = 0x02, storage = 0x04, pointer = 0x08, declarator = 0x10 };
public:
   C_Grammar_Syntax(A_Syntax* s) : syntax(s) {}
   void UpdateLexeme(T_Lexeme &l);
   bool Command(int command);
   int  IdentType(const T_Lexeme& l) const;
   int  IdentType() const { return IdentType(current_lexeme); }
   bool IdentType(const T_Lexeme& l, int type);
   bool IdentType(int type) { return IdentType(current_lexeme, type); }
public:
   virtual bool VerifyAction(const GSymbol& current_sym) { return false; }
   bool Typedef() const { return blocks.blocks.back().Typedef(); }
   void Typedef(bool x) { blocks.blocks.back().Typedef(x); }
public:
   C_GrammarBlockTable blocks;
   T_Lexeme current_lexeme;
public:
   A_Syntax* syntax;
};

#endif
#include "stdafx.h"
#include "CSyntax.h"
#include "TSemantic.h"

// --------------------------- CSyntax ---------------------------

void CSyntax::clear(TNode* node)
{
   if (node) { node->clear(); delete node; } 
}

bool CSyntax::Assign()
{
   if (!Question()) return false;
	if (Match(T_Symbol::prAssign)) {
      T_Lexeme lexeme = forward;
	   if (!Assign()) return false;
      if (!BinaryOper(lexeme)) return false;
	}
   return true;
}

bool CSyntax::Question()
{
   if (!Binary(T_Symbol::prOrOr)) return false;
	if (Match(T_Symbol::prQuestion)) {
      if (!MakeLogic()) return false;
      TExprStackItem logic = TipTop(); 
      AddCode(logic.true_label);
	   if (!Question()) return false;
      TNodeLabel *label_end = new TNodeLabel(semantic);
      TNodeGoTo* go_then = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
      AddCode(go_then);
		if (!MatchMust(T_Symbol::lxColon)) return false;
      AddCode(logic.false_label);
	   if (!Question()) return false;
      MakeValue();
      TExprStackItem right = TipTop(); 
      MakeValue();
      TExprStackItem left  = TipTop(); 
      T_BaseType result = CastableBetween(left.type,right.type);
	   if (result == btUnknown) { return error(erUnknownCast); }
      GenCastable(right.type,result,right.made);
      GenCastable(left .type,result,left .made);
      AddCode(label_end);
      Push(result);
	}
   return true;
}

bool CSyntax::Unary()
{
	if (Match(T_Symbol::prUnary) || Match(T_Symbol::prTerm) || Match(T_Symbol::prIncDec)) {
      T_Lexeme lexeme = forward;
      ChangeUnary(lexeme,true);
      if (!Unary()) return false;
      TExprStackItem& operand = Top();
      if ((operand.type == btLogical) && lexeme.Match(T_Symbol::lxNot)) {
         TNodeLabel *label = operand.true_label; operand.true_label = operand.false_label; operand.false_label = label;
      } else {
         if (!UnaryOper(lexeme)) return false;
      }
	   return true;
	}
   T_ScanStore store; Store(store);
   if (Match(T_Symbol::lxLeftBracket)) {
   	int detail = Match(T_Lexeme::W_Type::rwConst) ? 0x02 : 0x00;
      if (Match(T_Lexeme::W_Type::rwDefine)) {
         T_Lexeme lexeme = forward;
         if (Match(T_Symbol::lxRightBracket)) {
            if (!Unary()) return false;
            MakeValue();
            const TNodeType *type = TBaseType::BaseType(lexeme,detail);
            if (!GenCastable(Top().type,type->BaseType(),Top().made)) return error(erUnknownCast);
            Top().type = type->BaseType();
	         return true;
         }
      } else {
         if (detail) return error_true(erUnknownCast);
      } 
	}
   Restore(store);
   bool ret = Primary(); if (!ret) return false;
	while (Match(T_Symbol::prIncDec)) {
      T_Lexeme lexeme = forward;
      ChangeUnary(lexeme,false);
      if (!UnaryOper(lexeme)) return false;
   }
   return true;
}

bool CSyntax::Index(const T_Lexeme &lexeme)
{
   TNodeDefVar* def = semantic->FindIdent(lexeme);
   int  count = 0;
   while (Match(T_Symbol::lxLeftScrape)) {
   	if (!Expressions(psValue)) return false;
      Pop(); // cast -> const int
      count++;
      if (!MatchMust(T_Symbol::lxRightScrape)) return false;
   }
   if (def) {
      TNodeDefArr *def_arr = dynamic_cast<TNodeDefArr*> (def);
      if (def_arr && (count == def_arr->ranges.count())) {
         semantic->GenCommand(T_Command::command_PushArr,def_arr->offset,def_arr->alloc,def_arr->BaseType()); 
         Push(def_arr->BaseType());
      } else {
         return error(erInvalidType,lexeme);
      }
   } else {
      return error(erUnknownIdent,lexeme);
   }
   return true;
}

bool CSyntax::Call(const T_Lexeme &lexeme)
{
   bool ret = true;
   TFuncProfile profile; 
   std::vector<int> mades;
	if (!Match(T_Symbol::lxRightBracket)) {
	   do {
			if (!Assign()) { return false; }
         MakeValue();
         TExprStackItem& param = Top();
         if ((param.type == btUnknown) || (param.type == btVoid)) {
            return error(erUnknownParam);
         }
         profile.Add(param.type); Top(); mades.push_back(made());
		} while (Match(T_Symbol::lxComma));
	   if (!MatchMust(T_Symbol::lxRightBracket)) { return false; }
	}
   profile.ident = lexeme;
   TNodeDefFunc* func = semantic->FuncTable.Find(profile);
   if (func) {
      profile.result = func->profile->result;
      for (int i = (int)mades.size() - 1; i >= 0; i--) {
         semantic->GenCastable(profile[i], (*func->profile)[i], mades[i]);
      }
		int number = func->number;
      semantic->GenCommand(T_Command::command_Call,number,0,profile.result); 
      Push(profile.result);
   } else {
      ret = error(erUnknownFunc,lexeme);
   }
   return ret;
}

bool CSyntax::Primary()
{
   if (Match(T_Lexeme::grIdent)) {
      T_Lexeme lexeme = forward;
		if (Match(T_Symbol::lxLeftBracket)) {
         bool ret = Call(lexeme);
			return ret;
		}
		if (MatchSpot(T_Symbol::lxLeftScrape)) {
         bool ret = Index(lexeme);
			return ret;
		}
      TNodeDefVar *def_var = semantic->FindIdent(lexeme); 
      if (!def_var) { return error(erUnknownIdent,lexeme); }
      if (def_var->uninitialized) { return error(erUninitialized,lexeme); }
      semantic->GenCommand(T_Command::command_PushVar,def_var->offset,def_var->alloc,def_var->BaseType()); 
      Push(def_var->BaseType());
   	return true;
   	}
   if (Match(T_Lexeme::grInteger) || Match(T_Lexeme::grNumber)) {
      T_Lexeme lexeme = forward;
      semantic->GenNumber(lexeme); 
      T_BaseType base_type = (lexeme.group == lexeme.grInteger) ? btCInt : ((lexeme.group == lexeme.grNumber) ? btCDouble : btUnknown);
      Push(TExprStackItem(base_type, lexeme));
		return true;
   }
   if (Match(T_Symbol::lxLeftBracket)) {
      if (!Expressions() || !Match(T_Symbol::lxRightBracket)) return false;
		return true;
      }
   if (Match(T_Lexeme::W_Type::rwDefine)) {
      T_Lexeme lexeme = forward;
	   if (!MatchMust(T_Symbol::lxLeftBracket) || !Expressions(psValue) || !MatchMust(T_Symbol::lxRightBracket)) return false;
      const TNodeType *type = TBaseType::BaseType(lexeme,0);
      if (!GenCastable(Top().type,type->BaseType(),Top().made)) return error(erUnknownCast,lexeme);
      Top().type = type->BaseType();
		return true;
   }
   return error(erPrimary);
}

bool CSyntax::Binary(T_Symbol::T_Priority priority)
{
   if ((priority + 1) < T_Symbol::prUnary) {
      if (!Binary(T_Symbol::T_Priority(priority + 1))) return false;
   } else {
      if (!Unary()) return false;
   }
   while (Match(priority)) {
      T_Lexeme lexeme = forward;
      if ((priority + 1) < T_Symbol::prUnary) {
         if (!Binary(T_Symbol::T_Priority(priority + 1))) return false;
      } else {
         if (!Unary()) return false;
      }
      if ((priority == T_Symbol::prOrOr ) || (priority == T_Symbol::prAndAnd)) {
         if (!BinaryLogic(lexeme)) return false;
      } else {
         if (!BinaryOper(lexeme)) return false;
      }
   }
   return true;
}

bool CSyntax::Expressions(T_Part part) // !param_list
{
   do {
      if (!Assign()) return false;
      const TExprStackItem& result = Top();
      if (MatchSpot(T_Symbol::lxComma)) { // !last
         if (result.type == btLogical) {
            AddCode(result.false_label); AddCode(result.true_label);
         } else if (result.value()) {
            semantic->GenPop(1);
         }
         Pop();
      } else if (part != psNone) { // last && !primary
         if ((part & psIfGoTo)) { 
            if (!MakeLogic()) return false;
         } else if (part & psValue) {
            MakeValue();
            if (!Top().value()) return false;
         } else {
            if (result.value()) {
               semantic->GenPop(1);
            }
            Pop();
         }
      }
   } while (Match(T_Symbol::lxComma));
   return true;
}

bool CSyntax::Statement(T_Part part)
{
	if (Match(T_Symbol::lxSemicolon)) return !(part & T_Part::psNoSemicolon);

   if (part & T_Part::psDefine) {
      T_Lexeme l;
      int def = SCDefine(l,0x26); // -1 - error, 0, 0x01 - define, 0x02 - const, 0x04 - static, 0x20 - void
		if (def < 0) return false;
 		if (def) {
         forward = l;
		   return Define(part,def);
		}
	}
   if (part & T_Part::psStatement) {
      T_Lexeme lexeme;
      T_ScanStore store; Store(store);
      if (Match(lexeme,T_Lexeme::grIdent) && Match(T_Symbol::lxColon)) {
			TNodeUserLabel* label = new TNodeUserLabel(lexeme);
         semantic->MakeGoToLabel(label);
         semantic->UserLabelTable.Add(label);
         semantic->ExecStack.Label();
         AddCode(label);
         return Statement(T_Part::psLabel);
      } 
      Restore(store);
      if (Match(T_Lexeme::W_Type::rwFor))      return For();
      if (Match(T_Lexeme::W_Type::rwWhile))    return While();
      if (Match(T_Lexeme::W_Type::rwIf))       return If();
      if (Match(T_Lexeme::W_Type::rwDo))       return Do();
      if (Match(T_Lexeme::W_Type::rwContinue)) return BreakContinue(T_Block::tbContinue);
      if (Match(T_Lexeme::W_Type::rwBreak))    return BreakContinue(T_Block::tbBreak);
      if (Match(T_Lexeme::W_Type::rwGoTo))     return GoTo();
      if (Match(T_Lexeme::W_Type::rwReturn))   return Return();
      if (Match(T_Lexeme::W_Type::rwSwitch))   return Switch();
	}
   if (part & T_Part::psCompaund) {
      if (Match(T_Symbol::lxLeftCramp)) return Compaund();
	}

   if (part & T_Part::psExpression) {
      return Expressions(part) && ((part & T_Part::psNoSemicolon) || Match(T_Symbol::lxSemicolon));
	}

   return false;
}

bool CSyntax::Compaund()
{
   TNodeStatements *compaund = new TNodeStatements();
   semantic->BlockBegin(compaund);
   while (!Match(T_Symbol::lxRightCramp)) {
      if (!Statement(T_Part::psBody)) return false;
   }
   semantic->BlockEnd(NULL,true);
   return true;
}

bool CSyntax::Statements(T_Part part)
{
   TNodeStatements *statements = new TNodeStatements();
   semantic->BlockBegin(statements);
   while (!Match(T_Lexeme::grEof)) {
      if (!Statement(part)) return false;
   }
   semantic->BlockEnd(NULL,true);
   return true;
}

bool CSyntax::Translate()
{
   bool ret = Statements(T_Part::psMain);
   return ret;
}

bool CSyntax::DefineParam(TNodeDefVar* &par)
{
   T_Lexeme lexeme;
   int def = SCDefine(lexeme, 0x02); // -1 - error, 0, 0x01 - define, 0x02 - const, 0x08 - &
	if (def < 0) return false;
   if (!def) return error(erDefine);
   T_Lexeme ident = (Match(T_Lexeme::grIdent) ? forward : empty_ident);
   TNodeType *type = BaseType(lexeme,def); // owner + clear
	if (MatchSpot(T_Symbol::lxLeftScrape)) {
      if (def & 0x08) { return error_true(erDefArr); } // reference ???
      TNodeDefArr *param = new TNodeDefArr(type,ident,NULL);
      int scrape = 0;
   	while (Match(T_Symbol::lxLeftScrape)) {
   	   if (!scrape++ && Match(T_Symbol::lxRightScrape)) continue;
   		if (!Assign()) { clear(param); return false; }
         Pop();
         TDefArrRangeItem item;
         param->ranges.push_back(item);
   	   if (!MatchMust(T_Symbol::lxRightScrape)) { clear(param); return false; }
   	}
      if (Match(T_Symbol::lxAssign)) {
     		if (!Assign()) { clear(param); return false; }
      } else if (param->BaseType() & T_BaseType::btReference) {
         error(erUninitialized);
      }
      par = param;
      return true;
   }
   TNodeDefVar *param = new TNodeDefVar(type,ident);
   if (Match(T_Symbol::lxAssign)) {
  		if (!Assign()) { clear(param); return false; }
   } else if (param->BaseType() & T_BaseType::btReference) {
      error(erUninitialized);
   }
   par = param;
   return true;
}

bool CSyntax::Function(TNodeDefFunc *function, int &def)
{
   TFuncProfile &profile = *(function->profile = new TFuncProfile());
   semantic->BlockBegin(function);
   profile.result = function->BaseType();
   profile.ident = function->Lexeme();
	if (!Match(T_Symbol::lxRightBracket)) {
      do {
         TNodeDefVar *param = NULL;
         if (!DefineParam(param)) { clear(function); return false; }
         semantic->AddDef(param); 
         profile.Add(param->BaseType());
      } while (Match(T_Symbol::lxComma));
      if (!MatchMust(T_Symbol::lxRightBracket)) { clear(function); return false; }
   }
   bool yes_body = Match(T_Symbol::lxLeftCramp);
   if (yes_body) {
      function->SetBody(new TNodeNull());
   }
   semantic->AddFunc(function);
   semantic->ExecStack.Push();
   if (yes_body) {
      if (!Compaund()) return false;
      def = -2;
   }
   int exec_mode = semantic->ExecStack.Pop();
   if (def == -2) {
      if (!(exec_mode & T_ExecMode::meRestituer)) {
         if ((TBaseType::Tilda(function->BaseType(),T_BaseType::btStatic) != T_BaseType::btVoid) && (function->BaseType() != T_BaseType::btUnknown)) {
            return error_true(erNoReturn);
         }
      }
   
      semantic->UserGoToTable .Verify();
      semantic->UserLabelTable.Verify();
      semantic->UserGoToTable .clear();
      semantic->UserLabelTable.clear();
   
      semantic->GenCommand(T_Command::command_Exit,function->number,0,T_BaseType::btVoid);
   }
   semantic->BlockEnd(NULL);
   return true;
}

bool CSyntax::Initializer(TNodeDefArr &arr, int level)
{
   if (!MatchMust(T_Symbol::lxLeftCramp)) return false;
   if (!Match(T_Symbol::lxRightCramp)) {
      do {
         if (MatchSpot(T_Symbol::lxLeftCramp)) {
            if ((level + 1) >= arr.ranges.count()) return error(erInvalidInit);
            if (!Initializer(arr, level + 1)) return false;
         } else {
            if (!arr.ranges.next()) return error(erInvalidInit);
            if (!Assign()) return false;
            MakeValue();
            TExprStackItem operand = TipTop();
      		if (!semantic->GenCastable(operand.type, TBaseType::Const(arr.BaseType()))) {
               return error(erUnknownCast);
   	   	}
            semantic->GenCommand(T_Command::command_PushInt,arr.ranges.offset(),0,btCInt);
            semantic->GenCommand(T_Command::command_InitArr,arr.offset,arr.alloc,arr.BaseType()); 
         }
      } while (Match(T_Symbol::lxComma));
      if (!MatchMust(T_Symbol::lxRightCramp)) return false;
   }
   arr.ranges.jump(level);
   return true;
}

bool CSyntax::Array(TNodeDefArr *arr)
{
   int scrape = 0;
   bool unknown_range = false;
   int first_range_made = 0;
   while (Match(T_Symbol::lxLeftScrape)) {
      TDefArrRangeItem item;
      if (!scrape++ && Match(T_Symbol::lxRightScrape)) {
         item.range = -1;
         arr->ranges.push_back(item);
         AddCode(new TNodeCommand(T_Command::command_PushInt,item.range,0,btCInt));
         first_range_made = made();
         unknown_range = true;
         continue;
      }
   	if (!Assign()) { clear(arr); return false; }
      TExprStackItem range = TipTop();
      if ((range.type == btCInt) && (range.lexeme.group == T_Lexeme::grInteger)) {
         item.range = Integer(range.lexeme);
      	if (item.range < 1) { error(erRanges); item.range = -2; }
      } else {
         item.range = -2;
         if (!semantic->GenCastable(range.type, btCInt)) {
            return error(erUnknownCast);
         }
      }
      arr->ranges.push_back(item);
      if (!MatchMust(T_Symbol::lxRightScrape)) { clear(arr); return false; }
   }
   arr->ranges.calc();
   semantic->AddDef(arr);
   int count = scrape;
   semantic->GenCommand(T_Command::command_NewArr,count,arr->alloc,arr->BaseType()); 
   if (Match(T_Symbol::lxAssign)) {
      if (arr->ranges.variable_range()) { clear(arr); return error(erInvalidInit); }
      if (Initializer(*arr,0)) {
         if (unknown_range) {
            arr->ranges[0].range = arr->ranges[0].index;
            if (arr->ranges.count() == 1) arr->ranges[0].range++;
            TNodeCommand* command = (TNodeCommand*)GetCommand(first_range_made - 1);
            command->param = arr->ranges[0].range;
         }
      } else {
         clear(arr);
         return error(erInvalidInit);
      }
   } else if (arr->BaseType() & T_BaseType::btConstReference) {
      error(erUninitialized,arr->Lexeme());
   }
   return true;
}

int CSyntax::DefineItem(const T_Lexeme &lexeme, T_Part part, int detail, TNode* &node) // 0x04 - static, 0x02 - const
{
	if (Match(T_Symbol::lxAnd)) detail |= 0x08; // reference
   if (!Match(T_Lexeme::grIdent)) return error(erNoIdent);
   TNodeType *type = BaseType(lexeme,detail);
   T_Lexeme ident = forward;

   if (Match(T_Symbol::lxLeftBracket)) {
      if (!(part & psDefFunc)) { return error(erDefFunc); }
      TNodeDefFunc *func = new TNodeDefFunc(type,ident,NULL,NULL);
      node = func;
      return -1;
   }
   if (lexeme.Match(T_Lexeme::W_Type::rwVoid)) { return error(erDefVoid); }

	if (MatchSpot(T_Symbol::lxLeftScrape)) {
		if ((detail & 0x08) || (part & T_Part::psOneDef)) { return error(erDefArr); } // reference
      TNodeDefArr *arr = new TNodeDefArr(type, ident, NULL);
      return Array(arr);
   }

   TNodeDefVar *var = new TNodeDefVar(type, ident);
   semantic->AddDef(var);
   semantic->GenCommand(T_Command::command_NewVar,var->offset,var->alloc,var->BaseType()); 

   if (Match(T_Symbol::lxAssign)) {
      T_Lexeme lexeme = forward;
      semantic->GenCommand(T_Command::command_PushVar,var->offset,var->alloc,var->BaseType()); 
      var->uninitialized = true;
      Push(TBaseType::Tilda(var->BaseType(),T_BaseType::btConst));
      if (!Assign()) { clear(var); return false; }
      if (!BinaryOper(lexeme)) { clear(var); return false; }
      semantic->GenPop(1);
      Pop();
      var->uninitialized = false;
   } else if (var->BaseType() & T_BaseType::btConstReference) {
      error(erUninitialized,ident);
   }
   if (part & T_Part::psOneDef) { // condition
      semantic->GenCommand(T_Command::command_PushVar,var->offset,var->alloc,var->BaseType()); 
      Push(var->BaseType());
      if (!MakeLogic()) return false;
   }
   return true;
}

bool CSyntax::Define(T_Part part, int constant) // 0x02 - static, 0x01 - const
{
   T_Lexeme lexeme = forward;
   int count = 0, def;
   TNode* node = NULL;
   do {
      def = DefineItem(lexeme, part, constant, node);
      if (!def) return false;
      count++;
      if (part & T_Part::psOneDef) break;
   } while (Match(T_Symbol::lxComma));
   if ((count == 1) && (def == -1)) {
      if (!Function(dynamic_cast<TNodeDefFunc*>(node),def)) return false;
   }
   return (part & T_Part::psNoSemicolon) || Match(T_Symbol::lxSemicolon) || (def == -2);
}

bool CSyntax::For()
{
   TNodeFor *cycle = new TNodeFor();
   semantic->BlockBegin(cycle);
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psForBeg)) return false;  // prefix

   TNodeLabel *label_condition = new TNodeLabel(semantic), *label_body, *label_end;
   TNodeLabel *label_continue = new TNodeLabel(semantic), *&label_break = label_end;

   AddCode(label_condition);
   int before_condition = made();
   if (!Statement(T_Part::psForExpr)) return false; // condition
   int after_condition = made();
   if (after_condition > before_condition) {        // yes condition
      TExprStackItem logic = TipTop();
      label_body = logic.true_label; label_end = logic.false_label;
   } else {
      label_body = new TNodeLabel(semantic); label_end = new TNodeLabel(semantic);
   }

   AddCode(label_continue);
   if (!Match(T_Symbol::lxRightBracket)) {
      if (!Expressions(psExpression)) return false;  // postfix
      if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   }
   TNodeGoTo* go_cycle = new TNodeGoTo(T_GoTo::tgGoTo,label_condition); 
   AddCode(go_cycle);

   AddCode(label_body);
   semantic->ExecStack.Push();
   cycle->BreakContinueLabel(label_break,label_continue);
   if (!Statement(T_Part::psBody)) return false;    // body
    
   semantic->ExecStack.Down();
   TNodeGoTo* go_continue = new TNodeGoTo(T_GoTo::tgGoTo,label_continue);
   AddCode(go_continue);

   AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   return true;
}

bool CSyntax::While()
{
   TNodeWhile *cycle = new TNodeWhile();
   semantic->BlockBegin(cycle);
   TNodeLabel *label_while = new TNodeLabel(semantic);
   AddCode(label_while);
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psCondition)) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   TExprStackItem logic = TipTop(); 
   TNodeLabel *label_body = logic.true_label, *label_end = logic.false_label;

   semantic->ExecStack.Push();
   cycle->BreakContinueLabel(label_end,label_while);
   AddCode(label_body);
   if (!Statement(T_Part::psBody)) return false;
    
   semantic->ExecStack.Down();
   
   TNodeGoTo* go_cycle = new TNodeGoTo(T_GoTo::tgGoTo,label_while);
   AddCode(go_cycle);
   AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   return true;
}

bool CSyntax::Do()
{
   TNodeDo *cycle = new TNodeDo();
   semantic->BlockBegin(cycle);

   TNodeLabel *label_do = new TNodeLabel(semantic), *label_while = new TNodeLabel(semantic), *label_end = new TNodeLabel(semantic);
   AddCode(label_do);
   semantic->ExecStack.Push();
   cycle->BreakContinueLabel(label_end,label_while);
   if (!Statement(T_Part::psBody)) return false;
    
   semantic->ExecStack.Down();

   AddCode(label_while);
   if (!Match(T_Lexeme::W_Type::rwWhile)) return false;
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psCondition)) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   TExprStackItem logic = TipTop(); 
   semantic->Reference(logic.true_label,label_do);
   semantic->Reference(logic.false_label,label_end);

   AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   clear(cycle);
   return MatchMust(T_Symbol::lxSemicolon);
}

bool CSyntax::If()
{
   TNodeIf *statement = new TNodeIf();
   semantic->BlockBegin(statement);

   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psCondition)) return false;    // condition
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   TExprStackItem logic = TipTop(); 

   statement->trunc = statement->size;
   semantic->ExecStack.Push();
   AddCode(logic.true_label);
   if (!Statement(T_Part::psBody)) return false;    // then
   semantic->BlockTrunc(statement->trunc);

   int then_exec = semantic->ExecStack.Pop();
   semantic->ExecStack.Push();

   TNodeLabel *label_end = new TNodeLabel(semantic);
   TNodeGoTo* go_then = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
   AddCode(go_then);
   AddCode(logic.false_label);
   if (Match(T_Lexeme::W_Type::rwElse)) {
      if (!Statement(T_Part::psBody)) return false; // else
   }
   int else_exec = semantic->ExecStack.Pop();
   semantic->ExecStack.Up(then_exec & else_exec);

   AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   return true;
}

bool CSyntax::GoTo()
{
   T_Lexeme lexeme = forward; // goto
   if (!Match(T_Lexeme::grIdent)) return error(erNoIdent);
   GenGoTo(forward); // ident
   return MatchMust(T_Symbol::lxSemicolon);
}

bool CSyntax::BreakContinue(T_Block rate)
{
   return GenBreakContinue(rate,forward) && MatchMust(T_Symbol::lxSemicolon);
}

bool CSyntax::Return()
{
   bool value = false;
	if (!Match(T_Symbol::lxSemicolon)) {
      if (!Expressions(psValue)) return false;
      MakeValue();
      value = true;
   }
   GenReturn(value);
   return !value || MatchMust(T_Symbol::lxSemicolon);
}

bool CSyntax::Switch()
{
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psCondition)) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   if (!MatchMust(T_Symbol::lxLeftCramp)) return false;
   int case_count = 0, default_count = 0;
   do {
      while (Match(T_Lexeme::W_Type::rwCase) || Match(T_Lexeme::W_Type::rwDefault)) {
         if (forward.Match(T_Lexeme::W_Type::rwCase)) {
            case_count++; 
            if (!Question()) return error(erNoInteger);;
         } else {
            if (default_count++) return false;
         } 
         if (!MatchMust(T_Symbol::lxColon)) return false;
      }
      while (!MatchSpot(T_Lexeme::W_Type::rwCase) && !MatchSpot(T_Lexeme::W_Type::rwDefault) && !MatchSpot(T_Symbol::lxRightCramp)) {
         if (!Statement(T_Part::psCase)) return false;
      }
   } while (!Match(T_Symbol::lxRightCramp));
   if (!case_count || (default_count > 1)) return false;
   return true;
}
#ifndef TRN_CSYNTAX_H
#define TRN_CSYNTAX_H

#include "Parse.h"
#include "ASyntax.h"
#include "TNodes.h"
 
// --------------------------- CSyntax ---------------------------
class TSemantic;

struct TExprStackItem {
public:
   TExprStackItem() :part(T_Part::psNone), param(0), made(0), type(T_BaseType::btUnknown), node(NULL), true_label(NULL), false_label(NULL) {}
   TExprStackItem(T_Part p) :part(p), param(0), made(0), type(T_BaseType::btUnknown), node(NULL), true_label(NULL), false_label(NULL) {}
   TExprStackItem(T_BaseType t) :part(T_Part::psNone), param(0), made(0), type(t), node(NULL), true_label(NULL), false_label(NULL) {}
   TExprStackItem(T_BaseType t, const T_Lexeme &l) :lexeme(l), part(T_Part::psNone), param(0), made(0), type(t), node(NULL), true_label(NULL), false_label(NULL) {}
   TExprStackItem(TNode* n) :part(T_Part::psNone), param(0), made(0), type(T_BaseType::btUnknown), node(n), true_label(NULL), false_label(NULL) {}
   bool value() const { return (type != btVoid) && (type != btLogical) && (type != btUnknown); }
public:
   T_Part part;
   int    made, param;
   TNodeLabel *true_label, *false_label;
   T_BaseType type;
   T_Lexeme   lexeme;
   TNode*     node;
};

class TExprStack : public std::stack<TExprStackItem> {
public:
   TExprStack() {}
   void Push(const TExprStackItem& item) { push(item); }
   void Push(T_BaseType t)               { Push(TExprStackItem(t)); }
   TExprStackItem& Top()                 { return top(); }
   void Pop()                            { pop(); }
   T_BaseType PopType()                  { if (empty()) return btUnknown; T_BaseType ret = Top().type; Pop(); return ret; }
public:
};

class C_Syntax
{
public:
	C_Syntax() :stack(), semantic(NULL), trunc_type(0) {}
   bool UnaryOper(const T_Lexeme &l);
   bool BinaryOper(const T_Lexeme &l);
   bool BinaryLogic(const T_Lexeme &l);
   bool GenCastable(T_BaseType from, T_BaseType to, int& made);
   bool GenCastable(T_BaseType from, T_BaseType to) { int made = -1; return GenCastable(from, to, made); }
   bool MakeLogic();
   void MakeValue();
   void GenReturn(bool value);
   bool GenBreakContinue(T_Block r, const T_Lexeme &l);
   void GenGoTo(const T_Lexeme &l);

   T_BaseType PopType()                  { return stack.PopType(); }
   void Push(const TExprStackItem& item) { stack.Push(item); stack.Top().made = made(); } // +made
   void Push(T_BaseType t)               { Push(TExprStackItem(t)); }
   void PushWithoutMade(const TExprStackItem& item) { stack.Push(item); } // !made
   void Pop()                            { stack.Pop(); }
   TExprStackItem& Top()                 { return stack.Top(); }
   TExprStackItem  TipTop()              { TExprStackItem item = stack.Top(); stack.Pop(); return item; }
   int  CountTypes() const               { return (int)stack.size(); }
   void TruncTypes(int trunc)            { while (trunc < CountTypes()) { stack.pop(); trunc_type++; } }

   void AddCode(TNode* code, int counter = -1);
   void InsCode(TNode* code, int counter);
   int  made();
   TNode* GetCommand(int counter);

   void set_semantic(TSemantic* s) { semantic = s; }

	virtual bool error_code(T_Error code, int value = 0) { return false; }

public:
   TSemantic* semantic;
   TExprStack stack;
   int trunc_type;
};

class CSyntax : public A_Syntax, public C_Syntax
{
public:
   CSyntax(T_Scan *s) :A_Syntax(s) { make_mode = mmCode; }

	bool Assign();	
	bool Question();
	bool Unary();
	bool Primary();
   bool Call(const T_Lexeme &l);
   bool Index(const T_Lexeme &l);
   bool Function(TNodeDefFunc *function, int &def);
   bool Array(TNodeDefArr *arr);

	bool Binary(T_Symbol::T_Priority priority);

	bool Expressions(T_Part part = T_Part::psNone);
   bool Statement(T_Part part);
   bool Statements(T_Part part);
   bool Compaund();

	bool Define(T_Part part, int constant); // 0x02 - static, 0x01 - const
	int  DefineItem(const T_Lexeme &l, T_Part part, int constant, TNode* &node); // 0x02 - static, 0x01 - const
   bool DefineParam(TNodeDefVar* &par);
   bool Initializer(TNodeDefArr &arr, int level);
	bool For();
	bool If();
	bool While();
	bool Do();
	bool GoTo();
	bool BreakContinue(T_Block rate);
	bool Return();
	bool Switch();

public:
   virtual bool Translate();
   virtual void clear(TNode* node);
	virtual bool error_code(T_Error code, int value = 0) { return A_Syntax::error(code,value); }

};

#endif


   FORMULA(S_) 
      PRODUCE RULE(Program) END
   END

   FORMULA(Program)
#if   defined(DEFINE_RULE_FULL)
      PRODUCE RULE(Defines) END
#elif defined(DEFINE_RULE_DEF)
      PRODUCE RULE(Define) END
#elif defined(DEFINE_RULE_EXPR)
      PRODUCE EXPRESSION(Expression) END
#elif defined(DEFINE_RULE_STMT)
      PRODUCE RULE(StmExpr) END
#else
#endif
   END

   FORMULA(DefParInit)
      PRODUCE OPER(Assign) MAKE_CODE(BegParVarAssign) RULE(Assign) MAKE(ParVarAssign) END
      EMPTY 
   END

   FORMULA(DefParVar)
      PRODUCE GROUP(DefVar) MAKE_YACC(DefType) LEX(Ident) MAKE(DefParVar) RULE(DefParInit) MAKE_NODE(DefVar,L(2,1),0) END
   END

   FORMULA(DefParArr)
      PRODUCE GROUP(DefArr) MAKE_YACC(DefType) GROUP(IdentArr) MAKE(DefParArr) RULE(DefArrDA) MAKE_NODE(DefArr,L(3,0,1),0) RULE(DefParInit) MAKE_NODE(DefArr,L(1,2),2) END
   END

   FORMULA(DefPar) 
      PRODUCE RULE(DefParArr) END
      PRODUCE RULE(DefParVar) END
   END

   FORMULA(DefParItem)
      PRODUCE RULE(DefPar) MAKE_TREE(AddToList) END
   END

   FORMULA(DefParList)
      PRODUCE SYM(Comma) RULE(DefParItem) PARAM(MAKE_YACC(AddToList),0x06) MASTER END
      EMPTY 
   END

   FORMULA(DefParams)
      PRODUCE PARAM(MAKE_TREE(Define), 0x02) RULE(DefParItem) MAKE_NODE(Define,L(1,2),1) RULE(DefParList) MAKE_TREE(EndParams) END
   END

   FORMULA(BodyFunc)
      PRODUCE SYM(Semicolon) PARAM(MAKE(BodyFunc),0x00) END
      PRODUCE GROUP(EmptyCramp) PARAM(MAKE(BodyFunc),0x01) MAKE_NODE(Null,L(1),0) END
      PRODUCE SYM(LeftCramp) MAKE_CODE(EndParams) RULE(StmExpr) MAKE_NODE(Copy,L(1),0) SYM(RightCramp) PARAM(MAKE(BodyFunc),0x02) END
   END

   FORMULA(DefFunc_)
      PRODUCE GROUP(EmptyBracket) END
      PRODUCE SYM(LeftBracket) RULE(DefParams) MAKE_NODE(Copy, L(1), 0) SYM(RightBracket) END
   END

   FORMULA(DefFunc)
      PRODUCE GROUP(DefFunc) MAKE_NODE(DefFunc,L(0),0) GROUP(IdentFunc) MAKE_NODE(DefFunc,L(0),1) MAKE(FuncIdent) RULE(DefFunc_) MAKE_NODE(DefFunc,L(0),2) RULE(BodyFunc) MAKE_NODE(DefFunc,L(0),3) END
   END

   FORMULA(AInitialList)
      PRODUCE SYM(Comma) RULE(AInitItem) PARAM(MAKE_YACC(AddToList), 0x06)  MAKE_TREE(AddToList) MASTER END
      EMPTY
   END
  
   FORMULA(AInitial)
      PRODUCE RULE(AInitItem) MAKE_TREE(AddToList) PARAM(MAKE_YACC(AddToList),0x06) RULE(AInitialList) END
   END

   FORMULA(Initializer)
      PRODUCE GROUP(EmptyCramp) MAKE_CODE(BegInitial) MAKE_TREE(NodeList) MAKE_NODE(List,L(0),0) END
      PRODUCE SYM(LeftCramp) PARAM(MAKE_CODE(BegInitial),0x01) MAKE_TREE(NodeList) MAKE_NODE(List,L(0,2),0) RULE(AInitial) SYM(RightCramp) MAKE_CODE(EndInitial) END
   END

   FORMULA(AInitItem)
      PRODUCE RULE(Initializer) END
      PRODUCE RULE(Assign) MAKE_CODE(AInitItem) END
   END

   FORMULA(DefAInit)
      PRODUCE OPER(Assign) MAKE_CODE(BegAInit) RULE(Initializer) MAKE(EndAInit) END 
      EMPTY
   END

   FORMULA(DRanges)
      PRODUCE SYM(LeftScrape) RULE(Assign) PARAM(MAKE_YACC(AddToList),0x0A)  SYM(RightScrape) MAKE(DRange) MASTER END
      EMPTY
   END

   FORMULA(DefArrD1A) 
      PRODUCE GROUP(EmptyScrape) MAKE(DefArrD1AEmpty) MAKE_NODE(Ranges,L(0),5) END // Null
      PRODUCE SYM(LeftScrape) RULE(Assign) MAKE_NODE(Ranges,L(1),2) SYM(RightScrape) MAKE(DRange) END // create
   END

   FORMULA(DefArrDA)
      PRODUCE RULE(DefArrD1A) MAKE_NODE(Copy,L(1,2),0) RULE(DRanges) MAKE_CODE(EndRanges) END
   END

   FORMULA(DefArr)
      PRODUCE GROUP(IdentArr) MAKE(DefArray) RULE(DefArrDA) MAKE_NODE(DefArr,L(0,0,1),0) RULE(DefAInit) MAKE_NODE(DefArr,L(1,2),2) END
   END

   FORMULA(DefVarAssign)
      PRODUCE OPER(Assign) MAKE_CODE(BegDefVarAssign) RULE(Assign) MAKE(DefVarAssign) END
   END

   FORMULA(DefVarInit) 
      PRODUCE RULE(DefVarAssign) END
      EMPTY 
   END

   FORMULA(DefVar)
      PRODUCE LEX(Ident) MAKE(DefIdent) RULE(DefVarInit) MAKE_NODE(DefVar,L(0,1),0) END
   END

   FORMULA(DefIAV) 
      PRODUCE RULE(DefArr) END
      PRODUCE RULE(DefVar) END
   END

   FORMULA(DefItem) 
      PRODUCE PRIOR(And) RULE(DefIAV) MAKE_TREE(RefDef) MAKE_NODE(RefDef, L(1), 0) END
      PRODUCE RULE(DefIAV) END
   END

   FORMULA(DefType) 
      PRODUCE GROUP(DefArr) END
      PRODUCE GROUP(DefVar) END
   END

   FORMULA(DefineList)
      PRODUCE SYM(Comma) RULE(DefItem) PARAM(MAKE_YACC(AddToList),0x06) MAKE_TREE(AddToList) MASTER END
      EMPTY 
   END

   FORMULA(Define)
      PRODUCE RULE(DefType) MAKE(Define) MAKE_NODE(Define,L(4),0) RULE(DefItem) PARAM(MAKE_YACC(AddToList),0x02) MAKE_TREE(AddToList) RULE(DefineList) MAKE_CODE(EndDefine) END
   END

   FORMULA(ConditionDef)
      PRODUCE PRIOR(And) RULE(DefVar) MAKE_TREE(RefDef) MAKE_NODE(RefDef, L(1), 0) END
      PRODUCE RULE(DefVar) END
   END

   FORMULA(Condition)
      PRODUCE GROUP(DefVar) MAKE(Define) RULE(ConditionDef) MAKE(PushDef) MAKE_NODE(Copy,L(1),0) END
      PRODUCE EXPRESSION(Condition) END
   END

   FORMULA(ExprList)
      PRODUCE SYM(Comma) RULE(Assign) PARAM(MAKE_YACC(AddToList),0x06) MAKE_TREE(AddToList) MAKE_CODE(AddToExpr) MASTER END
      EMPTY 
   END

   FORMULA(Expressions)
      PRODUCE RULE(Assign) MAKE(Expressions) MAKE_NODE(Expressions,L(2,3),1) RULE(ExprList) MAKE_CODE(ExpressionS) END
   END

   bool PRIOR_ASSIGNN = ((table.option & TGrammar::POption::opNoPriorAssign) == 0);

   FORMULA(PriorAssign)
if (!PRIOR_ASSIGNN) {
      PRODUCE OPER(AddAssign)    END 
      PRODUCE OPER(SubAssign)    END 
      PRODUCE OPER(MultiAssign)  END 
      PRODUCE OPER(DivAssign)    END 
      PRODUCE OPER(ModAssign)    END 
      PRODUCE OPER(Assign)       END
      PRODUCE OPER(OrAssign)     END 
      PRODUCE OPER(XOrAssign)    END
      PRODUCE OPER(AndAssign)    END 
      PRODUCE OPER(LShiftAssign) END 
      PRODUCE OPER(RShiftAssign) END
} else {
      PRODUCE PRIOR(Assign) END
}
   END

   FORMULA(AssignList)
      PRODUCE RULE(PriorAssign) MAKE_NODE(Copy,L(2),2) RULE(Assign) MAKE(Binary) MAKE_NODE(Binary,L(2,1),0) END
      EMPTY 
   END
   
   FORMULA(Assign)
      PRODUCE RULE(Question) MAKE_NODE(Copy,L(1,2),0) RULE(AssignList) END
   END

   FORMULA(QuestionList)  
      PRODUCE PRIOR(Question) MAKE_CODE(BegQuestion) RULE(Question) MAKE_NODE(Trio,L(0),0) MUST(SYM(Colon)) MAKE_CODE(MidQuestion) RULE(Question) MAKE_NODE(Trio,L(0),1) MAKE(Question) END
      EMPTY 
   END
   
   FORMULA(Question)
      PRODUCE RULE(OrOr) MAKE_NODE(Copy,L(1,2),0) RULE(QuestionList) END
   END

   FORMULA_PRIOR(OrOr,AndAnd)
   FORMULA_PRIOR(AndAnd,Or)
   FORMULA_PRIOR(Or,XOr)
   FORMULA_PRIOR(XOr,And)
   FORMULA_PRIOR(And,Equ)
   FORMULA_PRIOR(Equ,Compare)
   FORMULA_PRIOR(Compare,Shift)
   FORMULA_PRIOR(Shift,Term)
   FORMULA_PRIOR(Term,Factor)
   FORMULA_PRIOR(Factor,Unary)

   FORMULA(UnaryIncDec)
      PRODUCE PRIOR(IncDec) MAKE(IncDec) MAKE_NODE(Unary,L(2),1) END
      EMPTY
   END

   FORMULA(Unary)
      PRODUCE PRIOR(Unary)     RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),0) END
      PRODUCE PRIOR(Term)      RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),1) END
      PRODUCE PRIOR(IncDec)    RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),0) END
      PRODUCE GROUP(CastUnary) RULE(Unary) MAKE(Cast)  MAKE_NODE(Cast,L(1,2),0) END
      PRODUCE RULE(PrimaryExpr) MAKE_NODE(Copy,L(1,2),0) RULE(UnaryIncDec) END 
   END

   FORMULA(Primary) 
      PRODUCE SYM(LeftBracket) EXPRESSION(None) MAKE_NODE(Copy,L(1),0) MUST(SYM(RightBracket)) MAKE_TREE(Primary) END
   END

   FORMULA(PrimaryExpr) 
      PRODUCE LEX(Integer) MAKE(Number) MAKE_NODE(Number,L(1),0) END
      PRODUCE LEX(Number)  MAKE(Number) MAKE_NODE(Number,L(1),0) END
      PRODUCE GROUP(IdentArr)  RULE(Ranges) MAKE_NODE(Index,L(1),0) END
      PRODUCE GROUP(IdentFunc) RULE(CallParams) MAKE_NODE(Call,L(1),0) END
      PRODUCE GROUP(Cast)  RULE(Primary) MAKE(Cast) MAKE_NODE(Cast,L(1),0) END
      PRODUCE LEX(Ident)   MAKE(Ident)   MAKE_NODE(Var,L(1),0) END
      PRODUCE RULE(Primary) END
   END

   FORMULA(RangesList)
      PRODUCE SYM(LeftScrape) EXPRESSION(Value) PARAM(MAKE_YACC(AddToList),0x0A)  SYM(RightScrape) MAKE(Index) MASTER END 
      EMPTY
   END

   FORMULA(Ranges)
      PRODUCE MAKE(BegIndex) MAKE_NODE(List,L(2,3),0) RULE(RangesList) MAKE(EndIndex) END
   END

   FORMULA(CallParams) 
      PRODUCE GROUP(EmptyBracket) MAKE(Params) MAKE_NODE(List,L(0),0) END
      PRODUCE SYM(LeftBracket) EXPRESSION(ValueList) MAKE_NODE(Copy,L(1),0) SYM(RightBracket) PARAM(MAKE(Params),0x01) END
   END

   FORMULA(CompaundStmnt)
      PRODUCE GROUP(EmptyCramp) MAKE(Compaund) MAKE_CODE(EndBlock) MAKE_NODE(Null,L(1),0) END
      PRODUCE SYM(LeftCramp) MAKE(Compaund) RULE(StmExpr) MAKE_NODE(Copy,L(1),0) SYM(RightCramp) MAKE_CODE(EndBlock) MAKE_TREE(AddToList) END
   END

   FORMULA(IfStmnt_)
      PRODUCE WARNING WORD(Else) MAKE_CODE(Else) RULE(DefExpr) PARAM(MAKE(If), 0x01) END
      PRODUCE WARNING MAKE(If) END
   END

   FORMULA(IfStmnt)
      PRODUCE WORD(If) SYM(LeftBracket) MAKE_CODE(BegIf) RULE(Condition) MAKE_NODE(If,L(1),0) SYM(RightBracket) MAKE_CODE(Then) RULE(DefExpr) MAKE_NODE(If,L(1),1) RULE(IfStmnt_) MAKE_NODE(If,L(1),2) END
   END 

   FORMULA(ForPrefix) // prefix
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null, L(1), 0) END
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(ExprSemi) END
   END

   FORMULA(ForCondition) // condition
      PRODUCE SYM(Semicolon) MAKE(NodeNull) MAKE_NODE(Null, L(1), 0) END
      PRODUCE RULE(Condition) MAKE_NODE(Copy, L(1), 0) SYM(Semicolon) END
   END

   FORMULA(ForPosfix) // postfix
      PRODUCE SYM(RightBracket) MAKE_TREE(NodeNull) MAKE_NODE(Null, L(1), 0) END
      PRODUCE EXPRESSION(Expression) MAKE_NODE(Copy, L(1), 0) SYM(RightBracket) END
   END

   FORMULA(ForStmnt)
      PRODUCE WORD(For) SYM(LeftBracket) MAKE_CODE(BegFor) RULE(ForPrefix) MAKE_CODE(PrefFor) MAKE_NODE(For,L(1),0) RULE(ForCondition) MAKE_CODE(ConditionFor) MAKE_NODE(For,L(1),1) RULE(ForPosfix) MAKE_CODE(PostFor) MAKE_NODE(For,L(1),2) RULE(DefExpr) MAKE_NODE(For,L(1),3) MAKE(For) END // body
   END 

   FORMULA(DoStmnt) 
      PRODUCE WORD(Do) MAKE_CODE(BegDo) RULE(DefExpr) MAKE_NODE(Copy,L(1),0) WORD(While) SYM(LeftBracket) MAKE_CODE(MidDo) RULE(Condition) MAKE_NODE(Do,L(1,4),0) SYM(RightBracket) SYM(Semicolon) MAKE(Do) END
   END 
   FORMULA(WhileStmnt) 
      PRODUCE WORD(While) MAKE_CODE(BegWhile) SYM(LeftBracket) RULE(Condition) MAKE_NODE(Copy,L(1),0) SYM(RightBracket) MAKE_CODE(MidWhile) RULE(DefExpr) MAKE(While) MAKE_NODE(While,L(2,1),0) END
   END 

/*
   FORMULA(SwitchStmnt) 
      PRODUCE WORD(Switch) SYM(LeftBracket) SYM(RightBracket) END 
   END
*/
   FORMULA(GoToStmnt) 
      PRODUCE WORD(GoTo) LEX(Ident) SYM(Semicolon) MAKE_NODE(GoTo,L(1),0) MAKE(GoTo) END 
   END

   FORMULA(BreakStmnt) 
      PRODUCE WORD(Break) SYM(Semicolon) MAKE(Break) MAKE_NODE(Break,L(1),0) END 
   END

   FORMULA(ContinueStmnt) 
      PRODUCE WORD(Continue) SYM(Semicolon) MAKE(Continue) MAKE_NODE(Continue,L(1),0) END 
   END

   FORMULA(ReturnVal)
      PRODUCE EXPRESSION(Value) PARAM(MAKE(Return), 0x01) END
      PRODUCE MAKE(Return) END
   END

   FORMULA(ReturnStmnt)
      PRODUCE WORD(Return) RULE(ReturnVal) MAKE_NODE(Return,L(1),0) SYM(Semicolon) END
   END 

   FORMULA(Statement) 
      PRODUCE GROUP(Label) SYM(Colon) MAKE_CODE(Label) RULE(DefExpr) MAKE_NODE(Label,L(1),0) MAKE_TREE(Label) END
      PRODUCE RULE(IfStmnt      ) END
      PRODUCE RULE(DoStmnt      ) END
      PRODUCE RULE(WhileStmnt   ) END
      PRODUCE RULE(ForStmnt     ) END
//      PRODUCE RULE(SwitchStmnt  ) END
      PRODUCE RULE(GoToStmnt    ) END
      PRODUCE RULE(BreakStmnt   ) END
      PRODUCE RULE(ContinueStmnt) END
      PRODUCE RULE(ReturnStmnt  ) END
      PRODUCE RULE(CompaundStmnt) END
   END

   FORMULA(DefineSemi) 
      PRODUCE RULE(Define) MAKE_NODE(Copy,L(1),0) SYM(Semicolon) END 
   END

   FORMULA(ExprSemi) 
     PRODUCE EXPRESSION(Expression) MAKE_NODE(Copy,L(1),0) SYM(Semicolon) END 
   END

   FORMULA(DefExpr) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END 
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(Statement) END
      PRODUCE RULE(ExprSemi) END
   END

   FORMULA(StmExprList)
      PRODUCE RULE(DefExpr) PARAM(MAKE_YACC(AddToList),0x06) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END 

   FORMULA(StmExpr) 
      PRODUCE MAKE(BegStmExpr) MAKE_NODE(Statements,L(2,3),0) RULE(StmExprList) MAKE_CODE(EndBlock) END
   END

   FORMULA(DefFAV) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END 
      PRODUCE RULE(DefFunc) END
      PRODUCE RULE(DefineSemi) END
   END

   FORMULA(DefinesList)
      PRODUCE RULE(DefFAV) PARAM(MAKE_YACC(AddToList),0x06) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END 

   FORMULA(Defines)
      PRODUCE MAKE(BegStmExpr) MAKE_NODE(Statements,L(2,3),0) RULE(DefinesList) MAKE_CODE(EndBlock) END
   END
   FORMULA(S_) 
      PRODUCE RULE(Program) END
   END

   FORMULA(Program)
#if   defined(DEFINE_RULE_FULL)
      PRODUCE RULE(Defines) END
#elif defined(DEFINE_RULE_DEF)
      PRODUCE RULE(Define) END
#elif defined(DEFINE_RULE_EXPR)
      PRODUCE EXPRESSION(Expression) END
#elif defined(DEFINE_RULE_STMT)
      PRODUCE RULE(StmExpr) END
#else
#endif
   END

   FORMULA(DefBegParVar) 
      PRODUCE LEX(Ident) MAKE(DefParVar) MAKE_TURN(Make,DefVar,-1) END
   END
   FORMULA(DefParVar) 
      PRODUCE RULE(DefBegParVar) OPER(Assign) MAKE_CODE(BegParVarAssign) MAKE_TURN(Command,Lexeme,0) RULE(Assign) MAKE(ParVarAssign) MAKE_TURN(Down,0,0) END
      PRODUCE RULE(DefBegParVar) END
   END

   FORMULA(DefBegParArr) 
      PRODUCE GROUP(IdentArr) MAKE(DefParArr) MAKE_TURN(Make,List,0) RULE(DefBegRanges) MAKE_TURN(Make,DefArr,-2) END
   END

   FORMULA(DefParArr) 
      PRODUCE RULE(DefBegParArr) OPER(Assign) MAKE_CODE(BegParVarAssign) MAKE_TURN(Command,Lexeme,0) RULE(Assign) MAKE(ParVarAssign) MAKE_TURN(Down,0,0) END 
      PRODUCE RULE(DefBegParArr) END // !!!
   END

   FORMULA(DefParItem) 
      PRODUCE GROUP(DefArr) MAKE_TURN(Push,Type,0) RULE(DefParArr) END
      PRODUCE GROUP(DefVar) MAKE_TURN(Push,Type,0) RULE(DefParVar) END
   END

   FORMULA(DefParams)
      PRODUCE MASTER SYM(Comma) RULE(DefParItem) MAKE_TREE(AddToList) MAKE_TURN(Down,0,0) END
      PRODUCE RULE(DefParItem) MAKE_TREE(AddToList) MAKE_TURN(Down,0,0) END
   END

   FORMULA(BodyFunc)
      PRODUCE SYM(Semicolon) PARAM(MAKE(BodyFunc),0x00) MAKE_TURN(Make,Null,0) END
      PRODUCE GROUP(EmptyCramp) PARAM(MAKE(BodyFunc),0x01) MAKE_TURN(Make, Statements,0) END
      PRODUCE SYM(LeftCramp) MAKE_CODE(EndParams) MAKE(BegStmExpr) MAKE_TURN(Make,Statements,0) RULE(StmExpr) SYM(RightCramp) PARAM(MAKE(BodyFunc),0x02) END
   END

   FORMULA(DefFunc_)
      PRODUCE GROUP(EmptyBracket) MAKE_TURN(Make, Null, 0) MAKE_TURN(Down, 0, 0) END
      PRODUCE SYM(LeftBracket) PARAM(MAKE_TREE(Define), 0x02) MAKE_TURN(Make, Define, 0) RULE(DefParams) SYM(RightBracket) MAKE_TREE(EndParams) MAKE_TURN(Down, 0, 1) END
   END

   FORMULA(DefFunc) 
      PRODUCE GROUP(DefFunc) MAKE_TURN(Push,Type,0) GROUP(IdentFunc) MAKE(FuncIdent) MAKE_TURN(Make,DefFunc,-1) RULE(DefFunc_) RULE(BodyFunc) MAKE_TURN(Down,0,0) END
   END

   FORMULA(AInitItem)
      PRODUCE RULE(Initializer) END
      PRODUCE RULE(Assign) MAKE_CODE(AInitItem) END
   END

   FORMULA(AInitial)
      PRODUCE MASTER SYM(Comma) RULE(AInitItem) MAKE_TREE(AddToList) MAKE_TURN(Down,0,0) END
      PRODUCE RULE(AInitItem) MAKE_TREE(AddToList) MAKE_TURN(Down,0,0) END
   END

   FORMULA(Initializer)
      PRODUCE GROUP(EmptyCramp) MAKE_CODE(BegInitial) MAKE_TREE(NodeList) MAKE_TURN(Make,List,0) END
      PRODUCE SYM(LeftCramp) PARAM(MAKE_CODE(BegInitial),0x01) MAKE_TREE(NodeList) MAKE_TURN(Make,List,0) RULE(AInitial) SYM(RightCramp) MAKE_CODE(EndInitial) END
   END

   FORMULA(DefRanges_)
      PRODUCE SYM(LeftScrape) RULE(Assign) SYM(RightScrape) END
   END

   FORMULA(DefRanges)
      PRODUCE MASTER RULE(DefRanges_) MAKE(DRange) MAKE_TURN(Down,0,0) END
      PRODUCE RULE(DefRanges_) MAKE(DRange) MAKE_TURN(Down,0,0) END 
   END

   FORMULA(DefBegRanges) 
      PRODUCE GROUP(EmptyScrape) MAKE(DefArrD1AEmpty) MAKE_TURN(Put,Null,0) MAKE_TURN(Down,0,0) RULE(DefRanges) END 
      PRODUCE GROUP(EmptyScrape) MAKE(DefArrD1AEmpty) MAKE_TURN(Put,Null,0) MAKE_TURN(Down,0,0) END 
      PRODUCE RULE(DefRanges) END
   END

   FORMULA(DefBegArr) 
      PRODUCE GROUP(IdentArr) MAKE(DefArray) MAKE_TURN(Push,DefArr,0) MAKE_TURN(Make,Ranges,0) RULE(DefBegRanges) MAKE_CODE(EndRanges) MAKE_TURN(Down,0,0) END
   END

   FORMULA(DefArr) 
      PRODUCE RULE(DefBegArr) OPER(Assign) MAKE_CODE(BegAInit) MAKE_TURN(Command,Lexeme,0) RULE(Initializer) MAKE(EndAInit) MAKE_TURN(Down,0,0) END 
      PRODUCE RULE(DefBegArr) END
   END

   FORMULA(DefVarIdent) 
      PRODUCE LEX(Ident) MAKE(DefIdent) MAKE_TURN(Push, DefVar, 0) END
   END
   FORMULA(DefVarAssign) 
      PRODUCE RULE(DefVarIdent) OPER(Assign) MAKE_CODE(BegDefVarAssign) MAKE_TURN(Command, Lexeme, 0) RULE(Assign) MAKE(DefVarAssign) MAKE_TURN(Down, 0, 0) END
   END

   FORMULA(DefVar) 
      PRODUCE RULE(DefVarAssign) END
      PRODUCE RULE(DefVarIdent)  END
   END

   FORMULA(DefIAV) 
      PRODUCE RULE(DefArr) END
      PRODUCE RULE(DefVar) END
   END
   FORMULA(RefDefIAV) 
      PRODUCE PRIOR(And) RULE(DefIAV) MAKE_TREE(RefDef) MAKE_TURN(Command,Lexeme,0) END
   END
   FORMULA(DefItem) 
      PRODUCE RULE(RefDefIAV) END
      PRODUCE RULE(DefIAV)    END
   END

   FORMULA(DefType) 
      PRODUCE GROUP(DefArr) END
      PRODUCE GROUP(DefVar) END
   END

   FORMULA(DefineComma)
      PRODUCE MASTER SYM(Comma) RULE(DefItem) MAKE_TREE(AddToList) MAKE_TURN(Down, 0, 0) END
      PRODUCE RULE(DefItem) MAKE_TREE(AddToList) MAKE_TURN(Down, 0, 0) END
   END

   FORMULA(Define)
      PRODUCE RULE(DefType) MAKE(Define) MAKE_TURN(Push,Type,0) MAKE_TURN(Make,Define,1) RULE(DefineComma) MAKE_CODE(EndDefine) END
   END

   FORMULA(Expressions)
      PRODUCE MASTER SYM(Comma) RULE(Assign) MAKE_TREE(AddToList) MAKE_TURN(Down,0,0) MAKE_CODE(AddToExpr) END
      PRODUCE RULE(Assign) MAKE(Expressions) MAKE_TURN(Make,Expressions,1) END
   END

   bool PRIOR_ASSOCIATION = ((table.option & TGrammar::POption::opAssociation  ) != 0);
   bool PRIOR_ASSIGNN     = ((table.option & TGrammar::POption::opNoPriorAssign) == 0);

   FORMULA(PriorAssign)
if (!PRIOR_ASSIGNN) {
      PRODUCE OPER(AddAssign)    END
      PRODUCE OPER(SubAssign)    END
      PRODUCE OPER(MultiAssign)  END
      PRODUCE OPER(DivAssign)    END
      PRODUCE OPER(ModAssign)    END
      PRODUCE OPER(Assign)       END
      PRODUCE OPER(OrAssign)     END
      PRODUCE OPER(XOrAssign)    END
      PRODUCE OPER(AndAssign)    END
      PRODUCE OPER(LShiftAssign) END
      PRODUCE OPER(RShiftAssign) END
} else {
      PRODUCE PRIOR(Assign) END
}
   END

   FORMULA(Assign)
      PRODUCE 
if (PRIOR_ASSOCIATION && PRIOR_ASSIGNN) {
         MASTER PRIOR(Assign) MASTER MAKE(Binary) MAKE_TURN(Make, Binary, -2)
} else {
         RULE(Question) RULE(PriorAssign) MASTER MAKE(Binary) MAKE_TURN(Make, Binary, -2)
}
      END
      PRODUCE RULE(Question) END
   END

   FORMULA(Question)
      PRODUCE 
if (PRIOR_ASSOCIATION) {
         RULE(Binary) 
} else {
         RULE(OrOr) 
}
         PRIOR(Question) MAKE_CODE(BegQuestion) MASTER SYM(Colon) MAKE_CODE(MidQuestion) MASTER MAKE(Question) MAKE_TURN(Make,Trio,-3)
      END
      PRODUCE
if (PRIOR_ASSOCIATION) {
         RULE(Binary) 
} else {
         RULE(OrOr) 
}
      END
   END

if (PRIOR_ASSOCIATION) {
   FORMULA(Binary)
      FORMULA_ASSOCIAT(OrOr)
      FORMULA_ASSOCIAT(AndAnd)
      FORMULA_ASSOCIAT(Or)
      FORMULA_ASSOCIAT(XOr)
      FORMULA_ASSOCIAT(And)
      FORMULA_ASSOCIAT(Equ)
      FORMULA_ASSOCIAT(Compare)
      FORMULA_ASSOCIAT(Shift)
      FORMULA_ASSOCIAT(Term)
      FORMULA_ASSOCIAT(Factor)
      PRODUCE RULE(Unary) END
   END
} else {
   FORMULA_PRIOR(OrOr,AndAnd)
   FORMULA_PRIOR(AndAnd,Or)
   FORMULA_PRIOR(Or,XOr)
   FORMULA_PRIOR(XOr,And)
   FORMULA_PRIOR(And,Equ)
   FORMULA_PRIOR(Equ,Compare)
   FORMULA_PRIOR(Compare,Shift)
   FORMULA_PRIOR(Shift,Term)
   FORMULA_PRIOR(Term,Factor)
   FORMULA_PRIOR(Factor,Unary)
}

   FORMULA(UnaryIncDec)
      PRODUCE RULE(PrimaryExpr) PRIOR(IncDec) MAKE(IncDec) MAKE_TURN(Make, IncDec, -1) END
      PRODUCE RULE(PrimaryExpr) END
   END

   FORMULA(Unary)
      PRODUCE PRIOR(Unary)      RULE(Unary) MAKE(Unary) MAKE_TURN(Make,Unary,-1) END
      PRODUCE PRIOR(Term)       RULE(Unary) MAKE(Unary) MAKE_TURN(Make,Unary,-1) END
      PRODUCE PRIOR(IncDec)     RULE(Unary) MAKE(Unary) MAKE_TURN(Make,Unary,-1) END
      PRODUCE GROUP(CastUnary)  RULE(Unary) MAKE(Cast)  MAKE_TURN(Make,Cast,-1)  END
      PRODUCE RULE(UnaryIncDec) END
   END

   FORMULA(Primary)
      PRODUCE SYM(LeftBracket) EXPRESSION(None) SYM(RightBracket) MAKE_TREE(Primary) MAKE_TURN(Make, Primary, 1) END
   END

   FORMULA(PrimaryExpr) 
      PRODUCE LEX(Integer) MAKE(Number) MAKE_TURN(Push,Number,0) END
      PRODUCE LEX(Number)  MAKE(Number) MAKE_TURN(Push,Number,0) END
      PRODUCE GROUP(IdentArr)  MAKE_TURN(Push,Index,0) RULE(Ranges) MAKE(EndIndex) MAKE_TURN(Down,0,0) END
      PRODUCE GROUP(IdentFunc) MAKE_TURN(Push,Call,0)  RULE(CallParams) MAKE_TURN(Down,0,0) END
      PRODUCE GROUP(Cast) RULE(Primary) MAKE(Cast) MAKE_TURN(Make,Cast,-1) END
      PRODUCE LEX(Ident)  MAKE(Ident)   MAKE_TURN(Push,Var,0)  END
      PRODUCE RULE(Primary) END
   END

   FORMULA(Range)
      PRODUCE SYM(LeftScrape) EXPRESSION(Value) SYM(RightScrape) END
   END

   FORMULA(Ranges)
      PRODUCE MASTER RULE(Range) MAKE(Index) MAKE_TURN(Down,0,0) END
      PRODUCE RULE(Range) MAKE(BegIndex) MAKE_TURN(Make,Ranges,1) END 
   END

   FORMULA(CallParams) 
      PRODUCE GROUP(EmptyBracket) MAKE(Params) MAKE_TURN(Make,Null,0) END
      PRODUCE SYM(LeftBracket) EXPRESSION(ValueList) SYM(RightBracket) PARAM(MAKE(Params),0x01) END
   END

   FORMULA(CompaundStmnt)
      PRODUCE GROUP(EmptyCramp) MAKE(Compaund) MAKE_CODE(EndBlock) MAKE_TURN(Make,Statements,0) END
      PRODUCE SYM(LeftCramp) MAKE(Compaund) MAKE_TURN(Make,Statements,0) RULE(StmExpr) SYM(RightCramp) END
   END

   FORMULA(Condition_V)
      PRODUCE PRIOR(And) RULE(DefVarAssign) MAKE_TREE(RefDef) MAKE_TURN(Command, Lexeme, 0) END
      PRODUCE RULE(DefVarAssign) END
   END

   FORMULA(Condition)
      PRODUCE GROUP(DefVar) MAKE(Define) RULE(Condition_V) MAKE(PushDef) END
      PRODUCE EXPRESSION(Condition) END
   END

   FORMULA(For_Prefix) // prefix
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_TURN(Make, Null, 0) END
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(ExprSemi) END
   END

   FORMULA(For_Condition) // condition
      PRODUCE SYM(Semicolon)  MAKE(NodeNull) MAKE_TURN(Make, Null, 0) END
      PRODUCE RULE(Condition) SYM(Semicolon) END
   END

   FORMULA(For_Postfix) // postfix
      PRODUCE SYM(RightBracket) MAKE_TREE(NodeNull) MAKE_TURN(Make, Null, 0) END
      PRODUCE EXPRESSION(Expression) SYM(RightBracket) END
   END

   FORMULA(ForStmnt) 
      PRODUCE
      WORD(For) SYM(LeftBracket) MAKE_CODE(BegFor)
      RULE(For_Prefix) MAKE_CODE(PrefFor)
      RULE(For_Condition) MAKE_CODE(ConditionFor)
      RULE(For_Postfix) MAKE_CODE(PostFor)
      RULE(DefExpr) MAKE(For) MAKE_TURN(Make,For,4) // body
      END
   END 

   FORMULA(ReturnValue)
      PRODUCE SYM(Semicolon)    MAKE(Return)   MAKE_TURN(Make, Return, 0) END
      PRODUCE EXPRESSION(Value) SYM(Semicolon) PARAM(MAKE(Return), 0x01) MAKE_TURN(Make, Return, 1) END
   END

   FORMULA(ReturnStmnt  )
      PRODUCE WORD(Return) RULE(ReturnValue) END
   END 

   FORMULA(BegIfStmnt) 
      PRODUCE WORD(If) SYM(LeftBracket) MAKE_CODE(BegIf) RULE(Condition) SYM(RightBracket) MAKE_CODE(Then) RULE(DefExpr) MAKE_TURN(Make, If, 2) END
   END

   FORMULA(Statement)
      PRODUCE RULE(BegIfStmnt) WORD(Else) MAKE_CODE(Else) RULE(DefExpr) PARAM(MAKE(If),0x01) MAKE_TURN(Down,0,0) END
      PRODUCE WARNING RULE(BegIfStmnt) MAKE(If) END
      PRODUCE GROUP(Label) SYM(Colon) MAKE_CODE(Label) MAKE_TURN(Push,Label,0) RULE(DefExpr) MAKE_TREE(Label) MAKE_TURN(Make,List,2) END
      PRODUCE WORD(Do)    RULE(DefExpr)    WORD(While) SYM(LeftBracket) RULE(Condition) SYM(RightBracket) SYM(Semicolon) MAKE(Do) MAKE_TURN(Make, Do, -2) END
      PRODUCE WORD(While) SYM(LeftBracket) RULE(Condition)   SYM(RightBracket) RULE(DefExpr) MAKE(While) MAKE_TURN(Make, While, -2) END
      PRODUCE RULE(ForStmnt     ) END 
      PRODUCE WORD(Switch)   SYM(LeftBracket) SYM(RightBracket) END
      PRODUCE WORD(GoTo)     LEX(Ident)       SYM(Semicolon)  MAKE(GoTo) MAKE_TURN(Push, GoTo, 0) END
      PRODUCE WORD(Break)    SYM(Semicolon)   MAKE(Break)     MAKE_TURN(Make, Break, 0) END
      PRODUCE WORD(Continue) SYM(Semicolon)   MAKE(Continue)  MAKE_TURN(Make, Continue, 0) END
      PRODUCE RULE(ReturnStmnt  ) END
      PRODUCE RULE(CompaundStmnt) END
   END

   FORMULA(DefineSemi)
      PRODUCE RULE(Define) SYM(Semicolon) END
   END

   FORMULA(ExprSemi)
      PRODUCE EXPRESSION(Expression) SYM(Semicolon) END
   END

   FORMULA(DefExpr) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_TURN(Make,Null,0) END 
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(Statement)  END
      PRODUCE RULE(ExprSemi)   END
   END

   FORMULA(StmExprList)
      PRODUCE MASTER RULE(DefExpr) MAKE_TREE(AddToList) MAKE_TURN(Down, 0, 0) END
      PRODUCE RULE(DefExpr) MAKE_TREE(AddToList) MAKE_TURN(Down, 0, 0) END
   END

   FORMULA(StmExpr)
      PRODUCE RULE(StmExprList) MAKE_CODE(EndBlock) END
   END

   FORMULA(DefFAV) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_TURN(Make,Null,0) END 
      PRODUCE RULE(DefFunc) END
      PRODUCE RULE(DefineSemi) END
   END

   FORMULA(DefinesList)
      PRODUCE MASTER RULE(DefFAV) MAKE_TREE(AddToList) MAKE_TURN(Down,0,0) END
      PRODUCE RULE(DefFAV) PARAM(MAKE_TREE(BegStmExpr),0x01) MAKE_TURN(Down,0,0) END
   END

   FORMULA(Defines)
      PRODUCE MAKE_CODE(BegStmExpr) MAKE_TURN(Make, Statements, 0) RULE(DefinesList) MAKE_CODE(EndBlock) END
   END
   FORMULA(S_) 
      PRODUCE RULE(Program) END
   END

   FORMULA(Program)
#if   defined(DEFINE_RULE_FULL)
      PRODUCE RULE(Defines) END
#elif defined(DEFINE_RULE_DEF)
      PRODUCE RULE(Define) END
#elif defined(DEFINE_RULE_EXPR)
      PRODUCE EXPRESSION(Expression) END
#elif defined(DEFINE_RULE_STMT)
      PRODUCE RULE(StmExpr) END
#else
#endif
   END

#define GRAMMAR_FULL

#undef WORD_Define
//#define WORD_Define GROUP(DefType)
#define WORD_Define WORD(Define)

#if defined(PARSE_YACC)
   #define Prior_Assign RULE(PriorAssign)
   #define Prior_And    PRIOR(And)
#else
   #define Prior_Assign PRIOR(Assign)
   #define Prior_And    OPER(And)
#endif

   FORMULA(DefineParType)
      PRODUCE WORD(Const) WORD_Define OPER(And) PARAM(MAKE(DefType), 0x0B) END
      PRODUCE             WORD_Define OPER(And) PARAM(MAKE(DefType), 0x09) END
      PRODUCE WORD(Const) WORD_Define            PARAM(MAKE(DefType), 0x03) END
      PRODUCE             WORD_Define            PARAM(MAKE(DefType), 0x01) END
   END

   FORMULA(DefParType)
      PRODUCE RULE(DefineParType) LEX(Ident) END
   END

   FORMULA(DefPar) 
      PRODUCE OPER(Assign) RULE(Assign) MAKE(ParVarAssign) END
      EMPTY
   END

   FORMULA(DefParItem) 
      PRODUCE RULE(DefParType) SYM(LeftScrape) MAKE(DefParArr) RULE(DefArrDA) RULE(DefPar)  END
      PRODUCE RULE(DefParType) MAKE(DefParVar) RULE(DefPar) END
   END

   FORMULA(DefParamsList)
      PRODUCE SYM(Comma) RULE(DefParItem) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END

   FORMULA(DefParams) 
      PRODUCE PARAM(MAKE_TREE(Define), 0x02) RULE(DefParItem) MAKE_TREE(AddToList) RULE(DefParamsList) MAKE_TREE(EndParams) END
   END

   FORMULA(BodyFunc)
      PRODUCE SYM(Semicolon) PARAM(MAKE(BodyFunc),0x00) END
      PRODUCE SYM(LeftCramp) SYM(RightCramp) PARAM(MAKE(BodyFunc),0x01) END
      PRODUCE SYM(LeftCramp) MAKE(BegStmExpr) RULE(StmExpr) SYM(RightCramp) PARAM(MAKE(BodyFunc),0x02) END
   END

   FORMULA(DefFuncType)
      PRODUCE WORD(Static) WORD(Const) WORD_Define PARAM(MAKE(DefType),0x07) END
      PRODUCE WORD(Static)             WORD_Define PARAM(MAKE(DefType),0x05) END
      PRODUCE              WORD(Const) WORD_Define PARAM(MAKE(DefType),0x03) END
      PRODUCE                          WORD_Define PARAM(MAKE(DefType),0x01) END
      PRODUCE WORD(Static)             WORD(Void) PARAM(MAKE(DefType),0x24) END
      PRODUCE                          WORD(Void) PARAM(MAKE(DefType),0x20) END
   END

   FORMULA(DefFuncParams)
      PRODUCE SYM(RightBracket) END
      PRODUCE RULE(DefParams) SYM(RightBracket) END
   END

   FORMULA(DefFunc) 
      PRODUCE RULE(DefFuncType) LEX(Ident) SYM(LeftBracket) MAKE(FuncIdent) RULE(DefFuncParams) RULE(BodyFunc) END
   END

   FORMULA(AInitialList)
      PRODUCE SYM(Comma) RULE(AInitItem) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END

   FORMULA(AInitial) 
      PRODUCE RULE(AInitItem) MAKE_TREE(AddToList) RULE(AInitialList) END
   END

   FORMULA(Initializer)
      PRODUCE SYM(LeftCramp) SYM(RightCramp) MAKE_TREE(NodeList) END
      PRODUCE SYM(LeftCramp) MAKE_TREE(NodeList) RULE(AInitial) SYM(RightCramp) END
   END

   FORMULA(AInitItem)
      PRODUCE RULE(Initializer) END
      PRODUCE RULE(Assign) END
   END

   FORMULA(DefAInit)
      PRODUCE OPER(Assign) RULE(Initializer) MAKE(EndAInit) END 
      EMPTY
   END

   FORMULA(DRanges)
      PRODUCE SYM(LeftScrape) RULE(Assign) SYM(RightScrape) MAKE(DRange) MASTER END
      EMPTY
   END

   FORMULA(DefArrD1A)
      PRODUCE SYM(RightScrape) MAKE(DefArrD1AEmpty) END
      PRODUCE  RULE(Assign) SYM(RightScrape) MAKE(DRange) END
   END

   FORMULA(DefArrDA) 
      PRODUCE RULE(DefArrD1A) RULE(DRanges) END
   END

   FORMULA(DefArr) 
      PRODUCE LEX(Ident) SYM(LeftScrape) MAKE(DefArray) RULE(DefArrDA) RULE(DefAInit) END
   END

   FORMULA(DefVarInit) 
      PRODUCE OPER(Assign) RULE(Assign) MAKE(DefVarAssign) END
      EMPTY
   END
   FORMULA(DefVar) 
      PRODUCE LEX(Ident) MAKE(DefIdent) RULE(DefVarInit) END
   END

   FORMULA(DefItem) 
      PRODUCE OPER(And) RULE(DefArr) MAKE_TREE(RefDef) END 
      PRODUCE OPER(And) RULE(DefVar) MAKE_TREE(RefDef) END 
      PRODUCE RULE(DefArr) END
      PRODUCE RULE(DefVar) END
   END

   FORMULA(DefType)
      PRODUCE WORD(Static) WORD(Const) WORD_Define PARAM(MAKE(DefType),0x07) PARAM(MAKE(Define),0x01) END
      PRODUCE WORD(Static)             WORD_Define PARAM(MAKE(DefType),0x05) PARAM(MAKE(Define),0x01) END
      PRODUCE              WORD(Const) WORD_Define PARAM(MAKE(DefType),0x03) PARAM(MAKE(Define),0x01) END
      PRODUCE                          WORD_Define PARAM(MAKE(DefType),0x01) PARAM(MAKE(Define),0x01) END
   END

   FORMULA(DefineList)
      PRODUCE SYM(Comma) RULE(DefItem) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END

   FORMULA(Define)
      PRODUCE RULE(DefType) RULE(DefItem) MAKE_TREE(AddToList) RULE(DefineList) END
   END

   FORMULA(ConditionVar)
      PRODUCE OPER(And) RULE(DefVar) MAKE_TREE(RefDef) END
      PRODUCE RULE(DefVar) END
   END

   FORMULA(Condition)
      PRODUCE RULE(DefType) RULE(ConditionVar) MAKE(PushDef) END
      PRODUCE EXPRESSION(Condition) END
   END

   FORMULA(ExpressionsList)
      PRODUCE SYM(Comma) RULE(Assign) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END

   FORMULA(Expressions)
      PRODUCE RULE(Assign) MAKE(Expressions) RULE(ExpressionsList) END
   END

   FORMULA(PriorAssign) 
      PRODUCE OPER(AddAssign) END PRODUCE OPER(SubAssign) END PRODUCE OPER(MultiAssign) END PRODUCE OPER(DivAssign)    END PRODUCE OPER(ModAssign)    END PRODUCE OPER(Assign) END
      PRODUCE OPER(OrAssign)  END PRODUCE OPER(XOrAssign) END PRODUCE OPER(AndAssign)   END PRODUCE OPER(LShiftAssign) END PRODUCE OPER(RShiftAssign) END
   END

   FORMULA(AssignList)
      PRODUCE PRIOR(Assign) RULE(Assign) MAKE(Binary) END
      EMPTY
   END

   FORMULA(Assign)
      PRODUCE RULE(Question) RULE(AssignList) END
   END

   FORMULA(QuestionList)
      PRODUCE PRIOR(Question) RULE(Question) MUST(SYM(Colon)) RULE(Question) MAKE(Question) END
      EMPTY
   END

   FORMULA(Question)
      PRODUCE RULE(OrOr) RULE(QuestionList) END
   END

   FORMULA_PRIOR(OrOr,AndAnd)
   FORMULA_PRIOR(AndAnd,Or)
   FORMULA_PRIOR(Or,XOr)
   FORMULA_PRIOR(XOr,And)
   FORMULA_PRIOR(And,Equ)
   FORMULA_PRIOR(Equ,Compare)
   FORMULA_PRIOR(Compare,Shift)
   FORMULA_PRIOR(Shift,Term)
   FORMULA_PRIOR(Term,Factor)
   FORMULA_PRIOR(Factor,Unary)

   FORMULA(UnaryIncDec)
      PRODUCE PRIOR(IncDec) MAKE(IncDec) MASTER END
      EMPTY
   END

   FORMULA(DefineCast)
      PRODUCE WORD(Const) WORD_Define PARAM(MAKE(DefType), 0x03) END
      PRODUCE             WORD_Define PARAM(MAKE(DefType), 0x01) END
   END

   FORMULA(Unary)
      PRODUCE PRIOR(Unary)     RULE(Unary) MAKE(Unary) END
      PRODUCE PRIOR(Term)      RULE(Unary) MAKE(Unary) END
      PRODUCE PRIOR(IncDec)    RULE(Unary) MAKE(Unary) END
#if defined(GRAMMAR_FULL)
      PRODUCE SYM(LeftBracket) RULE(DefineCast) SYM(RightBracket) RULE(Unary) MAKE(Cast) END
#endif
      PRODUCE RULE(PrimaryExpr) RULE(UnaryIncDec) END 
   END

   FORMULA(Primary) 
      PRODUCE SYM(LeftBracket) EXPRESSION(None) MUST(SYM(RightBracket)) MAKE_TREE(Primary) END 
   END

   FORMULA(PrimaryExpr) 
      PRODUCE LEX(Ident) SYM(LeftScrape)  RULE(Ranges) END
      PRODUCE LEX(Ident) SYM(LeftBracket) RULE(CallParams) END
      PRODUCE LEX(Integer) MAKE(Number) END
      PRODUCE LEX(Number)  MAKE(Number) END
      PRODUCE LEX(Ident)   MAKE(Ident)  END
      PRODUCE RULE(Primary) END
#if defined(GRAMMAR_FULL)
      PRODUCE WORD_Define RULE(Primary) MAKE(Cast) END
#endif
   END

   FORMULA(Range)
      PRODUCE SYM(LeftScrape) EXPRESSION(Value) SYM(RightScrape) MAKE(Index) MASTER END
      EMPTY
   END

   FORMULA(Ranges)
      PRODUCE MAKE(BegIndex) EXPRESSION(Value) SYM(RightScrape) MAKE(Index) RULE(Range) MAKE(EndIndex) END
   END

   FORMULA(CallParams) 
      PRODUCE SYM(RightBracket) MAKE(Params) END
      PRODUCE EXPRESSION(ValueList) SYM(RightBracket) PARAM(MAKE(Params),0x01) END
   END

   FORMULA(CompaundStmnt)
      PRODUCE SYM(LeftCramp) SYM(RightCramp) MAKE(Compaund) END
      PRODUCE SYM(LeftCramp) MAKE(Compaund) RULE(StmExpr) SYM(RightCramp) END
   END
   FORMULA(IfStmntElse)
      PRODUCE WORD(Else) RULE(DefExpr) PARAM(MAKE(If), 0x01) END
      PRODUCE WARNING MAKE(If) END
   END
   FORMULA(IfStmnt)
      PRODUCE WORD(If) SYM(LeftBracket) RULE(Condition) SYM(RightBracket) RULE(DefExpr) RULE(IfStmntElse) END
   END 

   FORMULA(ForPrefix) // prefix
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) END
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(ExprSemi) END
   END
   FORMULA(ForCondition) // condition
      PRODUCE SYM(Semicolon) MAKE(NodeNull) END
      PRODUCE RULE(Condition) SYM(Semicolon) END
   END
   FORMULA(ForPostfix) // postfix
      PRODUCE SYM(RightBracket) MAKE_TREE(NodeNull) END
      PRODUCE EXPRESSION(Expression) SYM(RightBracket) END
   END

   FORMULA(ForStmnt) 
      PRODUCE WORD(For) SYM(LeftBracket) RULE(ForPrefix) RULE(ForCondition) RULE(ForPostfix) RULE(DefExpr) MAKE(For) END // body 
   END 
   FORMULA(DoStmnt      ) PRODUCE WORD(Do      ) RULE(DefExpr) WORD(While) SYM(LeftBracket) RULE(Condition) SYM(RightBracket) SYM(Semicolon) MAKE(Do) END END
   FORMULA(WhileStmnt   ) PRODUCE WORD(While   ) SYM(LeftBracket) RULE(Condition) SYM(RightBracket) RULE(DefExpr) MAKE(While)  END END
   FORMULA(SwitchStmnt  ) PRODUCE WORD(Switch  ) SYM(LeftBracket) SYM(RightBracket) END END
   FORMULA(GoToStmnt    ) PRODUCE WORD(GoTo    ) LEX(Ident)       SYM(Semicolon) MAKE(GoTo) END END
   FORMULA(BreakStmnt   ) PRODUCE WORD(Break   ) SYM(Semicolon)   MAKE(Break   ) END END
   FORMULA(ContinueStmnt) PRODUCE WORD(Continue) SYM(Semicolon)   MAKE(Continue) END END

   FORMULA(ReturnValue)
      PRODUCE EXPRESSION(Value) PARAM(MAKE(Return), 0x01) END
      PRODUCE MAKE(Return) END
   END

   FORMULA(ReturnStmnt  ) 
      PRODUCE WORD(Return) RULE(ReturnValue) SYM(Semicolon) END
   END 

   FORMULA(Statement) 
      PRODUCE RULE(IfStmnt      ) END
      PRODUCE RULE(DoStmnt      ) END
      PRODUCE RULE(WhileStmnt   ) END
      PRODUCE RULE(ForStmnt     ) END
      PRODUCE RULE(SwitchStmnt  ) END
      PRODUCE RULE(GoToStmnt    ) END
      PRODUCE RULE(BreakStmnt   ) END
      PRODUCE RULE(ContinueStmnt) END
      PRODUCE RULE(ReturnStmnt  ) END
      PRODUCE RULE(CompaundStmnt) END
   END

   FORMULA(DefineSemi) PRODUCE RULE(Define) SYM(Semicolon) END END
   FORMULA(ExprSemi) PRODUCE EXPRESSION(Expression) SYM(Semicolon) END END
   FORMULA(DefExpr) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) END 
#if defined(GRAMMAR_FULL)
      PRODUCE LEX(Ident) SYM(Colon) RULE(DefExpr) MAKE_TREE(Label) END
#endif
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(Statement) END
      PRODUCE RULE(ExprSemi) END
   END

   FORMULA(StmExpr) 
      PRODUCE RULE(DefExpr) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END

   FORMULA(DefFAV) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) END 
      PRODUCE RULE(DefFunc) END
      PRODUCE RULE(DefineSemi) END
   END

   FORMULA(DefinesBeg)
      PRODUCE RULE(DefFAV) MAKE_TREE(AddToList) MASTER END
      EMPTY
   END

   FORMULA(Defines)
      PRODUCE MAKE(BegStmExpr) RULE(DefinesBeg) END
   END
   FORMULA(S_) 
      PRODUCE RULE(Program) END
   END

   FORMULA(Program)
#if   defined(DEFINE_RULE_FULL)
      PRODUCE RULE(Defines) END
#elif defined(DEFINE_RULE_DEF)
      PRODUCE RULE(Define) END
#elif defined(DEFINE_RULE_EXPR)
      PRODUCE EXPRESSION(Expression) END
#elif defined(DEFINE_RULE_STMT)
      PRODUCE RULE(StmExpr) END
#else
#endif
   END

#define NO_PRIOR_SYMBOL
#if  defined(NO_PRIOR_SYMBOL)
#undef PRIOR
#define PRIOR(P) RULE(Prior##P)
#endif

#undef WORD_Define
#define WORD_Define  GROUP(DefType)

   FORMULA(DefParType)
      PRODUCE WORD(Const) WORD_Define OPER(And) PARAM(MAKE_ALL(DefType),0x0B) END
      PRODUCE             WORD_Define OPER(And) PARAM(MAKE_ALL(DefType),0x09) END
      PRODUCE WORD(Const) WORD_Define           PARAM(MAKE_ALL(DefType),0x03) END
      PRODUCE             WORD_Define           PARAM(MAKE_ALL(DefType),0x01) END
   END

   FORMULA(DefBegParVar) 
      PRODUCE RULE(DefParType) LEX(Ident) MAKE(DefParVar) MAKE_NODE(DefVar,L(2,1),1) END
   END
   FORMULA(DefParVar) 
      PRODUCE RULE(DefBegParVar) OPER(Assign) MAKE_CODE(BegParVarAssign) RULE(Assign) MAKE(ParVarAssign) MAKE_NODE(DefVar,L(2,1,3),2) END
      PRODUCE RULE(DefBegParVar) END
   END

   FORMULA(DefBegParArr) 
      PRODUCE RULE(DefParType) LEX(Ident) MAKE(DefParArr) RULE(DefBegRanges) MAKE_NODE(DefArr,L(2,1,0,3),1) END
   END
   FORMULA(DefParArr) 
      PRODUCE RULE(DefBegParArr) OPER(Assign) MAKE_CODE(BegParVarAssign) RULE(Assign) MAKE(ParVarAssign) MAKE_NODE(DefArr,L(2,1,3),2) END 
      PRODUCE RULE(DefBegParArr) END // !!!
   END

   FORMULA(DefParItem) 
      PRODUCE RULE(DefParArr) END
      PRODUCE RULE(DefParVar) END
   END

   FORMULA(DefParams)
      PRODUCE MASTER SYM(Comma) RULE(DefParItem) MAKE_TREE(AddToList) PARAM(MAKE_YACC(AddToList),0x05) END
      PRODUCE RULE(DefParItem) MAKE_TREE(AddToList) MAKE_NODE(Define,L(0,0,1),0) END
   END

   FORMULA(BodyFunc)
      PRODUCE SYM(Semicolon) PARAM(MAKE(BodyFunc),0x00) MAKE_NODE(NodeOne,L(1),0) END
      PRODUCE SYM(LeftCramp) SYM(RightCramp) PARAM(MAKE(BodyFunc),0x01) MAKE_NODE(NodeOne,L(1),1) END
      PRODUCE SYM(LeftCramp) MAKE_CODE(EndParams) MAKE(BegStmExpr) RULE(StmExpr) SYM(RightCramp) PARAM(MAKE(BodyFunc),0x02) MAKE_NODE(NodeOne,L(1,2),2) END
   END

   FORMULA(DefFuncParBody)
      PRODUCE SYM(RightBracket) MAKE_TREE(EndParams) MAKE_NODE(Define, L(0), 0) END
      PRODUCE RULE(DefParams) SYM(RightBracket) MAKE_TREE(EndParams) END
   END

   FORMULA(DefParBodyFunc) 
      PRODUCE PARAM(MAKE_TREE(Define), 0x02) RULE(DefFuncParBody) RULE(BodyFunc) MAKE_NODE(NodeTwo,L(0,1,2),0) END
   END

   FORMULA(DefVoidType)
      PRODUCE WORD(Static)             WORD(Void) PARAM(MAKE_ALL(DefType),0x24) END
      PRODUCE                          WORD(Void) PARAM(MAKE_ALL(DefType),0x20) END
   END

   FORMULA(DefType)
      PRODUCE WORD(Static) WORD(Const) WORD_Define PARAM(MAKE_ALL(DefType),0x07) END
      PRODUCE WORD(Static)             WORD_Define PARAM(MAKE_ALL(DefType),0x05) END
      PRODUCE              WORD(Const) WORD_Define PARAM(MAKE_ALL(DefType),0x03) END
      PRODUCE                          WORD_Define PARAM(MAKE_ALL(DefType),0x01) END
   END

   FORMULA(CommaDefItem)
      PRODUCE MASTER SYM(Comma) RULE(DefItem) MAKE_TREE(AddToList) PARAM(MAKE_YACC(AddToList),0x05) END
      PRODUCE RULE(DefItem) MAKE_TREE(AddToList) MAKE_NODE(Define,L(0,0,1),0) END
   END

   FORMULA(Define)
      PRODUCE RULE(DefType) PARAM(MAKE(Define),0x01) RULE(CommaDefItem) MAKE_CODE(EndDefine) MAKE_NODE(Define,L(0,1,0,2),1) END
   END

   FORMULA(DefineBegRanges)
      PRODUCE SYM(RightScrape) MAKE(DefArrD1AEmpty) RULE(DefRanges) MAKE_NODE(Ranges, L(1, 2), 1) END // ins(Null) 
      PRODUCE SYM(RightScrape) MAKE(DefArrD1AEmpty) MAKE_NODE(Ranges, L(1), 0) END // Null 
      PRODUCE RULE(Assign) SYM(RightScrape) MAKE(DRange) RULE(DefRanges) MAKE_NODE(Ranges, L(0, 3, 1), 4) END // ins
      PRODUCE RULE(Assign) SYM(RightScrape) MAKE(DRange) MAKE_NODE(Ranges, L(0, 1), 2) END // create
   END

   FORMULA(DefineBegArr) 
      PRODUCE RULE(DefineBegRanges) MAKE_CODE(EndRanges) END
   END

   FORMULA(DefineArr) 
      PRODUCE RULE(IdentLeftScrape) OPER(Assign) MAKE_CODE(BegAInit) RULE(Initializer) MAKE(EndAInit) MAKE_NODE(DefArr,L(0,1,3),2) END 
      PRODUCE RULE(IdentLeftScrape) END
   END

   FORMULA(IdentLeftScrape) 
      PRODUCE LEX(Ident) SYM(LeftScrape) MAKE(Define) MAKE(DefArray) RULE(DefineBegArr) MAKE_NODE(DefArr,L(1,0,0,3),1) END
   END

   FORMULA(DefineVarAssign) 
      PRODUCE SYM(Comma) RULE(CommaDefItem) SYM(Semicolon) MAKE_CODE(EndDefine) MAKE_NODE(None,L(2),0) END
      PRODUCE SYM(Semicolon) MAKE_CODE(EndDefine) END
   END

   FORMULA(DefVariableAssign)
      PRODUCE LEX(Ident) MAKE(Define) MAKE(DefIdent) OPER(Assign) MAKE_CODE(BegDefVarAssign) RULE(Assign) MAKE(DefVarAssign) MAKE_TREE(AddToList) MAKE_NODE(DefVar, L(1, 0, 3), 1) END
   END

   FORMULA(DefVarComma)
      PRODUCE LEX(Ident) MAKE(Define) MAKE(DefIdent) MAKE_TREE(AddToList) MAKE_NODE(DefVar, L(1), 0) END
   END

   FORMULA(DefVarSemicolon)
      PRODUCE LEX(Ident) MAKE(Define) MAKE(DefIdent) MAKE_TREE(AddToList) MAKE_NODE(DefVar, L(1), 0) END
   END

   FORMULA(DefFuncArrVar)
      PRODUCE 
         RULE(DefType) LEX(Ident) SYM(LeftBracket) MAKE(FuncIdent) RULE(DefParBodyFunc) MAKE_NODE(DefFunc,L(2,1,4),0) 
      END
      PRODUCE 
         RULE(DefType) RULE(DefineArr) MAKE_TREE(AddToList) SYM(Comma) RULE(CommaDefItem) SYM(Semicolon) MAKE_CODE(EndDefine) MAKE_NODE(Define,L(0,1,2,4),1)
      END
      PRODUCE 
         RULE(DefType) RULE(DefineArr) MAKE_TREE(AddToList) SYM(Semicolon) MAKE_CODE(EndDefine) MAKE_NODE(Define,L(0,1,2),0) 
      END 
      PRODUCE 
         RULE(DefType) RULE(DefVariableAssign) RULE(DefineVarAssign) MAKE_NODE(Define,L(0,1,2,3),1)
      END
      PRODUCE 
         RULE(DefType) RULE(DefVarComma) SYM(Comma) RULE(CommaDefItem) SYM(Semicolon) MAKE_CODE(EndDefine) MAKE_NODE(Define,L(0,1,2,4),1)
      END
      PRODUCE 
         RULE(DefType) RULE(DefVarSemicolon) SYM(Semicolon) MAKE_CODE(EndDefine) MAKE_NODE(Define,L(0,1,2),0) 
      END 
   END

   FORMULA(DefFuncDefine)
      PRODUCE RULE(DefVoidType) LEX(Ident) SYM(LeftBracket) MAKE(FuncIdent) RULE(DefParBodyFunc) MAKE_NODE(DefFunc,L(2,1,4),0) END
      PRODUCE RULE(DefFuncArrVar) END
   END

   FORMULA(AInitItem)
      PRODUCE RULE(Initializer) END
      PRODUCE RULE(Assign) MAKE_CODE(AInitItem) END
   END

   FORMULA(AInitial)
      PRODUCE MASTER SYM(Comma) RULE(AInitItem) MAKE_TREE(AddToList) MAKE_NODE(List,L(0,3,1),1) END
      PRODUCE RULE(AInitItem) MAKE_TREE(AddToList) MAKE_NODE(List,L(1,1),0) END
   END

   FORMULA(Initializer)
      PRODUCE SYM(LeftCramp) SYM(RightCramp) MAKE_CODE(BegInitial) MAKE_TREE(NodeList) MAKE_NODE(List,L(1),0) END
      PRODUCE SYM(LeftCramp) PARAM(MAKE_CODE(BegInitial),0x01) MAKE_TREE(NodeList) RULE(AInitial) SYM(RightCramp) MAKE_CODE(EndInitial) MAKE_NODE(None,L(2),0) END
   END

   FORMULA(DefRange)
      PRODUCE SYM(LeftScrape) RULE(Assign) SYM(RightScrape) MAKE_NODE(None, L(2), 0) END
   END

   FORMULA(DefRanges)
      PRODUCE MASTER RULE(DefRange) MAKE(DRange) MAKE_NODE(Ranges,L(0,1,2),3) END // add
      PRODUCE RULE(DefRange) MAKE(DRange) MAKE_NODE(Ranges,L(0,1),2) END // create
   END

   FORMULA(DefBegRanges) 
      PRODUCE SYM(LeftScrape) SYM(RightScrape) MAKE(DefArrD1AEmpty) RULE(DefRanges) MAKE_NODE(Ranges,L(1,3),1) END // ins(Null)
      PRODUCE SYM(LeftScrape) SYM(RightScrape) MAKE(DefArrD1AEmpty) MAKE_NODE(Ranges,L(1),0) END // Null
      PRODUCE RULE(DefRanges) END
   END

   FORMULA(DefBegArr) 
      PRODUCE LEX(Ident) MAKE(DefArray) RULE(DefBegRanges) MAKE_CODE(EndRanges) MAKE_NODE(DefArr,L(1,0,0,2),1) END // (Lexeme,Type,Assign,Range)
   END

   FORMULA(DefArr) 
      PRODUCE RULE(DefBegArr) OPER(Assign) MAKE_CODE(BegAInit) RULE(Initializer) MAKE(EndAInit) MAKE_NODE(DefArr,L(0,1,3),2) END // (,Node,Assign)
      PRODUCE RULE(DefBegArr) END
   END

   FORMULA(DefVarIdent) 
      PRODUCE LEX(Ident) MAKE(DefIdent) MAKE_NODE(DefVar, L(1), 0) END
   END

   FORMULA(DefVarAssign)
      PRODUCE RULE(DefVarIdent) OPER(Assign) MAKE_CODE(BegDefVarAssign) RULE(Assign) MAKE(DefVarAssign) MAKE_NODE(DefVar, L(2, 1, 3), 2) END
   END
   FORMULA(DefVar)
      PRODUCE RULE(DefVarAssign) END
      PRODUCE RULE(DefVarIdent) END
   END

   FORMULA(DefIAV) 
      PRODUCE RULE(DefArr) END
      PRODUCE RULE(DefVar) END
   END
   FORMULA(RefDefIAV)
      PRODUCE OPER(And) RULE(DefIAV) MAKE_TREE(RefDef) MAKE_NODE(RefDef,L(1,2),0) END
   END
   FORMULA(DefItem) 
      PRODUCE RULE(RefDefIAV) END 
      PRODUCE RULE(DefIAV) END 
   END

   FORMULA(Expressions)
      PRODUCE MASTER SYM(Comma) RULE(Assign) MAKE_TREE(AddToList) MAKE_CODE(AddToExpr) PARAM(MAKE_YACC(AddToList),0x05) END
      PRODUCE RULE(Assign) MAKE(Expressions) MAKE_NODE(Expressions,L(1,1),0) END
   END

   FORMULA(PriorAssign) 
      PRODUCE OPER(AddAssign) END PRODUCE OPER(SubAssign) END PRODUCE OPER(MultiAssign) END PRODUCE OPER(DivAssign)    END PRODUCE OPER(ModAssign)    END PRODUCE OPER(Assign) END
      PRODUCE OPER(OrAssign)  END PRODUCE OPER(XOrAssign) END PRODUCE OPER(AndAssign)   END PRODUCE OPER(LShiftAssign) END PRODUCE OPER(RShiftAssign) END
   END

   FORMULA(PriorQuestion) PRODUCE OPER(Question) END END
   FORMULA(PriorOrOr)     PRODUCE OPER(OrOr)     END END
   FORMULA(PriorAndAnd)   PRODUCE OPER(AndAnd)   END END
   FORMULA(PriorOr)       PRODUCE OPER(Or)       END END
   FORMULA(PriorXOr)      PRODUCE OPER(XOr)      END END
   FORMULA(PriorAnd)      PRODUCE OPER(And)      END END
   FORMULA(PriorEqu)      PRODUCE OPER(Equ)      END PRODUCE OPER(NotEqu)     END END
   FORMULA(PriorCompare)  PRODUCE OPER(LE)       END PRODUCE OPER(LT)         END PRODUCE OPER(GE) END PRODUCE OPER(GT) END END
   FORMULA(PriorShift)    PRODUCE OPER(LShift)   END PRODUCE OPER(RShift)     END END
   FORMULA(PriorTerm)     PRODUCE OPER(Add)      END PRODUCE OPER(Sub)        END END
   FORMULA(PriorFactor)   PRODUCE OPER(Multi)    END PRODUCE OPER(Div)        END PRODUCE OPER(Mod) END END
   FORMULA(PriorUnary)    PRODUCE OPER(Not)      END PRODUCE OPER(Tilda)      END END
   FORMULA(PriorIncDec)   PRODUCE OPER(PlusPlus) END PRODUCE OPER(MinusMinus) END END

   FORMULA(Assign)
      PRODUCE RULE(Question) PRIOR(Assign) MASTER MAKE(Binary) MAKE_NODE(Binary,L(2,1,3),0) END
      PRODUCE RULE(Question) END
   END

   FORMULA(Question)
      PRODUCE RULE(OrOr) PRIOR(Question) MAKE_CODE(BegQuestion) MASTER SYM(Colon) MAKE_CODE(MidQuestion) MASTER MAKE(Question) MAKE_NODE(Trio,L(2,1,3,5),0) END
      PRODUCE RULE(OrOr) END
   END

   FORMULA_PRIOR(OrOr,AndAnd)
   FORMULA_PRIOR(AndAnd,Or)
   FORMULA_PRIOR(Or,XOr)
   FORMULA_PRIOR(XOr,And)
   FORMULA_PRIOR(And,Equ)
   FORMULA_PRIOR(Equ,Compare)
   FORMULA_PRIOR(Compare,Shift)
   FORMULA_PRIOR(Shift,Term)
   FORMULA_PRIOR(Term,Factor)
   FORMULA_PRIOR(Factor,Unary)

   FORMULA(UnaryIncDec)
      PRODUCE RULE(PrimaryExpr) PRIOR(IncDec) MAKE(IncDec) MAKE_NODE(Unary, L(2, 1), 1) END
      PRODUCE RULE(PrimaryExpr) END
   END

   FORMULA(DefTypeCast)
      PRODUCE WORD(Const) WORD_Define PARAM(MAKE_ALL(DefType), 0x03) END
      PRODUCE             WORD_Define PARAM(MAKE_ALL(DefType), 0x01) END
   END

   FORMULA(Unary)
      PRODUCE PRIOR(Unary)     RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),0) END
      PRODUCE PRIOR(Term)      RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),1) END
      PRODUCE PRIOR(IncDec)    RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),0) END
      PRODUCE SYM(LeftBracket) RULE(DefTypeCast) SYM(RightBracket) RULE(Unary) MAKE(Cast) MAKE_NODE(Cast,L(2,4),0) END
      PRODUCE RULE(UnaryIncDec) END
   END

   FORMULA(Primary) 
      PRODUCE SYM(LeftBracket) EXPRESSION(None) SYM(RightBracket) MAKE_TREE(Primary) MAKE_NODE(Primary, L(1, 2), 0) END 
   END

   FORMULA(PrimaryExpr) 
      PRODUCE LEX(Integer) MAKE(Number) MAKE_NODE(Number,L(1),0) END
      PRODUCE LEX(Number)  MAKE(Number) MAKE_NODE(Number,L(1),0) END
      PRODUCE LEX(Ident)   RULE(Ranges) MAKE(EndIndex) MAKE_NODE(Index,L(1,2),0) END
      PRODUCE LEX(Ident)   RULE(CallParams) MAKE_NODE(Call,L(1,2),0) END
      PRODUCE WORD_Define  RULE(Primary) MAKE(Cast) MAKE_NODE(Cast,L(1,2),0) END
      PRODUCE LEX(Ident)   MAKE(Ident) MAKE_NODE(Var,L(1),0) END  // !LR0
      PRODUCE RULE(Primary) END
   END

   FORMULA(Range) 
      PRODUCE SYM(LeftScrape) EXPRESSION(Value) SYM(RightScrape) MAKE_NODE(None, L(2), 0) END
   END

   FORMULA(Ranges)
      PRODUCE MASTER RULE(Range) MAKE(Index) PARAM(MAKE_YACC(AddToList),0x03) END
      PRODUCE RULE(Range) MAKE(BegIndex) MAKE_NODE(List,L(0,1),0) END 
   END

   FORMULA(CallParams) 
      PRODUCE SYM(LeftBracket) SYM(RightBracket) MAKE(Params) MAKE_NODE(List,L(1),0) END
      PRODUCE SYM(LeftBracket) EXPRESSION(ValueList) SYM(RightBracket) PARAM(MAKE(Params),0x01) MAKE_NODE(None,L(2),0) END
   END

   FORMULA(CompaundStmnt)
      PRODUCE SYM(LeftCramp) SYM(RightCramp) MAKE(Compaund) MAKE_CODE(EndBlock) MAKE_NODE(Statements,L(1),0) END
      PRODUCE SYM(LeftCramp) MAKE(Compaund) RULE(StmExpr) SYM(RightCramp) MAKE_NODE(None,L(2),0) END
   END
      
   FORMULA(ConditionVar)
      PRODUCE OPER(And) RULE(DefVar) MAKE_TREE(RefDef) MAKE_NODE(RefDef, L(1, 2), 0) END
      PRODUCE RULE(DefVar) END
   END

   FORMULA(Condition)
      PRODUCE RULE(DefType) PARAM(MAKE(Define),0x01) RULE(ConditionVar) MAKE(PushDef) MAKE_NODE(Define,L(0,1,2),0) END
      PRODUCE EXPRESSION(Condition) END
   END

   FORMULA(ForPrefix) // prefix
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null, L(1), 0) END
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(ExprSemi) END
   END
   FORMULA(ForCondition) // condition
      PRODUCE SYM(Semicolon) MAKE(NodeNull) MAKE_NODE(Null, L(1), 0) END
      PRODUCE RULE(Condition) SYM(Semicolon) END
   END
   FORMULA(ForPostfix) // postfix
      PRODUCE SYM(RightBracket) MAKE_TREE(NodeNull) MAKE_NODE(Null, L(1), 0) END
      PRODUCE EXPRESSION(Expression) SYM(RightBracket) END
   END

   FORMULA(ForStmnt) 
      PRODUCE
         WORD(For) SYM(LeftBracket) MAKE_CODE(BegFor)
         RULE(ForPrefix) MAKE_CODE(PrefFor)
         RULE(ForCondition) MAKE_CODE(ConditionFor)
         RULE(ForPostfix) MAKE_CODE(PostFor)
         RULE(DefExpr) // body
         MAKE(For) MAKE_NODE(For,L(1,3,4,5,6),0) 
      END
   END 

   FORMULA(DoStmnt      ) PRODUCE WORD(Do      ) RULE(DefExpr)    WORD(While) SYM(LeftBracket) RULE(Condition) SYM(RightBracket) SYM(Semicolon) MAKE(Do) MAKE_NODE(Do,L(1,5,2),0) END END
   FORMULA(WhileStmnt   ) PRODUCE WORD(While   ) SYM(LeftBracket) RULE(Condition)   SYM(RightBracket) RULE(DefExpr) MAKE(While) MAKE_NODE(While,L(1,3,5),0) END END
//   FORMULA(SwitchStmnt  ) PRODUCE WORD(Switch  ) SYM(LeftBracket) SYM(RightBracket) END END
   FORMULA(GoToStmnt    ) PRODUCE WORD(GoTo    ) LEX(Ident)       SYM(Semicolon)  MAKE_NODE(GoTo    ,L(2),0) MAKE(GoTo) END END
   FORMULA(BreakStmnt   ) PRODUCE WORD(Break   ) SYM(Semicolon)   MAKE(Break   )  MAKE_NODE(Break   ,L(1),0) END END
   FORMULA(ContinueStmnt) PRODUCE WORD(Continue) SYM(Semicolon)   MAKE(Continue)  MAKE_NODE(Continue,L(1),0) END END

   FORMULA(ReturnValue)
      PRODUCE SYM(Semicolon) MAKE(Return) MAKE_NODE(Return, L(1), 0) END
      PRODUCE EXPRESSION(Value) SYM(Semicolon) PARAM(MAKE(Return), 0x01) MAKE_NODE(Return, L(1, 1), 0) END
   END
   FORMULA(ReturnStmnt  )
      PRODUCE WORD(Return) RULE(ReturnValue) MAKE_NODE(None,L(2),0) END
   END 

#define IF_ELSE_LR1_

#ifdef IF_ELSE_LR1
   FORMULA(IfStatement) 
      PRODUCE RULE(IfSttmnt_M) END 
      PRODUCE RULE(IfSttmnt_U) END
   END

   FORMULA(BegIfStmnt) 
      PRODUCE WORD(If) SYM(LeftBracket) MAKE_CODE(BegIf) RULE(Condition) SYM(RightBracket) MAKE_CODE(Then) MAKE_NODE(If, L(1, 3, 5), 0) END
   END

   FORMULA(IfSttmnt_M)
      PRODUCE RULE(BegIfStmnt)    RULE(IfSttmnt_M)     WORD(Else)  MAKE_CODE(Else)  RULE(IfSttmnt_M) PARAM(MAKE(If), 0x01) MAKE_NODE(If, L(2, 1, 3), 1) END
      PRODUCE RULE(DefExpr) END
   END

   FORMULA(IfSttmnt_U)
      PRODUCE RULE(BegIfStmnt)    RULE(IfStatement)    MAKE(If)    END
      PRODUCE RULE(BegIfStmnt)    RULE(IfSttmnt_M)     WORD(Else)  MAKE_CODE(Else)  RULE(IfSttmnt_U) PARAM(MAKE(If), 0x01) MAKE_NODE(If, L(2, 1, 3), 1) END
   END
#else
   FORMULA(BegIfStmnt) 
      PRODUCE WORD(If) SYM(LeftBracket) MAKE_CODE(BegIf) RULE(Condition) SYM(RightBracket) MAKE_CODE(Then) RULE(DefExpr) MAKE_NODE(If, L(1, 3, 5), 0) END
   END
#endif

   FORMULA(LabelIdent) 
      PRODUCE LEX(Ident) SYM(Colon) MAKE_CODE(Label) MAKE_NODE(Label, L(1), 0) END
   END

   FORMULA(LabelList)
      PRODUCE RULE(LabelIdent) MAKE_NODE(List, L(0, 1), 0) END
   END

   FORMULA(Statement)
#ifdef IF_ELSE_LR1
      PRODUCE RULE(IfStatement) END
#else
      PRODUCE RULE(BegIfStmnt) WORD(Else) MAKE_CODE(Else) RULE(DefExpr) PARAM(MAKE(If),0x01) MAKE_NODE(If,L(2,1,3),1) END
      PRODUCE WARNING RULE(BegIfStmnt) MAKE(If) END
#endif
      PRODUCE 
         RULE(LabelList) RULE(DefExpr) PARAM(MAKE_YACC(AddToList),0x03) MAKE_TREE(Label)
      END
      PRODUCE RULE(DoStmnt      ) END
      PRODUCE RULE(WhileStmnt   ) END
      PRODUCE RULE(ForStmnt     ) END
//      PRODUCE RULE(SwitchStmnt  ) END
      PRODUCE RULE(GoToStmnt    ) END
      PRODUCE RULE(BreakStmnt   ) END
      PRODUCE RULE(ContinueStmnt) END
      PRODUCE RULE(ReturnStmnt  ) END
      PRODUCE RULE(CompaundStmnt) END
   END

   FORMULA(DefineSemi) PRODUCE RULE(Define) SYM(Semicolon) END END
   FORMULA(ExprSemi) PRODUCE EXPRESSION(Expression) SYM(Semicolon) END END
   FORMULA(DefExpr) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END 
      PRODUCE RULE(DefineSemi) END
      PRODUCE RULE(Statement) END
      PRODUCE RULE(ExprSemi) END
   END

   FORMULA(StmExprList)
      PRODUCE MASTER RULE(DefExpr) MAKE_TREE(AddToList) PARAM(MAKE_YACC(AddToList), 0x03) END
      PRODUCE RULE(DefExpr) MAKE_TREE(AddToList) MAKE_NODE(Statements, L(0, 1), 0) END
   END

   FORMULA(StmExpr)
      PRODUCE RULE(StmExprList) MAKE_CODE(EndBlock) END
   END

   FORMULA(DefFAV) 
      PRODUCE SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END 
      PRODUCE RULE(DefFuncDefine) END
   END

   FORMULA(DefinesList)
      PRODUCE MASTER RULE(DefFAV) MAKE_TREE(AddToList) PARAM(MAKE_YACC(AddToList),0x03) END
      PRODUCE RULE(DefFAV) PARAM(MAKE_TREE(BegStmExpr),0x01) MAKE_NODE(Statements,L(0,1),0) END
   END

   FORMULA(Defines)
      PRODUCE MAKE_CODE(BegStmExpr) RULE(DefinesList) MAKE_CODE(EndBlock) END
   END

   FORMULA(S_)
      PRODUCE  RULE(Program) END
   END

   FORMULA(DefParInit)
      PRODUCE  OPER(Assign) MAKE_CODE(BegParVarAssign) RULE(Assign) MAKE(ParVarAssign) END
      PRODUCE  EMPTY END
   END

   FORMULA(DefPar)
      PRODUCE  GROUP(DefArr) MAKE_YACC(DefType) GROUP(IdentArr) MAKE(DefParArr) RULE(DefArrDA) MAKE_NODE(DefArr,L(3,0,1),0) RULE(DefParInit) MAKE_NODE(DefArr,L(1,2),2) END
      PRODUCE  GROUP(DefVar) MAKE_YACC(DefType) LEX(Ident) MAKE(DefParVar) RULE(DefParInit) MAKE_NODE(DefVar,L(2,1),0) END
   END

   FORMULA(DefParList)
      PRODUCE  SYM(Comma) RULE(DefParItem) PARAM(MAKE_YACC(AddToList),6) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(BodyFunc)
      PRODUCE  SYM(Semicolon) MAKE(BodyFunc) END
      PRODUCE  GROUP(EmptyCramp) PARAM(MAKE(BodyFunc),1) MAKE_NODE(Null,L(1),0) END
      PRODUCE  SYM(LeftCramp) MAKE_CODE(EndParams) RULE(StmExpr) MAKE_NODE(None,L(1),0) SYM(RightCramp) PARAM(MAKE(BodyFunc),2) END
   END

   FORMULA(DefFunc_)
      PRODUCE  GROUP(EmptyBracket) END
      PRODUCE  SYM(LeftBracket) RULE(DefParams) MAKE_NODE(None,L(1),0) SYM(RightBracket) END
   END

   FORMULA(AInitItem)
      PRODUCE  RULE(Initializer) END
      PRODUCE  RULE(Assign) MAKE_CODE(AInitItem) END
   END

   FORMULA(AInitialList)
      PRODUCE  SYM(Comma) RULE(AInitItem) PARAM(MAKE_YACC(AddToList),6) MAKE_TREE(AddToList) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Initializer)
      PRODUCE  GROUP(EmptyCramp) MAKE_CODE(BegInitial) MAKE_TREE(NodeList) MAKE_NODE(List,L(0),0) END
      PRODUCE  SYM(LeftCramp) PARAM(MAKE_CODE(BegInitial),1) MAKE_TREE(NodeList) MAKE_NODE(List,L(0,2),0) RULE(AInitial) SYM(RightCramp) MAKE_CODE(EndInitial) END
   END

   FORMULA(DefAInit)
      PRODUCE  OPER(Assign) MAKE_CODE(BegAInit) RULE(Initializer) MAKE(EndAInit) END
      PRODUCE  EMPTY END
   END

   FORMULA(DRanges)
      PRODUCE  SYM(LeftScrape) RULE(Assign) PARAM(MAKE_YACC(AddToList),10) SYM(RightScrape) MAKE(DRange) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(DefArrD1A)
      PRODUCE  GROUP(EmptyScrape) MAKE(DefArrD1AEmpty) MAKE_NODE(Ranges,L(0),5) END
      PRODUCE  SYM(LeftScrape) RULE(Assign) MAKE_NODE(Ranges,L(1),2) SYM(RightScrape) MAKE(DRange) END
   END

   FORMULA(DefVarInit)
      PRODUCE  OPER(Assign) MAKE_CODE(BegDefVarAssign) RULE(Assign) MAKE(DefVarAssign) END
      PRODUCE  EMPTY END
   END

   FORMULA(DefIAV)
      PRODUCE  GROUP(IdentArr) MAKE(DefArray) RULE(DefArrDA) MAKE_NODE(DefArr,L(0,0,1),0) RULE(DefAInit) MAKE_NODE(DefArr,L(1,2),2) END
      PRODUCE  LEX(Ident) MAKE(DefIdent) RULE(DefVarInit) MAKE_NODE(DefVar,L(0,1),0) END
   END

   FORMULA(DefItem)
      PRODUCE  PRIOR(And) RULE(DefIAV) MAKE_TREE(RefDef) MAKE_NODE(RefDef,L(1),0) END
      PRODUCE  RULE(DefIAV) END
   END

   FORMULA(DefType)
      PRODUCE  GROUP(DefArr) END
      PRODUCE  GROUP(DefVar) END
   END

   FORMULA(DefineList)
      PRODUCE  SYM(Comma) RULE(DefItem) PARAM(MAKE_YACC(AddToList),6) MAKE_TREE(AddToList) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Condition)
      PRODUCE  GROUP(DefVar) MAKE(Define) RULE(ConditionDef) MAKE(PushDef) MAKE_NODE(None,L(1),0) END
      PRODUCE  RULE(formula_00058) END
   END

   FORMULA(ConditionDef)
      PRODUCE  PRIOR(And) RULE(DefVar) MAKE_TREE(RefDef) MAKE_NODE(RefDef,L(1),0) END
      PRODUCE  LEX(Ident) MAKE(DefIdent) RULE(DefVarInit) MAKE_NODE(DefVar,L(0,1),0) END
   END

   FORMULA(ExprList)
      PRODUCE  SYM(Comma) RULE(Assign) PARAM(MAKE_YACC(AddToList),6) MAKE_TREE(AddToList) MAKE_CODE(AddToExpr) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(AssignList)
      PRODUCE  RULE(PriorAssign) MAKE_NODE(Copy, L(2), 2) RULE(Assign) MAKE(Binary) MAKE_NODE(Binary,L(2,1),0) END
      PRODUCE  EMPTY END
   END

   bool PRIOR_ASSIGNN = ((table.option & TGrammar::POption::opNoPriorAssign) == 0);

   FORMULA(PriorAssign)
if (!PRIOR_ASSIGNN) {
      PRODUCE  OPER(AddAssign)    END
      PRODUCE  OPER(SubAssign)    END
      PRODUCE  OPER(MultiAssign)  END
      PRODUCE  OPER(DivAssign)    END
      PRODUCE  OPER(ModAssign)    END
      PRODUCE  OPER(Assign)       END
      PRODUCE  OPER(OrAssign)     END
      PRODUCE  OPER(XOrAssign)    END
      PRODUCE  OPER(AndAssign)    END
      PRODUCE  OPER(LShiftAssign) END
      PRODUCE  OPER(RShiftAssign) END
} else {
      PRODUCE  PRIOR(Assign)      END
}
   END

   FORMULA(QuestionList)
      PRODUCE  PRIOR(Question) MAKE_CODE(BegQuestion) RULE(Question) MAKE_NODE(Trio,L(0),0) SYM(Colon) MAKE_CODE(MidQuestion) RULE(Question) MAKE_NODE(Trio,L(0),1) MAKE(Question) END
      PRODUCE  EMPTY END
   END

   FORMULA(AndAnd_)
      PRODUCE  PRIOR(OrOr) RULE(AndAnd) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Or_)
      PRODUCE  PRIOR(AndAnd) RULE(Or) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(XOr_)
      PRODUCE  PRIOR(Or) RULE(XOr) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(And_)
      PRODUCE  PRIOR(XOr) RULE(And) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Equ_)
      PRODUCE  PRIOR(And) RULE(Equ) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Compare_)
      PRODUCE  PRIOR(Equ) RULE(Compare) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Shift_)
      PRODUCE  PRIOR(Compare) RULE(Shift) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Term_)
      PRODUCE  PRIOR(Shift) RULE(Term) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Factor_)
      PRODUCE  PRIOR(Term) RULE(Factor) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Unary_)
      PRODUCE  PRIOR(Factor) RULE(Unary) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Unary)
      PRODUCE  PRIOR(Unary) RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),0) END
      PRODUCE  PRIOR(Term) RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),1) END
      PRODUCE  PRIOR(IncDec) RULE(Unary) MAKE(Unary) MAKE_NODE(Unary,L(1,2),0) END
      PRODUCE  GROUP(CastUnary) RULE(Unary) MAKE(Cast) MAKE_NODE(Cast,L(1,2),0) END
      PRODUCE  RULE(PrimaryExpr) MAKE_NODE(None,L(1,2),0) RULE(UnaryIncDec) END
   END

   FORMULA(UnaryIncDec)
      PRODUCE  PRIOR(IncDec) MAKE(IncDec) MAKE_NODE(Unary,L(2),1) END
      PRODUCE  EMPTY END
   END

   FORMULA(PrimaryExpr)
      PRODUCE  GROUP(IdentArr) RULE(Ranges) MAKE_NODE(Index,L(1),0) END
      PRODUCE  GROUP(IdentFunc) RULE(CallParams) MAKE_NODE(Call,L(1),0) END
      PRODUCE  LEX(Integer) MAKE(Number) MAKE_NODE(Number,L(1),0) END
      PRODUCE  LEX(Number) MAKE(Number) MAKE_NODE(Number,L(1),0) END
      PRODUCE  LEX(Ident) MAKE(Ident) MAKE_NODE(Var,L(1),0) END
      PRODUCE  SYM(LeftBracket) RULE(formula_00073) MAKE_NODE(None,L(1),0) SYM(RightBracket) MAKE_TREE(Primary) END
      PRODUCE  GROUP(Cast) RULE(Primary) MAKE(Cast) MAKE_NODE(Cast,L(1),0) END
   END

   FORMULA(CallParams)
      PRODUCE  GROUP(EmptyBracket) MAKE(Params) MAKE_NODE(List,L(0),0) END
      PRODUCE  SYM(LeftBracket) RULE(formula_00075) MAKE_NODE(None,L(1),0) SYM(RightBracket) PARAM(MAKE(Params),1) END
   END

   FORMULA(RangesList)
      PRODUCE  SYM(LeftScrape) RULE(formula_00074) PARAM(MAKE_YACC(AddToList),10) SYM(RightScrape) MAKE(Index) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(CompaundStmnt)
      PRODUCE  GROUP(EmptyCramp) MAKE(Compaund) MAKE_CODE(EndBlock) MAKE_NODE(Null,L(1),0) END
      PRODUCE  SYM(LeftCramp) MAKE(Compaund) RULE(StmExpr) MAKE_NODE(None,L(1),0) SYM(RightCramp) MAKE_CODE(EndBlock) MAKE_TREE(AddToList) END
   END

   FORMULA(IfStmnt_)
      PRODUCE  WORD(Else) MAKE_CODE(Else) RULE(DefExpr) PARAM(MAKE(If),1) END
      PRODUCE  EMPTY MAKE(If) END
   END

   FORMULA(DefExpr)
      PRODUCE  SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END
      PRODUCE  RULE(Define) MAKE_NODE(None,L(1),0) SYM(Semicolon) END
      PRODUCE  RULE(Statement) END
      PRODUCE  RULE(formula_00078) MAKE_NODE(None,L(1),0) SYM(Semicolon) END
   END

   FORMULA(ForPrefix)
      PRODUCE  SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END
      PRODUCE  RULE(Define) MAKE_NODE(None,L(1),0) SYM(Semicolon) END
      PRODUCE  RULE(formula_00078) MAKE_NODE(None,L(1),0) SYM(Semicolon) END
   END

   FORMULA(ForCondition)
      PRODUCE  SYM(Semicolon) MAKE(NodeNull) MAKE_NODE(Null,L(1),0) END
      PRODUCE  RULE(Condition) MAKE_NODE(None,L(1),0) SYM(Semicolon) END
   END

   FORMULA(ForPosfix)
      PRODUCE  SYM(RightBracket) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END
      PRODUCE  RULE(formula_00076) MAKE_NODE(None,L(1),0) SYM(RightBracket) END
   END

   FORMULA(ReturnVal)
      PRODUCE  RULE(formula_00077) PARAM(MAKE(Return),1) END
      PRODUCE  EMPTY MAKE(Return) END
   END

   FORMULA(Statement)
      PRODUCE  GROUP(Label) SYM(Colon) MAKE_CODE(Label) RULE(DefExpr) MAKE_NODE(Label,L(1),0) MAKE_TREE(Label) END
      PRODUCE  WORD(If) SYM(LeftBracket) MAKE_CODE(BegIf) RULE(Condition) MAKE_NODE(If,L(1),0) SYM(RightBracket) MAKE_CODE(Then) RULE(DefExpr) MAKE_NODE(If,L(1),1) RULE(IfStmnt_) MAKE_NODE(If,L(1),2) END
      PRODUCE  WORD(Do) MAKE_CODE(BegDo) RULE(DefExpr) MAKE_NODE(None,L(1),0) WORD(While) SYM(LeftBracket) MAKE_CODE(MidDo) RULE(Condition) MAKE_NODE(Do,L(1,4),0) SYM(RightBracket) SYM(Semicolon) MAKE(Do) END
      PRODUCE  WORD(While) MAKE_CODE(BegWhile) SYM(LeftBracket) RULE(Condition) MAKE_NODE(None,L(1),0) SYM(RightBracket) MAKE_CODE(MidWhile) RULE(DefExpr) MAKE(While) MAKE_NODE(While,L(2,1),0) END
      PRODUCE  WORD(For) SYM(LeftBracket) MAKE_CODE(BegFor) RULE(ForPrefix) MAKE_CODE(PrefFor) MAKE_NODE(For,L(1),0) RULE(ForCondition) MAKE_CODE(ConditionFor) MAKE_NODE(For,L(1),1) RULE(ForPosfix) MAKE_CODE(PostFor) MAKE_NODE(For,L(1),2) RULE(DefExpr) MAKE_NODE(For,L(1),3) MAKE(For) END
      PRODUCE  WORD(GoTo) LEX(Ident) SYM(Semicolon) MAKE_NODE(GoTo,L(1),0) MAKE(GoTo) END
      PRODUCE  WORD(Break) SYM(Semicolon) MAKE(Break) MAKE_NODE(Break,L(1),0) END
      PRODUCE  WORD(Continue) SYM(Semicolon) MAKE(Continue) MAKE_NODE(Continue,L(1),0) END
      PRODUCE  WORD(Return) RULE(ReturnVal) MAKE_NODE(Return,L(1),0) SYM(Semicolon) END
      PRODUCE  RULE(CompaundStmnt) END
   END

   FORMULA(StmExprList)
      PRODUCE  RULE(DefExpr) PARAM(MAKE_YACC(AddToList),6) MAKE_TREE(AddToList) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(DefFAV)
      PRODUCE  SYM(Semicolon) MAKE_TREE(NodeNull) MAKE_NODE(Null,L(1),0) END
      PRODUCE  GROUP(DefFunc) MAKE_NODE(DefFunc,L(0),0) GROUP(IdentFunc) MAKE_NODE(DefFunc,L(0),1) MAKE(FuncIdent) RULE(DefFunc_) MAKE_NODE(DefFunc,L(0),2) RULE(BodyFunc) MAKE_NODE(DefFunc,L(0),3) END
      PRODUCE  RULE(Define) MAKE_NODE(None,L(1),0) SYM(Semicolon) END
   END

   FORMULA(DefinesList)
      PRODUCE  RULE(DefFAV) PARAM(MAKE_YACC(AddToList),6) MAKE_TREE(AddToList) MASTER END
      PRODUCE  EMPTY END
   END

   FORMULA(Program)
      PRODUCE  RULE(Defines) MAKE_NODE(None,L(1),1) END
   END

   FORMULA(Defines)
      PRODUCE  MAKE(BegStmExpr) MAKE_NODE(Statements,L(2,3),0) RULE(DefinesList) MAKE_CODE(EndBlock) END
   END

   FORMULA(Assign)
      PRODUCE  RULE(Question) MAKE_NODE(None,L(1,2),0) RULE(AssignList) END
   END

   FORMULA(DefArrDA)
      PRODUCE  RULE(DefArrD1A) MAKE_NODE(None,L(1,2),0) RULE(DRanges) MAKE_CODE(EndRanges) END
   END

   FORMULA(DefParItem)
      PRODUCE  RULE(DefPar) MAKE_TREE(AddToList) END
   END

   FORMULA(DefParams)
      PRODUCE  PARAM(MAKE_TREE(Define), 0x02) RULE(DefParItem) MAKE_NODE(Define,L(1,2),1) RULE(DefParList) MAKE_TREE(EndParams) END
   END

   FORMULA(StmExpr)
      PRODUCE  MAKE(BegStmExpr) MAKE_NODE(Statements,L(2,3),0) RULE(StmExprList) MAKE_CODE(EndBlock) END
   END

   FORMULA(AInitial)
      PRODUCE  RULE(AInitItem) MAKE_TREE(AddToList) PARAM(MAKE_YACC(AddToList),6) RULE(AInitialList) END
   END

   FORMULA(DefVar)
      PRODUCE  LEX(Ident) MAKE(DefIdent) RULE(DefVarInit) MAKE_NODE(DefVar,L(0,1),0) END
   END

   FORMULA(Define)
      PRODUCE  RULE(DefType) MAKE(Define) MAKE_NODE(Define,L(4),0) RULE(DefItem) PARAM(MAKE_YACC(AddToList),2) MAKE_TREE(AddToList) RULE(DefineList) MAKE_CODE(EndDefine) END
   END

   FORMULA(formula_00058)
      PRODUCE  PARAM(MAKE_CODE(Part),241) RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),241) PARAM(MAKE_YACC(ExpressionS),241) END
   END

   FORMULA(Expressions)
      PRODUCE  RULE(Assign) MAKE(Expressions) MAKE_NODE(Expressions,L(2,3),1) RULE(ExprList) MAKE_CODE(ExpressionS) END
   END

   FORMULA(Question)
      PRODUCE  RULE(OrOr) MAKE_NODE(None,L(1,2),0) RULE(QuestionList) END
   END

   FORMULA(OrOr)
      PRODUCE  RULE(AndAnd) MAKE_NODE(None,L(1,2),0) RULE(AndAnd_) END
   END

   FORMULA(AndAnd)
      PRODUCE  RULE(Or) MAKE_NODE(None,L(1,2),0) RULE(Or_) END
   END

   FORMULA(Or)
      PRODUCE  RULE(XOr) MAKE_NODE(None,L(1,2),0) RULE(XOr_) END
   END

   FORMULA(XOr)
      PRODUCE  RULE(And) MAKE_NODE(None,L(1,2),0) RULE(And_) END
   END

   FORMULA(And)
      PRODUCE  RULE(Equ) MAKE_NODE(None,L(1,2),0) RULE(Equ_) END
   END

   FORMULA(Equ)
      PRODUCE  RULE(Compare) MAKE_NODE(None,L(1,2),0) RULE(Compare_) END
   END

   FORMULA(Compare)
      PRODUCE  RULE(Shift) MAKE_NODE(None,L(1,2),0) RULE(Shift_) END
   END

   FORMULA(Shift)
      PRODUCE  RULE(Term) MAKE_NODE(None,L(1,2),0) RULE(Term_) END
   END

   FORMULA(Term)
      PRODUCE  RULE(Factor) MAKE_NODE(None,L(1,2),0) RULE(Factor_) END
   END

   FORMULA(Factor)
      PRODUCE  RULE(Unary) MAKE_NODE(None,L(1,2),0) RULE(Unary_) END
   END

   FORMULA(Ranges)
      PRODUCE  MAKE(BegIndex) MAKE_NODE(List,L(2,3),0) RULE(RangesList) MAKE_CODE(EndIndex) END
   END

   FORMULA(Primary) 
      PRODUCE  SYM(LeftBracket) RULE(formula_00073) MAKE_NODE(None,L(1),0) SYM(RightBracket) MAKE_TREE(Primary) END
   END

   FORMULA(formula_00073)
      PRODUCE  MAKE_CODE(Part) RULE(Expressions) MAKE_TREE(ExpressionS) MAKE_YACC(ExpressionS) END
   END

   FORMULA(formula_00074)
      PRODUCE  PARAM(MAKE_CODE(Part),256) RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),256) PARAM(MAKE_YACC(ExpressionS),256) END
   END

   FORMULA(formula_00075)
      PRODUCE  PARAM(MAKE_CODE(Part),512) RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),512) PARAM(MAKE_YACC(ExpressionS),512) END
   END

   FORMULA(formula_00076)
      PRODUCE  PARAM(MAKE_CODE(Part),16) RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),16) PARAM(MAKE_YACC(ExpressionS),16) END
   END

   FORMULA(formula_00077)
      PRODUCE  PARAM(MAKE_CODE(Part),256) RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),256) PARAM(MAKE_YACC(ExpressionS),256) END
   END

   FORMULA(formula_00078)
      PRODUCE  PARAM(MAKE_CODE(Part),16) RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),16) PARAM(MAKE_YACC(ExpressionS),16) END
   END
   EXPRESSION_BODY(Expression)
   EXPRESSION_BODY(Condition)
   EXPRESSION_BODY(None)
   EXPRESSION_BODY(Value)
   EXPRESSION_BODY(ValueList)
#ifndef DEFINE_CAST_H
#define DEFINE_CAST_H

#define _______ T_CastType::_______
#define S___I__ T_CastType::S___I__
#define S___L__ T_CastType::S___L__
#define S___F__ T_CastType::S___F__
#define S___D__ T_CastType::S___D__
#define S___SC_ T_CastType::S___SC_
#define S___IC_ T_CastType::S___IC_
#define S___LC_ T_CastType::S___LC_
#define S___FC_ T_CastType::S___FC_
#define S___DC_ T_CastType::S___DC_
#define S___SR_ T_CastType::S___SR_
#define S___SCR T_CastType::S___SCR
#define I___S__ T_CastType::I___S__
#define I___L__ T_CastType::I___L__
#define I___F__ T_CastType::I___F__
#define I___D__ T_CastType::I___D__
#define I___SC_ T_CastType::I___SC_
#define I___IC_ T_CastType::I___IC_
#define I___LC_ T_CastType::I___LC_
#define I___FC_ T_CastType::I___FC_
#define I___DC_ T_CastType::I___DC_
#define I___IR_ T_CastType::I___IR_
#define I___ICR T_CastType::I___ICR
#define L___S__ T_CastType::L___S__
#define L___I__ T_CastType::L___I__
#define L___F__ T_CastType::L___F__
#define L___D__ T_CastType::L___D__
#define L___SC_ T_CastType::L___SC_
#define L___IC_ T_CastType::L___IC_
#define L___LC_ T_CastType::L___LC_
#define L___FC_ T_CastType::L___FC_
#define L___DC_ T_CastType::L___DC_
#define L___LR_ T_CastType::L___LR_
#define L___LCR T_CastType::L___LCR
#define F___S__ T_CastType::F___S__
#define F___I__ T_CastType::F___I__
#define F___L__ T_CastType::F___L__
#define F___D__ T_CastType::F___D__
#define F___SC_ T_CastType::F___SC_
#define F___IC_ T_CastType::F___IC_
#define F___LC_ T_CastType::F___LC_
#define F___FC_ T_CastType::F___FC_
#define F___DC_ T_CastType::F___DC_
#define F___FR_ T_CastType::F___FR_
#define F___FCR T_CastType::F___FCR
#define D___S__ T_CastType::D___S__
#define D___I__ T_CastType::D___I__
#define D___L__ T_CastType::D___L__
#define D___F__ T_CastType::D___F__
#define D___SC_ T_CastType::D___SC_
#define D___IC_ T_CastType::D___IC_
#define D___LC_ T_CastType::D___LC_
#define D___FC_ T_CastType::D___FC_
#define D___DC_ T_CastType::D___DC_
#define D___DR_ T_CastType::D___DR_
#define D___DCR T_CastType::D___DCR
#define SC__S__ T_CastType::SC__S__
#define SC__I__ T_CastType::SC__I__
#define SC__L__ T_CastType::SC__L__
#define SC__F__ T_CastType::SC__F__
#define SC__D__ T_CastType::SC__D__
#define SC__IC_ T_CastType::SC__IC_
#define SC__LC_ T_CastType::SC__LC_
#define SC__FC_ T_CastType::SC__FC_
#define SC__DC_ T_CastType::SC__DC_
#define IC__S__ T_CastType::IC__S__
#define IC__I__ T_CastType::IC__I__
#define IC__L__ T_CastType::IC__L__
#define IC__F__ T_CastType::IC__F__
#define IC__D__ T_CastType::IC__D__
#define IC__SC_ T_CastType::IC__SC_
#define IC__LC_ T_CastType::IC__LC_
#define IC__FC_ T_CastType::IC__FC_
#define IC__DC_ T_CastType::IC__DC_
#define LC__S__ T_CastType::LC__S__
#define LC__I__ T_CastType::LC__I__
#define LC__L__ T_CastType::LC__L__
#define LC__F__ T_CastType::LC__F__
#define LC__D__ T_CastType::LC__D__
#define LC__SC_ T_CastType::LC__SC_
#define LC__IC_ T_CastType::LC__IC_
#define LC__FC_ T_CastType::LC__FC_
#define LC__DC_ T_CastType::LC__DC_
#define FC__S__ T_CastType::FC__S__
#define FC__I__ T_CastType::FC__I__
#define FC__L__ T_CastType::FC__L__
#define FC__F__ T_CastType::FC__F__
#define FC__D__ T_CastType::FC__D__
#define FC__SC_ T_CastType::FC__SC_
#define FC__IC_ T_CastType::FC__IC_
#define FC__LC_ T_CastType::FC__LC_
#define FC__DC_ T_CastType::FC__DC_
#define DC__S__ T_CastType::DC__S__
#define DC__I__ T_CastType::DC__I__
#define DC__L__ T_CastType::DC__L__
#define DC__F__ T_CastType::DC__F__
#define DC__D__ T_CastType::DC__D__
#define DC__SC_ T_CastType::DC__SC_
#define DC__IC_ T_CastType::DC__IC_
#define DC__LC_ T_CastType::DC__LC_
#define DC__FC_ T_CastType::DC__FC_
#define SR__S__ T_CastType::SR__S__
#define SR__I__ T_CastType::SR__I__
#define SR__L__ T_CastType::SR__L__
#define SR__F__ T_CastType::SR__F__
#define SR__D__ T_CastType::SR__D__
#define SR__SC_ T_CastType::SR__SC_
#define SR__IC_ T_CastType::SR__IC_
#define SR__LC_ T_CastType::SR__LC_
#define SR__FC_ T_CastType::SR__FC_
#define SR__DC_ T_CastType::SR__DC_
#define IR__S__ T_CastType::IR__S__
#define IR__I__ T_CastType::IR__I__
#define IR__L__ T_CastType::IR__L__
#define IR__F__ T_CastType::IR__F__
#define IR__D__ T_CastType::IR__D__
#define IR__SC_ T_CastType::IR__SC_
#define IR__IC_ T_CastType::IR__IC_
#define IR__LC_ T_CastType::IR__LC_
#define IR__FC_ T_CastType::IR__FC_
#define IR__DC_ T_CastType::IR__DC_
#define LR__S__ T_CastType::LR__S__
#define LR__I__ T_CastType::LR__I__
#define LR__L__ T_CastType::LR__L__
#define LR__F__ T_CastType::LR__F__
#define LR__D__ T_CastType::LR__D__
#define LR__SC_ T_CastType::LR__SC_
#define LR__IC_ T_CastType::LR__IC_
#define LR__LC_ T_CastType::LR__LC_
#define LR__FC_ T_CastType::LR__FC_
#define LR__DC_ T_CastType::LR__DC_
#define FR__S__ T_CastType::FR__S__
#define FR__I__ T_CastType::FR__I__
#define FR__L__ T_CastType::FR__L__
#define FR__F__ T_CastType::FR__F__
#define FR__D__ T_CastType::FR__D__
#define FR__SC_ T_CastType::FR__SC_
#define FR__IC_ T_CastType::FR__IC_
#define FR__LC_ T_CastType::FR__LC_
#define FR__FC_ T_CastType::FR__FC_
#define FR__DC_ T_CastType::FR__DC_
#define DR__S__ T_CastType::DR__S__
#define DR__I__ T_CastType::DR__I__
#define DR__L__ T_CastType::DR__L__
#define DR__F__ T_CastType::DR__F__
#define DR__D__ T_CastType::DR__D__
#define DR__SC_ T_CastType::DR__SC_
#define DR__IC_ T_CastType::DR__IC_
#define DR__LC_ T_CastType::DR__LC_
#define DR__FC_ T_CastType::DR__FC_
#define DR__DC_ T_CastType::DR__DC_
#define SCR_S__ T_CastType::SCR_S__
#define SCR_I__ T_CastType::SCR_I__
#define SCR_L__ T_CastType::SCR_L__
#define SCR_F__ T_CastType::SCR_F__
#define SCR_D__ T_CastType::SCR_D__
#define SCR_SC_ T_CastType::SCR_SC_
#define SCR_IC_ T_CastType::SCR_IC_
#define SCR_LC_ T_CastType::SCR_LC_
#define SCR_FC_ T_CastType::SCR_FC_
#define SCR_DC_ T_CastType::SCR_DC_
#define ICR_S__ T_CastType::ICR_S__
#define ICR_I__ T_CastType::ICR_I__
#define ICR_L__ T_CastType::ICR_L__
#define ICR_F__ T_CastType::ICR_F__
#define ICR_D__ T_CastType::ICR_D__
#define ICR_SC_ T_CastType::ICR_SC_
#define ICR_IC_ T_CastType::ICR_IC_
#define ICR_LC_ T_CastType::ICR_LC_
#define ICR_FC_ T_CastType::ICR_FC_
#define ICR_DC_ T_CastType::ICR_DC_
#define LCR_S__ T_CastType::LCR_S__
#define LCR_I__ T_CastType::LCR_I__
#define LCR_L__ T_CastType::LCR_L__
#define LCR_F__ T_CastType::LCR_F__
#define LCR_D__ T_CastType::LCR_D__
#define LCR_SC_ T_CastType::LCR_SC_
#define LCR_IC_ T_CastType::LCR_IC_
#define LCR_LC_ T_CastType::LCR_LC_
#define LCR_FC_ T_CastType::LCR_FC_
#define LCR_DC_ T_CastType::LCR_DC_
#define FCR_S__ T_CastType::FCR_S__
#define FCR_I__ T_CastType::FCR_I__
#define FCR_L__ T_CastType::FCR_L__
#define FCR_F__ T_CastType::FCR_F__
#define FCR_D__ T_CastType::FCR_D__
#define FCR_SC_ T_CastType::FCR_SC_
#define FCR_IC_ T_CastType::FCR_IC_
#define FCR_LC_ T_CastType::FCR_LC_
#define FCR_FC_ T_CastType::FCR_FC_
#define FCR_DC_ T_CastType::FCR_DC_
#define DCR_S__ T_CastType::DCR_S__
#define DCR_I__ T_CastType::DCR_I__
#define DCR_L__ T_CastType::DCR_L__
#define DCR_F__ T_CastType::DCR_F__
#define DCR_D__ T_CastType::DCR_D__
#define DCR_SC_ T_CastType::DCR_SC_
#define DCR_IC_ T_CastType::DCR_IC_
#define DCR_LC_ T_CastType::DCR_LC_
#define DCR_FC_ T_CastType::DCR_FC_
#define DCR_DC_ T_CastType::DCR_DC_

#endif
#ifndef CASTABLE_ENUM_TYPE_H
#define CASTABLE_ENUM_TYPE_H

enum T_CastType {
   _______ ,
   S___I__ ,
   S___L__ ,
   S___F__ ,
   S___D__ ,
   S___SC_ ,
   S___IC_ ,
   S___LC_ ,
   S___FC_ ,
   S___DC_ ,
   S___SR_ ,
   S___SCR ,
   I___S__ ,
   I___L__ ,
   I___F__ ,
   I___D__ ,
   I___SC_ ,
   I___IC_ ,
   I___LC_ ,
   I___FC_ ,
   I___DC_ ,
   I___IR_ ,
   I___ICR ,
   L___S__ ,
   L___I__ ,
   L___F__ ,
   L___D__ ,
   L___SC_ ,
   L___IC_ ,
   L___LC_ ,
   L___FC_ ,
   L___DC_ ,
   L___LR_ ,
   L___LCR ,
   F___S__ ,
   F___I__ ,
   F___L__ ,
   F___D__ ,
   F___SC_ ,
   F___IC_ ,
   F___LC_ ,
   F___FC_ ,
   F___DC_ ,
   F___FR_ ,
   F___FCR ,
   D___S__ ,
   D___I__ ,
   D___L__ ,
   D___F__ ,
   D___SC_ ,
   D___IC_ ,
   D___LC_ ,
   D___FC_ ,
   D___DC_ ,
   D___DR_ ,
   D___DCR ,
   SC__S__ ,
   SC__I__ ,
   SC__L__ ,
   SC__F__ ,
   SC__D__ ,
   SC__IC_ ,
   SC__LC_ ,
   SC__FC_ ,
   SC__DC_ ,
   IC__S__ ,
   IC__I__ ,
   IC__L__ ,
   IC__F__ ,
   IC__D__ ,
   IC__SC_ ,
   IC__LC_ ,
   IC__FC_ ,
   IC__DC_ ,
   LC__S__ ,
   LC__I__ ,
   LC__L__ ,
   LC__F__ ,
   LC__D__ ,
   LC__SC_ ,
   LC__IC_ ,
   LC__FC_ ,
   LC__DC_ ,
   FC__S__ ,
   FC__I__ ,
   FC__L__ ,
   FC__F__ ,
   FC__D__ ,
   FC__SC_ ,
   FC__IC_ ,
   FC__LC_ ,
   FC__DC_ ,
   DC__S__ ,
   DC__I__ ,
   DC__L__ ,
   DC__F__ ,
   DC__D__ ,
   DC__SC_ ,
   DC__IC_ ,
   DC__LC_ ,
   DC__FC_ ,
   SR__S__ ,
   SR__I__ ,
   SR__L__ ,
   SR__F__ ,
   SR__D__ ,
   SR__SC_ ,
   SR__IC_ ,
   SR__LC_ ,
   SR__FC_ ,
   SR__DC_ ,
   IR__S__ ,
   IR__I__ ,
   IR__L__ ,
   IR__F__ ,
   IR__D__ ,
   IR__SC_ ,
   IR__IC_ ,
   IR__LC_ ,
   IR__FC_ ,
   IR__DC_ ,
   LR__S__ ,
   LR__I__ ,
   LR__L__ ,
   LR__F__ ,
   LR__D__ ,
   LR__SC_ ,
   LR__IC_ ,
   LR__LC_ ,
   LR__FC_ ,
   LR__DC_ ,
   FR__S__ ,
   FR__I__ ,
   FR__L__ ,
   FR__F__ ,
   FR__D__ ,
   FR__SC_ ,
   FR__IC_ ,
   FR__LC_ ,
   FR__FC_ ,
   FR__DC_ ,
   DR__S__ ,
   DR__I__ ,
   DR__L__ ,
   DR__F__ ,
   DR__D__ ,
   DR__SC_ ,
   DR__IC_ ,
   DR__LC_ ,
   DR__FC_ ,
   DR__DC_ ,
   SCR_S__ ,
   SCR_I__ ,
   SCR_L__ ,
   SCR_F__ ,
   SCR_D__ ,
   SCR_SC_ ,
   SCR_IC_ ,
   SCR_LC_ ,
   SCR_FC_ ,
   SCR_DC_ ,
   ICR_S__ ,
   ICR_I__ ,
   ICR_L__ ,
   ICR_F__ ,
   ICR_D__ ,
   ICR_SC_ ,
   ICR_IC_ ,
   ICR_LC_ ,
   ICR_FC_ ,
   ICR_DC_ ,
   LCR_S__ ,
   LCR_I__ ,
   LCR_L__ ,
   LCR_F__ ,
   LCR_D__ ,
   LCR_SC_ ,
   LCR_IC_ ,
   LCR_LC_ ,
   LCR_FC_ ,
   LCR_DC_ ,
   FCR_S__ ,
   FCR_I__ ,
   FCR_L__ ,
   FCR_F__ ,
   FCR_D__ ,
   FCR_SC_ ,
   FCR_IC_ ,
   FCR_LC_ ,
   FCR_FC_ ,
   FCR_DC_ ,
   DCR_S__ ,
   DCR_I__ ,
   DCR_L__ ,
   DCR_F__ ,
   DCR_D__ ,
   DCR_SC_ ,
   DCR_IC_ ,
   DCR_LC_ ,
   DCR_FC_ ,
   DCR_DC_ ,
   None = _______,
   Illegal = -1
};
#endif
static const char* cast_type_title[] = {
   "_______" ,
   "S___I__" ,
   "S___L__" ,
   "S___F__" ,
   "S___D__" ,
   "S___SC_" ,
   "S___IC_" ,
   "S___LC_" ,
   "S___FC_" ,
   "S___DC_" ,
   "S___SR_" ,
   "S___SCR" ,
   "I___S__" ,
   "I___L__" ,
   "I___F__" ,
   "I___D__" ,
   "I___SC_" ,
   "I___IC_" ,
   "I___LC_" ,
   "I___FC_" ,
   "I___DC_" ,
   "I___IR_" ,
   "I___ICR" ,
   "L___S__" ,
   "L___I__" ,
   "L___F__" ,
   "L___D__" ,
   "L___SC_" ,
   "L___IC_" ,
   "L___LC_" ,
   "L___FC_" ,
   "L___DC_" ,
   "L___LR_" ,
   "L___LCR" ,
   "F___S__" ,
   "F___I__" ,
   "F___L__" ,
   "F___D__" ,
   "F___SC_" ,
   "F___IC_" ,
   "F___LC_" ,
   "F___FC_" ,
   "F___DC_" ,
   "F___FR_" ,
   "F___FCR" ,
   "D___S__" ,
   "D___I__" ,
   "D___L__" ,
   "D___F__" ,
   "D___SC_" ,
   "D___IC_" ,
   "D___LC_" ,
   "D___FC_" ,
   "D___DC_" ,
   "D___DR_" ,
   "D___DCR" ,
   "SC__S__" ,
   "SC__I__" ,
   "SC__L__" ,
   "SC__F__" ,
   "SC__D__" ,
   "SC__IC_" ,
   "SC__LC_" ,
   "SC__FC_" ,
   "SC__DC_" ,
   "IC__S__" ,
   "IC__I__" ,
   "IC__L__" ,
   "IC__F__" ,
   "IC__D__" ,
   "IC__SC_" ,
   "IC__LC_" ,
   "IC__FC_" ,
   "IC__DC_" ,
   "LC__S__" ,
   "LC__I__" ,
   "LC__L__" ,
   "LC__F__" ,
   "LC__D__" ,
   "LC__SC_" ,
   "LC__IC_" ,
   "LC__FC_" ,
   "LC__DC_" ,
   "FC__S__" ,
   "FC__I__" ,
   "FC__L__" ,
   "FC__F__" ,
   "FC__D__" ,
   "FC__SC_" ,
   "FC__IC_" ,
   "FC__LC_" ,
   "FC__DC_" ,
   "DC__S__" ,
   "DC__I__" ,
   "DC__L__" ,
   "DC__F__" ,
   "DC__D__" ,
   "DC__SC_" ,
   "DC__IC_" ,
   "DC__LC_" ,
   "DC__FC_" ,
   "SR__S__" ,
   "SR__I__" ,
   "SR__L__" ,
   "SR__F__" ,
   "SR__D__" ,
   "SR__SC_" ,
   "SR__IC_" ,
   "SR__LC_" ,
   "SR__FC_" ,
   "SR__DC_" ,
   "IR__S__" ,
   "IR__I__" ,
   "IR__L__" ,
   "IR__F__" ,
   "IR__D__" ,
   "IR__SC_" ,
   "IR__IC_" ,
   "IR__LC_" ,
   "IR__FC_" ,
   "IR__DC_" ,
   "LR__S__" ,
   "LR__I__" ,
   "LR__L__" ,
   "LR__F__" ,
   "LR__D__" ,
   "LR__SC_" ,
   "LR__IC_" ,
   "LR__LC_" ,
   "LR__FC_" ,
   "LR__DC_" ,
   "FR__S__" ,
   "FR__I__" ,
   "FR__L__" ,
   "FR__F__" ,
   "FR__D__" ,
   "FR__SC_" ,
   "FR__IC_" ,
   "FR__LC_" ,
   "FR__FC_" ,
   "FR__DC_" ,
   "DR__S__" ,
   "DR__I__" ,
   "DR__L__" ,
   "DR__F__" ,
   "DR__D__" ,
   "DR__SC_" ,
   "DR__IC_" ,
   "DR__LC_" ,
   "DR__FC_" ,
   "DR__DC_" ,
   "SCR_S__" ,
   "SCR_I__" ,
   "SCR_L__" ,
   "SCR_F__" ,
   "SCR_D__" ,
   "SCR_SC_" ,
   "SCR_IC_" ,
   "SCR_LC_" ,
   "SCR_FC_" ,
   "SCR_DC_" ,
   "ICR_S__" ,
   "ICR_I__" ,
   "ICR_L__" ,
   "ICR_F__" ,
   "ICR_D__" ,
   "ICR_SC_" ,
   "ICR_IC_" ,
   "ICR_LC_" ,
   "ICR_FC_" ,
   "ICR_DC_" ,
   "LCR_S__" ,
   "LCR_I__" ,
   "LCR_L__" ,
   "LCR_F__" ,
   "LCR_D__" ,
   "LCR_SC_" ,
   "LCR_IC_" ,
   "LCR_LC_" ,
   "LCR_FC_" ,
   "LCR_DC_" ,
   "FCR_S__" ,
   "FCR_I__" ,
   "FCR_L__" ,
   "FCR_F__" ,
   "FCR_D__" ,
   "FCR_SC_" ,
   "FCR_IC_" ,
   "FCR_LC_" ,
   "FCR_FC_" ,
   "FCR_DC_" ,
   "DCR_S__" ,
   "DCR_I__" ,
   "DCR_L__" ,
   "DCR_F__" ,
   "DCR_D__" ,
   "DCR_SC_" ,
   "DCR_IC_" ,
   "DCR_LC_" ,
   "DCR_FC_" ,
   "DCR_DC_" 
};
// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "Rules.h"
#include "FSyntax.h"
#include "Maker.h"

int TTokenTable::Add(const char* name, int index)
{
   int ret = TNameTable::Add(name);

   names_index.push_back(index);

   return ret;
}

int TTokenTable::Token(const char* name) const
{
   int ret = Find(name);

   if (ret < 0) return ret;

   return names_index[ret];
}

// --------------------------- FSyntax ---------------------------

bool FSyntax::Translate()
{
   if (MatchSpot(T_Symbol::lxModBegin) || MatchSpot(T_Symbol::lxModToken) || MatchSpot(T_Symbol::lxModMod)) {
      if (Match(T_Symbol::lxModBegin))
         if (!Enums()) return false;

      if (Match(T_Symbol::lxModToken))
         if (!Tokens()) return false;

      if (!Match(T_Symbol::lxModMod)) return false;
   }

	bool ret = Formulas();

   if (ret) {
      data->formulas->make(*data->names);
   }

   return ret;
}

bool FSyntax::Enums()
{  
   T_Lexeme l;

   while (Match(l,T_Lexeme::rwEnum)) {
      TTokenTable Enum;

      if (Match(l,T_Lexeme::grReserv,T_Lexeme::rwClass)) {
         T_Lexeme enum_name;
         if (!Match(enum_name,T_Lexeme::grIdent)) return false;
         Enum.Enum_name = Text(enum_name);
      } else if (Match(l,T_Lexeme::grIdent)) {
         Enum.Enum_name = Text(l);
      }

      if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxLeftCramp)) return false;

      T_Lexeme enum_element;

      for (int i = 0; Match(enum_element,T_Lexeme::grIdent); i++) {
         if (Enum.Token(Text(enum_element)) >= 0) return false;
         if (Match(l,T_Lexeme::grOper,T_Symbol::lxAssign)) {
            if (!Match(l,T_Lexeme::grInteger)) return false;
            i = Integer(l);
         }

         Enum.Add(Text(enum_element),i);

         if (Match(l,T_Lexeme::grSeparator,T_Symbol::lxRightCramp)) break;
         if (!Match(T_Symbol::lxComma)) return false;
      }

      if (!Match(T_Symbol::lxSemicolon)) return false;
      enums.push_back(Enum);
   }

   if (!Match(T_Symbol::lxModEnd)) return false;

	return true;
}

bool FSyntax::Tokens()
{
	T_Lexeme l;

   do {
      T_Lexeme name;

		if (!Match(name,T_Lexeme::grIdent)) return false;
		if (!Match(l,T_Lexeme::grInteger)) return false;

		if (lexemes.Token(Text(name)) < 0) {
			lexemes.Add(Text(name), Integer(l));
		} else return false;
   } while (Match(T_Symbol::lxModToken));

	return true;
}

bool FSyntax::Formulas()
{
   while (!Match(T_Lexeme::grEof)) {
      if (!Formula()) return false;
   }

   return true;
}

bool FSyntax::Formula()
{
	T_Lexeme l;

	if (!Match(l,T_Lexeme::grIdent)) return false;
	if (!Match(T_Symbol::lxColon)) return false;

	GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula,data->names->Add(Text(l)))); 
	formula->title = Scan().Text(l); 
   int index;
   if (!data->formulas->Add(formula, index)) {
      delete formula;
      return false;
   }

	do {
		if (!Produce()) return false;
	} while (Match(T_Symbol::lxOr)); 

	if (!Match(T_Symbol::lxSemicolon)) return false;

	return true;
}

bool FSyntax::Produce()
{
	GFormula* formula = data->formulas->back();
	GProduce produce(GSymbol(GSymbol::gsProduce,formula->head.formula,formula->count())); 
	formula->Add(produce); 
	GProduce* rule = &formula->back();
   
	T_Lexeme l;

   while (Match(l,T_Lexeme::grIdent) || Match(l,T_Lexeme::grOper,T_Symbol::lxLT) || Match(l,T_Lexeme::grSeparator,T_Symbol::lxLeftCramp) || Match(l,T_Lexeme::grInteger))
   {
      if (l.Match(T_Lexeme::grIdent)) {
         if (Scan().Compare(l, "Empty")) {
            GSymbol item(GSymbol::gsEmpty); 
			   rule->Add(item);
         } else {
            int token = lexemes.Token(Text(l));
            if (token < 0) {
			      GSymbol item(GSymbol::gsFormula,data->names->Add(Text(l))); 
			      rule->Add(item);
		      } else {
			      GSymbol item(GSymbol::gsTerminal,(token & 0x00FF00) >> 8,(token & 0x00FF));
			      rule->Add(item);
		      }
         }
      } else if (l.Match(T_Symbol::lxLT)) {
         int group;
         if (Match(l,T_Lexeme::grIdent)) group = title_group(Text(l));
         else if (Match(l,T_Lexeme::grInteger)) group = Integer(l);
         else return false;
         if (Match(T_Symbol::lxComma)) {
            T_Lexeme type;
            if (Match(type,T_Lexeme::grIdent)) {
               if (group == T_Lexeme::grReserv) {
                  GSymbol item(GSymbol::gsTerminal,group,title_word(Text(type)));
                  rule->Add(item);
               } else if (group == T_Lexeme::grError) {
                  GSymbol item(GSymbol::gsTerminal,group,title_error(Text(type)));
                  rule->Add(item);
               } else if (group == T_Lexeme::grPriority) {
                  GSymbol item(GSymbol::gsTerminal,group,title_priority(Text(type)));
                  rule->Add(item);
               } else if (group == T_Lexeme::grSyntax) {
                  GSymbol item(GSymbol::gsTerminal,group,title_syntax(Text(type)));
                  rule->Add(item);
               } else {
                  GSymbol item(GSymbol::gsTerminal,group,title_type(Text(type)));
			         rule->Add(item);
               }
            } else if (Match(type,T_Lexeme::grInteger)) {
               GSymbol item(GSymbol::gsTerminal,group, Integer(type));
               rule->Add(item);
            } else return false;
         } else {
            GSymbol item(GSymbol::gsTerminal,group); 
			   rule->Add(item);
         }
         if (!Match(T_Symbol::lxGT)) return false;
      } else if (l.Match(T_Symbol::lxLeftCramp)) {
         T_Lexeme maker;
         if (Match(maker,T_Lexeme::grReserv,T_Lexeme::rwNODE)) {
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxLeftBracket)) return false;
            if (!Match(l,T_Lexeme::grIdent)) return false;
            int index = title_snode_maker(Text(l));
            if (!Match(T_Symbol::lxComma)) return false;
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxLeftBracket)) return false;
            int i = 0;
            int a[5] = {0};
            do {
               T_Lexeme param;
               if (Match(param,T_Lexeme::grInteger)) a[i] = Integer(param);
               else if (!param_to_int(&a[i])) return false;
               i++;
            } while (Match(T_Symbol::lxComma) && i != 5);
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxRightBracket)) return false;
            int param_number = 0;
            if (Match(T_Symbol::lxComma)) {
               T_Lexeme param;
               if (Match(param,T_Lexeme::grInteger)) param_number = Integer(param);
               else if (!param_to_int(&param_number)) return false;
            }
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxRightBracket)) return false;
            GSymbol maker(GSymbol::gsMaker,index,param_number,syn_tree(a[0], a[1], a[2], a[3], a[4]),GSymbol::SNode);
            rule->Add(maker);
         } else if (Match(maker,T_Lexeme::grReserv,T_Lexeme::rwTURN)) {
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxLeftBracket)) return false;
            if (!Match(l,T_Lexeme::grIdent)) return false;
            int indexTT = title_tnode_maker(Text(l));
            if (!Match(T_Symbol::lxComma)) return false;
            if (!Match(l,T_Lexeme::grIdent)) return false;
            int indexST = title_snode_maker(Text(l));
            int param_number = 0;
            if (Match(T_Symbol::lxComma)) {
               T_Lexeme param;
               if (Match(param,T_Lexeme::grInteger)) param_number = Integer(param);
               else if (Match(T_Symbol::lxSub))
                  if (Match(param,T_Lexeme::grInteger)) param_number = (-1) * Integer(param);
                  else return false;
               else if (!param_to_int(&param_number)) return false;
            }
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxRightBracket)) return false;
            GSymbol maker(GSymbol::gsMaker,indexTT,param_number,indexST,GSymbol::Turn);
            rule->Add(maker);
         } else {
            int mode = 0;
            if (Match(T_Lexeme::rwMAKE)) mode = GSymbol::Tree | GSymbol::Code;
            else if (Match(T_Lexeme::rwCODE)) mode = GSymbol::Code;
            else if (Match(T_Lexeme::rwTREE)) mode = GSymbol::Tree;
            else if (Match(T_Lexeme::rwYACC)) mode = GSymbol::Yacc;
            else if (Match(T_Lexeme::rwALL)) mode = GSymbol::Yacc | GSymbol::Code | GSymbol::Tree;
            else return false;
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxLeftBracket)) return false;
            if (!Match(l,T_Lexeme::grIdent)) return false; 
            int index = GMakerTable::maker_table.Find(Text(l));
            int param_number = 0;
            if (Match(T_Symbol::lxComma)) {
               T_Lexeme param;
               if (Match(param,T_Lexeme::grInteger)) param_number = Integer(param);
               else if (!param_to_int(&param_number)) return false;
            }
            if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxRightBracket)) return false;
            GSymbol maker(GSymbol::gsMaker,index,param_number,0,mode);
            rule->Add(maker);
         }
         if (!Match(T_Symbol::lxSemicolon)) return false;
         if (!Match(l,T_Lexeme::grSeparator,T_Symbol::lxRightCramp)) return false;
      } else if (l.Match(T_Lexeme::grInteger)) {
         T_Lexeme lex;
         const T_SymbolTable& test = symbol_table();
         if (!test.Find(Integer(l),lex)) return false;
         GSymbol item(GSymbol::gsTerminal,lex.group,lex.type); 
			rule->Add(item);
      }
   }

	return true;
}

bool FSyntax::skip_error(bool check_ident, int n, T_Symbol::T_Type type, ...)
{
   T_Symbol::T_Type *p = &type;

   while (!Match(T_Lexeme::grEof)) {
      bool temp = false;
      int count = n;

      T_Symbol::T_Type *p_temp = p;

      while (count--) {
         temp = MatchSpot(*p_temp);
         if (temp) return true;
         p_temp++;
      }

      if (check_ident) {
         T_Lexeme l;

         temp = MatchSpot(l, T_Lexeme::grIdent);
         if (temp) return true;
      }

      if (!temp) Next();
   }

   return false;
}

bool FSyntax::param_to_int(int* param_int) 
{
   T_Lexeme param;

   if (!Match(param,T_Lexeme::grIdent)) return false;

   if (Match(T_Symbol::lxColonColon)) {
      T_Lexeme enum_param;
      if (!Match(enum_param,T_Lexeme::grIdent)) return false;
      for (int j = 0; j < (int)enums.size(); j++) {
         if (enums[j].Enum_name && Scan().Compare(param, enums[j].Enum_name)) {
            int check_param = enums[j].Token(Text(enum_param));
            if (check_param >= 0) {
               *param_int = check_param;
               return true;
            }
         }
      }
   } else {
      for (int j = 0; j < (int)enums.size(); j++) {
         int check_param = enums[j].Token(Text(param));
         if (enums[j].Enum_name == NULL && check_param >= 0) {
            *param_int = check_param;
            return true;
         }
      }
   }

   return false;
}

// --------------------------- GrammarSyntax ---------------------------
#include "Grammar.h"

T_Lexeme::T_Group GrammarSyntax::Lexeme(T_Lexeme &l)
{
   A_Syntax::Lexeme(l);
   return l.group;
}

bool GrammarSyntax::Grammar()
{
   if (!Tree()) return false;

   int index = 0;

   SNode* list = Tree()->Get(index);

   if (!list) return false;

   data->formulas->clear();

   if (Enums(list)) {
      index++;
      list = tree->Get(index);
   }
   if (Tokens(list)) {
      index++;
      list = tree->Get(index);
   }
   if (!Formulas(list)) return false;

   return data->formulas->make(*data->names);

}

bool GrammarSyntax::Enums(SNode* list) {
   if (list->type != SNode::stEnums) return false;

   for (int i = 0; i < list->Count(); i++) {
      SNode* enum_node = list->Get(i);
      TTokenTable Enum;
      int index = 0;
      Enum.Enum_name = Text(enum_node->Lexeme());

      for (int j = 0; j < enum_node->Count(); j++, index++) {
         SNode* enum_item = enum_node->Get(j);
         T_Lexeme ident = enum_item->Lexeme();
         if (enum_item->Count()) {
            T_Lexeme integer = enum_item->Get(0)->Lexeme();
            index = integer.value;
         }
         Enum.Add(Text(ident), index);
      }
      enums.push_back(Enum);
   }

   return true;
}

bool GrammarSyntax::Tokens(SNode* list) {
   if (list->type != SNode::stTokens) return false;

   for (int i = 0; i < list->Count(); i++) {
      SNode* token_node = list->Get(i);
      T_Lexeme name = token_node->Lexeme();
      T_Lexeme integer = token_node->Get(0)->Lexeme();
      if (MyTable::lexemes.Token(Text(name)) < 0) {
         MyTable::lexemes.Add(Text(name), integer.value);
      }
   }

   return true;
}

bool GrammarSyntax::Formulas(SNode* list) {
   if (list->type != SNode::stFormula) return false;

   for (int i = 0; i < list->Count(); i++) {
      if (!Formula(list->Get(i))) return false;
   }

   return true;
}

bool GrammarSyntax::Formula(SNode* list) {
   T_Lexeme name = list->Lexeme();

   GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula, data->names->Add(Text(name))));
   formula->title = Scan().Text(name);
   int index;
   bool add = data->formulas->Add(formula, index);
   if (!add) {
      delete formula;
   }
   GFormula* formula_new_old = (*data->formulas)[index];
   for (int i = 0; i < list->Count(); i++) {
      if (!Produce(formula_new_old, list->Get(i))) return false;
   }

   return true;
}

bool GrammarSyntax::Produce(GFormula* formula, SNode* list) {
   GProduce produce(GSymbol(GSymbol::gsProduce, formula->head.formula, formula->count()));
   formula->Add(produce);
   GProduce* rule = &formula->back();

   for (int i = 0; i < list->Count(); i++) {
      SNode* produce_node = list->Get(i);

      if (produce_node->type == SNode::stItem) {
         T_Lexeme ident = produce_node->Lexeme();
         if (produce_node->option == 0) { // Item(Ident)
            const char* text_ident = Text(ident);
            if (Scan().Compare(ident, "Empty")) {
               rule->Add(GSymbol::empty);
            } else if (ident.group == T_Lexeme::grIdent) {
               int token = MyTable::lexemes.Token(text_ident);

               if (token < 0) {
                  if (data->tokens) {
                     int index = data->tokens->Find(text_ident);
                     if (index >= 0) {
                        token = data->tokens->Token(index);
                     }
                  }
               }
               if (token < 0) {
                  GSymbol item(GSymbol::gsFormula, data->names->Add(text_ident));
                  rule->Add(item);
               } else {
                  GSymbol item(GSymbol::gsTerminal, (token & 0x00FF00) >> 8, (token & 0x00FF));
                  rule->Add(item);
               }
            } else {
               rule->Add(ident);
            }
         } else if (produce_node->option == 1) { // Item(Integer)
            T_Lexeme lex;
            const T_SymbolTable& test = symbol_table();
            if (!test.Find(ident.value, lex)) return false;

            GSymbol item(GSymbol::gsTerminal, lex.group, lex.type);
            rule->Add(item);
         } else if (produce_node->option == 2) { // Item(<Group>)
            int group = T_Lexeme::grNone;

            if (ident.group == T_Lexeme::grIdent) group = title_group(Text(ident));
            else if (ident.group == T_Lexeme::grInteger) group = Integer(ident);

            GSymbol item(GSymbol::gsTerminal, group);
            rule->Add(item);
         } else if (produce_node->option == 3) { // Item(<Group,Type>)

            T_Lexeme type = produce_node->Get(0)->Lexeme();

            if (ident.group == T_Lexeme::grIdent) {
               int group = title_group(Text(ident));
               const char* text_type = Text(type);
               GSymbol item(GSymbol::gsTerminal, group);
               if (group == T_Lexeme::grReserv) {
                  item.lexeme_type = title_word(text_type);
               } else if (group == T_Lexeme::grError) {
                  item.lexeme_type = title_error(text_type);
               } else if (group == T_Lexeme::grPriority) {
                  item.lexeme_type = title_priority(text_type);
               } else if (group == T_Lexeme::grSyntax) {
                  item.lexeme_type = title_syntax(text_type);
               } else {
                  item.lexeme_type = title_type(text_type);
               }
               rule->Add(item);
            } else if (ident.group == T_Lexeme::grInteger) {
               int group = Integer(ident);
               GSymbol item(GSymbol::gsTerminal, group, Integer(type));
               rule->Add(item);
            }
         }
      } else if (produce_node->type == SNode::stMaker) {
         if (produce_node->option == 0) {
            T_Lexeme ident = produce_node->Get(0)->Lexeme();

            int index = GMakerTable::maker_table.Find(Text(ident));
            int param_number = 0;

            if (!check_param(produce_node, &param_number)) return false;

            int mode = 0;
            T_Lexeme maker_ident = produce_node->Lexeme();

            if (maker_ident.type == T_Lexeme::rwMAKE) mode = GSymbol::Tree | GSymbol::Code;
            else if (maker_ident.type == T_Lexeme::rwCODE) mode = GSymbol::Code;
            else if (maker_ident.type == T_Lexeme::rwTREE) mode = GSymbol::Tree;
            else if (maker_ident.type == T_Lexeme::rwYACC) mode = GSymbol::Yacc;
            else if (maker_ident.type == T_Lexeme::rwALL) mode = GSymbol::Yacc | GSymbol::Code | GSymbol::Tree;

            GSymbol maker(GSymbol::gsMaker, index, param_number, 0, mode);
            rule->Add(maker);
         } else if (produce_node->option == 1) {
            T_Lexeme ident = produce_node->Lexeme();

            int index = title_snode_maker(Text(ident));
            int i = 0;
            int a[5] = { 0 };
            SNode* int_node = produce_node->Get(0);

            for (int i = 0; i < int_node->Count(); i++) {
               T_Lexeme param = int_node->Get(i)->Lexeme();
               if (param.group == T_Lexeme::grInteger) {
                  a[i] = Integer(param);
               } else if (!param_to_int(param, int_node->Get(i), &a[i])) {
                  return false;
               }
            }

            int param_number = 0;
            if (!check_param(produce_node, &param_number)) return false;

            GSymbol maker(GSymbol::gsMaker, index, param_number, syn_tree(a[0], a[1], a[2], a[3], a[4]), GSymbol::SNode);
            rule->Add(maker);
         } else if (produce_node->option == 5) {
            int indexTT = title_tnode_maker(Text(produce_node->Lexeme()));
            int indexST = title_snode_maker(Text(produce_node->Get(0)->Lexeme()));

            int param_number = 0;
            if (!check_param(produce_node, &param_number)) return false;

            GSymbol maker(GSymbol::gsMaker, indexTT, param_number, indexST, GSymbol::Turn);
            rule->Add(maker);
         }
      }
   }

   return true;
}

bool GrammarSyntax::check_param(SNode* produce_node, int* param_number)
{
   if (produce_node->Count() != 2) return true;

   SNode* param_node = produce_node->Get(1);
   T_Lexeme param = produce_node->Get(1)->Lexeme();

   if (param_node->option == 3) {
      if (param.group == T_Lexeme::grInteger) {
         *param_number = Integer(param);
      } else {
         return param_to_int(param, param_node, param_number);
      }
   } else if (param_node->option == 4) {
      *param_number = (-1) * Integer(param);
   }

   return true;
}

bool GrammarSyntax::param_to_int(T_Lexeme param, SNode* param_node, int* param_int)
{
   if (param_node->Count() == 1) {
      T_Lexeme enum_param = param_node->Get(0)->Lexeme();

      for (int i = 0; i < (int)enums.size(); i++) {
         if (enums[i].Enum_name && Scan().Compare(param, enums[i].Enum_name)) {
            int check_param = enums[i].Token(Text(enum_param));

            if (check_param >= 0) {
               *param_int = check_param;
               return true;
            }
         }
      }
   } else {
      for (int i = 0; i < (int)enums.size(); i++) {
         int check_param = enums[i].Token(Text(param));
         if (enums[i].Enum_name == NULL && check_param >= 0) {
            *param_int = check_param;
            return true;
         }
      }
   }

   return false;
}

enum T_BNF { S_, bnf, rules, rule, symbol_list };

void GrammarSyntax::LexemeToSymbol(T_Lexeme& lexeme, GSymbol& current_sym)
{
   current_sym = GSymbol(lexeme);
   if (state == T_State::tsYACCHead) {
      if (lexeme.Match(A_Symbol::lxModMod)) {
         state = T_State::tsBNFProduce;
      }
   } else if (state == T_State::tsBNFProduce) {
      if (lexeme.Match(A_Symbol::lxLeftCramp)) {
         state = T_State::tsMaker;
      } else if (!lexeme.Match(A_Symbol::lxOr) && !lexeme.Match(A_Symbol::lxBNFSet) && !lexeme.Match(T_Lexeme::grInteger)) {
         current_sym.group = T_Lexeme::grSpace; current_sym.lexeme_type = 0;
      }
   } else if (state == T_State::tsMaker) {
      if (lexeme.Match(A_Symbol::lxRightCramp)) {
         state = T_State::tsBNFProduce;
      }
   }
}

SNode* GrammarSyntax::BNF(T_SyntaxNode* unit)
{
   TProduceNode* produce = (TProduceNode*)unit;
   SNode* node = NULL;
   switch (unit->symbol.formula) {
      case T_BNF::S_ : 
      case T_BNF::bnf : {
         SNodeList* formulas = NULL;
         if (produce->size() == 1) {
            formulas = new SNodeList(SNode::stFormula);
            formulas->option = 5;
         } else {
            formulas = (SNodeList*)BNF(produce->front());
         }
         SNode* formula = BNF(produce->back());
         formulas->Add(formula);
         node = formulas;
         } break;
      case T_BNF::rules : {
         if (produce->size() == 1) {
            return BNF(produce->front());
         }
         SNodeList* formula = (SNodeList*)BNF(produce->Get(0));
         if (produce->size() > 2) {
            SNode* rule = BNF(produce->Get(2));
            formula->Add(rule);
         }
         node = formula;
         } break;
      case T_BNF::rule : {
         SNodeList* formula = new SNodeList(SNode::stFormula);
         formula->option = 2;
         TLexemeNode* lexeme = (TLexemeNode*)produce->Get(0);
         formula->SetLexeme(lexeme->lexeme);
         SNode* rule = BNF(produce->Get(2));
         formula->Add(rule);
         node = formula;
         } break;
      case T_BNF::symbol_list : {
         SNodeList* list = NULL;
         if (produce->front()->symbol.IsTerminal()) {
            list = new SNodeList(SNode::stProduce);
            list->option = 5;
         } else {
            list = (SNodeList*)BNF(produce->front());
         }
         TLexemeNode* lexeme = (TLexemeNode*)produce->back();
         SNode* item = new SNodeList(lexeme->lexeme, SNode::stItem);
         if (lexeme->lexeme.group == T_Lexeme::grIdent) {
            item->option = 0;
         } else if (lexeme->lexeme.group == T_Lexeme::grInteger) {
            item->option = 1;
         }
         list->Add(item);
         node = list;
         } break;
      default :
         break;
   }
   return node;
}

bool MyYSyntax::Translate()
{
   bool ret = false;
   if (!Match(T_Lexeme::grEof)) {
      syntax_lexeme = T_SyntaxLexeme::slNone;
      ret = ParseYACC();
   } else {
      ret = true;
   }

   return ret;
}

int yy_nl_parse(void *YYPARSE_PARAM);

bool MyYSyntax::ParseYACC()
{
   int ret = 1;

   ret = yy_nl_parse(this);

   return !ret;
}

int yylex(void *yylval, void *param)
{
   MyYSyntax* syntax = (MyYSyntax*)param;
   T_Lexeme current_lexeme;
   syntax->Lexeme(current_lexeme);

   bool print_lexeme = (syntax->option & (T_OptionMode::omPrintOther | T_OptionMode::omPrintSpace | T_OptionMode::omPrintLine | T_OptionMode::omPrintLexeme)) != 0;
   if (print_lexeme) { printf(">>  "); current_lexeme.print(&syntax->Scan()); }

   (*(T_Lexeme_SNode*)yylval).lexeme = current_lexeme;
   int token = !current_lexeme.Match(T_Lexeme::grEof) ? ((current_lexeme.group << 8) | current_lexeme.type) : 0;
   return token;
}

#include "GrammarStock.h"

#pragma optimize("", off)
namespace TableGrammar {
#include "TableGrammar.cpp"
}

namespace BNFGrammar {
#include "BSyntax.cpp"
}

#include "C99_Lexer.h"

#pragma optimize("", on)

bool grammar_reception(TGrammar& table, int type, int option, const char *file, const char *table_file, const T_WordTable* word_table)
{
   M_Syntax::M_Mode make_mode = M_Syntax::M_Mode((type & 0x0F0) >> 4);
   A_Syntax::T_SyntaxMode syntax_mode = A_Syntax::T_SyntaxMode(type & 0x00F);
   int def_rule_mode = ((type & 0xF00) >> 8); // 0 - LL, 1 - NL, 2 - LR, 3 - NR
   int scan_type = (type & 0xF000) >> 12;
   int look_ahead = (type & 0x000F0000) >> 16;

   table.option = option; table.look_ahead = look_ahead; table.file = file;
   table.makers = &GMakerTable::maker_table;

   if (def_rule_mode == 0x0F) { // read(*.tab)
      if (!table.read(table_file, 0x00)) return false;
      table.print(NULL, 0x00);
      table.root = table.formulas.front();
      if (table.option & TGrammar::POption::opMaker) {
         table.makers_used();
      }
   } else if ((def_rule_mode == 0x0E) || (def_rule_mode == 0x0D) || (def_rule_mode == 0x0C) || (def_rule_mode == 0x0B)) { // parse(*.grammar)
      T_SourceFile source;

      TGrammar    my_table;
      TIfdefScan  scan(&source);
      T_FlexLexer lexer(&source);
      FSyntax     f_parse(&scan);
      MyYSyntax   y_parse(&scan);
      GrammarSyntax    parse_G(&scan, &my_table);
      A_Syntax*   parse = NULL;

      if (def_rule_mode == 0x0E) {
         parse = &f_parse;
         parse->Mask(A_Symbol::mmGrammar);
         parse->option = 0x0000;
      } else if (def_rule_mode == 0x0C) { // YACC
         parse = &y_parse;
         parse->Mask(A_Symbol::mmGrammar);
         parse->option = 0x0000;
      } else if (def_rule_mode == 0x0D) {
         parse = &parse_G;
         TableGrammar::make_grammar(my_table);
         parse->syntax_mode = A_Syntax::smParseLR0;
         parse->syntax_lexeme = T_SyntaxLexeme::slNone;
         parse_G.set_make_mode(M_Syntax::M_Mode::mmNode);
         parse->Mask(A_Symbol::mmGrammar);
         parse->option = 0x0000;
//         parse->option = 0x0708;
//         parse->option |= T_OptionMode::omPrintSNode;
//         parse->option |= T_OptionMode::omPrintSource;
      } else { // 0x0B - BNF
         parse = &parse_G;
         BNFGrammar::make_grammar(my_table);
         parse->syntax_mode = A_Syntax::smParseLR0;
         parse->syntax_lexeme = T_SyntaxLexeme::slNone;
         parse_G.set_make_mode(M_Syntax::M_Mode::mmNode);
         parse_G.look_ahead = my_table.look_ahead ;
         parse_G.state = parse_G.T_State::tsBNFProduce;
         parse->Mask(A_Symbol::M_Mask(A_Symbol::mmGrammar | A_Symbol::mmBNF));
         parse->option = 0x0000;
         //         parse->option = T_OptionMode::omAutoTree;
//         parse->option |= 0x0708;
//         parse->option |= T_OptionMode::omPrintSNode;
      }

      TRuleNames names;
      TData      data(((def_rule_mode == 0x0E) || (def_rule_mode == 0x0C)) ? &table : &my_table, parse, NULL); data.names = &names;

      parse->line_is_space = true;
      if (!parse->Source(source, table_file, word_table)) return false;
      if (scan_type) {
         if (!lexer.Open()) return false;
         parse->Scan(&lexer);
      } else {
         if (table.option & TGrammar::POption::opAssociation) {
            scan.AddDef("PRIOR_ASSOCIATION");
         }
         if (!(table.option & TGrammar::POption::opNoPriorAssign)) {
            scan.AddDef("PRIOR_ASSIGNN");
         }
         parse->Mask((A_Symbol::M_Mask)(parse->Mask() | A_Symbol::mmIfdef));
      }

      TTokenNames tokens; data.tokens = &tokens;
      parse->MakeTokens(tokens, (def_rule_mode == 0x0B) ? T_PrintMode::pmBNF : T_PrintMode::pmNone);

      bool ret = parse->Translate();
      if (table.names) {
         *table.names = parse->Scan().names;
      }

      if (def_rule_mode == 0x0B) { // BNF
         TSyntaxTree* unit = parse->Auto();
         if (unit && unit->root) {
            char *file_unit = get_file_name(file, "auto");
            unit->print(file_unit, 0x00);
            free(file_unit);
            SNode* node = parse_G.BNF(unit->root);
            if (node) {
               parse_G.Tree(node);
            }
         } else if (parse_G.Tree()) {
            SNodeList* formula = new SNodeList(SNode::stFormula);
            formula->Add(parse_G.Tree());
            parse_G.Tree(formula);
         }
      }

      if (ret) {
         if ((def_rule_mode == 0x0D) || (def_rule_mode == 0x0B)) {
            if (parse_G.option & T_OptionMode::omPrintSNode) {
               parse_G.Tree()->print(0x00);
            }
            data.grammar = &table;
            data.formulas = &table.formulas;
            if (!parse_G.Grammar()) {
               ret = false;
            }
         }
//         data.grammar->print(NULL, 0x010804 | T_PrintMode::pmBNF);
      }

      parse->Scan().names.Zero();
      if (ret) {
         printf("\ntrue\n");
      } else {
         printf("\nfalse\n");
         parse->forward.print(&scan);
         return false;
      }

      table.make_produces();
      table.root = table.formulas.front();
      if (table.option & TGrammar::POption::opMaker) {
         table.makers_used();
      }

   } else {
      // LRTable != GOTO  <- ((table.option & TGrammar::POption::opAssociation) != 0);

      bool ret = build_grammar(table, def_rule_mode, make_mode, 0x01);
      if (!ret) return false;
   }
   return true;
}

#ifndef TRN_FSYNTAX_H
#define TRN_FSYNTAX_H

#include "Parse.h"
#include "ASyntax.h"
#include "RSyntax.h"
#include "GSyntax.h"

// --------------------------- FSyntax ---------------------------

class TTokenTable : public TNameTable {
public:
   TTokenTable() :Enum_name(NULL) {}
public:
   const char* Enum_name;

   int Add(const char* name, int index);
   int Token(const char* name) const;

public:
   std::vector<int> names_index;
};

class MyTable {
public:
	TTokenTable lexemes;
   //TTokenTable enums;
   //TTokenTable names;

public:
   std::vector<TTokenTable> enums;
};

class FSyntax : public A_Syntax, public MyTable {
public:
	FSyntax(T_Scan *s) : A_Syntax(s) {}

	bool error(T_Error code, int value = 0) { return error(code,lex,value); }
	bool error(T_Error code, const T_Lexeme &l, int value) {  return Error.error(code,l,value); }
   
   bool Enums();
	bool Tokens();
   bool Formulas();
   bool Formula();
   bool Produce();
	
   bool param_to_int(int*);
   bool skip_error(bool check_ident, int n, T_Symbol::T_Type, ...);

	virtual bool Translate();
};

class MyYSyntax : public A_Syntax, public MyTable {
public:  
   MyYSyntax(T_Scan *s) : A_Syntax(s) {}
   
   bool MakerYACC(const GSymbol& sym, T_Lexeme_SNode* S0, T_Lexeme_SNode* S1, int maker_index = -1);

   virtual bool ParseYACC();

   virtual bool Translate();
};

//enum T_TypeIdent { tiNone, tiToken, tiMake, tiNode, tiCode, tiTree, tiYacc, tiAll, tiTurn, tiClass };

// --------------------------- GrammarSyntax ---------------------------

class GrammarSyntax : public GSyntax, public MyTable
{
public:
   GrammarSyntax(T_Scan *s, TGrammar* g) :GSyntax(s, g), state(T_State::tsNone) {}
   virtual T_Lexeme::T_Group Lexeme(T_Lexeme &l);

   bool Grammar();
   bool Enums(SNode* list);
   bool Tokens(SNode* list);
   bool Formulas(SNode* list);
   bool Formula(SNode* list);
   bool Produce(GFormula* formula, SNode* list);
   bool check_param(SNode* produce_node, int* param_number);
   bool param_to_int(T_Lexeme param, SNode* param_node, int* param_int);
public:
   SNode* BNF(T_SyntaxNode* unit);
   virtual void LexemeToSymbol(T_Lexeme& lexeme, GSymbol& sym);
public:
   enum T_State { tsNone, tsYACCHead, tsBNFProduce, tsMaker, tsSQLProduce };
public:
   T_State state;
};

#endif



#include "stdafx.h"

#include "YSyntax.h"
#include "FSyntax.h"
#include "Maker.h"

// --------------------------- ParseYACC ---------------------------
#define yy_nl_lex yylex
#define yy_nl_error yyerror

int yylex (void *yylval, void *param);
void yyerror(const char* mess);

#define MAKER_Enum_Create(S1) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   TTokenTable Enum; \
   if (S1.lexeme.Match(T_Lexeme::grIdent)) Enum.Enum_name = syntax->Text(S1.lexeme); \
   syntax->enums.push_back(Enum);

#define MAKER_Enum_FirstItem(S1, S2) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   TTokenTable* Enum = &syntax->enums[syntax->enums.size()-1]; \
   if (Enum->Token(syntax->Text(S1.lexeme)) < 0 && syntax->Integer(S2.lexeme) >= 0) Enum->Add(syntax->Text(S1.lexeme),syntax->Integer(S2.lexeme)); \
   // else return false;

#define MAKER_Enum_Item(S1) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   TTokenTable* Enum = &syntax->enums[syntax->enums.size()-1]; \
   if (Enum->Token(syntax->Text(S1.lexeme)) < 0) { \
      if (!Enum->Count()) { \
         Enum->Add(syntax->Text(S1.lexeme),0); \
      } else { \
         Enum->Add(syntax->Text(S1.lexeme),Enum->names_index[Enum->names_index.size() - 1] + 1); \
      } /* else return false; */ \
   } // else return false;

#define MAKER_Enum_1(S1, S2) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   if (S1.lexeme.Match(T_Lexeme::grInteger)) S2.lexeme = S1.lexeme; \
   else if (S1.lexeme.Match(T_Lexeme::grIdent)) { \
      for (int j = 0; j < (int)syntax->enums.size(); j++) { \
         int check_param = syntax->enums[j].Token(syntax->Text(S1.lexeme)); \
         if (syntax->enums[j].Enum_name == NULL && check_param >= 0) { \
            S2.lexeme.group = T_Lexeme::grInteger; \
            S2.lexeme.value = syntax->Integer(check_param); \
         } \
      } \
   } // else return false;

#define MAKER_Enum_2(S1, S2, S3) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   for (int j = 0; j < (int)syntax->enums.size(); j++) { \
      if (syntax->enums[j].Enum_name && syntax->Scan().Compare(S1.lexeme, syntax->enums[j].Enum_name)) { \
         int check_param = syntax->enums[j].Token(syntax->Text(S2.lexeme)); \
         if (check_param >= 0) { \
            S3.lexeme.group = T_Lexeme::grInteger; \
            S3.lexeme.value = syntax->Integer(check_param); \
         } \
      } \
   }

#define MAKER_Enum_3(S1, S2) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   if (S1.lexeme.Match(T_Lexeme::grInteger)) { \
      S2.lexeme = S1.lexeme; \
      S2.lexeme.value = syntax->Integer((-1) * syntax->Integer(S1.lexeme)); \
   } // else return false;

#define MAKER_Tokens(S3, S4) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   if (syntax->lexemes.Token(syntax->Text(S3.lexeme)) < 0) { \
		syntax->lexemes.Add(syntax->Text(S3.lexeme), syntax->Integer(S4.lexeme)); \
	} \

#define MAKER_Formulas \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   syntax->data->formulas->make(*syntax->data->names);

#define MAKER_Formula(S1) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula,syntax->data->names->Add(syntax->Text(S1.lexeme)))); \
	formula->title = syntax->Scan().Text(S1.lexeme); \
   syntax->data->formulas->Add(formula); 

#define MAKER_Produce \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = syntax->data->formulas->back(); \
	GProduce produce(GSymbol(GSymbol::gsProduce,formula->head.formula,formula->count())); \
   formula->Add(produce);

#define MAKER_Ident(S1) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
	GFormula* formula = syntax->data->formulas->back(); \
	GProduce* rule = &formula->back(); \
   if (S1.lexeme.Match(T_Lexeme::grIdent)) { \
      if (syntax->Scan().Compare(S1.lexeme, "Empty")) { \
         GSymbol item(GSymbol::gsEmpty); \
			rule->Add(item); \
      } else { \
         int token = syntax->lexemes.Token(syntax->Text(S1.lexeme)); \
	      if (token < 0) { \
		      GSymbol item(GSymbol::gsFormula,syntax->data->names->Add(syntax->Text(S1.lexeme))); \
		      rule->Add(item); \
	      } else { \
		      GSymbol item(GSymbol::gsTerminal,(token & 0x00FF00) >> 8,(token & 0x00FF)); \
		      rule->Add(item); \
	      } \
      } \
   }

#define MAKER_Lexeme1(S1) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = syntax->data->formulas->back(); \
	GProduce* rule = &formula->back(); \
   int group; \
   if (S1.lexeme.Match(T_Lexeme::grIdent)) group = title_group(syntax->Text(S1.lexeme)); \
   else if (S1.lexeme.Match(T_Lexeme::grInteger)) group = syntax->Integer(S1.lexeme); \
   GSymbol item(GSymbol::gsTerminal,group); \
   rule->Add(item);

#define MAKER_Lexeme2(S1, S2) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = syntax->data->formulas->back(); \
	GProduce* rule = &formula->back(); \
   int group; \
   if (S1.lexeme.Match(T_Lexeme::grIdent)) group = title_group(syntax->Text(S1.lexeme)); \
   else if (S1.lexeme.Match(T_Lexeme::grInteger)) group = syntax->Integer(S1.lexeme); \
   /*T_Lexeme::T_Group group = title_group(syntax->Text(S1.lexeme)); */ \
   if (S2.lexeme.Match(T_Lexeme::grIdent)) { \
      if (group == T_Lexeme::grReserv) { \
         GSymbol item(GSymbol::gsTerminal,group,title_word(syntax->Text(S2.lexeme))); \
         rule->Add(item); \
      } else if (group == T_Lexeme::grError) { \
         GSymbol item(GSymbol::gsTerminal,group,title_error(syntax->Text(S2.lexeme))); \
         rule->Add(item); \
      } else if (group == T_Lexeme::grPriority) { \
         GSymbol item(GSymbol::gsTerminal,group,title_priority(syntax->Text(S2.lexeme))); \
         rule->Add(item); \
      } else if (group == T_Lexeme::grSyntax) { \
         GSymbol item(GSymbol::gsTerminal,group,title_syntax(syntax->Text(S2.lexeme))); \
         rule->Add(item); \
      } else { \
         GSymbol item(GSymbol::gsTerminal,group,title_type(syntax->Text(S2.lexeme))); \
		   rule->Add(item); \
      } \
   } else if (S2.lexeme.Match(T_Lexeme::grInteger)) { \
      GSymbol item(GSymbol::gsTerminal,group,syntax->Integer(S2.lexeme)); \
      rule->Add(item); \
   }

#define MAKER_Integer(S1) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = syntax->data->formulas->back(); \
	GProduce* rule = &formula->back(); \
   T_Lexeme lex; \
   const T_SymbolTable& test = symbol_table(); \
   if (test.Find(syntax->Integer(S1.lexeme),lex)) { \
      GSymbol item(GSymbol::gsTerminal,lex.group,lex.type); \
	   rule->Add(item); \
   }

#define MAKER_Make(S1, S2, S3) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = syntax->data->formulas->back(); \
	GProduce* rule = &formula->back(); \
   int index = GMakerTable::maker_table.Find(syntax->Text(S2.lexeme)); \
   int param = 0; \
   if (S3.lexeme.Match(T_Lexeme::grInteger)) param = syntax->Integer(S3.lexeme); \
   int mode = 0; \
   if (S1.lexeme.Match(T_Lexeme::grIdent,T_Lexeme::rwMAKE)) mode = GSymbol::Tree | GSymbol::Code; \
   else if (S1.lexeme.Match(T_Lexeme::grIdent,T_Lexeme::rwCODE)) mode = GSymbol::Code; \
   else if (S1.lexeme.Match(T_Lexeme::grIdent,T_Lexeme::rwTREE)) mode = GSymbol::Tree; \
   else if (S1.lexeme.Match(T_Lexeme::grIdent,T_Lexeme::rwYACC)) mode = GSymbol::Yacc; \
   else if (S1.lexeme.Match(T_Lexeme::grIdent,T_Lexeme::rwALL)) mode = GSymbol::Yacc | GSymbol::Code | GSymbol::Tree; \
   GSymbol maker(GSymbol::gsMaker,index,param,0,mode); \
   rule->Add(maker);

#define MAKER_Node(S1, S2, S3) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = syntax->data->formulas->back(); \
	GProduce* rule = &formula->back(); \
   int param = 0; \
   if (S3.lexeme.Match(T_Lexeme::grInteger)) param = syntax->Integer(S3.lexeme); \
   GSymbol maker(GSymbol::gsMaker,title_snode_maker(syntax->Text(S1.lexeme)),param,syntax->Integer(S2.lexeme),GSymbol::SNode); \
   rule->Add(maker);

#define MAKER_Turn(S1, S2, S3) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   GFormula* formula = syntax->data->formulas->back(); \
	GProduce* rule = &formula->back(); \
   int indexTT = title_tnode_maker(syntax->Text(S1.lexeme)); \
   int indexST = title_snode_maker(syntax->Text(S2.lexeme)); \
   int param = 0; \
   if (S3.lexeme.Match(T_Lexeme::grInteger)) param = syntax->Integer(S3.lexeme); \
   GSymbol maker(GSymbol::gsMaker,indexTT,param,indexST,GSymbol::Turn); \
   rule->Add(maker);

#define MAKER_Syn_Tree(S1, S2, S3, S4, S5, S6) \
   MyYSyntax* syntax = (MyYSyntax*)YYPARSE_PARAM; \
   int a[5] = {0}; \
   a[0] = syntax->Integer(S1.lexeme); \
   if (S2.lexeme.Match(T_Lexeme::grInteger)) a[1] = syntax->Integer(S2.lexeme); \
   if (S3.lexeme.Match(T_Lexeme::grInteger)) a[2] = syntax->Integer(S3.lexeme); \
   if (S4.lexeme.Match(T_Lexeme::grInteger)) a[3] = syntax->Integer(S4.lexeme); \
   if (S5.lexeme.Match(T_Lexeme::grInteger)) a[4] = syntax->Integer(S5.lexeme); \
   S6.lexeme.value = syntax->Integer(syn_tree(a[0], a[1], a[2], a[3], a[4]));

int yy_nl_parse (void *YYPARSE_PARAM); // { return 0; }

#pragma warning( disable : 4065 )
#include "FSyntax.tab.c"
#include "stdafx.h"

#include "RSyntax.h"
#include "Maker.h"
#include "GBuilder.h"

bool TPara::operator == (const TPara& p) const 
{ 
   return ((const GSymbol&)(*this) == (const GSymbol&)p) && (sym == p.sym); 
}
bool TPara::operator <  (const TPara& p) const
{
   return ((const GSymbol&)(*this) < (const GSymbol&)p) || ((const GSymbol&)(*this) == (const GSymbol&)p) && (sym < p.sym); 
}
int  TPara::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   bool compact = (print_mode & T_PrintMode::pmCompactGroup) != 0, simple = (print_mode & T_PrintMode::pmSimplePara) != 0;
   if (!file) file = stdout;
   int len = 0;
   if (!simple) {
      if (sym.IsNone()) {
         fprintf(file, "(%1d)",point); 
      } else {
         fprintf(file, "(%1d,",point); sym.print(grammar, print_mode, file); fprintf(file, ")");
      }
      if (IsPara()) {
         const GSymbol p(GSymbol::gsProduce, formula, produce);
         const GProduce& pr = grammar->Produce(p);
         pr.print(grammar, print_mode | (compact ? T_PrintMode::pmCompact : T_PrintMode::pmNone), file, point);
      } else {
         len += ((const GSymbol&)(*this)).print(grammar, print_mode, file);
      }
   } else {
      len += ((const GSymbol&)(*this)).print(grammar, print_mode, file);
      if (!sym.IsNone()) {
         fprintf(file, ","); len += 1;
         len += sym.print(grammar, print_mode, file);
      }
   }
   return len;
}

void TPara::write(FILE *file, const TGrammar* grammar, int print_mode) const
{
   GSymbol::write(file,grammar,print_mode);
   if (!sym.IsNone()) { 
      fprintf(file, ","); sym.write(file,grammar,print_mode);
   }
   fprintf(file, ";");
}

TParaSet::TParaSet(const TGrammar* g, const TParaSet& I) :grammar(g), mode(0) 
{
   for (const TPara& para : I) {
      Add(para);
   }
}

int TParaSet::operator += (const TPara& s)
{
   int ret = Add(s);
   return ret;
}

int TParaSet::operator += (const TParaSet& m)
{
   int ret = 0;
   for (const TPara& item : m) {
      if (item.IsEmpty()) continue;
      if (Add(item)) ret++;
   }
   return ret;
}

TParaSet TParaSet::Empty(NULL);

bool TParaSet::Add(const TPara& sym)
{ 
   const_iterator ip = find(sym); 
   if (ip != end()) return false;
   insert(sym);
   return true; 
}

bool TParaSet::Have(const TPara& sym) const
{ 
   const_iterator ip = find(sym); 
   return (ip != end());
}

bool TParaSet::ValidLRk() const
{
   if (size() == 1) return true;
   std::vector<TFirst> firsts; firsts.resize(size());
   bool ended = false;
   for (const TPara& para : (*this)) {
      const GProduce& produce = grammar->Produce(para);
      if ((para.point == produce.count()) || produce.IsEmpty()) {
         ended = true; break;
      }
   }
   if (!ended) return true;

   int i = 0;
   for (const TPara& para : (*this)) {
      const GProduce& produce = grammar->Produce(para);
      TFirst& eff_beta2_v = firsts[i];
      if ((para.point < produce.count()) && !produce.IsEmpty()) {
         GSymbolVector beta2_v;
         produce.SymAndTail(para, beta2_v);
         if (para.sym.IsVector()) {
            beta2_v << grammar->Vector(para.sym);
         } else {
            beta2_v << para.sym;
         }
         grammar->EFFs.EFF(beta2_v, eff_beta2_v, grammar->look_ahead);
      } else {
         eff_beta2_v << para.sym;
      }
      i++;
   }

   for (const TPara& para_one : (*this)) {
      const GProduce& produce_one = grammar->Produce(para_one);
      if (produce_one.head.mode & GSymbol::Warning) continue;
      if ((para_one.point < produce_one.count()) && !produce_one.IsEmpty()) continue;
      int j = 0;
      for (const TPara& para_two : (*this)) {
         if (!(para_one == para_two) && !produce_one.IsEmpty()) {
            const TFirst& eff_beta2_v = firsts[j];
            if (eff_beta2_v.Have(para_one.sym)) {
               fprintf(stdout, "\nA: "); para_one.print(grammar, 0x00, stdout); fprintf(stdout, " B: "); para_two.print(grammar, 0x00, stdout);
               return false;
            }
         }
         j++;
      }
   }
   return true;
}

bool TParaSet::ValidSLRk() const
{
   if (size() == 1) return true;
   std::vector<TFirst> firsts; firsts.resize(size());
   bool ended = false;
   for (const TPara& para : (*this)) {
      const GProduce& produce = grammar->Produce(para);
      if ((para.point == produce.count()) || produce.IsEmpty()) {
         ended = true; break;
      }
   }
   if (!ended) return true;

   int i = 0;
   for (const TPara& para : (*this)) {
      const GProduce& produce = grammar->Produce(para);
      TFirst& eff_beta_follow = firsts[i];
      if ((para.point < produce.count()) && !produce.IsEmpty()) {
         GSymbolVector beta;
         produce.SymAndTail(para, beta);
         const GSymbol A = GSymbol(GSymbol::gsFormula, para.formula);
         const TFollow& follow_A = (const TFollow&)grammar->Follow(A);
         for (const GSymbol& item : follow_A) {
            GSymbolVector beta_follow(beta);
            if (item.IsVector()) {
               beta_follow << grammar->Vector(item);
            } else if (!item.IsEmpty() && !item.IsEof()) {
               beta_follow << item;
            }
            TFirst eff_beta_item;
            grammar->EFFs.EFF(beta_follow, eff_beta_item, grammar->look_ahead);
            eff_beta_follow << eff_beta_item;
         }
      }
      i++;
   }

   for (const TPara& para_B : (*this)) {
      const GProduce& produce_B = grammar->Produce(para_B);
      if ((para_B.point < produce_B.count()) || produce_B.IsEmpty()) continue;
      const GSymbol B = GSymbol(GSymbol::gsFormula, para_B.formula);
      int j = 0;
      for (const TPara& para_A : (*this)) {
         if (!(para_A == para_B)) {
            const GSymbol A = GSymbol(GSymbol::gsFormula, para_A.formula);
            const GProduce& produce_A = grammar->Produce(para_A);
            TFirstFollow multi;
            if (!produce_A.IsEmpty()) {
               const TFirst& eff_beta_follow_A = firsts[j];
               multi = grammar->Follow(B) * eff_beta_follow_A;
            } else {
               multi = grammar->Follow(A) * grammar->Follow(B);
            }
            if (!multi.empty()) {
               fprintf(stdout, "\nA: "); para_A.print(grammar, 0x00, stdout); fprintf(stdout, " B: "); para_B.print(grammar, 0x00, stdout);
               fprintf(stdout, "\n"); multi.print(stdout, grammar, 0x00);
               return false;
            }
         }
         j++;
      }
   }
   return true;
}

TParaSet* TParaSet::Core() const
{
   TParaSet* core = new TParaSet(grammar); 
   for (const TPara& para : (*this)) {
      *core << TPara((GSymbol)para);
   }
   return core;  
}

bool TParaSet::CoreCompare(const TParaSet& join) const
{
   GSymbolSet p1, p2;
   for (const GSymbol& sym : (*this)) {
      p1 << sym;
   }
   for (const GSymbol& sym : join) {
      p2 << sym;
   }
   return p1 == p2;
}

bool TParaSet::Have(const TParaSet& join) const
{
   for (const TPara& para : join) {
      if (!Have(para)) return false;
   }
   return true;
}

void TParaSet::print(const char* title, int print_mode, FILE* file) const
{
   bool basic = (print_mode & T_PrintMode::pmBasic) != 0, compact = (print_mode & T_PrintMode::pmCompactGroup) != 0, simple = (print_mode & T_PrintMode::pmSimplePara) != 0;
   if (!simple) {
	   fprintf(file, "\n--- ");
      if (title) fprintf(file, "%s",title); else fprintf(file, "ParaSet");
      int count = basic ? 0 : (int)size();
      if (basic) {
         for (const TPara& gamma : *this) {
            if (!gamma.IsPara() || gamma.IsBasic()) count++;
         }
      }
      fprintf(file, " --- <%d> ---\n", count);
   }
   for (const TPara& gamma : *this) {
      if (basic && gamma.IsPara() && !gamma.IsBasic()) continue;
      if (!simple) {
         fprintf(file, "\n");
         if (gamma.sym.IsNone()) {
            fprintf(file, "(%1d)",gamma.point); 
         } else {
            fprintf(file, "(%1d,",gamma.point); gamma.sym.print(grammar, print_mode, file); fprintf(file, ")");
         }
         if (gamma.IsPara()) {
            const GSymbol p(GSymbol::gsProduce,gamma.formula,gamma.produce);
            const GProduce& pr = grammar->Produce(p);
            pr.head.print(grammar, print_mode,file); pr.print(grammar, print_mode | (compact ? T_PrintMode::pmCompact : 0x00), file, gamma.point);
         } else {
            ((const GSymbol&)gamma).print(grammar, print_mode, file);
         }
      } else {
         const MTableKey to((GSymbol)gamma,gamma.sym);
         to.print(grammar, T_PrintMode::pmCompact,file);
         fprintf(file, "   ");
      }
   }
   fprintf(file, "\n");
}

void TParaSet::write(FILE* file, int print_mode) const
{
   bool basic = (print_mode & T_PrintMode::pmBasic) != 0;
   for (const TPara& para : *this) {
      if (basic && !para.IsBasic()) continue;
      para.write(file,grammar,print_mode);
   }
   fprintf(file, "\n");
}

void TSituationMap::Clear()
{
   for (const TParaSet* item : vector) {
      delete item;
   }
   vector.clear(); map.clear();
}

void TSituationMap::Copy(const TSituationMap& join)
{
   for (const TParaSet* item : join.vector) {
      TParaSet* copy = new TParaSet(item->grammar,*item);
      Add(copy);
   }
}

void TSituationMap::Basic()
{
   std::vector<TParaSet*> temp_vector(vector);
   vector.clear(); map.clear();
   for (TParaSet* item : temp_vector) {
      item->Basic();
      Add(item);
   }
}

int TSituationMap::ValidLRk()
{
   int invalid = 0;
   for (const TParaSet* situation : vector) {
      if (!situation->ValidLRk()) {
         invalid++;
      }
   }
   return invalid;
}

int TSituationMap::ValidSLRk()
{
   int invalid = 0;
   int i = 0;
   for (const TParaSet* situation : vector) {
      if (!situation->ValidSLRk()) {
         invalid++;
      }
      i++;
   }
   return invalid;
}

GSymbol TSituationMap::Add(TParaSet* key)
{
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(key)); 
   if (ip != map.end()) {
      std::pair<const Key,const GSymbol&> item = (*ip);
      return item.second;
   }
   GSymbol sym(GSymbol::gsSituation,count());
   vector.push_back(key);
   std::pair<const Key,const GSymbol&> item(key,sym);
   map.insert(item); 
   return sym;
}

GSymbol TSituationMap::Find(const TParaSet& key) const
{
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(&key)); 
   if (ip != map.end()) {
      std::pair<const Key,const GSymbol&> item = (*ip);
      return item.second;
   }
   return GSymbol();
}

TParaSet* TSituationMap::Get(const GSymbol& sym) const
{
   return vector[sym.situation];
}

void TSituationMap::make_NEXTs(const MTableMap& GOTOtable, TNextTab& NEXTs)
{
   TGrammar* grammar = NEXTs.grammar;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < this->count(); situation.situation++) {
      const TParaSet& situation_items = *this->Get(situation);
      for (const TPara& para : situation_items) {
         if (para.point) continue;
         const GProduce& produce = grammar->Produce(para);
         if (produce.IsEmpty()) continue;
         GSymbol my_situation = situation;
         for (int index = 0; index < produce.count(); index++) {
            const GSymbol& X = produce[index];
            MTableKey key(my_situation, X);
            const GSymbol& next = GOTOtable.Find(key);
            my_situation = next;
         }
         MTableKey key_A(situation, GSymbol(GSymbol::gsFormula, produce.head.formula)); // A -> produce
         const GSymbol& next = GOTOtable.Find(key_A);
         TTwoSym key_next(my_situation, produce.head);
         NEXTs.Add(key_next, next);
      }
   }
}

void TSituationMap::Expansion(const TFirstFollowTable& table, TSituationMap& TO) const
{
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < count(); situation.situation++) {
      const TParaSet& situation_items = *Get(situation);
      TParaSet *I_X = new TParaSet(situation_items.grammar);
      for (const TPara& para : situation_items) {
         const GSymbol& para_sym = para.sym;
         if (para_sym.IsTable()) {
            const TFirstFollow& tab = table.Table(para_sym);
            for (const GSymbol& sym : tab) {
               TPara my_para(para, sym);
               (*I_X) << my_para;
            }
         } else {
            (*I_X) << para;
         }
      }

      int before = TO.count();
      const GSymbol go_to = TO.Add(I_X);
      if (before == TO.count()) {
         delete I_X;
      } else {
      }
   }
}

void TSituationMap::print_(FILE* file, int print_mode) const
{
   static char buffer[20] = {};
   bool basic = (print_mode & T_PrintMode::pmBasic) != 0;
   int para_count = 0;
   for (const TParaSet* key : vector) {
      if (basic) {
         for (const TPara& gamma : *key) {
            if (!gamma.IsPara() || gamma.IsBasic()) para_count++;
         }
      } else {
         para_count += key->count();
      }
   }
   fprintf(file, "\n--- Situations --- <%d> --- <%d> ---\n", (int)count(), para_count);
   if (print_mode == T_PrintMode::pmNone) return;
   if (print_mode & T_PrintMode::pmSortMode) {
      GSymbol situation;
      for (TParaSet* key : vector) {
         SPRINTF(buffer, "(%05d)", situation.situation++);
         key->print(buffer, print_mode, file);
      }
   } else {
      for (std::pair<const Key&, const GSymbol&> item : map) {
         SPRINTF(buffer, "(%05d)", item.second.situation);
         item.first.key->print(buffer, print_mode, file);
      }
   }
}

void TSituationMap::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   print_(file, print_mode);
   if (title) {
      fclose(file);
   }
}

void TSituationMap::write(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if (print_mode & T_PrintMode::pmWriteZero) {
      fprintf(file, "%05d\n",count());
   } else {
      fprintf(file, "%d\n",count());
   }
   if (print_mode == T_PrintMode::pmNone) return;
   if (print_mode & T_PrintMode::pmSortMode) {
      for (TParaSet* key : vector) {
         const GSymbol& situation = map.at(Key(key));
         key->write(file,print_mode);
      }
   } else {
      for (std::pair<const Key&,const GSymbol&> item : map) {
         item.first.key->write(file,print_mode);
      }
   }
   if (title) {
      fclose(file);
   }
}

GSymbol TSituationCore::Add(TParaSet* key, int situation)
{
   key = key->Core();
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(key)); 
   if (ip != map.end()) {
      std::pair<const Key,const GSymbol&> item = (*ip);
      core_arr[item.second.situation].push_back(situation);
      delete key;
      return item.second;
   }
   GSymbol sym(GSymbol::gsSituation,count());
   vector.push_back(key);
   core_arr.push_back(TCoreArrItem());
   core_arr.back().push_back(situation); 
   std::pair<const Key,const GSymbol&> item(key,sym);
   map.insert(item); 
   return sym;
}

void TSituationCore::print(const char* title, int print_mode) const
{
   TSituationMap::print(title, print_mode);
   PRINT_FILE_OPEN(file, title, "w");
   fprintf(file, "\n");
   int core = 0;
   for (const TCoreArrItem &list : core_arr) {
    	fprintf(file, "%05d -> ", core++);
      for (int item: list) {
      	fprintf(file, "%d ", item);
      }
   	fprintf(file, ";\n");
   }
	fprintf(file, "\n");
   if (title) {
      fclose(file);
   }
}

GSymbol TSituationKernel::Add(TParaSet* key)
{
   TParaSet* core = new TParaSet(key->grammar);
   for (const TPara& para : *key) {
      *core << TPara((GSymbol)para);
   }
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(core)); 
   if (ip != map.end()) {
      std::pair<const Key,const GSymbol&> item = (*ip);
      if (yes_queue) {
         TParaSet* old_key = vector[item.second.situation]; int key_count = old_key->count();
         int para_step = old_key->mode ? step : 0;
         for (const TPara& para : *key) {
            TPara new_para(para); new_para.sym.value = para_step;
            *old_key << new_para;
         }
         if (old_key->mode && (key_count < old_key->count())) queue.Push(item.second);
      }
//fprintf(stdout,"\nsituation=:%05d,%05d,%05d",item.second.situation,key->count(),key_count - old_key->count());
      delete core;
      return item.second;
   }
   GSymbol sym(GSymbol::gsSituation,count());
   vector.push_back(key);
   std::pair<const Key,const GSymbol&> item(core,sym);
   map.insert(item); 
   if (yes_queue) queue.Push(sym);
//fprintf(stdout,"\nsituation+:%05d,%05d",sym.situation,key->count());
   return sym;
}

GSymbol TSituationKernel::Find(const TParaSet& key) const
{
   TParaSet core (key.grammar);
   for (const TPara& para : key) {
      core << TPara((GSymbol)para);
   }
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(&core)); 
   if (ip != map.end()) {
      std::pair<const Key,const GSymbol&> item = (*ip);
      return item.second;
   }
   return GSymbol();
}

void TSituationKernel::Clear()
{
   for (std::pair<const Key&,const GSymbol&> item : map) {
      delete item.first.key;
   }
   step = 0;
   TSituationMap::Clear();
}

class T_CLOSURE : public TParaSet
{
public:
   T_CLOSURE(const TGrammar* g, const TParaSet& I);
};

class T_GOTO : public TParaSet
{
public:
   T_GOTO(const TGrammar* g) :TParaSet(g) {}
   T_GOTO(const TGrammar* g, const TParaSet& I, const GSymbol& X);
};

class T_CLOSURE_LR1 : public TParaSet
{
public:
   T_CLOSURE_LR1(const TGrammar* g, const TParaSet& I);
};

class T_GOTO_LR1 : public TParaSet
{
public:
   T_GOTO_LR1(const TGrammar* g, const TParaSet& I, const GSymbol& X);
};

T_CLOSURE::T_CLOSURE(const TGrammar* g, const TParaSet& I) :TParaSet(g,I)
{
   grammar->builder->Added.Next();
   int j_work;
   do {
      j_work = 0;
      const TParaSet J(*this);
      for (const TPara& para : J) {
         const GProduce& produce = grammar->Produce(para);
         if (para.point < produce.count()) {
            const GSymbol& sym_B = produce[para.point];
            if (!sym_B.IsFormula()) continue;
            const GFormula& formula_B = grammar->Formula(sym_B);
            bool added = grammar->builder->Added.Added(sym_B);
            if (added) { 
               grammar->builder->false_count--;
               continue; 
            }
            TPara gamma(GSymbol::gsPara,sym_B.formula);
            int b_work = 0;
            for (gamma.produce = 0; gamma.produce < formula_B.count(); gamma.produce++) {
               if (!Have(gamma)) { 
                  (*this) << gamma; b_work++;
                  grammar->builder->true_count++;
               } else {
                  grammar->builder->false_count++;
               }
            }
            if (b_work) {
               j_work++;
            }
         }
      }
   } while(j_work);
}

T_GOTO::T_GOTO(const TGrammar* g, const TParaSet& I, const GSymbol& X) :TParaSet(g)
{
   TParaSet closure(grammar);
   for (const TPara& para : I) {
      const GProduce& produce = grammar->Produce(para);
      if (para.point < produce.count()) {
         const GSymbol& sym_B = produce[para.point];
         if (!(sym_B == X)) continue; // (B !== X) 
         TPara shift_para(para); produce.Shift(shift_para);
         closure << shift_para;
      }
   }
   T_CLOSURE C(grammar,closure);
   (*this) << C;
}

void TParaSet::Basic()
{
   const TPara S(GSymbol::gsPara);
   const TPara S_Eof(GSymbol(GSymbol::gsPara), GSymbol::eof);
	iterator ip = begin();
   while (ip != end()) {
      const TPara& para = (*ip);
      if (!para.point && ((para.sym.IsNone() && !(para == S)) || (!para.sym.IsNone() && !(para == S_Eof)))) {
         ip = erase(ip);
      } else {
         ip++;
      }
   } 
}

void TClosureAdded::Init(int f, int s) // +Eof, +sharp, +Empty
{ 
   formula_count = f, sym_count = s, current = 0; clear(); resize(formula_count * sym_count, 0); 
}

void TClosureAdded::Init(int m) // -1 - off, 0 - LR0, 1 - LR1, 2 - LALR, 3 - LRk, 4 - Core
{
   if (m == 0) {
      Init(grammar->count(),1);
   } else if (m == 1) {
      Init(grammar->count(),grammar->lexemes.count() + 1 + 1 + 1);
   } else if (m == 2) {
      Init((int)grammar->produces.size(),grammar->lexemes.count() + 1 + 1 + 1);
   } else if (m == 3) {
      Init(grammar->count(), grammar->lexemes.count() + 1 + 1 + 1 + grammar->Vectors().count()); // Vectors
   } else if (m == 4) {
      Init((int)grammar->produces.size(), grammar->lexemes.count() + 1 + 1 + 1 + grammar->Vectors().count()); // Vectors
   }
   type = m;
}

bool TClosureAdded::Added(const GSymbol &formula)
{
   if (type != 0) return false;
   bool added = Get(formula.formula);
   Set(formula.formula);
   return added;
}

bool TClosureAdded::Added(const GSymbol &formula, const GSymbol &lexeme)
{
   if (type == -1) return false;
   if (type == 0) return Added(formula);

   if ((type != 1) && (type != 2) && (type != 3) && (type != 4)) return false;
   int b_added = Index(lexeme);
   int a_formula = ((type != 2) && (type != 4)) ? formula.formula : ((formula.formula < 0) ? formula.produce : formula.value);
   if (b_added > (int)sym_count - 1) {
      sym_count += 100;
      resize(formula_count * sym_count, 0);
   }
   bool added = Get(a_formula,b_added);
   if (type != 2) Set(a_formula,b_added);
   return added;
}

int  TClosureAdded::Index(const GSymbol &lexeme) const
{
   int b_added = 0; // +(Eof.added = 0), +(sharp.added = 1), +(Empty.added = 2)
   if (lexeme.IsEof() || lexeme.IsEmpty())
      b_added = 0;
   else if (lexeme == GSymbol::sharp)
      b_added = 1;
   else if (lexeme.IsEmpty())
      b_added = 2;
   else if (lexeme.IsTerminal())
      b_added = grammar->lexemes.GetAdded(lexeme) + 1 + 1 + 1;
   else if (lexeme.IsVector())
      b_added = grammar->lexemes.count() + 1 + 1 + 1 + lexeme.formula;
   return b_added;
}

void TClosureAdded::Set(const GSymbol &formula, const GSymbol &lexeme)
{
   int b_added = Index(lexeme);
   int a_formula = ((type != 2) && (type != 4)) ? formula.formula : ((formula.formula < 0) ? formula.produce : formula.value);
   Set(a_formula,b_added);
}

T_CLOSURE_LR1::T_CLOSURE_LR1(const TGrammar* g, const TParaSet& I) :TParaSet(g,I)
{
   grammar->builder->Added.Next();
   int work;
   do {
      work = 0;
      const TParaSet J(*this);
      for (const TPara& para : J) {
         const GSymbol& a = para.sym;
         const GProduce& produce = grammar->Produce(para);
         if (para.point < produce.count()) {
            const GSymbol& sym_B = produce[para.point];
            if (!sym_B.IsFormula()) continue;
            const GFormula& formula_B = grammar->Formula(sym_B);

            GSymbolVector beta;
            produce.TailWithoutMaker(para, beta);
            beta << a;
            TFirst first_beta_a(beta, &grammar->FIRSTs);

            for (const GSymbol& b : first_beta_a) {
               bool added = grammar->builder->Added.Added(sym_B,b);
               if (added) { 
                  grammar->builder->false_count--;
                  continue; 
               }
               TPara gamma(GSymbol(GSymbol::gsPara,sym_B.formula),b);
               for (gamma.produce = 0; gamma.produce < formula_B.count(); gamma.produce++) {
                  if (!Have(gamma)) { 
                     (*this) << gamma; work++;
                     grammar->builder->true_count++;
                  } else {
                     grammar->builder->false_count++;
                  }
               }
            }
         }
      }
   } while(work);
}

T_GOTO_LR1::T_GOTO_LR1(const TGrammar* g, const TParaSet& I, const GSymbol& X) :TParaSet(g)
{
   TParaSet closure(grammar);
   for (const TPara& para : I) {
      const GProduce& produce = grammar->Produce(para);
      if (para.point < produce.count()) {
         const GSymbol& sym_B = produce[para.point];
         if (!(sym_B == X)) continue; // (B !== X) 
         TPara shift_para(para); produce.Shift(shift_para);
         closure << shift_para;
      }
   }
   T_CLOSURE_LR1 C(g,closure);
   (*this) << C;
}

bool TGrammarBuilder::make_LL1Table()
{
   bool ret = true;
   for (const GFormula* formula : grammar->formulas) {
      for (const GProduce& produce : *formula) {
         TFirst first_produce(produce,&grammar->FIRSTs);
         for (const GSymbol& sym : first_produce) {
            if (sym.IsTerminal()) {
               MTableKey key(formula->head,sym);
               Mtable.Add(key,produce.head);
            }
         }
         if (first_produce.HaveEmpty()) {
            const TFirstFollow& follow_formula = Follow(formula->head);
            for (const GSymbol& b : follow_formula) {
               if (b.IsTerminal()) {
                  MTableKey key(formula->head,b);
                  Mtable.Add(key,produce.head);
               }
            }
            if (follow_formula.Have(GSymbol::eof)) {
               MTableKey key(formula->head,GSymbol::eof);
               Mtable.Add(key,produce.head);
            }
         }
      }
   }
#if defined(ERROR_RECOVERY)
   for (const GFormula* formula : grammar->formulas) {
      const TFirstFollow follow_produce = FOLLOWs.at(formula->head);
      for (const GSymbol& sym : follow_produce) {
         MTableKey key(formula->head,sym);
         if (Mtable.Find(key).IsNone()) Mtable.Add(key,sym);
      }
   }
#endif

   if (Mtable.duplicate) printf("\nDuplicate: %d\n", Mtable.duplicate);
   if (Mtable.warning) printf("\nWarning: %d\n", Mtable.warning);
   printf("\nLL1Table: %05d", Mtable.count());

   return ret;
}

class TProduceSet
{
public:
   TProduceSet() {}
   bool Add(GProduce* key);
public:
   int  count() const { return (int)set.size(); }
public:
   struct Key {
      Key(GProduce *p) :key(p) {}
      bool operator == (const Key& k) const { return *(GSymbolVector*)key == *(GSymbolVector*)k.key; }
      bool operator <  (const Key& k) const { return *(GSymbolVector*)key <  *(GSymbolVector*)k.key; }
   public:
      GProduce *key;
   };
   std::set<Key> set;
};

bool TProduceSet::Add(GProduce* key)
{
   std::set<Key>::const_iterator ip = set.find(Key(key)); 
   if (ip != set.end()) {
      return false;
   }
   set.insert(key); 
   return true;
}

bool TGrammar::make_Symple()
{
   bool ret = true;
   bool yes_change;
   do {
      yes_change = false;
      for (int f = 0; f < formulas.count(); f++) {
         GFormula* formula = formulas[f];
         if (formula == root) continue;
         GFormula::iterator i_f = formula->begin();
         while (i_f != formula->end()) {
            GProduce& produce = (*i_f);
            if (produce.empty()) { i_f++; continue; }
            if (produce[0].IsFormula()) {
               const GFormula& simple_formula = *formulas[produce[0].formula];
               if (simple_formula.back().IsEmpty()) { i_f++; continue; } 
               int before = formula->count();
               i_f = formula->insert(i_f,simple_formula.count() - 1, produce);
               int after = formula->count();
//               printf("\n%d %d %d", before, after, simple_formula.count());
               for (int s = 0; s < simple_formula.count(); s++) {
                  GProduce& produce = (*i_f++);
//                  printf("\n"); formula->head.print(this,0x00); printf(" => "); produce[0].print(this,0x00); printf(" -> "); simple_formula[s].head.print(this,0x00); printf(" used=%d",simple_formula.used);
                  GProduce::iterator ip = produce.begin();
                  ip = produce.erase(ip);
                  for (const GSymbol& sym : simple_formula[s]) {
                     ip = produce.insert(ip,sym); ip++;
                     if (sym.IsFormula()) {
                        const GFormula& used = Formula(sym);
                        used.used++;
                     }
                  }
               }
               int p = 0;
               for (GProduce& produce : *formula) {
                  produce.head.produce = p++;
               }
               simple_formula.used--;
               yes_change = true;
            } else if (produce[0].IsMaker()) {
               int i = 0; i++;
//               formula->head.print(this,0x00); printf(" maker \n");
               i_f++;
            } else {
               i_f++;
            }
         }
      }
   } while(yes_change);
   return true;
}

bool TGrammar::make_Left()
{
   bool ret = true;
   for (int f = 0; f < formulas.count(); f++) {
      bool yes_change = false;
      GFormula* formula = formulas[f];
      if (formula->count() == 1) continue;
      TProduceSet p_set;
      for (int i = 0; i < formula->count(); i++) {
         p_set.Add(&(*formula)[i]);
      }

      std::vector<GProduce*> arr;
      for (TProduceSet::Key item : p_set.set) {
         arr.push_back(item.key);
      }
      std::vector<int> equs;
      int equ_max = 0, arr_max = 0;
      for (int i_arr = 0; i_arr < (int)arr.size() - 1; i_arr++) {
         const GProduce& one = *arr[i_arr], two = *arr[i_arr + 1];
         int equ = 0;
         while ((equ < one.count()) && (equ < two.count())) {
            if (!(one[equ] == two[equ])) break;
            equ++; 
            if (equ > equ_max) { equ_max = equ; arr_max = i_arr; }
         }
         equs.push_back(equ);
      }
      if (!equ_max) continue;

      yes_change = true;
      int beg = arr_max, end = beg, p = 0;
      for (end = beg + 1; (end < (int)equs.size()) && (equs[end] == equ_max); end++);
      printf("\n"); formula->head.print(this,0x00); printf("equ_max=%d, beg=%d, end=%d",equ_max,beg,end);
      GFormula *left_formula = new GFormula(GSymbol(GSymbol::gsFormula,formulas.count()));
      formulas.push_back(left_formula);
      for (int i = beg; i <= end; i++) {
         GProduce new_produce(GSymbol(GSymbol::gsProduce,left_formula->head.formula));
         new_produce.head.produce = p++;
         GProduce* old = arr[i];
         for (int s = equ_max; s < old->count(); s++) {
            new_produce << (*old)[s];
         }
         left_formula->Add(new_produce);
         if (i == beg) {
            GProduce::iterator ip = old->begin() + equ_max;
            while(ip != old->end()) ip = old->erase(ip);
            (*old) << left_formula->head; 
            left_formula->used++;
         } else {
            old->clear();
         }
      }
      p = 0;
      GFormula::iterator ip = formula->begin();
      while(ip != formula->end()) {
         if ((*ip).size() == 0) {
            ip = formula->erase(ip);
         } else {
            (*ip).head.produce = p++;
            ip++;
         }
      }
      if (yes_change) f--;
   }
   return ret;
}

bool TGrammar::verify_LL()
{
   int first_first = 0, first_ffollow = 0;
   bool ret = true;
   for (GFormula* formula : formulas) {
//      if (!formula->used) continue;
      const TFirstFollow& follow_A = FOLLOWs.at(formula->head);
      for (int i = 0; i < formula->count() - 1; i++) {
         TFirst first_apha(&FIRSTs);
         first_apha += (*formula)[i];
         for (int j = i + 1; j < formula->count(); j++) {
            TFirst first_beta(&FIRSTs);
            first_beta += (*formula)[j];
            TFirstFollow first_ij = first_apha * first_beta;
            if (!first_ij.empty()) {
               ret = false; first_first++;
               printf("\nfirst*first:\n");
               formula->head.print(this, 0x00); printf(" : ");
               (*formula)[i].head.print(this, 0x00); (*formula)[j].head.print(this, 0x00); 
               printf(" -> "); first_ij.GSymbolSet::print(this, 0x00); printf("\n");
            }
            if (first_beta.HaveEmpty()) {
               TFirstFollow first_follow = first_apha * follow_A;
               if (!first_follow .empty()) {
                  ret = false; first_ffollow++;
                  printf("\nfirst*ffollow:\n");
                  formula->head.print(this, 0x00); printf(" : ");
                  (*formula)[i].head.print(this, 0x00); (*formula)[j].head.print(this, 0x00); 
                  printf(" -> "); first_follow .GSymbolSet::print(this, 0x00); printf("\n");
               }
            }
            if (first_apha.HaveEmpty()) {
               TFirstFollow first_follow = first_beta * follow_A;
               if (!first_follow .empty()) {
                  ret = false; first_ffollow++;
                  printf("\nfirst*ffollow:\n");
                  formula->head.print(this, 0x00); printf(" : ");
                  (*formula)[i].head.print(this, 0x00); (*formula)[j].head.print(this, 0x00); 
                  printf(" -> "); first_follow .GSymbolSet::print(this, 0x00); printf("\n");
               }
            }
         }
      }
   }
   if (first_first || first_ffollow) printf("\n");
   if (first_first)   printf("first*first: %d", first_first);
   if (first_first && first_ffollow) printf(", ");
   if (first_ffollow) printf("first*ffollow: %d", first_ffollow);
   if (first_first || first_ffollow) printf("\n");
   return ret;
}

void TGrammar::change_group()
{
   int change = 0;
   for (GFormula* formula : formulas) {
      for (GProduce& produce : *formula) {
         GProduce::iterator ip = produce.begin();
         while (ip != produce.end()) {
            GSymbol& sym = (*ip);
            if (sym.IsTerminal() && (sym.group == T_Lexeme::grSyntax)) {
               switch (sym.lexeme_type) {
               case T_Lexeme::T_Syntax::sxIdentFunc    :
                  sym.group = T_Lexeme::grIdent; sym.lexeme_type = 0;
                  change++;
                  break;
               case T_Lexeme::T_Syntax::sxIdentArr     :
                  sym.group = T_Lexeme::grIdent; sym.lexeme_type = 0;
                  change++;
                  break;
               case T_Lexeme::T_Syntax::sxDefFunc      :
                  sym.lexeme_type = T_Lexeme::sxDefType;
                  change++;
                  break;
               case T_Lexeme::T_Syntax::sxDefArr       :
                  sym.lexeme_type = T_Lexeme::sxDefType;
                  change++;
                  break;
               case T_Lexeme::T_Syntax::sxDefVar       :
                  sym.lexeme_type = T_Lexeme::sxDefType;
                  change++;
                  break;
               case T_Lexeme::T_Syntax::sxDefType      :
                  break;
               case T_Lexeme::T_Syntax::sxLabel        :
                  sym.group = T_Lexeme::grIdent; sym.lexeme_type = 0;
                  change++;
                  break;
               case T_Lexeme::T_Syntax::sxCast         :
                  sym.lexeme_type = T_Lexeme::sxDefType;
                  change++;
                  break;
               case T_Lexeme::T_Syntax::sxCastUnary    : {
                  sym.lexeme_type = T_Lexeme::sxDefType;
                  GSymbol  left(GSymbol::gsTerminal, T_Lexeme::grSeparator, T_Symbol::lxLeftBracket); 
                  ip = produce.insert(ip, left);
                  GSymbol right(GSymbol::gsTerminal, T_Lexeme::grSeparator, T_Symbol::lxRightBracket); 
                  ip = produce.insert(ip + 2, right);
                  change++;
                   } break;
               case T_Lexeme::T_Syntax::sxEmptyCramp   : {
                  sym.group = T_Lexeme::grSeparator; sym.lexeme_type = T_Symbol::lxLeftCramp;
                  GSymbol right(GSymbol::gsTerminal, T_Lexeme::grSeparator, T_Symbol::lxRightCramp); 
                  ip = produce.insert(++ip, right);
                  change++;
                  } break;
               case T_Lexeme::T_Syntax::sxEmptyBracket : {
                  sym.group = T_Lexeme::grSeparator; sym.lexeme_type = T_Symbol::lxLeftBracket;
                  GSymbol right(GSymbol::gsTerminal, T_Lexeme::grSeparator, T_Symbol::lxRightBracket); 
                  ip = produce.insert(++ip, right);
                  change++;
                  } break;
               case T_Lexeme::T_Syntax::sxEmptyScrape  : {
                  sym.group = T_Lexeme::grSeparator; sym.lexeme_type = T_Symbol::lxLeftScrape;
                  GSymbol right(GSymbol::gsTerminal, T_Lexeme::grSeparator, T_Symbol::lxRightScrape); 
                  ip = produce.insert(++ip, right);
                  change++;
                  } break;
               default:
                  break;
               }
            }
            ip++;
         }
      }
   }
   printf("\nchange terminal: %d\n", change);
}

// Green(v=1,p=169,a=2.7)
bool TGrammar::NoEmptyLanguage(int mode)
{
   for (GFormula* formula : formulas) {
      formula->ClearUsed();
   }
   int change, cycle = 0;
   do {
      change = 0;
      for (GFormula* formula : formulas) {
         for (const GProduce& produce : *formula) {
            bool yes_symbol = true;
            if (!produce.IsEmpty()) {
               for (const GSymbol& item : produce) {
                  if (!item.IsTerminal() && !(item.IsFormula() && Formula(item).IsUsed()) && !item.IsMaker()) {
                     yes_symbol = false; break;
                  }
               }
            } else { // empty
               if (produce.maker.IsNone()) { // !maker
                  yes_symbol = false; break;
               }
            }
            if (yes_symbol) {
               if (!formula->IsUsed()) {
                  formula->SetUsed();
                  change++;
               }
            }
         }
      }
      cycle++;
   } while (change && (cycle <= count() + 1));

   for (GFormula* formula : formulas) {
      if (formula->IsUsed()) {
         formula->ClearUsed();
      } else {
         formula->SetDeleted();
      }
   }

   return root && !root->IsDeleted();
}

// Green(v=1,p=171,a=2.8)
bool TGrammar::UnacceptableSymbols(int mode)
{
   formulas.root->SetUsed();

   TLexemeSet my_lexemes(this);

   int change;
   do {
      change = 0;
      for (GFormula* formula : formulas) {
         FORMULA_DELETED_CONTINUE(formula);
         if (!formula->IsUsed()) continue;
         for (const GProduce& produce : *formula) {
            for (const GSymbol& item : produce) {
               if (item.IsTerminal()) {
                  my_lexemes.Add(item);
               } else if (item.IsFormula()) {
                  GFormula* item_formula = formulas[item.formula];
                  if (!item_formula->IsUsed() && !item_formula->IsDeleted()) {
                     item_formula->SetUsed();
                     change++;
                  }
               } else if (item.IsMaker()) {
               }
            }
         }
      }
   } while (change);

   for (GFormula* formula : formulas) {
      if (formula->IsUsed()) {
         formula->ClearUsed();
      } else {
         formula->SetDeleted();
      }
   }
   lexemes = my_lexemes;

   return true;
}

// Green(v=1,p=171,a=2.9)
bool TGrammar::ExcessRemoval(int mode)
{
   if (formulas.empty() || !root || !NoEmptyLanguage()) return false;
   if (!UnacceptableSymbols()) return false;

   int new_formula = 0;
   std::vector<int> new_formulas(formulas.count(),0);
   for (const GFormula* formula : formulas) {
      if (!formula->IsDeleted()) {
         new_formulas[formula->head.formula] = new_formula++;
      }
   }

   GFormulaTable::iterator ip_formula = formulas.begin();
   while (ip_formula != formulas.end()) {
      GFormula& formula = *(*ip_formula);
      if (!formula.IsDeleted()) {
         new_formula = new_formulas[formula.head.formula];
         formula.head.formula = new_formula;
         formula.ClearUsed();
         GFormula::iterator ip_produce = formula.begin();
         int new_produce = 0;
         while (ip_produce != formula.end()) {
            GProduce& produce = *ip_produce;
            if (!produce.IsDeleted()) {
               produce.head.formula = new_formula;
               produce.head.produce = new_produce++;
               for (GSymbol& item : produce) {
                  if (item.IsFormula()) {
                     item.formula = new_formulas[item.formula];
                  }
               }
               ip_produce++;
            } else {
               ip_produce = (*ip_formula)->erase(ip_produce);
            }
         }
         ip_formula++;
      } else {
         ip_formula = formulas.erase(ip_formula);
      }
   }

   return true;
}

void TLookAhead::Add(const TElement& key)
{
   std::pair<TElement, TItem> item(key, TItem());
   map.insert(item); 
}

void TLookAhead::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   static char buffer[20] = {};
   int exp_count = 0, sym_count = 0;
   for (std::pair<const TElement&, const TItem&> item : map) {
      exp_count += (int)item.second.expansions.size();
      sym_count += item.second.symbols.count();
   }
   fprintf(file, "\n--- LookAhead --- <%d> --- <%d> --- <%d> ---\n", count(), exp_count, sym_count);
   if (print_mode == T_PrintMode::pmNone) return;
   if (print_mode & T_PrintMode::pmSortMode) {
      for (std::pair<const TElement&, const TItem&> item : map) {
         const GSymbolSet& syms = item.second.symbols;
      	fprintf(file, "\n--- ");
         syms.print(grammar, T_PrintMode::pmNone,file);
      }
      for (std::pair<const TElement&, const TItem&> item : map) {
         fprintf(file, "\n--> ");
         for (const TElement& exp : item.second.expansions) {
            exp.print(grammar, T_PrintMode::pmSimplePara, file);
         }
      }
   } else {
      for (std::pair<const TElement&, const TItem&> item : map) {
         const TElement& key = item.first;
      	fprintf(file, "\n");
         key.print(grammar, T_PrintMode::pmCompact,file);
         if (item.second.symbols.count()) {
      	   fprintf(file, "\n--- ");
            item.second.symbols.print(grammar, T_PrintMode::pmNone,file);
         }
         if (item.second.expansions.size()) {
      	   fprintf(file, "\n--> ");
            for (const TElement& exp : item.second.expansions) {
               exp.print(grammar, T_PrintMode::pmSimplePara, file); fprintf(file, " ");
            }
         }
      }
   }
   fprintf(file, "\n");
   if (title) {
      fclose(file);
   }
}

void TLookAhead::TElement::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   fprintf(file, "{");
   situation.print(grammar, T_PrintMode::pmCompact, file);
   fprintf(file, ",");
   para.print(grammar, T_PrintMode::pmSimplePara, file);
   fprintf(file, "}");
}

int not_find = 0, count_empty = 0, shift_count = 0, reduce_count = 0, goto_count = 0, equ_count = 0;
int delete_count = 0, empty_count = 0, add_count = 0;

class T_GOTO_CtoAa : public TParaSet
{
public:
   T_GOTO_CtoAa(TGrammarBuilder* g_b, const TParaSet& I, const GSymbol& X, A_Syntax::T_SyntaxMode mode);
public:
   TGrammarBuilder* builder;
};

T_GOTO_CtoAa::T_GOTO_CtoAa(TGrammarBuilder* g_b, const TParaSet& I, const GSymbol& X, A_Syntax::T_SyntaxMode mode) :TParaSet(g_b->grammar), builder(g_b)
{
   TClosureAdded& Added = grammar->builder->Added;
   Added.Next();
   for (const TPara& para_B : I) {
      if ((I.mode > 0) && (para_B.sym.value <= I.mode)) continue;
      const GProduce& produce_B = grammar->Produce(para_B); // [B -> gamma . ? delta, b ]
      if (para_B.point < produce_B.count()) {
         const GSymbol& sym_B = produce_B[para_B.point];
         if (sym_B == X) {  // [B -> gamma . X delta, b ]
            TPara shift_para(para_B); produce_B.Shift(shift_para);
            (*this) << shift_para;
         }
         if (sym_B.IsFormula()) { // [B -> gamma . C delta, b ]
            const GSymbol& C = sym_B;
            Tc2a& C_A = builder->CtoAa.Get(C);
            const TAmus& tails = C_A.Get(X);
            if (tails.empty()) continue;

            TFirst first_delta_b;
            if (mode != A_Syntax::smParseLR0_Core) {
               TBTailItem* delta = builder->CtoAa.point_tails.Get(para_B);
               if (!delta->delta.empty()) {
                  first_delta_b = delta->delta;
               }
               if (!delta->half.empty()) {
                  first_delta_b << para_B.sym; // b
               }
            }

            for (std::pair<const GSymbol&, const TAmu&> item_mu : tails) {
               const TAmu& tail = item_mu.second;
               GSymbol para(GSymbol::gsPara, tail.point.formula, tail.point.produce, tail.point.point + 1);
               if (mode == A_Syntax::smParseLR0_Core) {
                  (*this) << TPara(para);
               } else {
                  // [ A -> X . beta , ?]
                  if (!tail.half.empty()) {
                     for (const GSymbol& a : first_delta_b) {
                        (*this) << TPara(para, a);
                     }
                  }
                  if (tail.step != Added.Current()) {
                     for (const GSymbol& a : tail.mu) {
                        (*this) << TPara(para, a);
                     }
                  } else {
                     count_empty++;
                  }
                  tail.step = Added.Current();
               }
            }
         }
      }
   }
}

void TGrammarBuilder::make_ActionC2Aa(const TSituationMap& stable, const GSymbol& situation, A_Syntax::T_SyntaxMode mode)
{
   const TParaSet& situation_items = *stable.Get(situation);
   for (const TPara& para_B : situation_items) { // [B -> gamma . ? delta, b ]
      const GProduce& produce_B = grammar->Produce(para_B);
      if (para_B.point < produce_B.count()) {
         const GSymbol& sym_B = produce_B[para_B.point];
         if (sym_B.IsFormula()) { // [B -> gamma . C delta, b ]
            const GSymbol& C = sym_B;
            Tc2a& C_A = CtoAa.Get(C);
            for (const GSymbol& a : C_A.terminals) {
               MTableKey key(situation,a);
               const GSymbol& I_j = GOTOtable.Find(key);
               if (I_j.IsSituation()) {
                  TAction action(TAction::taShift,I_j);
                  int before = LRtable.count();
                  LRtable.Add(key,action);
                  if (before == LRtable.count()) equ_count++; else shift_count++;
               } else {
                  not_find++;
               }
            }

            const TAmus& tails = C_A.Get(GSymbol::empty);
            TFirst first_delta_b;
            if ((mode == A_Syntax::smParseLR1_Core) && !tails.empty()) {
               TBTailItem* delta = CtoAa.point_tails.Get(para_B);
               if (!delta->delta.empty()) {
                  first_delta_b = delta->delta;
               }
               if (!delta->half.empty()) {
                  first_delta_b << para_B.sym; // b
               }
            }

            for (std::pair<const GSymbol&, const TAmu&> item_mu : tails) {
               const TAmu& tail = item_mu.second;
               TFirst first_mu_A;
                if (mode == A_Syntax::smParseLR0_Core) {
                   first_mu_A = (TFirst&)Follow(GSymbol(GSymbol::gsFormula,tail.point.formula));
                } else {
                   first_mu_A.Plus(tail.mu, first_delta_b);
                }
                GSymbol A(GSymbol::gsProduce,tail.point.formula,tail.point.produce);
                const GProduce& produce_A = grammar->Produce(A);
                TAction action(TAction::taReduce,produce_A.head);
                for (const GSymbol& a : first_mu_A) {
                   MTableKey key(situation,a); key.sym.value = 0;
                   int before = LRtable.count();
                   LRtable.Add(key,action);
                   if (before == LRtable.count()) equ_count++; else reduce_count++;
                }
             }
         } else if (sym_B.IsTerminal()) {
            MTableKey key(situation,sym_B); key.sym.value = 0;
            const GSymbol& I_j = GOTOtable.Find(key);
            if (I_j.IsSituation()) {
               TAction action(TAction::taShift,I_j);
               int before = LRtable.count();
               LRtable.Add(key,action);
               if (before == LRtable.count()) equ_count++; else shift_count++;
            } else {
               not_find++;
            }
         }
      }
      if ((para_B.point == produce_B.count()) || produce_B.IsEmpty()) {
         if (produce_B.head.IsStart()) {
            TAction action(TAction::taAccept,produce_B.head);
            MTableKey key(situation,GSymbol::eof);
            LRtable.Add(key,action);
         } else {
            TAction action(TAction::taReduce,produce_B.head);
            GSymbol A(GSymbol::gsFormula,produce_B.head.formula);
            TFirstFollow follow_A;
            if (mode == A_Syntax::smParseLR0_Core) {
               follow_A = Follow(A);
            } else {
               follow_A << para_B.sym;
            }
            for (const GSymbol& a : follow_A) {
               MTableKey key(situation,a); key.sym.value = 0;
               int before = LRtable.count();
               LRtable.Add(key,action);
               if (before == LRtable.count()) equ_count++; else reduce_count++;
            }
         }
      }
   }
}

void TGrammarBuilder::make_StateC2Aa(TSituationMap& stable, const GSymbol& situation, const GSymbol& X, A_Syntax::T_SyntaxMode mode)
{
   const TParaSet *I = stable.Get(situation);
   TParaSet *I_X = new T_GOTO_CtoAa(this,*I,X,mode);
   if (I_X->empty()) { delete I_X; delete_count++; empty_count++; return; }
   int before = stable.count();
   GSymbol go_to = stable.Add(I_X);
   if (before == stable.count()) {
      delete I_X;
      delete_count++;
   } else {
      add_count++;
   }
   MTableKey key(situation,X);
   GOTOtable.Add(key,go_to);
}

void TGrammarBuilder::make_StateC2Aa(TSituationMap& stable, const GSymbol& situation, A_Syntax::T_SyntaxMode mode)
{
   TParaSet *I = stable.Get(situation);
   I->mode = -1;
   int new_step = stable.step++;
   for (const GFormula* formula : grammar->formulas) {
      const GSymbol& X = formula->head;
      make_StateC2Aa(stable, situation, X, mode);
   }
   for (const std::pair<const GSymbol&, int> item : grammar->lexemes) {
      const GSymbol& X = item.first;
      make_StateC2Aa(stable, situation, X, mode);
   }
   I->mode = new_step;
}

bool TGrammarBuilder::make_C2Aa_LR(A_Syntax::T_SyntaxMode mode)
{
   CtoAa.Core();
   CtoAa.Split();
   Added.Init((mode == A_Syntax::smParseLR0_Core) ? 0 : 4);

   bool ret = true;

   {
   TPara S(GSymbol::gsPara);
   if (mode == A_Syntax::smParseLR1_Core) {
      S.sym = GSymbol::empty;
   }
   TParaSet* I = new TParaSet(grammar,S);
   Stable.Add(I);
   Stable.step++;
   }

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d,%05d",situation.situation,Stable.count(), (int)GOTOtable.size());
      }
      make_StateC2Aa(Stable, situation, mode);
   }
   CtoAa.Merge();
   printf("\n%05d,%05d",Stable.count(),GOTOtable.count());
   Stable.print(NULL,0x00);
   printf("\n--- GOTOtable --- <%d> ---\n",GOTOtable.count());

   LRtable.GOTO(GOTOtable);
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d",situation.situation, LRtable.count());
      }
      make_ActionC2Aa(Stable, situation, mode);
   }
   printf("\n%05d,%05d, not_find=%d, empty=%d, shift=%d, reduce=%d, goto=%d\n", Stable.count(), LRtable.count(), not_find, count_empty, shift_count, reduce_count, goto_count);

   ret = LRtable.verify(GOTOtable);

   return ret;
}

bool TGrammarBuilder::make_C2Aa_LALR()
{
   CtoAa.Core();
   Added.Init(4);
   CtoAa.Split();

   bool ret = true;
   LALRStable.yes_queue = true;

   {
   TPara S(GSymbol(GSymbol::T_Type::gsPara), GSymbol::empty);
   TParaSet* I = new TParaSet(grammar,S);
   LALRStable.Add(I);
   LALRStable.step++;
   }

   int step = 0;
   for (GSymbol situation; LALRStable.queue.Pop(situation); ) {
      if ((++step % 100) == 0) {
         printf("\n%05d,%05d,%05d",situation.situation,LALRStable.count(), (int)GOTOtable.size());
      }
      make_StateC2Aa(LALRStable, situation, A_Syntax::smParseLR1_Core);

   }
   CtoAa.Merge();
   printf("\n%05d,%05d",LALRStable.count(),GOTOtable.count());
   LALRStable.print(NULL,0x00);
   printf("\n--- GOTOtable --- <%d> ---\n",GOTOtable.count());

   int before = LRtable.count();
   LRtable.GOTO(GOTOtable);
   goto_count += (LRtable.count() - before);

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < LALRStable.count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d",situation.situation, LRtable.count());
      }
      make_ActionC2Aa(LALRStable, situation, A_Syntax::smParseLR1_Core);
   }
   printf("\n%05d,%05d, not_find=%d, empty=%d, shift=%d, reduce=%d, goto=%d, equ=%d\n", LALRStable.count(), LRtable.count(), not_find, count_empty, shift_count, reduce_count, goto_count, equ_count);

   Stable.Copy(LALRStable); // print

   ret = LRtable.verify(GOTOtable);

   return ret;
}

class TLink {
public:
   TLink() {}
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE *file = NULL) const;
public:
   GSymbolSet provides;
};

void TLink::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   provides.print(grammar, print_mode | T_PrintMode::pmCompactGroup, file); fprintf(file, "\n");
}

class TGrammarLink : public std::map<const GSymbol, TLink> {
public:
   TGrammarLink(const TGrammar* g) :grammar(g), maker_tree(0), maker_code(0), maker_node(0), maker_yacc(0), maker_turn(0) {}
   int Add(const GSymbol& used, const GSymbol& owner);
   void make();
   void print(const char* title, int print_mode) const;
   void print(FILE* file, int print_mode) const;
public:
   const TGrammar * grammar;
   GSymbolVector left, right;
   int maker_tree, maker_code, maker_node, maker_turn, maker_yacc;
};

int  TGrammarLink::Add(const GSymbol& used, const GSymbol& owner)
{
   int ret = 0;
   iterator ip = find(used);
   if (ip != end()) {
      TLink& item = (*ip).second;
      GSymbolSet& owners = item.provides;
      if (owners.Add(owner)) ret++;
   } else {
      std::pair<GSymbol, TLink> item; item.first = used;
      GSymbolSet& owners = item.second.provides;
      if (owners.Add(owner)) ret++;
      insert(item); ret++;
   }
   return ret;
}

void TGrammarLink::make()
{
   for (const GFormula* formula : grammar->formulas) {
      for (const GProduce& produce : *formula) {
         int p = 0;
         for (const GSymbol& item : produce) {
            GSymbol point(GSymbol::gsPoint, produce.head.formula, produce.head.produce, p);
            if (item.IsMaster()) {
               if (!p) left.Add(point); else right.Add(point);
            }
            if (item.IsMaker()) {
               if (item.IsMakerTree()) maker_tree++;
               if (item.IsMakerCode()) maker_code++;
               if (item.IsMakerNode()) maker_node++;
               if (item.IsMakerYACC()) maker_yacc++;
               if (item.IsMakerTurn()) maker_turn++;
            }
            Add(item, point);
            p++;
         }
         const GSymbol& maker = produce.maker;
         if (maker.IsMaker()) {
            if (maker.IsMakerTree()) maker_tree++;
            if (maker.IsMakerCode()) maker_code++;
            if (maker.IsMakerNode()) maker_node++;
            if (maker.IsMakerYACC()) maker_yacc++;
            if (maker.IsMakerTurn()) maker_turn++;
         }
      }
   }
}

void TGrammarLink::print(FILE* file, int print_mode) const
{
   GSymbol::T_Type old_type = GSymbol::T_Type::gsNone;
   for (std::pair<const GSymbol&, const TLink&> item : (*this)) {
      if (item.first.type != old_type) {
         old_type = item.first.type;
         fprintf(file, "-------- %s --------\n", symbol_title(old_type));
      }
      item.first.print(grammar, print_mode, file); fprintf(file, " -> %d\n", (int)item.second.provides.size());
      item.second.print(grammar, print_mode | T_PrintMode::pmCompactGroup, file);
      fprintf(file, "\n");
   }

   if (!left.empty()) {
      fprintf(file, "Lleft recursion: %d\n", (int)left.size());
      left.print(grammar, print_mode | T_PrintMode::pmCompactGroup, file); fprintf(file, "\n");
      if (!right.empty()) fprintf(file, "\n");
   }

   if (!right.empty()) {
      fprintf(file, "Right recursion: %d\n", (int)right.size());
      right.print(grammar, print_mode | T_PrintMode::pmCompactGroup, file); fprintf(file, "\n");
   }

   if (maker_tree || maker_code || maker_node || maker_turn || maker_yacc) {
      fprintf(file, "\nMakers: Tree(%d), Code(%d), Node(%d), YACC(%d), Turn(%d)\n", maker_tree, maker_code, maker_node, maker_yacc, maker_turn);
   }
}

void TGrammarLink::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   print(file, print_mode);
   if (title) {
      fclose(file);
   } else {
      fprintf(file, "\n");
   }

}

void TGrammar::output(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");

   fprintf(file, "Type:");
   char seporator = ' ';
   if (type & T_Grammar::gtLL         ) { fprintf(file, "%c LL"         , seporator); seporator = ','; }
   if (type & T_Grammar::gtLR         ) { fprintf(file, "%c LR"         , seporator); seporator = ','; }
   if (type & T_Grammar::slSyntax     ) { fprintf(file, "%c Syntax"     , seporator); seporator = ','; }
   if (type & T_Grammar::slPrior      ) { fprintf(file, "%c Prior"      , seporator); seporator = ','; }
   if (type & T_Grammar::slPriorAssign) { fprintf(file, "%c PriorAssign", seporator); seporator = ','; }
   if (type & T_Grammar::slSimple     ) { fprintf(file, "%c Simple"     , seporator); seporator = ','; }
   if (type & T_Grammar::slNoDefType  ) { fprintf(file, "%c NoDefType"  , seporator); seporator = ','; }
   if (type & T_Grammar::slNoDefArrVar) { fprintf(file, "%c NoDefArrVar", seporator); seporator = ','; }
   if (type & T_Grammar::slNoSave     ) { fprintf(file, "%c NoSave"     , seporator); seporator = ','; }
   if (type & (T_Grammar::mtTree | T_Grammar::mtCode | T_Grammar::mtSNode | T_Grammar::mtYacc | T_Grammar::mtTurn)) {
      fprintf(file, "%c Makers(", seporator); const char* seporator = "";
      if (type & T_Grammar::mtTree ) { fprintf(file, "%sTree" , seporator); seporator = ", "; }
      if (type & T_Grammar::mtCode ) { fprintf(file, "%sCode" , seporator); seporator = ", "; }
      if (type & T_Grammar::mtSNode) { fprintf(file, "%sNode" , seporator); seporator = ", "; }
      if (type & T_Grammar::mtYacc ) { fprintf(file, "%sYacc" , seporator); seporator = ", "; }
      if (type & T_Grammar::mtTurn ) { fprintf(file, "%sTurn" , seporator); seporator = ", "; }
      if (type & T_Grammar::mtEmpty) { fprintf(file, "%sEmpty", seporator); seporator = ", "; }
      if (type & T_Grammar::mtHead ) { fprintf(file, "%sHead" , seporator); seporator = ", "; }
      fprintf(file, ")");
   }
   fprintf(file, "\nPrefix: %s",prefix);
   fprintf(file, "\n");

   TGrammarLink link(this);
   link.make();
   fprintf(file, "\n--- Link --- <%d> ---\n\n", (int)link.size());
   link.print(file, T_PrintMode::pmCompact);

   if (title) {
      fclose(file);
   }
}

bool TGrammarBuilder::make_LALRTable()
{
   bool ret = make_LR0States(); // Stable, GOTOtable
   Stable.Basic();
   Stable.print(NULL,0x0000);

   true_count = 0; false_count = 0;

   {
   TFirstFollow FIRST(&grammar->FIRSTs); FIRST += GSymbol::sharp;
   grammar->FIRSTs.Add(GSymbol::sharp,FIRST);
   }

   bool start = true;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      const TParaSet *I = Stable.Get(situation);
      for (const TPara& para : *I) {
         TLookAhead::TElement key(situation,para);
         LookAhead.Add(key);
         if (start) { start = false; (*LookAhead.map.begin()).second.symbols.Add(GSymbol::eof); }
      }
   }

   Added.Init(1);
   int step = 0, para_count = 0, sym_count = 0;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      const TParaSet *I = Stable.Get(situation);
      if ((step % 100) == 0) {
         printf("\n%05d,%05d,%05d",step,para_count,sym_count);
      }
      step++;
      for (const TPara& A_ab : *I) {
         TLookAhead::TElement key_core(situation, A_ab);
         TLookAhead::TItem& item_from = LookAhead.Get(key_core);
         TPara sharp_para((GSymbol)A_ab, GSymbol::sharp);
         TParaSet P(grammar,sharp_para);
         T_CLOSURE_LR1 J(grammar,P);
         for (const TPara& B_gXd : J) {
            const GProduce& produce = grammar->Produce(B_gXd);
            if ((B_gXd.point < produce.count()) && !produce.IsEmpty()) {
               const GSymbol& X = produce[B_gXd.point];
               MTableKey key_goto(situation,X);
               const GSymbol& goto_X = GOTOtable.Find(key_goto); 
               TPara to_para(B_gXd); to_para.point++; to_para.sym = GSymbol::none;
               const TLookAhead::TElement key_to(goto_X, to_para);
               TLookAhead::TItem& to_item = LookAhead.Get(key_to);
               GSymbolSet& to_symbols = to_item.symbols;
               TLookAhead::TElement expansion(goto_X, to_para);
               if (B_gXd.sym == GSymbol::sharp) {
                  item_from.Add(expansion);
               } else {
                  to_symbols.Add(B_gXd.sym);
               }
               sym_count++;
            }
         }
         para_count++;
      }
   }
   printf("\n%05d,%05d,%05d\n",step,para_count,sym_count);
   printf("\ntrue_count=%d, false_count=%d, closure_count=%d\n",true_count, false_count, Added.Current());

   std::set<TLookAhead::TElement> queue;
   for (std::pair<const TLookAhead::TElement&, const TLookAhead::TItem&> item : LookAhead.map) {
      if (item.second.expansions.empty()) continue;
      queue.insert(item.first);
   }

   step = 0;
   while (!queue.empty()) {
      const TLookAhead::TElement queue_item = *queue.begin(); queue.erase(queue.begin());
      int all_work = 0;
      TLookAhead::TItem& from_item = LookAhead.Get(queue_item);
      const GSymbolSet& symbols = from_item.symbols;
      for (const TLookAhead::TElement& expansion : from_item.expansions) {
         TLookAhead::TElement key_to(expansion);
         TLookAhead::TItem& to_item = LookAhead.Get(key_to);
         GSymbolSet& to_symbols = to_item.symbols;
         int work = 0;
         for (const GSymbol sym : symbols) {
            if (to_symbols.Add(sym)) work++;
         }
         if (work && (queue.find(key_to) == queue.end())) {
            queue.insert(key_to);
         }
         all_work += work;
      }
      if ((step % 100) == 0) {
         printf("\n%05d,%05d", step, all_work);
      }
      step++;
   }
   printf("\n%05d\n", step);

   TSituationMap  LALRStable;
   step = 0;
   para_count = 0;
   true_count = 0; false_count = 0;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      if ((step % 100) == 0) {
         printf("\n%05d,%05d",step,para_count);
      }
      step++;
      const TParaSet *I = Stable.Get(situation);
      TParaSet LALR_I(grammar); 
      for (const TPara& A_ab : *I) {
         const TLookAhead::TElement key_core(situation, A_ab);
         const TLookAhead::TItem& item = LookAhead.Get(key_core);
         const GSymbolSet& symbols = item.symbols;
         for (const GSymbol sym : symbols) {
            TPara LALR_para((const GSymbol)A_ab, sym);
            LALR_I.Add(LALR_para);
         }
         para_count++;
      }

      T_CLOSURE_LR1* I_X = new T_CLOSURE_LR1(grammar,LALR_I);
      TParaSet *I_X_P = new TParaSet(grammar,LALR_I); TablePrint.Add(I_X_P);
      const GSymbol go_to = LALRStable.Add(I_X);
   }
   printf("\n%05d,%05d", step, para_count);
   printf("\ntrue_count=%d, false_count=%d, closure_count=%d", true_count, false_count, Added.Current());

   LALRStable.print(NULL,0x00);

   ret = make_LR1Table(LALRStable, 0x02); // go_to

   LRtable.print(0x00);
   Stable.Clear();
   Stable.Copy(LALRStable); // print
   LALRStable.Clear();

   ret = LRtable.verify(GOTOtable);

   return ret;
}

void TGrammarBuilder::make_ActionLR0(const TSituationMap& stable, const GSymbol& situation)
{
   const TParaSet& situation_items = *stable.Get(situation);
   for (const GSymbol& para : situation_items) {
      const GProduce& produce = grammar->Produce(para);
      if (para.point < produce.count()) {
         const GSymbol& a = produce[para.point];
         if (a.IsTerminal()) {
            MTableKey key(situation,a);
            const GSymbol& I_j = GOTOtable.Find(key);
            if (I_j.IsSituation()) {
               TAction action(TAction::taShift,I_j);
               int before = LRtable.count();
               LRtable.Add(key,action);
               if (before == LRtable.count()) equ_count++; else shift_count++;
            } else {
               not_find++;
            }
         }
      }
      if ((para.point == produce.count()) || produce.IsEmpty()) {
         if (produce.head.IsStart()) {
            TAction action(TAction::taAccept,produce.head);
            MTableKey key(situation,GSymbol::eof);
            LRtable.Add(key,action);
         } else {
            TAction action(TAction::taReduce,produce.head);
            GSymbol A(GSymbol::gsFormula,produce.head.formula);
            const TFirstFollow& follow_A = Follow(A);
            for (const GSymbol& a : follow_A) {
               MTableKey key(situation,a);
               int before = LRtable.count();
               LRtable.Add(key,action);
               if (before == LRtable.count()) equ_count++; else reduce_count++;
            }
         }
      }
   }
   for (const GFormula* formula : grammar->formulas) {
      const GSymbol& A = formula->head;
      if (A.IsStart()) continue;
      MTableKey key(situation,A);
      const GSymbol& I_j = GOTOtable.Find(key);
      if (I_j.IsSituation()) {
         TAction action(TAction::taGoto,I_j);
         int before = LRtable.count();
         LRtable.Add(key,action);
         if (before == LRtable.count()) equ_count++; else goto_count++;
      } else {
         not_find++;
      }
   }
}

void TGrammarBuilder::make_StateLR0(const GSymbol& situation, const GSymbol& X)
{
   const TParaSet *I = Stable.Get(situation);
   TParaSet *I_X = new T_GOTO(grammar,*I,X);
   if (I_X->empty()) { delete I_X; delete_count++; empty_count++; return; }
   int before = Stable.count();
   const GSymbol go_to = Stable.Add(I_X);
   if (before == Stable.count()) {
      delete I_X;
      delete_count++;
   } else {
      add_count++;
   }
   MTableKey key(situation,X);
   GOTOtable.Add(key,go_to);
}

void TGrammarBuilder::make_StateLR0(const GSymbol& situation)
{
   const TParaSet *I = Stable.Get(situation);
   if (I->count() > (grammar->lexemes.count() + grammar->formulas.count())) {
      for (const GFormula* formula : grammar->formulas) {
         const GSymbol& X = formula->head;
         make_StateLR0(situation, X);
      }
      for (const std::pair<const GSymbol&, int> item :  grammar->lexemes) {
         const GSymbol& X = item.first;
         make_StateLR0(situation, X);
      }
   } else {
      GSymbolSet symbols;
      for (const TPara& para : *I) {
         const GProduce& produce = grammar->Produce(para);
         if (para.point < produce.count()) {
            const GSymbol& sym_B = produce[para.point];
            if (sym_B.IsTerminal() || sym_B.IsFormula()) { 
               symbols << sym_B;
            }
         }
      }
      for (const GSymbol& X : symbols) {
         make_StateLR0(situation, X);
      }
   }
}

bool TGrammarBuilder::make_LR0States()
{
   bool ret = true;
   Added.Init(0);

   {
   TPara S(GSymbol::gsPara);
   TParaSet I(grammar,S);
   T_CLOSURE* J = new T_CLOSURE(grammar,I);
   Stable.Add(J);
   }

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d",situation.situation);
      }
      make_StateLR0(situation);
   }
   printf("\n%05d, delete=%d, empty=%d, add=%d, true_count=%d, false_count=%d, closure_count=%d",Stable.count(),delete_count, empty_count, add_count, true_count, false_count, Added.Current());
   Stable.print(NULL,0x0000);
   printf("\n--- GOTOtable --- <%d> ---\n", (int)GOTOtable.size());
   return ret;
}

bool TGrammarBuilder::make_LR0Table()
{
   bool ret = make_LR0States();

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d",situation.situation, LRtable.count());
      }
      make_ActionLR0(Stable, situation);
   }
   printf("\n%05d,%05d, not_find=%d, empty=%d, shift=%d, reduce=%d, goto=%d\n", Stable.count(), LRtable.count(), not_find, count_empty, shift_count, reduce_count, goto_count);
   TablePrint.Copy(Stable); // print
   LRtable.print(0x00);
   
   ret = LRtable.verify(GOTOtable);

   return ret;
}

void TGrammarBuilder::make_StateLR1(TSituationMap& stable, const GSymbol& situation, const GSymbol& X)
{
   const TParaSet *I = stable.Get(situation);
   TParaSet *I_X = new T_GOTO_LR1(grammar,*I,X);
   if (I_X->empty()) { delete I_X; delete_count++; empty_count++; return; }
   int before = stable.count();
   const GSymbol go_to = stable.Add(I_X);
   if (before == stable.count()) {
      delete I_X;
      delete_count++;
   } else {
      add_count++;
   }
   MTableKey key(situation,X);
   GOTOtable.Add(key,go_to);
}

void TGrammarBuilder::make_StateLR1(TSituationMap& stable, const GSymbol& situation)
{
   const TParaSet *I = stable.Get(situation);
   if (I->count() > (grammar->lexemes.count() + grammar->formulas.count())) {
      for (const GFormula* formula : grammar->formulas) {
         const GSymbol& X = formula->head;
         make_StateLR1(stable, situation, X);
      }
      for (const std::pair<const GSymbol&, int> item : grammar->lexemes) {
         const GSymbol& X = item.first;
         make_StateLR1(stable, situation, X);
      }
   } else {
      GSymbolSet symbols;
      for (const TPara& para : *I) {
         const GProduce& produce = grammar->Produce(para);
         if (para.point < produce.count()) {
            const GSymbol& sym_B = produce[para.point];
            if (sym_B.IsTerminal() || sym_B.IsFormula()) { 
               symbols << sym_B;
            }
         }
      }
      for (const GSymbol& X : symbols) {
         make_StateLR1(stable, situation, X);
      }
   }
}

void TGrammarBuilder::make_ActionLR1(TSituationMap& stable, const GSymbol& situation, int mode)
{
   const TParaSet& situation_items = *stable.Get(situation);
   bool basic = mode & 0x01, go_to = (mode & 0x02) != 0, make_go_to = (mode & 0x08) != 0;
   for (const TPara& para : situation_items) {
      const GProduce& produce = grammar->Produce(para);
      if (para.point < produce.count()) {
         const GSymbol& a = produce[para.point];
         if (a.IsTerminal()) {
            MTableKey key(situation,a);
            GSymbol I_j;
            if (go_to) {
               I_j = GOTOtable.Find(key);
            } else {
               T_GOTO_LR1 I_A(grammar,situation_items,a);
               if (!I_A.empty()) {
                  if (basic) I_A.Basic();
                  I_j = stable.Find(I_A);
               } else {
                  count_empty++;
               }
            }
            if (I_j.IsSituation()) {
               TAction action(TAction::taShift,I_j);
               int before = LRtable.count();
               LRtable.Add(key,action);
               if (before == LRtable.count()) equ_count++; else shift_count++;
               if (make_go_to) {
                  GOTOtable.Add(key,I_j);
               }
            } else {
               not_find+=go_to?-1:1;
            }
         }
      }
      if ((para.point == produce.count()) || produce.IsEmpty()) {
         if (produce.head.IsStart()) {
            TAction action(TAction::taAccept,produce.head);
            MTableKey key(situation,GSymbol::eof);
            LRtable.Add(key,action);
         } else {
            TAction action(TAction::taReduce,produce.head);
            const GSymbol& a = para.sym;
            MTableKey key(situation,a);
            int before = LRtable.count();
            LRtable.Add(key,action);
            if (before == LRtable.count()) equ_count++; else reduce_count++;
         }
      }
   }
   for (const GFormula* formula : grammar->formulas) {
      const GSymbol& A = formula->head;
      if (A.IsStart()) continue;
      MTableKey key(situation,A);
      GSymbol I_j;
      if (go_to) {
         I_j = GOTOtable.Find(key);
      } else {
         T_GOTO_LR1 I_A(grammar,situation_items,A);
         if (I_A.empty()) {
            count_empty++;
            continue;
         }
         if (basic) I_A.Basic();
         I_j = stable.Find(I_A);
      }
      if (I_j.IsSituation()) {
         TAction action(TAction::taGoto,I_j);
         int before = LRtable.count();
         LRtable.Add(key,action);
         if (before == LRtable.count()) equ_count++; else goto_count++;
         if (make_go_to) {
            GOTOtable.Add(key,I_j);
         }
      } else {
         not_find+=go_to?-1:1;
      }
   }
}

bool TGrammarBuilder::make_LR1Table(TSituationMap& stable, int mode)
{
   bool ret = true;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < stable.count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d",situation.situation, LRtable.count());
      }
      const TParaSet& situation_items = *stable.Get(situation);
      make_ActionLR1(stable, situation, mode);
   }
   printf("\n%05d,%05d, not_find=%d, empty=%d, shift=%d, reduce=%d, goto=%d, equ=%d\n", stable.count(), LRtable.count(), not_find, count_empty, shift_count, reduce_count, goto_count, equ_count);

   return ret;
}

bool TGrammarBuilder::make_LR1States()
{
   bool ret = true;
   Added.Init(1);

   {
   const GSymbol eof(GSymbol::gsEof);
   TPara S(GSymbol(GSymbol::T_Type::gsPara),eof);
   TParaSet I(grammar,S);
   T_CLOSURE_LR1* J = new T_CLOSURE_LR1(grammar,I);
   Stable.Add(J);
   }

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d,%05d",situation.situation,Stable.count(), (int)GOTOtable.size());
      }
      make_StateLR1(Stable, situation);
   }
   printf("\n%05d,%05d",Stable.count(),GOTOtable.count());
   Stable.print(NULL,0x00);
   printf("\n--- GOTOtable --- <%d> ---\n",GOTOtable.count());

   return ret;
}

bool TGrammarBuilder::make_LR1Table()
{
   bool ret = true;

   ret = make_LR1States();
   ret = make_LR1Table(Stable, 0x02); // go_to
   TablePrint.Copy(Stable); // print
   LRtable.print(0x00);

   ret = LRtable.verify(GOTOtable);

   return ret;
}

bool TGrammarBuilder::make_LALR_FullTable(A_Syntax::T_SyntaxMode syntax_mode)
{
   bool ret = true;

   ret = make_LR1States(); // Stable, GOTOtable

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      const TParaSet* item = Stable.Get(situation);
      TParaSet* core = item->Core();
      COREtable.Add(core, situation.situation);
   }
   const TCoreArr& core_arr = COREtable.Core();

   std::vector<int> move; move.resize(Stable.count(),-1);
   GSymbol situation(GSymbol::gsSituation);

   for (const TCoreArrItem &core : core_arr) {
      TParaSet *I = new TParaSet(grammar);
      for (int item : core) {
         situation.situation = item;
         (*I) << *Stable.Get(situation); move[situation.situation] = LALRStable.count();
      }
      LALRStable.Add(I);
   }

   for (int i = 0; i < (int)move.size(); i++) {
      if (move[i] < 0) {
         situation.situation = i; move[situation.situation] = LALRStable.count();
         LALRStable.Add(new TParaSet(grammar, *Stable.Get(situation)));  
      }
   }

   if (syntax_mode == A_Syntax::smParseLALR_Full) {
      GOTOtable.clear(); // print
      ret = make_LR1Table(LALRStable, 0x08); // make_go_to
   } else {
      MTableMap  old_GOTOtable(GOTOtable);
      GOTOtable.clear();
      for (const std::pair<const MTableKey&,const GSymbol&> item : old_GOTOtable) {
         MTableKey key = item.first; key.produce.situation = move[key.produce.situation];
         GSymbol go_to = item.second; go_to.situation = move[go_to.situation];
         GOTOtable.Add(key,go_to);
      }
   
      ret = make_LR1Table(LALRStable, 0x02); // goto
   }

   Stable.Clear();
   Stable.Copy(LALRStable); // print
   LALRStable.Clear();
   LRtable.print(0x00);

   ret = LRtable.verify(GOTOtable);

   return ret;
}

#include "GrammarCFG.h"

//#define TABLE_WRITE
//#define TABLE_READ
//#define YACC_WRITE
//#define MACRO_WRITE
//#define PROG_WRITE

//#define YACC_SYNTREE
//#define TURN_MAKE

// 0x0100 - YACC_SYNTREE SyntaxTree, 0x0200 - union { lexeme, node }
char* get_file_name(const char*file, const char* ext);

bool TGrammarBuilder::Analyze(A_Syntax::T_SyntaxMode syntax_mode, const char* file)
{
   return true;
}

bool TGrammarBuilder::Make(A_Syntax::T_SyntaxMode syntax_mode, const char* file)
{
   bool ret = true;
   char *file_state = NULL, *file_action = NULL, *file_cell = NULL, *file_goto = NULL, 
        *file_C2A   = NULL, *file_core   = NULL, *file_look = NULL, *file_cpp    = NULL;

   look_ahead = grammar->look_ahead;

   if ((syntax_mode >= A_Syntax::smParseLR0) && (syntax_mode <= A_Syntax::smParseLALR_Core)) {
      if (syntax_mode == A_Syntax::smParseLR0) {
         if (look_ahead > 0) {
            make_SLRkTable(look_ahead);
         } else {
            make_LR0Table();
//            make_SLRkTable(0);
         }
      } else if (syntax_mode == A_Syntax::smParseLR1) {
         if (look_ahead > 0) {
            if (grammar->option & TGrammar::opSplitting) {
               make_GrammarSplitting(look_ahead);
            } else {
               make_LRkTable(look_ahead);
               if (grammar->option & (TGrammar::opFiUnattainable | TGrammar::opChainRule)) {
                  make_FiUnattainable(look_ahead);
               }
            }
         } else {
            make_LR1Table();
         }
      } else if (syntax_mode == A_Syntax::smParseLR0_Core) {
//         make_C2Aa_LR(syntax_mode);
         make_LR0Core();
      } else if (syntax_mode == A_Syntax::smParseLR1_Core) {
         if (look_ahead > 0) {
            make_LRkCore(look_ahead);
         } else {
            make_C2Aa_LR(syntax_mode);
         }
      } else if (syntax_mode == A_Syntax::smParseLALR) {
         if (look_ahead > 0) {
            make_LALRkTable(look_ahead);
         } else {
            make_LALRTable();
         }
      } else if (syntax_mode == A_Syntax::smParseLALR_Core) {
         if (look_ahead > 0) {
            make_LALRkCore(look_ahead);
         } else {
            make_C2Aa_LALR();
         }
      } else { // smParseLALR_Tab | smParseLALR_Full
         if (look_ahead > 0) {
            make_LALRk_FullTable(syntax_mode, look_ahead);
         } else {
            make_LALR_FullTable(syntax_mode);
         }
      }
      if (grammar->option & TGrammar::POption::opCompression) {
         LRtable.Compression();
      }
      if (LRtable.duplicate) printf("\nDuplicate: %d\n", LRtable.duplicate);
      if (LRtable.warning) printf("\nWarning: %d\n", LRtable.warning);
//      if (Stable.invalid) printf("\nInvalid: %d\n", Stable.invalid);
      grammar->grammar_type();
      grammar->write_LR(file, T_PrintMode::pmWriteSimple);
      int option_state = 0x0000, option_action = 0x0000;
      if (grammar->option & TGrammar::POption::opTable) {
         file_cpp = get_file_name(file,"cpp");
         grammar->write_LR(file_cpp, T_PrintMode::pmWriteProg);
      }
      if (grammar->option & TGrammar::POption::opEof2Empty) {
         option_state |= T_PrintMode::pmEofToEmpty; option_action |= T_PrintMode::pmEofToEmpty;
      }
      if (grammar->option & TGrammar::POption::opState) {
         option_state |= T_PrintMode::pmCompactGroup; // compact
         if (!(grammar->option & TGrammar::POption::opStateSort)) option_state |= T_PrintMode::pmSortMode;
         if   (grammar->option & TGrammar::POption::opStateCore)  option_state |= T_PrintMode::pmBasic;
      }
      if (option_state) {
         file_state  = get_file_name(file,"state");
         Stable.print(file_state,option_state);
         option_state |= T_PrintMode::pmCompactGroup | T_PrintMode::pmSortMode | T_PrintMode::pmBasic;
         if (TablePrint.count()) {
            file_core  = get_file_name(file,"core");
            if (grammar->option & TGrammar::opSplitting) option_state &= ~T_PrintMode::pmBasic;
            TablePrint.print(file_core, option_state);
         } else if (COREtable.count()) {
            file_core  = get_file_name(file,"core");
            COREtable.print(file_core, option_state );
            }
         }
      Stable.Clear(); TablePrint.Clear(); COREtable.Clear();
      if (grammar->option & TGrammar::POption::opAction) {
         file_action = get_file_name(file,"action");
         LRtable.print(file_action, T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem | option_action);
      }
      if (GOTOtable.count() && (grammar->option & TGrammar::POption::opGoTo)) {
         file_goto = get_file_name(file,"goto");
         GOTOtable.print(file_goto, T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
      }
      if (CtoAa.size() && (grammar->option & TGrammar::POption::opC2A)) {
         file_C2A = get_file_name(file,"c2a");
         CtoAa.print(file_C2A,grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmSortMode | T_PrintMode::pmCompact);
      }
      if (LookAhead.count() && (grammar->option & TGrammar::POption::opAhead)) {
         file_look = get_file_name(file,"look");
         LookAhead.print(file_look, T_PrintMode::pmCompact);
      }
   } else if (syntax_mode == A_Syntax::smParseLL1) {
      if (look_ahead > 0) {

         int invalid = grammar->ValidLLk();
         if (invalid) printf("\nInvalid: %d\n", invalid);

         make_LLkTable(look_ahead);
      } else {
         make_LL1Table();
      }
      grammar->grammar_type();
      grammar->write_LL(file, T_PrintMode::pmWriteSimple);
      if (grammar->option & TGrammar::POption::opCell) {
         file_cell = get_file_name(file,"cell");
         Mtable.print(file_cell, T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem | ((grammar->option & TGrammar::POption::opEof2Empty) ? T_PrintMode::pmEofToEmpty : T_PrintMode::pmNone));
      }
      if (grammar->option & TGrammar::POption::opTable) {
         file_cpp = get_file_name(file,"cpp");
         grammar->write_LL(file_cpp, T_PrintMode::pmWriteProg);
      }
   }
   if (file_state)  free(file_state);
   if (file_action) free(file_action);
   if (file_cell)   free(file_cell);
   if (file_cpp)    free(file_cpp);
   if (file_goto)   free(file_goto);
   if (file_core)   free(file_core);
   if (file_look)   free(file_look);
   if (file_C2A)    free(file_C2A);
   return ret;
}

bool TGrammarBuilder::make()
{
   bool ret = true;
   int print_state = T_PrintMode::pmCompactGroup | T_PrintMode::pmSortMode;

   grammar->make_FIRSTs();
   grammar->FIRSTs.print("FIRSTs.txt", "FIRSTs", T_PrintMode::pmSpaces | T_PrintMode::pmMultiLine | T_PrintMode::pmOffset);

   grammar->make_FOLLOWs();
   grammar->FOLLOWs.print("FOLLOWs.txt", "FOLLOWs", T_PrintMode::pmSpaces | T_PrintMode::pmMultiLine | T_PrintMode::pmOffset);

#if defined(PARSE_LR0) || defined(PARSE_LR1) || defined(PARSE_LALR)
   true_count = 0, false_count = 0;
   #if defined(PARSE_LR0)
      make_LR0Table();
   #elif  defined(PARSE_LR1)
      make_LR1Table();
   #elif  defined(PARSE_LALR)
      make_LALRTable();
//      make_C2Aa_LR(A_Syntax::smParseLR0_Core);
//      make_C2Aa_LR(A_Syntax::smParseLR1_Core);
//      make_C2Aa_LALR();
//      CtoAa.print("CtoAa.txt",grammar,print_state | T_PrintMode::pmCompact);
//      make_LALR_FullTable(A_Syntax::smParseLALR_Full);
//      make_LALR_FullTable(A_Syntax::smParseLALR_Tab);
//      LALRStable.print("state_table_LALR.LR0",T_PrintMode::pmCompactGroup);

   #endif
   printf("\ntrue_count=%d, false_count=%d, closure_count=%d, level=%d\n",true_count, false_count, Added.Current(), max_level);
   #if defined(TABLE_WRITE)
      #if defined(PARSE_LR0)
         LRtable.print("table_R0.txt", T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
         LRtable.write("def_rule_R0.txt", T_PrintMode::pmWriteSimple);
         grammar->formulas.write("formula_R0.txt", T_PrintMode::pmWriteSimple);
         Stable.print("state_table_R0.txt", print_state);
      #elif  defined(PARSE_LR1)
         LRtable.print("table_R1.txt", T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
         LRtable.write("def_rule_R1.txt", T_PrintMode::pmWriteSimple);
         grammar->formulas.write("formula_R1.txt", T_PrintMode::pmWriteSimple);
         Stable.print("state_table_R1.txt", print_state);
      #elif  defined(PARSE_NLR)
         LRtable.print("table_NR.txt", T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
         LRtable.write("def_rule_NR.txt", T_PrintMode::pmWriteSimple);
         grammar->formulas.write("formula_NR.txt", T_PrintMode::pmWriteSimple);
         Stable.print("state_table_NR.txt", print_state | T_PrintMode::pmBasic);
      #elif  defined(PARSE_LALR)
         LRtable.print("table_LALR.txt", T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
         LRtable.write("def_rule_LALR.txt", T_PrintMode::pmWriteSimple);
         grammar->formulas.write("formula_LALR.txt", T_PrintMode::pmWriteSimple);
         Stable.print("state_table_LALR.txt", print_state);
      #endif
      if (GOTOtable.count()) GOTOtable.print("GOTOtable.txt", T_PrintMode::pmPrintItem);
      if (TablePrint.count()) TablePrint.print("state_table.core", print_state | T_PrintMode::pmBasic); // 0x0D00
      if (COREtable.count()) COREtable.print("COREtable.txt", print_state | T_PrintMode::pmBasic);
   #endif
//   LRtable.print("table_R0.txt", 0x0201);
//   Stable.print("state_table_R0.txt",T_PrintMode::pmCompactGroup | T_PrintMode::pmSortMode);
   LRtable.print(NULL,0x00);
   Stable.Clear();
   if (LRtable.duplicate) printf("\nDuplicate: %d\n", LRtable.duplicate);
   if (LRtable.warning) printf("\nWarning: %d\n", LRtable.warning);
#elif  defined(PARSE_LL) || defined(PARSE_NLL)
//      make_LR1Table();
//      LRtable.print("table_R1.txt", T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
//      LRtable.write("def_rule_R1.txt",T_PrintMode::pmWriteSimple);
//      grammar->formulas.write("formula_R1.txt",T_PrintMode::pmWriteSimple);
//      Stable.print("state_table_R1.txt",print_state);
//      grammar->write_LR("NL_change_R1.tab",T_PrintMode::pmWriteSimple);
      make_MTable();
      grammar->write_LL("NL_change_LL.tab", T_PrintMode::pmWriteSimple);
   #if defined(TABLE_WRITE)
      Mtable.write("def_rule_LL.txt", T_PrintMode::pmWriteSimple);
      Mtable.print("state_table_LL.txt", T_PrintMode::pmPrintItem);
      grammar->formulas.write("formula_LL.txt", T_PrintMode::pmWriteSimple);
   #endif
#endif

   return ret;
}

bool TGrammar::make(const GMakerTable* makers)
{
   bool ret = true;
   this->makers = makers;
   root = formulas.front();
   make_produces();
   make();
   return ret;
}

bool TGrammar::Make(int type, A_Syntax::T_SyntaxMode syntax_mode, M_Syntax::M_Mode make_mode_, const char* file)
{
   int def_rule_mode = ((type & 0xF00) >> 8); // 0 - LL, 1 - NL, 2 - LR, 3 - NR
   M_Syntax::M_Mode make_mode = (M_Syntax::M_Mode)(make_mode_ & 0x7);
   bool make_empty = !(make_mode_ & 0x08);
   bool ret = true;
   TGrammarBuilder my_builder(this, file);
   builder = &my_builder;

   Used();

   if (option & TGrammar::POption::opLexeme) {
      char *file_lexeme  = get_file_name(file,"lexeme");
      lexemes.print(file_lexeme, T_PrintMode::pmLexemePart);
      free(file_lexeme);
   }

   if ((option & TGrammar::POption::opMaker) && (make_mode != M_Syntax::mmNone)) {
      char *file_make  = get_file_name(file,"make");
      makers->print(file_make, T_PrintMode::pmMakerItem);
      free(file_make);
   }

   if (option & TGrammar::POption::opGrammar) {
      char *file_grammar = get_file_name(file,"grammar");
      print(file_grammar, T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup | ((option & TGrammar::opBNF) ? T_PrintMode::pmBNF : 0));
      free(file_grammar);
   }

   int filter = 0;
   if ((make_mode == M_Syntax::mmTree) || (make_mode == M_Syntax::mmCode)) {
      filter |= (GSymbol::Tree);
      if ((def_rule_mode != 2) || !(option & TGrammar::POption::opSplitting)) filter |= (GSymbol::Code); // LR !Code
   } else if ((make_mode == M_Syntax::mmNode) || (make_mode == M_Syntax::mmMade)) {
      filter |= (GSymbol::SNode | GSymbol::Yacc);
   } else if (make_mode == M_Syntax::mmTurn) {
      filter |= (GSymbol::Turn);
   }   
   filter_makers(filter);

   if (syntax_mode == A_Syntax::smParseYACC) {
      if (option & TGrammar::POption::opBNF) {
         BNF(file, T_PrintMode::pmBNF);
      } else {
         if ((make_mode == M_Syntax::mmNode) || (make_mode == M_Syntax::mmMade)) {
            YACC(file, T_PrintMode::pmYACCMode | T_PrintMode::pmYACCStack,"yy_sn_");
         } else {
            YACC(file, T_PrintMode::pmYACCMode,"yy_tc_");
         }
      }
   } else if (syntax_mode == A_Syntax::smParseFormula) { // DEFINE_GRAMMAR_(LL,NL)
      PROG(file,0x00);
   } else {
      if (syntax_mode >= A_Syntax::smParseLR0) {
         if (make_empty) {
            make_makers_empty();
         } else {
            make_makers_head();
         }
      }

      if (look_ahead > 0) {
         bool option_splitting = false;
         if ((syntax_mode == A_Syntax::smParseLR1) && (option & TGrammar::opSplitting) && (option & TGrammar::opSplittingAddition)) {
            option_splitting = true;
         }
         if (!option_splitting) {
            make_FIRST_ks(look_ahead);
            make_EFF_ks(look_ahead);
            make_FOLLOW_ks(look_ahead);
         }
      } else {
         make_FIRSTs();
         make_FOLLOWs();
      }
      if ((look_ahead > 0) && (syntax_mode == A_Syntax::smParseLL1)) {
         make_SIGMA_ks(look_ahead);
      }

      my_builder.Make(syntax_mode, file);

      int print_F_F_E = T_PrintMode::pmSpaces | T_PrintMode::pmMultiLine | T_PrintMode::pmOffset;
      if (option & TGrammar::POption::opFirst) {
         char *file_first = get_file_name(file, "first");
         FIRSTs.print(file_first, "FIRSTs", print_F_F_E); // 0x0702
         free(file_first);
      }
      if (option & TGrammar::POption::opFollow) {
         char *file_follow = get_file_name(file, "follow");
         FOLLOWs.print(file_follow, "FOLLOWs", print_F_F_E);
         free(file_follow);
      }
      if ((look_ahead > 0) && (option & TGrammar::POption::opEFF)) {
         char *file_eff = get_file_name(file, "eff");
         EFFs.print(file_eff, "EFFs", print_F_F_E);
         free(file_eff);
      }
   }

   if (option & TGrammar::POption::opFormula) {
      char *file_formula = get_file_name(file,"formula");
      print(file_formula, T_PrintMode::pmProduceHead | T_PrintMode::pmPrintItem); // 0x0203 
      free(file_formula);
   }
   if (option & TGrammar::POption::opOutput) {
      char *file_output = get_file_name(file, "output");
      output(file_output, 0x00);
      free(file_output);
   }

   return ret;
}

bool TGrammar::make()
{
   bool ret = true;
   TGrammarBuilder my_builder(this);
   builder = &my_builder;

   this->print("table_formula_", 0x03);
   Used();
   this->print("table_formula.txt", T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact); // 0x02010804

   lexemes.print("lexemes.txt", T_PrintMode::pmLexemePart);

   makers->print(0x00);
   
   change_group();
   this->print("table_group.txt", T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact); // 0x02010804

#if  defined(MACRO_WRITE)
   char* macro_file = NULL; 
   #if defined(PARSE_LR0) || defined(PARSE_LR1) || defined(PARSE_LALR)
      macro_file = "def_formula_LR.cpp";
   #elif  defined(PARSE_NLR)
      macro_file = "def_formula_NR.cpp";
   #elif  defined(PARSE_LL)
      macro_file = "def_formula_LL.cpp";
   #elif  defined(PARSE_NLL)
      macro_file = "def_formula_NL.cpp";
   #endif

   if (macro_file) {
      this->MACRO(macro_file, T_PrintMode::pmMacroMode);
   }
#endif
#if  defined(PROG_WRITE)
   #if  defined(PARSE_LL)
      this->PROG("rule_def_LL.prg",0x00000000);
   #elif  defined(PARSE_NLL)
      this->PROG("rule_def_NL.prg",0x00010000);
   #endif
#endif

   int filter = 0;
#if !defined(NO_GEN_MAKE)
   #if defined(YACC_SYNTREE)
      filter |= (GSymbol::SNode | GSymbol::Yacc);
   #elif defined(TURN_MAKE)
      filter |= (GSymbol::Turn);
   #else
      filter |= (GSymbol::Tree  | GSymbol::Code);
   #endif
#endif
   
//   filter = 0;
   filter_makers(filter);

#if defined(PARSE_LR0) || defined(PARSE_LR1) || defined(PARSE_NLR) || defined(PARSE_LALR) || defined(PARSE_NLL)
   #if defined(MAKER_RULE_EMPTY)
      make_makers_empty();
   #elif defined(MAKER_RULE_HEAD)
      make_makers_head();
   #endif
#endif
   this->print("table_formula", T_PrintMode::pmProduceHead | T_PrintMode::pmPrintItem); // 0x0203

#if defined(PARSE_GRAMMAR) && !defined(TABLE_READ) && !defined(YACC_WRITE) && !defined(MACRO_WRITE) && !defined(PROG_WRITE)
   #if defined(DEFINE_GRAMMAR_LL)
      make_Symple();
      Used();
      this->print("table_symple.txt", T_PrintMode::pmProduceHead | T_PrintMode::pmPrintItem); // 0x02010804
      this->print("table_symple", T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact); // 0x02010804
      make_Left();
      Used();
   #else
      Used();
   #endif
   this->print("table_left.txt", T_PrintMode::pmProduceHead | T_PrintMode::pmPrintItem); // 0x02010804
   this->print("table_left", T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact); // 0x02010804
   builder->make();
   #if defined(DEFINE_GRAMMAR_NL)
      verify_LL();
   #endif
   grammar_type();
   this->print(0x00);
#endif

#if defined(PARSE_LR0) || defined(PARSE_LR1) || defined(PARSE_NLR) || defined(PARSE_LALR)
   #if defined(TABLE_READ)
      #if defined(PARSE_LR0)
         LRtable.read("def_rule_R0.txt",0x01);
      #elif  defined(PARSE_LR1)
         LRtable.read("def_rule_R1.txt",0x01);
      #elif  defined(PARSE_NLR)
         LRtable.read("def_rule_NR.txt",0x01);
      #elif  defined(PARSE_LALR)
         LRtable.read("def_rule_LR.txt",0x01);
      #endif
   #elif !defined(TABLE_WRITE)
      LRtable = builder->LRtable;
   #endif
   LRtable.print(NULL,0x00);
#elif  defined(PARSE_LL)
   #if defined(TABLE_READ)
      Mtable.read("def_rule_LL.txt",0x00);
   #elif !defined(TABLE_WRITE) && !defined(YACC_WRITE) && !defined(MACRO_WRITE) && !defined(PROG_WRITE)
      Mtable = builder->Mtable;
   #endif
   Mtable.print(0x00);
#endif

#if  defined(YACC_WRITE)
   #if defined(PARSE_LR0) || defined(PARSE_LR1)
      this->YACC("rule_LR.y",0x00);
   #elif defined(PARSE_YACC)
      #if !defined(YACC_SYNTREE)
         this->YACC("rule_NR_TC.y",0x01000000,"yy_tc_");
      #else
         this->YACC("rule_NR_SN.y",0x01000100,"yy_sn_");
      #endif
   #elif defined(PARSE_LL)
      this->YACC("rule_NL.y",0x00,"yy_nl_");
   #endif
#endif

   return ret;
}

int T_Lexeme::YACC(FILE *file, T_Lexeme::T_Group group, int type, int mode)
{
   int len = 0;
   const char* title = group_title(group);
	fprintf(file, "%s", title);     len += (int)strlen(title);
   if ((group == grOper) || (group == grSeparator)) {
      title = lexeme_type_title((T_Symbol::T_Type)type);
   	fprintf(file, "_%s", title); len += (int)strlen(title) + 1;
   } else if (group == grReserv) {
   	title = lexeme_word_title((T_Lexeme::W_Type)type);
   	fprintf(file, "_%s", title); len += (int)strlen(title) + 1;
   } else if (group == grPriority) {
   	title = lexeme_priority_title((T_Symbol::T_Priority)type);
   	fprintf(file, "_%s", title); len += (int)strlen(title) + 1;
   } else if (group == grSyntax) {
   	title = lexeme_syntax_title((T_Lexeme::T_Syntax)type);
   	fprintf(file, "_%s", title); len += (int)strlen(title) + 1;
   } else {
   	fprintf(file, "_lexeme"); len += 7;
   }
   return len;
}

void tree_syn(int s, int &s1, int &s2, int &s3, int &s4, int &s5); 
int GSymbol::YACC(FILE *file, const TGrammar* grammar, int print_mode) const
{
   int len = 0;
   if (type == gsTerminal) {
      len += T_Lexeme::YACC(file,T_Lexeme::T_Group(group), lexeme_type, print_mode);
   } else if (type == gsFormula) {
      const GFormula& f = *grammar->formulas[formula];
      len += f.write_title(file);
   } else if (type == gsMaker) {
      len += print_maker(print_mode, file);
   } else if  (type == gsEmpty) {
      fprintf(file, "/* empty */");
   } else {
      const char* title = symbol_title(type);
	   fprintf(file, "%s", title); len += (int)strlen(title);
   }
   if (len && !(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
   return len;
}

void TLexemeSet::YACC(FILE *file, int print_mode) const
{
   for (const std::pair<const GSymbol&, int> item : *this) {
      const GSymbol& sym = item.first;
      if (print_mode & T_PrintMode::pmBNF) {
         if ((sym.group != T_Lexeme::grSyntax) && (sym.group != T_Lexeme::grIdent) && (sym.group != T_Lexeme::grInteger) && (sym.group != T_Lexeme::grNumber)) continue;
      }
      if (((grammar->option & TGrammar::POption::opAssociation) != 0) && (sym.group == T_Lexeme::grPriority)) {
         if ((sym.lexeme_type >= T_Symbol::prOrOr) && (sym.lexeme_type <= T_Symbol::prFactor)) {
            fprintf(file, "\n%%left  ");
         } else if (sym.lexeme_type == T_Symbol::prAssign) {
            fprintf(file, "\n%%right ");
         } else {
            fprintf(file, "\n%%token ");
         }
      } else {
         fprintf(file, "\n%%token ");
      }
      sym.YACC(file,grammar, print_mode);
      int token = (sym.group << 8) | sym.lexeme_type;
      fprintf(file, " %05d // %#06X",token,token);
   }
   fprintf(file, "\n"); 
}

void GMakerTable::YACC(FILE *file, int print_mode) const
{
   fprintf(file, "\nenum class T_Maker { ");
   int m = 0;
   for (const GMaker* maker : *this) {
      if (m) fprintf(file, ", ");
      if (m && !(m % 8)) fprintf(file, "\n                     ");
      fprintf(file, "%s", maker->title);
      m++;
   } 
   fprintf(file, "\n};\n\n");
}

void SNode::YACC(FILE *file, int print_mode)
{
   fprintf(file, "\nenum class S_Node  { ");
   int m = 0;
   for (int t = stNone; t <= stItem; t++) {
      if (m) fprintf(file, ", ");
      if (m && !(m % 8)) fprintf(file, "\n                     ");
      fprintf(file, "%s", snode_title((SNode::S_Type)t));
      m++;
   } 
   fprintf(file, "\n};\n\n");
}

void TGrammar::YACC(const char* title, int print_mode, const char* prefix) const
{
   static const char *offset = "                         ";
   static const int len_offset = (int)strlen(offset);
   PRINT_FILE_OPEN(file, title, "w");
   fprintf(file, "%%{\n");
   makers->YACC(file, print_mode);
   SNode::YACC(file, print_mode);
   fprintf(file, "#define YYPARSE_PARAM parm\n");
   fprintf(file, "#define YYLEX_PARAM parm\n");
   fprintf(file, "#define YYERROR_VERBOSE\n");
   fprintf(file, "#define YYSTYPE T_Lexeme_SNode\n");
   fprintf(file, "%%}\n");
   fprintf(file, "%%pure_parser\n");
   fprintf(file, "%%name-prefix=\"%s\"\n",prefix);
   fprintf(file, "%%no-lines\n");
   fprintf(file, "%%debug\n");
   lexemes.YACC(file, print_mode);
   fprintf(file, "%%%%\n");
   bool syntax_tree = (print_mode & T_PrintMode::pmYACCStack) != 0;
   const GFormula* start_formula = NULL;
   for (const GFormula* my_formula : formulas) {
      const GFormula* formula;
      if (!start_formula) {
         const GSymbol& start_sym = my_formula->front().front();
         formula = start_formula = &Formula(start_sym);
      } else {
         formula = my_formula;
         if (formula == start_formula) continue;
      }

      int len = 0;
      fprintf(file, "\n"); 
      len += formula->head.YACC(file,this,0x04) + 1; fprintf(file, ":");
      while (len++ < len_offset) fprintf(file, " ");
      const char *seporator = "   ";
      for (const GProduce& produce : *formula) {
         fprintf(file, "%s", seporator);
         int item = 0;
         for (const GSymbol& sym : produce) {
            len = sym.YACC(file,this,print_mode);
            if (!(print_mode & T_PrintMode::pmCompact) && (len > SYMBOL_PRINT_TITLE_LEN + 1)) {
               len -= SYMBOL_PRINT_TITLE_LEN + 1;
               while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
            }
            item++;
            if (!syntax_tree && (sym.type == GSymbol::gsTerminal) && (sym.IsSaved())) {
               fprintf(file, "{ SAVE($%d); }", item); item++;
               len = 13; if (!(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
            }
         }
         if (!produce.maker.IsNone()) {
            produce.maker.YACC(file,this,print_mode);
         }
         fprintf(file, "\n%s", offset);
         seporator = " | ";
      }
      fprintf(file, " ;\n");
   }
   fprintf(file, "%%%%\n");
   if (title) fclose(file);
}

void TGrammar::BNF(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   lexemes.YACC(file, print_mode | T_PrintMode::pmBNF);
   fprintf(file, "%%%%\n");
   formulas.print(this, T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup | T_PrintMode::pmBNF, file);
   if (title) fclose(file);
}

void write_offset(FILE *file, int level)
{
   fprintf(file, "\n");
   while (level--) fprintf(file, "   ");
}

int GSymbol::MACRO(FILE *file, const TGrammar* grammar, int print_mode) const
{
   static char buffer[20] = {};
   int len = 0;
   if (type == gsTerminal) {
      const char* title = "", *macro = "";
      if (group == T_Lexeme::grOper) {
         macro = "OPER";
         title = lexeme_type_title((T_Symbol::T_Type)lexeme_type);
      } else if (group == T_Lexeme::grSeparator) {
         macro = "SYM";
         title = lexeme_type_title((T_Symbol::T_Type)lexeme_type);
      } else if (group == T_Lexeme::grReserv) {
         macro = "WORD";
      	title = lexeme_word_title((T_Lexeme::W_Type)lexeme_type);
      } else if (group == T_Lexeme::grPriority) {
         macro = "PRIOR";
      	title = lexeme_priority_title((T_Symbol::T_Priority)lexeme_type);
      } else if (group == T_Lexeme::grSyntax) {
         macro = "GROUP";
      	title = lexeme_syntax_title((T_Lexeme::T_Syntax)lexeme_type);
      } else {
         macro = "LEX";
         title = group_title((T_Lexeme::T_Group)group);
      }
      fprintf(file, "%s", macro); len += (int)strlen(macro);
     	fprintf(file, "(%s)", title); len += (int)strlen(title) + 2;
   } else if (type == gsFormula) {
      if (mode & GSymbol::Master) {
         fprintf(file, "MASTER"); len += 6;
         if (!(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
         return len;
      }
      if (print_mode & T_PrintMode::pmFormulaHead) {
         fprintf(file, "FORMULA("); len += 8;
      } else {
         fprintf(file, "RULE("); len += 5;
      } 
      const GFormula& f = *grammar->formulas[formula];
      len += f.write_title(file);
      fprintf(file, ")"); len += 1;
   } else if  (type == gsMaker) {
      if (param && !(print_mode & T_PrintMode::pmParamMacro) && !(mode & (GSymbol::SNode | GSymbol::Turn))) {
         SPRINTF(buffer,"%d",param);
         fprintf(file, "PARAM("); len += MACRO(file,grammar,print_mode | T_PrintMode::pmParamMacro | T_PrintMode::pmCompact);
         fprintf(file, ",%s)", buffer); len += 8 + (int)strlen(buffer);
         if (!(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
         return len;
      }
      len += print_maker(print_mode, file);
   } else if  (type == gsEmpty) {
      fprintf(file, "EMPTY"); len += 5;
   } else {
      const char* title = symbol_title(type);
	   fprintf(file, "%s", title); len += (int)strlen(title);
   }
   if (!(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
   return len;
}

void TGrammar::MACRO(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   print_mode |= 0x04;
   for (const GFormula* formula : formulas) {
      int len = 0;
      write_offset(file, 1); len += formula->head.MACRO(file,this,print_mode | T_PrintMode::pmFormulaHead);
      for (const GProduce& produce : (*formula)) {
         int len = 0;
         write_offset(file, 2);
         fprintf(file, "PRODUCE "); len += 8;
         if (!(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
         for (const GSymbol& sym : produce) {
            fprintf(file, " "); len += sym.MACRO(file,this,print_mode);
         }
         if (produce.maker.IsMaker()) {
            fprintf(file, " "); len += produce.maker.MACRO(file,this,print_mode);
         }
         fprintf(file, " END");
      }
      write_offset(file, 1); fprintf(file, "END\n");
   }
   if (title) fclose(file);
}

int GSymbol::PROG(FILE *file, const TGrammar* grammar, int print_mode) const
{
   static char buffer[20] = {};
   int len = 0;
   if (type == gsTerminal) {
      const char* title = "", *macro = "";
      if (group == T_Lexeme::grOper) {
         macro = "T_Lexeme::grOper,T_Symbol::T_Type::lx";
         title = lexeme_type_title((T_Symbol::T_Type)lexeme_type);
      } else if (group == T_Lexeme::grSeparator) {
         macro = "T_Lexeme::grSeparator,T_Symbol::T_Type::lx";
         title = lexeme_type_title((T_Symbol::T_Type)lexeme_type);
      } else if (group == T_Lexeme::grReserv) {
         macro = "T_Lexeme::W_Type::rw";
      	title = lexeme_word_title((T_Lexeme::W_Type)lexeme_type);
      } else if (group == T_Lexeme::grPriority) {
         macro = "T_Symbol::T_Priority::pr";
      	title = lexeme_priority_title((T_Symbol::T_Priority)lexeme_type);
      } else if (group == T_Lexeme::grSyntax) {
         macro = "T_Lexeme::T_Syntax::sx";
      	title = lexeme_syntax_title((T_Lexeme::T_Syntax)lexeme_type);
      } else {
         macro = "T_Lexeme::T_Group::gr";
         title = group_title((T_Lexeme::T_Group)group);
      }
      fprintf(file, "Match(%s%s)", macro, title); len += (int)strlen(macro) + (int)strlen(title) + 7;
   } else if (type == gsFormula) {
      const GFormula& f = *grammar->formulas[formula];
      len += f.write_title(file,grammar,0x01);
      fprintf(file, "()"); len += 1;
   } else if  (type == gsMaker) {
      const char *func_title = maker_title(maker), *maker_mode = "", *make_title;
      if (param) {
         make_title = "PARAM";
         SPRINTF(buffer,",%d",param);
      } else {
         make_title = "MAKE";
         buffer[0] = 0x00;
      }
      if ((mode & GSymbol::Tree) && (mode & GSymbol::Code) && (mode & GSymbol::Yacc))
         maker_mode = "_ALL";
      else if ((mode & GSymbol::Tree) && !(mode & GSymbol::Code))
         maker_mode = "_TREE";
      else if ((mode & GSymbol::Code) && !(mode & GSymbol::Tree))
         maker_mode = "_CODE";
      else if (mode & GSymbol::Yacc)
         maker_mode = "_YACC";
	   fprintf(file, "%s%s(%s%s)",make_title , maker_mode, func_title, buffer); 
      len += 2 + (int)strlen(make_title) + (int)strlen(maker_mode) + (int)strlen(func_title) + (int)strlen(buffer);
   } else if  (type == gsEmpty) {
      fprintf(file, "true"); len += 4;
   } else {
      const char* title = symbol_title(type);
	   fprintf(file, "%s", title); len += (int)strlen(title);
   }
   if (!(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
   return len;
}

void GProduce::PROG(FILE *file, const TGrammar* grammar, int print_mode) const
{
   if (print_mode == T_PrintMode::pmProgCall) { // call
      const GFormula& formula = grammar->Formula(head);
      formula.write_title(file,grammar, T_PrintMode::pmPrintPrefix);
      fprintf(file, "_%d()",head.produce);
   } else if (print_mode == T_PrintMode::pmProgHeader) { // *.h
      const GFormula& formula = grammar->Formula(head);
      fprintf(file, "   int ");
      formula.write_title(file,grammar, T_PrintMode::pmPrintPrefix);
      fprintf(file, "_%d(); ",head.produce);
   } else { // body
      bool yes_list = (print_mode == T_PrintMode::pmProgList), yes_ret = false;
      for (const GSymbol& item : *this) {
         if (item.IsTerminal()) { yes_ret = false; break; };
         if (item.IsFormula())  { yes_ret =  true; break; }
      }
      const GFormula& formula = grammar->Formula(head);
      fprintf(file, "int PSyntax::");
      formula.write_title(file,grammar, T_PrintMode::pmPrintPrefix);
      fprintf(file, "_%d()\n{\n",head.produce);
      if (yes_ret) fprintf(file, "   int s_ret;\n");
      bool first = true;
      int row = 0;
      for (const GSymbol& item : *this) {
         if ((++row == count()) && yes_list) continue;
         if (item.IsEmpty()) continue;
         if (item.IsMaker()) {
            fprintf(file, "   ");
            item.PROG(file, grammar, T_PrintMode::pmCompact);
            fprintf(file, ";\n");
//            first = false;
         } else {
            fprintf(file, "   if (");
            if (first && yes_ret) fprintf(file, "(s_ret = ");
            if (item.IsTerminal()) fprintf(file, "!");
            item.PROG(file, grammar, T_PrintMode::pmCompact);
            if (first) {
               first = false;
               if (item.IsTerminal()) {
                  fprintf(file, ") return -1;\n");
               } else {
                  fprintf(file, ") <= 0) return s_ret;\n");
               }
            } else {
               if (item.IsTerminal()) {
                  fprintf(file, ") return 0;\n");
               } else {
                  fprintf(file, " <= 0) return 0;\n");
               }
            }
         }
      }
      if (maker.IsMaker()) {
         fprintf(file, "   ");
         maker.PROG(file, grammar, T_PrintMode::pmCompact);
         fprintf(file, ";\n");
      }
      fprintf(file, "   return 1;\n}\n");
   }
}

void GFormula::PROG(FILE *file, const TGrammar* grammar, int print_mode) const
{
   bool yes_list = ((count() == 2) && back().IsEmpty() && front().back().IsMaster());

   if (print_mode == T_PrintMode::pmProgHeader) { // *.h
      for (const GProduce& produce : (*this)) {
         produce.PROG(file, grammar, T_PrintMode::pmProgHeader);
         if (yes_list) break;
      }
      fprintf(file, "\n");

      fprintf(file, "   int ");
      write_title(file,grammar, T_PrintMode::pmPrintPrefix);
      fprintf(file, "();\n");
   } else { // *.cpp
      fprintf(file, "\n// -------------------- ");
      write_title(file,grammar, T_PrintMode::pmPrintPrefix);
      fprintf(file, " --------------------\n");

      for (const GProduce& produce : (*this)) {
         produce.PROG(file, grammar, (yes_list ? T_PrintMode::pmProgList : T_PrintMode::pmProgBody)); // body
         if (yes_list) break;
      }

      fprintf(file, "int PSyntax::");
      write_title(file,grammar, T_PrintMode::pmPrintPrefix);
      fprintf(file, "()\n{\n");

      if (yes_list) {
         fprintf(file,"   int p_ret;\n   while ((p_ret = ");
         front().PROG(file, grammar, T_PrintMode::pmProgCall); // call
         fprintf(file,") > 0);\n   return (!p_ret ? 0 : 1);\n");
      } else {
         fprintf(file,"   int f_ret = 0, p_ret;\n");
         fprintf(file,"   T_ScanStore store; Store(store);\n");
         int row = 0;
         for (const GProduce& produce : (*this)) {
            fprintf(file, "   if ((p_ret = ");
            produce.PROG(file, grammar, T_PrintMode::pmProgCall); // call
            fprintf(file, ") > 0) return 1; else f_ret += p_ret;\n");
            fprintf(file,"   Restore(store);\n");
         }
         fprintf(file, "   return ((f_ret == -%d) ? -1 : 0);\n",count());
      }
      fprintf(file, "}\n");
   }
}

void TGrammar::PROG(const char* title, int print_mode) const
{
   FILE *file;
   char *file_h = get_file_name(title,"h");
   FOPEN(file, file_h, "w");
   if (file == NULL) return;
   free(file_h);
   fprintf(file, 
   "class PSyntax : public P_Syntax {"
   "\npublic:"
	"\n   PSyntax(T_Scan *s, TGrammar* g) :P_Syntax(s,g) {}"
   "\n   virtual int translate() { return ");
   (*formulas.front()).write_title(file,this, T_PrintMode::pmPrintPrefix); fprintf(file, "(); }\n");
   fprintf(file, "public:\n");
   for (const GFormula* formula : formulas) {
      formula->PROG(file, this, T_PrintMode::pmProgHeader);
   }
   fprintf(file, "};\n");
   fclose(file);

   char *file_cpp = get_file_name(title,"cpp");
   FOPEN(file, file_cpp, "w");
   free(file_cpp);
   if (file == NULL) return;
   for (const GFormula* formula : formulas) {
      formula->PROG(file, this, T_PrintMode::pmProgBody);
   }
   fclose(file);
}

void TGrammar::write_LL(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if ((print_mode != T_PrintMode::pmWriteSymbol) && (print_mode != T_PrintMode::pmWriteProg)) fprintf(file, "%d\n", T_Grammar::gtLL | ((look_ahead > 0) ? 0x04 : 0));
   builder->Mtable.write(file,print_mode);
   write(file,print_mode);
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      if (look_ahead > 0) {
         fprintf(file, "\nvoid make_references(TGrammar& grammar)\n{"); 
         if (!references.empty()) {
            fprintf(file, "\nstd::vector<int> I = {");
            int i = 0; for (int ref : references) { fprintf(file, "%d", ref); if (++i < (int)references.size()) fprintf(file, ","); }
            fprintf(file, " };\ngrammar.references = I;");
         }
         fprintf(file, "\n}\n");
      }
      fprintf(file, "\nvoid make_grammar(TGrammar& grammar) { make_cells(grammar); make_formulas(grammar); make_vectors(grammar);");
      if (look_ahead > 0) {
         fprintf(file, " make_references(grammar);");
      }
      fprintf(file, " }\n");
   } else if (look_ahead > 0) {
      fprintf(file, "%d\n", (int)references.size());
      for (int ref : references) { fprintf(file, "%d ", ref); }
   }
   if (title) {
      fclose(file);
   }
}

void TGrammar::write_LR(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if ((print_mode != T_PrintMode::pmWriteSymbol) && (print_mode != T_PrintMode::pmWriteProg)) fprintf(file, "%d\n",T_Grammar::gtLR);
   builder->LRtable.write(file,print_mode);
   write(file,print_mode);
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "\nvoid make_grammar(TGrammar& grammar) { make_actions(grammar); make_formulas(grammar); make_vectors(grammar); }\n");
   }
   if (look_ahead > 0) {
      fprintf(file, "%d\n", (int)references.size());
      for (int ref : references) { fprintf(file, "%d ", ref); }
   }
   if (title) {
      fclose(file);
   }
}

// ------------------------------ GrammarSplitting -------------------------------

// Green(v=2,7.4.3)
// Green(v=2,p=104,a=7.12)
bool TGrammarGroup::AddGrammar(const GSymbol& root)
{
   GSymbol addition(root);
   if (general->option & TGrammar::opSplittingAddition) {
      if (!general->IsStart(addition)) {
         GFormula *root_formula = new GFormula(GSymbol(GSymbol::gsFormula, general->formulas.count()));
         GProduce root_produce(GSymbol(GSymbol::gsProduce, root_formula->head.formula));
         root_produce << addition;
         root_formula->Add(root_produce);
         addition = root_formula->head;
         general->formulas.push_back(root_formula);
      }
   }
   iterator ip = find(root);
   if (ip != end()) return false;
   std::pair<GSymbol, TGrammarGroupItem*> item(root, new TGrammarGroupItem());
   insert(item);
   ip = find(root);
   TGrammarGroupItem& grammar = *((*ip).second);
   grammar.formulas.Copy(general->formulas);
   if (general->option & TGrammar::opSplittingAddition) {
      grammar.S_ = addition;
   }
   grammar.root = grammar.formulas.root = grammar.formulas[addition.formula];
   grammar.general = general;
   grammar.look_ahead = general->look_ahead;
   grammar.option = general->option;
   return true;
}

void TGrammarGroup::FormulaToTerminal(GSymbol& sym)
{
   if (sym.IsFormula() && (find(sym) != end())) {
      sym.type = GSymbol::gsTerminal; sym.lexeme_type = sym.formula; sym.group = T_Lexeme::grGrammar;
   }
}

void TGrammarGroup::TerminalToFormula(GSymbol& sym)
{
   if (sym.IsTerminal() && (sym.group == T_Lexeme::grGrammar)) {
      sym.type = GSymbol::gsFormula; sym.formula = sym.lexeme_type; sym.produce = 0;
   }
}

void TGrammarGroup::Disclosure(const TSituationMap& from, TSituationMap& to) const
{
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < from.count(); situation.situation++) {
      const TParaSet& situation_items = *from.Get(situation);
      TParaSet* opened = new TParaSet(general);
      for (const TPara& para : situation_items) {
         if (para.IsPara()) {
//printf("\n"); para.GSymbol::print(general); printf(" -> "); para.print(general);
            (*opened) << para;
         } else { // situation
            TGrammarGroup::const_iterator ig = find(para.sym);
            const TGrammarGroupItem& item_grammar = *(*ig).second;
            const TParaSet* pointer = item_grammar.Stable.Get(para);
            if (general->option & TGrammar::opSplittingAddition) {
               for (const TPara& para_my : *pointer) {
//printf("\n"); para_my.GSymbol::print(general); printf(" -> "); para_my.print(general);
                  if (general->IsStart(para_my) || (para_my.formula != item_grammar.S_.formula) || (para_my.produce != item_grammar.S_.produce)) {
                     (*opened) << para_my;
                  }
               }
            } else {
               (*opened) << (*pointer);
            }
         }
      }
      to.Add(opened);
//printf("\n");
   }
}

void TGrammarGroup::Clear()
{
   for (std::pair<const GSymbol&, TGrammarGroupItem*> item : (*this)) {
      delete item.second;
   }
   clear();
}

void TGrammarGroup::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   for (std::pair<const GSymbol&, const TGrammarGroupItem*> item : (*this)) {
      item.second->print_(file, print_mode);
      int print_F_F_E = T_PrintMode::pmSpaces | T_PrintMode::pmMultiLine | T_PrintMode::pmOffset;
      fprintf(file, "\nF I R S T:\n");
      item.second->FIRSTs.print(file, print_F_F_E);
      fprintf(file, "\nE F F:\n");
      item.second->EFFs.print(file, print_F_F_E);
      fprintf(file, "\nF O L L O W:\n");
      item.second->FOLLOWs.print(file, print_F_F_E);
      int option_state = 0x0000; option_state |= T_PrintMode::pmSortMode;
      item.second->Stable.print_(file, option_state);
      fprintf(file, "\nG O T O:\n");
      item.second->GOTOtable.print_(file, T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
      fprintf(file, "\nL E X E M E S:\n");
      item.second->lexemes.print_(file, print_mode);
   }
   if (derivation) {
      fprintf(file, "\nD E R I V A T I O N:\n");
      derivation->print(file, print_mode);
   }
   if (title) {
      fclose(file);
   }
}
#ifndef TRN_GBUILDER_H
#define TRN_GBUILDER_H

#include "Grammar.h"

class TPara : public GSymbol
{
public:
   TPara(T_Type t = gsNone, int g = 0, int s = 0, int p = 0, int m = 0) :GSymbol(t, g, s, p, m), sym() {}
   TPara(const GSymbol& s) :GSymbol(s), sym() { /*type = gsPara;*/ }
   TPara(const GSymbol& p, const GSymbol& s) :GSymbol(p), sym(s) { /*type = gsPara;*/ }
   TPara(const TPara& p) :GSymbol(p), sym(p.sym) { /*type = gsPara;*/ }
public:
   bool operator == (const TPara& p) const;
   bool operator <  (const TPara& p) const;
   int  print(const TGrammar* grammar, int print_mode = 0x00, FILE *file = NULL) const;
   void write(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
public:
   GSymbol sym;
};

class TParaSet : public std::set<TPara>
{
public:
   TParaSet(const TGrammar* g) :grammar(g), mode(0) {}
   TParaSet(const TGrammar* g, const TParaSet& I);
   TParaSet(const TGrammar* g, const TPara& s) :grammar(g), mode(0) { (*this) << s; }
public:
   TParaSet& operator << (const TPara& s) { Add(s); return *this; }
   TParaSet& operator << (const TParaSet& s) { *this += s; return *this; }
   int  operator += (const TPara& s);
   int  operator += (const TParaSet& m);
   bool Add(const TPara& sym);
   bool Have(const TPara& para) const;
   bool Have(const TParaSet& join) const;
   bool ValidLRk() const;
   bool ValidSLRk() const;
   void Basic();
   bool CoreCompare(const TParaSet& join) const;
   TParaSet* Core() const;
   int  count() const { return (int)size(); }
public:
   void print(const char* title = NULL, int print_mode = 0x00, FILE* file = stdout) const;
   void write(FILE* file, int print_mode = 0x00) const;
public:
   int mode;
   const TGrammar* grammar;
   static TParaSet Empty;
};

// Red(p=244)
// ------------------------------------------------ TC2A -----------------------------------------------

#define TC2A_MAKE_QUEUE_
class TAmu {
public:
   TAmu(const GSymbol& p) :point(p), step(0), produce(0) {}
   //   bool operator == (const TAmu& p) const { return ((*this).point == p.point); }
   //   bool operator <  (const TAmu& p) const { return ((*this).point <  p.point); }
   //   bool operator == (const TAmu& p) const { return ((*this).point == p.point) && ((*this).mu == p.mu); }
   //   bool operator <  (const TAmu& p) const { return ((*this).point <  p.point) || ((*this).point == p.point) && ((*this).mu < p.mu); }
public:
   const GSymbol point;
   mutable TFirst mu, half;
   mutable int step, produce;
};

class TAmus : public std::map<const GSymbol, TAmu> {
public:
   TAmus() {}
   bool Add(const TAmu& mu);
public:
   static const TAmus none;
};

class TBTailItem {
public:
   TBTailItem() :step(0), count(0) {}
   void print(const TGrammar *grammar, int print_mode, FILE* file) const;
public:
   TFirst delta, half;
   int step, count;
};

class TBTails : public std::map<const GSymbol, TBTailItem> {
public:
   TBTails(TGrammar *g) :grammar(g) {}
   TBTailItem* Get(const GSymbol& point);
public:
   void print(const TGrammar *grammar, int print_mode, FILE* file) const;
public:
   TGrammar *grammar;
};

class Tc2a : public std::map<const GSymbol, TAmus> {
public:
   Tc2a() :step(0) {}
   bool Add(const GSymbol& A, const TAmu& mu);
public:
   const TAmus& Get(const GSymbol& C);
   void print(const TGrammar *grammar, int print_mode, FILE* file) const;
public:
   GSymbolSet terminals;
#ifdef TC2A_MAKE_QUEUE
   GSymbolVector points;
#endif
public:
   int step;
};

class TC2A : public std::map<const GSymbol, Tc2a> {
public:
   TC2A(TGrammar *g = NULL) :grammar(g), step(0), modif_count(0), point_tails(g) {}
   void Init();
   void Core();
   bool Verify() const;
public:
   Tc2a& Get(const GSymbol& C);
   const Tc2a& Get(const GSymbol& A) const { return at(A); }
   TAmus& Get(const GSymbol& C, const GSymbol& A);
#ifdef TC2A_MAKE_QUEUE
   void Make(const GSymbol& point, const GSymbol& C);
   void Make(const GSymbol& C);
#else
   int  Make(const GSymbol& B, const GSymbol& C, const GSymbol& point);
   int  Make();
#endif
public:
   void Split();
   void Merge();
public:
   void print(const char* title, const TGrammar *grammar, int print_mode) const;
   int  modif_count;
public:
   TGrammar *grammar;
   int step;
   TBTails point_tails;
#ifdef TC2A_MAKE_QUEUE
   GSymbolQueue queue;
#endif
};

class MTableMap;
class TNextTab;
class TSituationMap
{
public:
   TSituationMap() :step(0) {}
   virtual GSymbol Add(TParaSet* key);
   TSituationMap& operator << (TParaSet& s) { Add(&s); return *this; }
   TParaSet* Get(const GSymbol& sym) const;
   virtual GSymbol Find(const TParaSet&) const;
   virtual void Clear();
   int  ValidLRk();
   int  ValidSLRk();
   void Basic();
   void Copy(const TSituationMap& join);
   void make_NEXTs(const MTableMap& GOTOtable, TNextTab& NEXTs);
   void Expansion(const TFirstFollowTable& table, TSituationMap& TO) const;
public:
   int  count() const { return (int)vector.size(); }
   void print(const char* title = NULL, int print_mode = 0x00) const;
   void print_(FILE* file, int print_mode = 0x00) const;
   void write(const char* title, int print_mode = 0x00) const;
public:
   int step;
protected:
   struct Key {
      Key(const TParaSet *p) :key(p) {}
      bool operator == (const Key& k) const { return *key == *k.key; }
      bool operator <  (const Key& k) const { return *key <  *k.key; }
   public:
      const TParaSet *key;
   };
   std::map<const Key, const GSymbol> map;
   std::vector<TParaSet*> vector;
};

class TSituationTable : public TSituationMap
{
public:
   TSituationTable() {}
   const TFirstFollow& Table(const GSymbol& tab) const { return table.Get(tab); }
   GSymbol Table(const TFirstFollow& key) { return table.Add(key); }
public:
   TFirstFollowTable table;
};

class TCoreArrItem : public std::vector<int> { };
class TCoreArr : public std::vector<TCoreArrItem>
{
public:
};

class TSituationCore : public TSituationMap
{
public:
   TSituationCore() {}
   GSymbol Add(TParaSet* key, int situation);
   const TCoreArr& Core() const { return core_arr; }
   void print(const char* title = NULL, int print_mode = 0x00) const;
protected:
   TCoreArr core_arr;
};

class TClosureAdded : protected std::vector<int>
{
public:
   TClosureAdded(TGrammar* g) :current(0), formula_count(0), sym_count(0), grammar(g), type(-1) {}
   void Init(int m); // -1 - off, 0 - LR0, 1 - LR1, 2 - LALR, 3 - LRk, 4 - Core
   void Next() { current++; }
   bool Added(const GSymbol &formula);
   bool Added(const GSymbol &formula, const GSymbol &lexeme);
   void Set(const GSymbol &formula, const GSymbol &lexeme);
   int  Current() const { return current; }
   int  Index(const GSymbol &lexeme) const;
protected:
   void Init(int f, int s);
   void Set(int f, int s = 0) { (*this)[s * formula_count + f] = current; }
   bool Get(int f, int s = 0) const { return (*this)[s * formula_count + f] == current; }
protected:
   TGrammar * grammar;
   size_t formula_count, sym_count;
   int  type;
   int  current;
};

class TSituationKernel : public TSituationMap
{
public:
   TSituationKernel() :yes_queue(false) {}
   ~TSituationKernel() { Clear(); }
   virtual GSymbol Add(TParaSet* key);
   virtual GSymbol Find(const TParaSet&) const;
   virtual void Clear();
public:
   GSymbolQueue queue;
   bool yes_queue;
};

class TLookAhead
{
public:
   class TElement {
   public:
      TElement() {}
      TElement(const TElement& e) :situation(e.situation), para(e.para) {}
      TElement(const GSymbol& s, const TPara& p) :situation(s), para(p) {}
   public:
      bool operator == (const TElement& k) const { return (situation == k.situation) && (para == k.para); }
      bool operator <  (const TElement& k) const { return (situation <  k.situation) || (situation == k.situation) && (para <  k.para); }
   public:
      void print(const TGrammar *grammar, int print_mode, FILE* file) const;
   public:
      GSymbol situation; TPara para;
   };
public:
   TLookAhead(const TGrammar* g = NULL) :grammar(g) {}
   void Add(const TElement& key);
public:
   class TItem {
   public:
      TItem() :symbols() {};
      void Add(const TElement& expansion) { expansions.push_back(expansion); }
   public:
      GSymbolSet symbols;
      std::vector<TElement> expansions;
   };
public:
   TLookAhead::TItem& Get(const TElement& key) { return map.at(key); }
   int  count() const { return (int)map.size(); }
   void print(const char* title = NULL, int print_mode = 0x00) const;
public:
   std::map<const TElement, TItem> map;
public:
   const TGrammar* grammar;
};

// ------------------------------ GrammarSplitting -------------------------------
// Green(v=2,7.4.3)
// Green(v=2,p=104,a=7.12)

class TGrammarGroupItem : public TGrammar {
public:
   TGrammarGroupItem() :general(NULL) {}
   virtual GVectors& Vectors() { return general->Vectors(); }
   virtual const GVectors& Vectors() const { return general->Vectors(); }
public:
   GSymbol       S_;
   TSituationMap Stable;
   TGrammar*     general;
   MTableMap     GOTOtable;
};

class TGrammarGroup : public std::map<GSymbol, TGrammarGroupItem*> {
public:
   TGrammarGroup(TGrammar* g) : general(g), derivation(NULL) {}
   ~TGrammarGroup() { Clear(); }
   bool AddGrammar(const GSymbol& root);
   void FormulaToTerminal(GSymbol& sym);
   void TerminalToFormula(GSymbol& sym);
   void Disclosure(const TSituationMap&, TSituationMap&) const;
public:
   void Clear();
   void print(const char* title = NULL, int print_mode = 0x00) const;
public:
   TDerivation* derivation; // print
   TGrammar* general;
};

class TGrammarBuilder
{
public:
   TGrammarBuilder(TGrammar* g, const char* f = NULL) :root(NULL), grammar(g), Mtable(g), LRtable(g), GOTOtable(g), level(0), max_level(0), true_count(0), false_count(0), 
      Added(g), CtoAa(g), LookAhead(g), look_ahead(1), file(f), NEXTs(g) {}
   bool make_LL1Table();
   bool make_LR0States();
   bool make_LR0Table();
   void make_ActionLR0(const TSituationMap& stable, const GSymbol& situation);
   void make_StateLR0(const GSymbol& situation, const GSymbol& X);
   void make_StateLR0(const GSymbol& situation);
   void make_StateLR1(TSituationMap& stable, const GSymbol& situation, const GSymbol& X);
   void make_StateLR1(TSituationMap& stable, const GSymbol& situation);
   void make_ActionLR1(TSituationMap& stable, const GSymbol& situation, int mode); // 0x01 - basic, 0x02 - GOTO, 0x04 - LALR, 0x08 - make_go_to
   bool make_LR1Table(TSituationMap& stable, int mode);
   bool make_LR1States();
   bool make_LR1Table();
   void make_ActionC2Aa(const TSituationMap& stable, const GSymbol& situation, A_Syntax::T_SyntaxMode mode);
   void make_StateC2Aa(TSituationMap& stable, const GSymbol& situation, const GSymbol& X, A_Syntax::T_SyntaxMode mode);
   void make_StateC2Aa(TSituationMap& stable, const GSymbol& situation, A_Syntax::T_SyntaxMode mode);
   bool make_C2Aa_LR(A_Syntax::T_SyntaxMode mode);
   bool make_C2Aa_LALR();
   bool make_LALRTable();
   bool make_LALR_FullTable(A_Syntax::T_SyntaxMode mode);
   bool make();
   bool Make(A_Syntax::T_SyntaxMode syntax_mode, const char* file);
   bool Analyze(A_Syntax::T_SyntaxMode syntax_mode, const char* file);
public:
   bool make_LLkTable(int k);
   bool make_SLRkTable(int k);
   bool make_LRkTable(int k);
   bool make_LR0Core();
   bool make_LRkCore(int k);
   bool make_LALRk_FullTable(A_Syntax::T_SyntaxMode mode, int k);
   bool make_LALRkTable(int k);
   bool make_LALRkCore(int k);
public:
   bool make_FiUnattainable(int k);
   bool make_GrammarSplitting(int k);
public:
   int look_ahead;
public:
   GFormula * root;
   TSituationMap     Stable;
   TSituationMap     TablePrint;
   TSituationCore    COREtable;
   TSituationKernel  LALRStable;
   MTableMap         Mtable;
   LRTableMap        LRtable;
   MTableMap         GOTOtable;
   TNextTab          NEXTs;
public:
   TGrammar*         grammar;
   const char*       file;
public:
   TFirst & First(const GSymbol& key) { return grammar->First(key); }
   TFollow& Follow(const GSymbol& key) { return grammar->Follow(key); }
public:
   TClosureAdded     Added;
   TC2A              CtoAa;
   TLookAhead        LookAhead;
public:
   int level, max_level;
   int true_count, false_count;
};

#endif

#include "stdafx.h"

#include "Rules.h"
#include "Maker.h"
#include "Grammar.h"

int  TGrammar::Maker(const char* m) const
{
   return makers->Find(m);
}

const GMaker* TGrammar::Maker(int m) const
{
   return (*makers)[m];
}

GFormula* TGrammar::Find(const char* title) const
{
   for (GFormula* item : formulas) {
      if (!strcmp(item->title, title)) return item;
   }
   return NULL;
}

void TGrammar::Add(GFormula* f)
{
   formulas.push_back(f);
}

const GFormula& TGrammar::Formula(const GSymbol &sym) const
{
   const GFormula& formula = *formulas[sym.formula];
   return formula;
}

const GProduce& TGrammar::Produce(const GSymbol &sym) const
{
   if (sym.formula < 0) {
      return Produce(produces[sym.produce]);
   }
   const GFormula& formula = *formulas[sym.formula];
   const GProduce& produce = formula[sym.produce];
   return produce;
}

int TGrammar::Replace(const GSymbol &from, const GSymbol &to)
{
   int replace = 0;
   for (GFormula* formula : formulas) {
      for (GProduce& produce : (*formula)) {
         for (GSymbol& sym : produce) {
            if (sym == from) {
               sym = to; replace++;
            }
         }
      }
   }
   return replace;
}

const TAction& TGrammar::Action(MTableKey& key) const
{
   return LRtable.Action(key);
}

const GSymbol& TGrammar::Cell(const MTableKey& key) const
{
   return Mtable.Cell(key);
}

bool TGrammar::IsStart(const GSymbol& sym) const 
{
   if (!root || (sym.type != GSymbol::gsProduce) && (sym.type != GSymbol::gsFormula)) return false;
   return root->head.formula == sym.formula;
}

bool TGrammar::make_start()
{
   if (!root) return false;
   if (root->IsChain()) return false;
   GFormula *root_formula = new GFormula(GSymbol(GSymbol::gsFormula, formulas.count()));
   GProduce root_produce(GSymbol(GSymbol::gsProduce, root_formula->head.formula));
   root_produce << root->head;
   root_formula->Add(root_produce);
   formulas.push_back(root_formula);
   root = root_formula;
   return true;
}

void TGrammar::make_lexemes()
{
   for (GFormula* formula : formulas) {
      for (GProduce& produce : *formula) {
         for (GSymbol& sym : produce) {
            if (sym.IsTerminal()) {
               lexemes.Add(sym);
            }
         }
      }
   }
}

void TGrammar::makers_used() const
{
   for (GFormula* formula : formulas) {
      for (GProduce& produce : *formula) {
         for (GSymbol& sym : produce) {
            if (sym.IsMaker()) {
               const GMaker* used;
               if (sym.IsMakerNode()) {
                  used = (const GMaker*)(*makers)[makers->maker_node];
               } else if (sym.IsMakerTurn()) {
                  used = (const GMaker*)(*makers)[makers->maker_turn];
               } else {
                  used = (const GMaker*)(*makers)[sym.maker];
               }
               used->used++;
            }
         }
      }
   }
}

bool TGrammar::make_produces()
{
   bool ret = true;
   for (GFormula* formula : formulas) {
      for (GProduce& produce : *formula) {
         produce.head.value = (int)produces.size();
         produces.push_back(produce.head);
      }
   }
   return ret;
}

bool TGrammar::filter_makers(int filter)
{
   bool ret = true;
   for (GFormula* formula : formulas) {
      for (GProduce& produce : *formula) {
         GProduce::iterator ip = produce.begin();
         while (ip != produce.end()) {
            GSymbol& sym = (*ip);
            if (sym.IsMaker()) {
               if (!(sym.mode & filter)) {
                  ip = produce.erase(ip);
               } else {
                  sym.mode &= ~(GSymbol::Tree | GSymbol::Code | GSymbol::Yacc | GSymbol::SNode | GSymbol::Turn) | filter;
                  ip++;
               }
            } else {
               ip++;
            }
         }
      }
   }
   return ret;
}

bool TGrammar::make_makers_head()
{
   bool ret = true;
   int formulas_count = formulas.count();
   for (int f = 0; f < formulas_count; f++) {
      GFormula& formula = *formulas[f];
      GFormula::iterator fi = formula.begin();
      while (fi != formula.end()) {
         GProduce& produce = (*fi);
         int yes_make = 0;
         do {
            yes_make = 0;
            GProduce::iterator ip = produce.begin();
            GSymbolVector syms;
            while (ip != produce.end()) {
               GSymbol& sym = (*ip);
               if (sym.IsMaker()) {
                  if (sym.maker < 0) {
                     printf("\nerror maker: "); formula.head.print(this, 0x00); printf(", ");
                     produce.head.print(this, 0x00); printf(", "); sym.print(this, 0x00); printf("\n");
                     yes_make = 0;
                     break;
                  }
                  if (syms.empty()) {
                     /*
                     if ((produce.count() == 1) && formula.maker.IsNone() && (fi == (formula.produces.end() - 1))) {
                     formula.maker = sym;
                     yes_make = -1;
                     fi = formula.produces.erase(fi);
                     break;
                     }
                     */
                     printf("\nerror maker: "); formula.head.print(this, 0x00); printf(", ");
                     produce.head.print(this, 0x00); printf(", "); sym.print(this, 0x00); printf("\n");
                     yes_make = 0;
                     break;
                  }
                  if (ip == (produce.end() - 1)) {
                     produce.maker = sym;
                     ip = produce.erase(ip);
                  } else {
                     bool yes_m_f = false;
                     for (int m_f = formulas_count; m_f < formulas.count(); m_f++) {
                        const GFormula& m_formula = *formulas[m_f];
                        const GProduce& m_produce = m_formula.front();
                        if (((GSymbolVector)m_produce == syms) && (m_produce.maker == sym) && (m_produce.maker.mode == sym.mode)) {
                           sym = m_formula.head; m_formula.used++;
                           produce.erase(produce.begin(), ip);
                           yes_m_f = true;
                           break;
                        }
                     }
                     if (yes_m_f) {
                        yes_make = 1;
                        break;
                     }

                     GFormula *maker_formula = new GFormula(GSymbol(GSymbol::gsFormula, formulas.count()));
                     formulas.push_back(maker_formula);
                     GProduce maker_produce(GSymbol(GSymbol::gsProduce, maker_formula->head.formula));
                     maker_produce.maker = sym;
                     maker_produce << syms;
                     maker_formula->Add(maker_produce);
                     sym = maker_formula->head; maker_formula->used++;
                     produce.erase(produce.begin(), ip);
                  }
                  yes_make = 1;
                  break;
               } else {
                  syms << sym;
               }
               ip++;
            }
         } while (yes_make > 0);
         if (yes_make >= 0) fi++;
      }
   }
   type = (T_Grammar)(type | T_Grammar::mtHead);
   return ret;
}

bool TGrammar::make_makers_empty()
{
   bool ret = true;
   int formulas_count = formulas.count();
   for (int f = 0; f < formulas_count; f++) {
      GFormula& formula = *formulas[f];
      GFormula::iterator fi = formula.begin();
      while (fi != formula.end()) {
         GProduce& produce = (*fi);
         GProduce::iterator ip = produce.begin();
         bool del_produce = false;
         while (ip != produce.end()) {
            GSymbol& sym = (*ip);
            if (sym.IsMaker()) {
               if (sym.maker < 0) {
                  printf("\nerror maker: "); formula.head.print(this, 0x00); printf(", ");
                  produce.head.print(this, 0x00); printf(", "); sym.print(this, 0x00); printf("\n");
                  break;
               }
               if (ip == produce.begin()) {
                  /*
                  printf("\nerror maker: "); formula.head.print(this,0x00); printf(", ");
                  produce.head.print(this,0x00); printf(", "); sym.print(this,0x00); printf("\n");
                  break;
                  */
               }
               if (ip == (produce.end() - 1)) {
                  produce.maker = sym;
                  ip = produce.erase(ip);
               } else {
                  bool yes_m_f = false;
                  for (int m_f = formulas_count; m_f < formulas.count(); m_f++) {
                     const GFormula& m_formula = *formulas[m_f];
                     const GProduce& m_produce = m_formula.front();
                     if ((m_produce.maker == sym) && (m_produce.maker.mode == sym.mode)) {
                        sym = m_formula.head; m_formula.used++;
                        yes_m_f = true;
                        break;
                     }
                  }
                  if (!yes_m_f) {
                     GFormula *maker_formula = new GFormula(GSymbol(GSymbol::gsFormula, formulas.count()));
                     formulas.push_back(maker_formula);
                     GProduce maker_produce(GSymbol(GSymbol::gsProduce, maker_formula->head.formula));
                     maker_produce.maker = sym;
#ifdef PRODUCE_ITEM_EMPTY
                     maker_produce << GSymbol::empty;
#endif
                     maker_formula->Add(maker_produce);
                     sym = maker_formula->head; maker_formula->used++;
                  }
                  ip++;
               }
            } else {
               ip++;
            }
         }
         if (!del_produce) fi++;
      }
   }
   type = (T_Grammar)(type | T_Grammar::mtEmpty);
   return ret;
}

// Red(p=195,196)
bool TFirstFollowMap::make_FIRSTs()
{
   bool ret = true;

   for (const std::pair<const GSymbol&, int> item : grammar->lexemes) {
      const GSymbol& sym = item.first;
      TFirst FIRST; FIRST += sym;
      Add(sym, FIRST);
   }

   for (const GFormula* formula : grammar->formulas) {
      TFirst FIRST;
      for (const GProduce& produce : *formula) {
         if (produce.IsEmpty()) {
            FIRST << GSymbol::empty; break;
         }
      }
      Add(formula->head, FIRST);
   }

   bool cycle = false;
   do {
      cycle = false;
      for (const GFormula* formula : grammar->formulas) {
         TFirst& first_formula = (TFirst&)at(formula->head);
         for (const GProduce& produce : *formula) {
            if (first_formula += produce) cycle = true;
         }
      }
   } while (cycle);

   return true;
}

// Green(v=1,p=397,a=5.5)
bool TGrammar::make_FIRST_ks(int k)
{
   bool ret = true;
   FIRSTs.clear();
   int step = 0;
   std::vector<int> change_step; change_step.resize(formulas.count(), -1);

   TFirst first_empty; first_empty << GSymbol::empty;
   FIRSTs.Add(GSymbol::empty, first_empty);

   for (const std::pair<const GSymbol&, int> item : lexemes) {
      const GSymbol& sym = item.first;
      TFirst FIRST;
      GSymbolVector vector;
      vector << sym;
      const GSymbol header = AddVector(vector);
      FIRST += header;
      FIRSTs.Add(sym, FIRST);
   }

   for (const GFormula* formula : formulas) {
      FORMULA_DELETED_CONTINUE(formula);
      TFirst FIRST;
      for (const GProduce& produce : *formula) {
         if (produce.IsEmpty()) {
            FIRST += GSymbol::empty;
            continue;
         }
         GSymbolVector vector;
         int item = 0;
         for (const GSymbol& sym : produce) {
            if (++item > k) break;
            if (sym.IsTerminal()) {
               vector << sym;
            } else if (sym.IsMaker()) {
            } else {
               vector.clear();
               break;
            }
         }
         if (!vector.empty()) {
            const GSymbol header = AddVector(vector);
            FIRST += header;
         }
      }
      FIRSTs.Add(formula->head, FIRST);
      if (!FIRST.empty()) change_step[formula->head.formula] = step;
   }

   int cycle = 0, attempt_all = 0;
   do {
      step++;
      cycle = 0;
      int attempt = 0;
      for (const GFormula* formula : formulas) {
         FORMULA_DELETED_CONTINUE(formula);
         int A = formula->head.formula;
         TFirst& first_formula = (TFirst&)FIRSTs.at(formula->head);
         for (const GProduce& produce : *formula) {
            if (produce.IsEmpty()) continue;
            bool yes_change = false;
            for (const GSymbol& sym : produce) {
               if (sym.IsFormula()) {
                  int B = sym.formula;
                  if (change_step[B] < 0) { yes_change = false; break; }
                  if (change_step[B] >= step - 1) yes_change = true;
               }
            }
            if (!yes_change) continue;
            TFirst first;
            if (!FIRSTs.FIRST(produce, first, k)) continue;
            attempt++;
            if (int change = first_formula += first) {
               cycle += change;
               change_step[A] = step;
            }
         }
      }
      attempt_all += attempt;
      printf("\nstep = %2d, change = %7d, item = %7d, attempt = (%5d, %7d), vector = %4d", step, cycle, FIRSTs.count(), attempt, attempt_all, Vectors().count());
   } while (cycle);
   printf("\n");

   /*
   GVectors vectors_sort;
   std::vector<int> indexs; indexs.resize(Vectors().count(),-1);
   for (std::pair<const GVectors::Key, const GSymbol> item : Vectors().map) {
   const GSymbolVector *vector = item.first.key;
   const GSymbol v = vectors_sort.Add(*vector);
   indexs[item.second.formula] = v.formula;
   }
   vectors = vectors_sort;

   TFirstFollowMap   FIRSTs_V(this);
   for (const std::pair<const GSymbol, const TFirstFollow&> item : FIRSTs) {
   TFirst first_sort;
   const TFirst &first = (TFirst&)item.second;
   for (const GSymbol& sym : first) {
   GSymbol sym_sort(sym);
   if (sym.IsVector()) {
   sym_sort.formula = indexs[sym.formula];
   }
   first_sort << sym_sort;
   }
   FIRSTs_V.Add(item.first, first_sort);
   }
   FIRSTs = FIRSTs_V;

   FIRSTs.print("FIRSTs_V", "", 0x0702);
   */
   return true;
}

bool TGrammar::make_EFF_ks(int k)
{
   bool ret = true;
   EFFs.clear();
   int step = 0;
   std::vector<int> change_step; change_step.resize(formulas.count(), -1);

   TFirst eff_empty; eff_empty << GSymbol::empty;
   EFFs.Add(GSymbol::empty, eff_empty);

   for (const std::pair<const GSymbol&, int> item : lexemes) {
      const GSymbol& sym = item.first;
      TFirst eff;
      GSymbolVector vector;
      vector << sym;
      const GSymbol header = AddVector(vector);
      eff += header;
      EFFs.Add(sym, eff);
   }

   for (const GFormula* formula : formulas) {
      FORMULA_DELETED_CONTINUE(formula);
      TFirst eff;
      for (const GProduce& produce : *formula) {
         if (produce.IsEmpty()) continue;
         if (produce.front().IsTerminal()) {
            TFirst first;
            if (!FIRSTs.FIRST(produce, first, k)) continue;
            eff += first;
         }
      }
      EFFs.Add(formula->head, eff);
      if (!eff.empty()) change_step[formula->head.formula] = step;
   }

   int cycle = 0, attempt_all = 0;
   do {
      step++;
      cycle = 0;
      int attempt = 0;
      for (const GFormula* formula : formulas) {
         FORMULA_DELETED_CONTINUE(formula);
         int A = formula->head.formula;
         TFirst& eff_formula = (TFirst&)EFFs.at(formula->head);
         for (const GProduce& produce : *formula) {
            if (produce.IsEmpty()) continue;
            GSymbolVector symbols_produce(produce, GSymbol::msTerminal | GSymbol::msFormula);
            if (symbols_produce.empty()) continue;
            const GSymbol& X = symbols_produce.front();
            if (X.IsFormula()) {
               if (change_step[X.formula] < step - 1) continue;
               TFirst eff_X = (TFirst&)EFFs.at(X), eff_produce;
               GSymbolVector alpha;
               for (int index_a = 1; index_a < symbols_produce.count(); index_a++) {
                  alpha << symbols_produce[index_a];
               }
               TFirst first;
               if (!alpha.empty()) {
                  if (FIRSTs.FIRST(alpha, first, k)) {
                  }
               } else {
                  first << GSymbol::empty;
               }
               Vectors().Plus(eff_X, first, eff_produce, k);
               attempt++;
               if (int change = eff_formula += eff_produce) {
                  cycle += change;
                  change_step[A] = step;
               }
            }
         }
      }
      attempt_all += attempt;
      printf("\nstep = %2d, change = %7d, item = %7d, attempt = (%5d, %7d), vector = %4d", step, cycle, EFFs.count(), attempt, attempt_all, Vectors().count());
   } while (cycle);
   printf("\n");

   return true;
}

bool TGrammar::make_FIRSTsP()
{
   bool ret = true;

   for (const GFormula* formula : formulas) {
      for (const GProduce& produce : *formula) {
         TFirst FIRST(produce, &FIRSTs);
         FIRSTsP.Add(produce.head, FIRST);
      }
   }

   return ret;
}

// Red(p=195,196)
bool TFirstFollowMap::make_FOLLOWs(const TFirstFollowMap& FIRSTs)
{
   bool ret = true;
   bool cycle = false;
   for (const GFormula* formula : grammar->formulas) {
      TFollow follow;
      Add(formula->head, follow);
   }

   at((*grammar->root).head) += GSymbol::eof;
   do {
      cycle = false;
      for (const GFormula* formula : grammar->formulas) {
         const TFollow& follow_A = (const TFollow&)at(formula->head);
         for (const GProduce& produce : *formula) {
            GSymbolVector symbols_produce(produce, GSymbol::msTerminal | GSymbol::msFormula);
            for (int index_B = 0; index_B < symbols_produce.count(); index_B++) {
               const GSymbol& sym_B = symbols_produce[index_B];
               if (!sym_B.IsFormula()) continue;
               TFollow& follow_B = (TFollow&)at(sym_B);
               GSymbolVector symbols_tail;
               for (int index = index_B + 1; index < symbols_produce.count(); index++) {
                  const GSymbol& sym_tail = symbols_produce[index];
                  if (sym_tail.IsTerminal() || sym_tail.IsFormula()) {
                     symbols_tail.Add(sym_tail);
                  }
               }
               bool must_follow = false;
               if (!symbols_tail.empty()) {
                  TFirst first_tail(symbols_tail, &FIRSTs);
                  for (const GSymbol& sym : first_tail) {
                     if (!sym.IsEmpty()) {
                        if (follow_B += sym) cycle = true;
                     } else {
                        must_follow = true;
                     }
                  }
               } else {
                  must_follow = true;
               }
               if (must_follow) {
                  if (follow_B += follow_A) cycle = true;
               }
            }
         }
      }
   } while (cycle);
   return ret;
}

class TFirstFollowSigma : public std::map<const MTableKey, TLangFirst>
{
public:
   TFirstFollowSigma(TGrammar* g) :grammar(g) {}
   bool Add(const MTableKey& key, const TLangFirst& item);
public:
   int  count() const;
   void print(const char* file_name = NULL, int print_mode = 0x00) const;
public:
   TGrammar * grammar;
};

class TFirstFollowTab : public std::map<const MTableKey, TFirstFollow>
{
public:
   TFirstFollowTab(TGrammar* g) :grammar(g) {}
   bool Add(const MTableKey& key, const TFirstFollow& item);
public:
   int  count() const;
   void print(const char* file_name = NULL, int print_mode = 0x00) const;
public:
   TGrammar * grammar;
};

// L&T(p=181,2.9)
bool TGrammar::make_FOLLOW_ks(int k)
{
   TFirstFollowTab Fi(this);
   int formula_count = formulas.count();
   std::vector<int> change_step; change_step.resize(formula_count * formula_count, -1);

   int step = 0;
   bool ret = true;
   for (const GFormula* formula_A : formulas) {
      FORMULA_DELETED_CONTINUE(formula_A);
      const GSymbol& sym_A = formula_A->head;
      for (const GFormula* formula_B : formulas) {
         FORMULA_DELETED_CONTINUE(formula_B);
         const GSymbol& sym_B = formula_B->head;
         MTableKey A_B(sym_A, sym_B);
         TFollow follow;
         for (const GProduce& produce : *formula_A) {
            for (int index_B = 0; index_B < produce.count(); index_B++) {
               if (!(sym_B == produce[index_B])) continue;
               GSymbolVector alpha;
               produce.TailWithoutMaker(index_B + 1, alpha);
               if (!alpha.empty()) {
                  TFirst first;
                  if (FIRSTs.FIRST(alpha, first, k)) {
                     follow << (TFollow&)(TFirstFollow&)first;
                  }
               } else {
                  follow << GSymbol::empty;
               }
            }
         }
         Fi.Add(A_B, follow);
         if (!follow.empty()) change_step[formula_count * sym_A.formula + sym_B.formula] = step;
      }
   }

   int cycle = 0, attempt_all = 0;
   do {
      step++;
      cycle = 0;
      int attempt = 0;
      for (const GFormula* formula_A : formulas) {
         FORMULA_DELETED_CONTINUE(formula_A);
         const GSymbol& sym_A = formula_A->head;
         for (const GProduce& produce : *formula_A) {
            for (int index_P = 0; index_P < produce.count(); index_P++) {
               const GSymbol& sym_P = produce[index_P];
               if (!sym_P.IsFormula()) continue;
               GSymbolVector alpha;
               produce.TailWithoutMaker(index_P + 1, alpha);
               TFirst first;
               if (!alpha.empty()) {
                  if (!FIRSTs.FIRST(alpha, first, k)) continue;
               } else {
                  first << GSymbol::empty;
               }
               for (const GFormula* formula_B : formulas) {
                  FORMULA_DELETED_CONTINUE(formula_B);
                  const GSymbol& sym_B = formula_B->head;
                  if (change_step[formula_count * sym_P.formula + sym_B.formula] < step - 1) continue;
                  MTableKey A_B(sym_A, sym_B);
                  TFollow& fi_A_B = (TFollow&)Fi.at(A_B);
                  MTableKey P_B(sym_P, sym_B);
                  const TFollow& fi_P_B = (TFollow&)Fi.at(P_B);
                  TFollow follow;
                  Vectors().Plus(fi_P_B, first, follow, k);
                  attempt++;
                  if (int change = fi_A_B += follow) {
                     cycle += change;
                     change_step[formula_count * sym_A.formula + sym_B.formula] = step;
                  }
               }
            }
         }
      }
      attempt_all += attempt;
      printf("\nstep = %2d, change = %7d, item = %7d, attempt = (%5d, %7d), vector = %4d", step, cycle, Fi.count(), attempt, attempt_all, Vectors().count());
   } while (cycle);
   printf("\n");

   FOLLOWs.clear();
   const GSymbol& sym_S = root->head;
   for (const GFormula* formula_A : formulas) {
      FORMULA_DELETED_CONTINUE(formula_A);
      const GSymbol& sym_A = formula_A->head;
      MTableKey S_A(sym_S, sym_A);
      TFollow& fi_S_A = (TFollow&)Fi.at(S_A);
      FOLLOWs.Add(sym_A, fi_S_A);
   }
   TFollow& follow_S = Follow(sym_S);
   follow_S += GSymbol::empty;

   return ret;
}

// Green(v=1,p=399,a=5.6)
bool TGrammar::make_SIGMA_ks(int k)
{
   TFirstFollowSigma Sigma(this);
   int formula_count = formulas.count();
   std::vector<int> change_step; change_step.resize(formula_count * formula_count, -1);

   int step = 0;
   bool ret = true;
   for (const GFormula* formula_A : formulas) {
      const GSymbol& sym_A = formula_A->head;
      for (const GFormula* formula_B : formulas) {
         const GSymbol& sym_B = formula_B->head;
         MTableKey A_B(sym_A, sym_B);
         TLangFirst langs;
         for (const GProduce& produce : *formula_A) {
            for (int index_B = 0; index_B < produce.count(); index_B++) {
               if (!(sym_B == produce[index_B])) continue;
               GSymbolVector alpha;
               produce.TailWithoutMaker(index_B + 1, alpha);
               TFirst first;
               if (!alpha.empty()) {
                  if (FIRSTs.FIRST(alpha, first, k)) {
                     langs.Insert(first);
                  }
               } else {
                  first << GSymbol::empty;
                  langs.Insert(first);
               }
            }
         }
         Sigma.Add(A_B, langs);
         if (!langs.empty()) change_step[formula_count * sym_A.formula + sym_B.formula] = step;
      }
   }

   int cycle = 0, attempt_all = 0;
   do {
      step++;
      cycle = 0;
      int attempt = 0;
      for (const GFormula* formula_A : formulas) {
         const GSymbol& sym_A = formula_A->head;
         for (const GProduce& produce : *formula_A) {
            for (int index_P = 0; index_P < produce.count(); index_P++) {
               const GSymbol& sym_P = produce[index_P];
               if (!sym_P.IsFormula()) continue;
               GSymbolVector alpha;
               produce.TailWithoutMaker(index_P + 1, alpha);
               TFirst first;
               if (!alpha.empty()) {
                  if (!FIRSTs.FIRST(alpha, first, k)) continue;
               } else {
                  first << GSymbol::empty;
               }
               for (const GFormula* formula_B : formulas) {
                  const GSymbol& sym_B = formula_B->head;
                  if (change_step[formula_count * sym_P.formula + sym_B.formula] < step - 1) continue;
                  MTableKey A_B(sym_A, sym_B);
                  TLangFirst& langs_A_B = Sigma.at(A_B);
                  MTableKey P_B(sym_P, sym_B);
                  const TLangFirst& langs_P_B = Sigma.at(P_B);
                  for (const TFirst& L_P_B : langs_P_B) {
                     TFirst lang;
                     Vectors().Plus(L_P_B, first, lang, k);
                     attempt++;
                     if (langs_A_B.Insert(lang)) {
                        cycle++;
                        change_step[formula_count * sym_A.formula + sym_B.formula] = step;
                     }
                  }
               }
            }
         }
      }
      attempt_all += attempt;
      printf("\nstep = %2d, change = %7d, item = %7d, attempt = (%5d, %7d), vector = %4d", step, cycle, Sigma.count(), attempt, attempt_all, Vectors().count());
   } while (cycle);
   printf("\n");

   SIGMAs.clear();
   const GSymbol& sym_S = root->head;
   for (const GFormula* formula_A : formulas) {
      const GSymbol& sym_A = formula_A->head;
      MTableKey S_A(sym_S, sym_A);
      TLangFirst& langs_S_A = Sigma.at(S_A);
      SIGMAs.Add(sym_A, langs_S_A);
   }

   TFirst lang_S; lang_S << GSymbol::empty;
   TLangFirst& langs_S = SIGMAs.at(sym_S);
   langs_S.Insert(lang_S);

   for (const GFormula* formula_A : formulas) {
      const GSymbol& sym_A = formula_A->head;
      const TLangFirst& langs_A = SIGMAs.at(sym_A);
      const TFollow& follow_A = (TFollow&)FOLLOWs.at(sym_A);
      TFollow lang;
      langs_A.Merge(lang);
      if (!(follow_A == lang)) {
         fprintf(stdout, "\n");  sym_A.print(this, 0x00, stdout);
      }
   }

   return ret;
}

// Green(v=1,p=396,a=5.4)
int TGrammar::ValidLLk()
{
   int invalid = 0;
   for (const GFormula* formula_A : formulas) {
      int count = formula_A->count();
      if (count < 2) continue;
      const GSymbol& sym_A = formula_A->head;
      const TLangFirst& langs_A = SIGMAs.at(sym_A);
      for (int i = 0; i < count - 1; i++) {
         const GProduce& produce_I = (*formula_A)[i];
         GSymbolVector tail_I;
         produce_I.TailWithoutMaker(0, tail_I);
         TFirst first_I;
         if (!tail_I.empty()) {
            if (!FIRSTs.FIRST(tail_I, first_I, look_ahead)) continue;
         } else {
            first_I << GSymbol::empty;
         }
         for (int j = i + 1; j < count; j++) {
            const GProduce& produce_J = (*formula_A)[j];
            GSymbolVector tail_J;
            produce_J.TailWithoutMaker(0, tail_J);
            TFirst first_J;
            if (!tail_J.empty()) {
               if (!FIRSTs.FIRST(tail_J, first_J, look_ahead)) continue;
            } else {
               first_J << GSymbol::empty;
            }
            for (const TFirst& lang_A : langs_A) {
               TFirst lang_I;
               Vectors().Plus(first_I, lang_A, lang_I, look_ahead);
               TFirst lang_J;
               Vectors().Plus(first_J, lang_A, lang_J, look_ahead);
               GSymbolSet I_J = lang_I * lang_J;
               if (!I_J.empty()) {
                  invalid++;
                  fprintf(stdout, "\n"); sym_A.print(this, 0x00, stdout);
                  fprintf(stdout, " : "); I_J.print(this, 0x00, stdout);
                  break;
               }
            }
         }
      }
   }
   return invalid;
}

bool TGrammar::Split(GSymbolSet& main, GSymbolSet& half) const
{
   TFirst::iterator ip = main.begin();
   bool ret = false;
   while (ip != main.end()) {
      const GSymbol& sym = (*ip);
      bool migrate = false;
      if (sym.IsEmpty() || sym.IsEof()) {
         migrate = true;
      } else if (sym.IsTerminal()) {
         if (look_ahead > 1) migrate = true;
      } else if (sym.IsVector()) {
         const GSymbolVector& vec = Vector(sym);
         if (vec.count() < look_ahead) migrate = true;
      }
      if (migrate) {
         half << sym;
         ip = main.erase(ip);
         ret = true;
      } else {
         ip++;
      }
   }
   return ret;
}

TFirst::TFirst(const GSymbolVector& symbols, const TFirstFollowMap* g) :TFirstFollow(g)
{
   (*this) += symbols;
}

int TFirstFollow::operator += (const TFirstFollow& join)
{
   return ((GSymbolSet&)(*this)) += ((const GSymbolSet&)join);
}

// Red(p=195,196)
int TFirst::operator += (const GSymbolVector& symbols)
{
   int ret = 0;
   bool yes = true;
   TFirst& first_formula = (*this);
   for (const GSymbol& sym : symbols) {
      if (sym.IsMaker()) continue;
      if (sym.IsTerminal() || sym.IsFormula()) {
         const TFirst& first_sym = (const TFirst&)owner->at(sym);
         bool have_empty = false;
         for (const GSymbol& sym_sym : first_sym) {
            if (!sym_sym.IsEmpty()) {
               ret += first_formula += sym_sym;
            } else {
               have_empty = true;
            }
         }
         if (!have_empty) { yes = false; break; }
      } else if (sym.IsEof()) {
         ret += (first_formula += sym);
         yes = false; break;
      } else if (sym.IsEmpty()) {
         yes = true;
      } else {
         yes = false;
      }
   }
   if (yes) {
      ret += (first_formula += GSymbol::empty);
   }
   return ret;
}

TFirstFollow TFirstFollow::operator * (const TFirstFollow& join) const
{
   TFirstFollow ret(owner);
   for (const GSymbol& sym : join) {
      if (Have(sym)) ret += sym;
   }
   return ret;
}

int  TFirstFollow::Length(TGrammar * grammar)
{
   k = 10000;
   for (const GSymbol& sym : (*this)) {
      if (sym.IsEmpty() || sym.IsEof()) { k = 0; break; }
      if (sym.IsTerminal()) { k = 1; continue; } 
      const GSymbolVector& vec = grammar->Vector(sym);
      if (vec.count() < k) k = vec.count();
   }
   return k;
}

bool TFirstFollowMap::Add(const GSymbol& key, TFirstFollow& item)
{
   const_iterator ip = find(key);
   if (ip != end()) return false;
   item.owner = this;
   std::pair<const GSymbol&, const TFirstFollow&> my_item(key, item);
   insert(my_item);
   return true;
}

bool TFirstFollowMap::Have(const GSymbol& key, const GSymbol& sym) const
{
   const_iterator ip = find(key);
   if (ip == end()) return false;
   std::pair<const GSymbol&, const TFirstFollow&> item = (*ip);
   return item.second.Have(sym);
}

bool TFirstFollowMap::FIRST(const GSymbolVector& alpha, TFirst& first) const
{
   first.owner = this;
   first += alpha;
   return true;
}

// Green(v=1,p=389,l=5.1)
bool TFirstFollowMap::FIRST(const GSymbolVector& alpha, TFirst& first, int k) const
{
   if (k == 0) return FIRST(alpha, first);
   int i = 0;
   while ((i < alpha.count()) && alpha[i].IsMaker()) i++;
   if (i == alpha.count()) return false;
   TFirst FIRST_1 = (TFirst&)at(alpha[i]);
   int min_length = grammar->Vectors().MinLength(FIRST_1);
   if (min_length >= k) i = alpha.count();
   for (int y = i + 1; y < alpha.count(); y++) {
      const GSymbol& sym_y = alpha[y];
      if (sym_y.IsMaker()) continue;
      const TFirstFollow& FIRST_y = at(sym_y);
      TFirst FIRST;
      grammar->Vectors().Plus(FIRST_1, FIRST_y, FIRST, k);
      FIRST_1 = FIRST;
      int min_length = grammar->Vectors().MinLength(FIRST);
      if (min_length >= k) break;
   }
   first = FIRST_1;
   return true;
}

bool TFirstFollowMap::FirstTail(const GSymbol& point, TFirst& first) const
{
   const GProduce& produce = grammar->Produce(point);
   if ((point.point == produce.count()) || produce.IsEmpty()) {
      first << GSymbol::empty;
      return true;
   }
   GSymbolVector beta;
   produce.Tail(point, beta);
   return FIRST(beta, first);
}

bool TFirstFollowMap::FirstTail(const GSymbol& point, TFirst& first, int k) const
{
   const GProduce& produce = grammar->Produce(point);
   if ((point.point == produce.count()) || produce.IsEmpty()) {
      first << GSymbol::empty;
      return true;
   }
   GSymbolVector beta;
   produce.Tail(point, beta);
   return FIRST(beta, first, k);
}

#define MY_FIRST_K
// Green(v=1,p=450,e=5.2.19)
bool TFirstFollowMap::EFF(const GSymbolVector& alpha, TFirst& eff, int k) const
{
   if (alpha.IsEmpty()) return false;
   int i = 0;
   while ((i < alpha.count()) && alpha[i].IsMaker()) i++;
   if (i == alpha.count()) return false;
   const_iterator ip = find(alpha[i]);
   if (ip == end()) return false;
   TFirst FIRST_1 = (TFirst&)(*ip).second;
   int min_length = grammar->Vectors().MinLength(FIRST_1);
   if (min_length == k) i = alpha.count();
#ifdef MY_FIRST_K
   for (int y = i + 1; y < alpha.count(); y++) {
      const GSymbol& sym_y = alpha[y];
      if (sym_y.IsMaker()) continue;
      if (!sym_y.IsEmpty()) {
         const TFirstFollow& FIRST_y = grammar->FIRSTs.at(sym_y);
         TFirst FIRST;
         grammar->Vectors().Plus(FIRST_1, FIRST_y, FIRST, k);
         FIRST_1 = FIRST;
         int min_length = grammar->Vectors().MinLength(FIRST);
         if (min_length == k) break;
      }
   }
   eff = FIRST_1;
#else
   GSymbolVector first_alpha;
   for (int y = i + 1; y < alpha.count(); y++) {
      if (alpha[y].IsMaker()) continue;
      first_alpha << alpha[y];
   }
   if (!first_alpha.empty()) {
      TFirst FIRST;
      grammar->FIRSTs.FIRST(first_alpha, FIRST, k);
      grammar->Vectors().Plus(FIRST_1, FIRST, eff, k);
   } else {
      eff = FIRST_1;
   }
#endif
   return true;
}

void TFirstFollow::print(FILE *file, const TGrammar* grammar, int print_mode) const
{
   fprintf(file, "-> ");
   GSymbolSet::print(grammar, print_mode, file);
}

void TFirstFollowMap::print(FILE* file, int print_mode) const
{
   int number_item = 0;
   for (const std::pair<const GSymbol&, const TFirstFollow&> item : *this) {
      if (number_item++) fprintf(file, "\n");
      item.first.print(grammar, print_mode, file);
      item.second.print(file, grammar, print_mode);
   }
   fprintf(file, "\n");
}

void TFirstFollowMap::print(const char* file_name, const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   int sym_count = 0;
   for (const std::pair<const GSymbol, const TFirstFollow&> item : *this) {
      sym_count += item.second.count();
   }
   if (!file_name) {
      fprintf(file, "\n--- ");
      if (!title) title = "FirstFollow";
      fprintf(file, "%s --- <%d> --- <%d> ---\n", title, (int)size(), sym_count);
   }
   if (print_mode == T_PrintMode::pmNone) return;
   print(file, print_mode);
   if (file_name) {
      fclose(file);
   }
}

int  TFirstFollowMap::count() const
{
   int ret = 0;
   for (const std::pair<const GSymbol&, const TFirstFollow&> item : *this) {
      ret += item.second.count();
   }
   return ret;
}

int  TFirstFollowTab::count() const
{
   int ret = 0;
   for (const std::pair<const MTableKey&, const TFirstFollow&> item : *this) {
      ret += item.second.count();
   }
   return ret;
}

bool TFirstFollowTab::Add(const MTableKey& key, const TFirstFollow& item)
{
   const_iterator ip = find(key);
   if (ip != end()) return false;
   std::pair<const MTableKey&, const TFirstFollow&> my_item(key, item);
   insert(my_item);
   return true;
}

void TFirstFollowTab::print(const char* file_name, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   int sym_count = 0;
   for (const std::pair<const MTableKey, const TFirstFollow&> item : *this) {
      sym_count += item.second.count();
   }
   if (!file_name) {
      fprintf(file, "\n--- ");
      fprintf(file, "%s --- <%d> --- <%d> ---\n", "FirstFollow", (int)size(), sym_count);
   }
   if (print_mode == 0x00) return;
   int number_item = 0;
   for (const std::pair<const MTableKey&, const TFirstFollow&> item : *this) {
      if (number_item++) fprintf(file, "\n");
      item.first.print(grammar, print_mode, file);
      item.second.print(file, grammar, print_mode);
   }
   fprintf(file, "\n");
   if (file_name) {
      fclose(file);
   }
}

int  TFirstFollowSigma::count() const
{
   int ret = 0;
   for (const std::pair<const MTableKey&, const TLangFirst&> item : *this) {
      ret += (int)item.second.size();
   }
   return ret;
}

bool TFirstFollowSigma::Add(const MTableKey& key, const TLangFirst& item)
{
   const_iterator ip = find(key);
   if (ip != end()) return false;
   std::pair<const MTableKey&, const TLangFirst&> my_item(key, item);
   insert(my_item);
   return true;
}

void TFirstFollowSigma::print(const char* file_name, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   int sym_count = 0;
   for (const std::pair<const MTableKey, const TLangFirst&> item : *this) {
      sym_count += (int)item.second.size();
   }
   if (!file_name) {
      fprintf(file, "\n--- ");
      fprintf(file, "%s --- <%d> --- <%d> ---\n", "LangFirst", (int)size(), sym_count);
   }
   if (print_mode == 0x00) return;
   int number_item = 0;
   for (const std::pair<const MTableKey&, const TLangFirst&> item : *this) {
      if (number_item++) fprintf(file, "\n");
      item.first.print(grammar, print_mode, file);
      item.second.print(file, grammar, print_mode);
   }
   fprintf(file, "\n");
   if (file_name) {
      fclose(file);
   }
}

bool TLangFirst::Insert(const TFirst& item)
{  
   iterator ip = find(item);
   if (ip != end()) return false;
   insert(item);
   return true;
}

void TLangFirst::Merge(TFirstFollow& lang) const
{
   for (const TFirst& item : (*this)) {
      lang << item;
   }
}

void TLangFirst::print(FILE* file, const TGrammar* grammar, int print_mode) const
{
   for (const TFirst& item : (*this)) {
      item.print(file, grammar, print_mode);
   }
}

bool TLangFirstMap::Add(const GSymbol& key, TLangFirst& item)
{
   const_iterator ip = find(key);
   if (ip != end()) return false;
   item.owner = this;
   std::pair<const GSymbol&, const TLangFirst&> my_item(key, item);
   insert(my_item);
   return true;
}

GSymbol TFirstFollowTable::Add(const TFirstFollow& key)
{
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(&key));
   if (ip != map.end()) {
      std::pair<const Key, const GSymbol&> item = (*ip);
      return item.second;
   }
   GSymbol sym(GSymbol::gsTable, count());
   const TFirstFollow* my_key = new TFirstFollow(key);
   vector.push_back(my_key);
   std::pair<const Key, const GSymbol&> item(my_key, sym);
   map.insert(item);
   return sym;
}

void TFirstFollowTable::Copy(const TFirstFollowTable& join)
{
   for (const TFirstFollow* item : join.vector) {
      Add(*item);
   }
}

void TFirstFollowTable::Clear()
{
   for (const TFirstFollow* item : vector) {
      delete item;
   }
   vector.clear(); map.clear();
}

const TFirstFollow& TFirstFollowTable::Get(const GSymbol& sym) const
{
   return *vector[sym.situation];
}

void TFirstFollowTable::print(FILE* file, const TGrammar* grammar, int print_mode) const
{
   int t = 0;
   for (const TFirstFollow* item : vector) {
      fprintf(file, "\nTable: %05d", t++);
      item->print(file, grammar, print_mode);
   }
}

void TNextTab::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if (!title) {
      fprintf(file, "\n--- NEXTs table --- <%d> ---\n", (int)size());
   }
   if (print_mode == 0x00) return;
   GSymbol T_old; T_old.formula = -1;
   for (const std::pair<const TTwoSym&, const GSymbolSet&> item : *this) {
      TTwoSym key = item.first;
      GSymbol& T = key.one;
      if (!(T == T_old)) {
         T_old = T;
      } else {
         T.type = GSymbol::gsNone;
      }
      key.print(grammar, print_mode, file);
      fprintf(file, " -> ");
      item.second.print(grammar, print_mode, file);
      fprintf(file, "\n");
   }
   if (title) {
      fclose(file);
   }
}

bool GVectors::Plus(const GSymbolSet& left, const GSymbolSet& right, GSymbolSet& result, int k)
{
//   if (left.empty() || right.empty()) return false;
   if (left.empty()) { result = right; return true; }
   if (right.empty()) { result = left; return true; }
   for (const GSymbol& v1 : left) {
      for (const GSymbol& vy : right) {
         if ((v1.IsEmpty()) && (vy.IsEmpty())) {
            result += GSymbol::empty;
         } else if (v1.IsEmpty()) {
            result += vy;
         } else if (vy.IsEmpty() || (k == 0)) {
            result += v1;
         } else {
            const GSymbolVector *vec_1 = NULL;
            if (v1.IsVector()) vec_1 = &Vector(v1);
            if (vec_1 && (vec_1->count() == k)) {
               result += v1;
               break;
            }
            const GSymbolVector *vec_y = NULL;
            if (vy.IsVector()) vec_y = &Vector(vy);
            GSymbolVector vector;
            int len = 0;
            if (vec_1) {
               for (const GSymbol& sym : *vec_1) {
                  if (len++ >= k) break;
                  vector << sym;
               }
            } else {
               vector << v1;
            }
            if (vec_y) {
               for (const GSymbol& sym : *vec_y) {
                  if (len++ >= k) break;
                  vector << sym;
               }
            } else {
               vector << vy;
            }
            const GSymbol header = Add(vector);
            result += header;
         }
      }
   }
   return true;
}

int  GVectors::MinLength(const TFirstFollow& alpha) const
{
   if (alpha.empty()) return 0;
   int min = 1000000000;
   for (const GSymbol& v : alpha) {
      if (v.IsEmpty()) {
         return 0;
      } else if (v.IsTerminal()) {
         if (1 < min) {
            min = 1;
         }
      } else {
         const GSymbolVector &vec = Vector(v);
         if (vec.count() < min) {
            min = vec.count();
         }
      }
   }
   return min;
}

void GVectors::Tails(GSymbolVector& from, GSymbolVector& to, const TLexemeSet& lexemes)
{
   from.push_back(GSymbol());
   to.clear();
   for (const std::pair<const GSymbol&, int> item : lexemes) {
      from.back() = item.first; // lexeme
      GSymbol vector = Add(from);
      to.push_back(vector);
   }
   from.pop_back();
}

// -------------------------------- TDerivation -------------------------------
void TDerivation::Make(const GSymbolSet* filter)
{
   for (const GFormula* formula : grammar->formulas) {
      FORMULA_DELETED_CONTINUE(formula);
      for (const GProduce& produce : *formula) {
         if (produce.IsEmpty()) continue;
         const GSymbol& sym = produce.front();
         if (sym.IsFormula() && ((filter == NULL) || filter->Have(sym))) {
            Add(formula->head, sym);
         }
      }
   }
   int change;
   do {
      change = 0;
      for (const GFormula* formula : grammar->formulas) {
         FORMULA_DELETED_CONTINUE(formula);
         for (const GProduce& produce : *formula) {
            if (produce.IsEmpty()) continue;
            for (const GSymbol& sym : produce) {
               if (!sym.IsFormula()) break;
               if (Count(sym)) {
                  const GSymbolSet& set_B = Get(sym);
                  for (const GSymbol& sym_B : set_B) {
                     if (Add(formula->head, sym_B)) change++;
                  }
                  break;
               } else {
                  const GFormula& prefix = grammar->Formula(sym);
                  if (!prefix.IsEmpty()) break;
               }
            }
         }
      }
   } while (change);
}

void TDerivation::print(FILE* file, int print_mode) const
{
   int number_item = 0;
   for (const std::pair<const GSymbol&, const GSymbolSet&> item : *this) {
      if (number_item++) fprintf(file, "\n");
      item.first.print(grammar, print_mode, file);
//      fprintf(file, " -> ");
      item.second.print(grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmMultiLine | T_PrintMode::pmOffset, file);
   }
   fprintf(file, "\n");
}

bool GSymbolSetMap::Add(const GSymbol& A, const GSymbol& B)
{
   iterator ip = find(A);
   if (ip == end()) {
      std::pair<const GSymbol&, GSymbolSet> item(A, GSymbolSet());
      item.second.Add(B);
      insert(item);
      return true;
   }
   GSymbolSet& item = (*ip).second;
   if (item.Have(B)) return false;
   return item.Add(B);
}

bool GSymbolSetMap::Get(const GSymbol& A, const GSymbol& B) const
{
   const_iterator ip = find(A);
   if (ip == end()) return false;
   const GSymbolSet& item = (*ip).second;
   return item.Have(B);
}

GSymbolSet& GSymbolSetMap::Get(const GSymbol& A)
{
   iterator ip = find(A);
   if (ip == end()) {
      std::pair<const GSymbol&, GSymbolSet> item(A, GSymbolSet());
      insert(item);
      ip = find(A);
   }
   return (*ip).second;
}

int GSymbolSetMap::Count(const GSymbol& A) const
{
   const_iterator ip = find(A);
   if (ip == end()) return 0;
   return (int)((*ip).second).size();
}

#ifndef TRN_GRAMMAR_H
#define TRN_GRAMMAR_H

#include "RSyntax.h"

class TFirstFollowMap;
class TFirstFollow : public GSymbolSet
{
public:
   TFirstFollow(const TFirstFollowMap* g = NULL) :owner(g), k(-1) {}
   int  operator += (const GSymbol& sym) { return (GSymbolSet&)(*this) += sym; }
   int  operator += (const TFirstFollow& join);
   TFirstFollow operator * (const TFirstFollow& join) const;
public:
   int  Length(TGrammar * grammar);
   int  count() const { return (int)size(); }
   void print(FILE* file, const TGrammar* grammar, int print_mode = 0x00) const;
public:
   int  k;
   const TFirstFollowMap* owner;
};

class TFirst : public TFirstFollow
{
public:
   TFirst(const TFirstFollowMap* g = NULL) :TFirstFollow(g) {}
   TFirst(const GSymbolVector& s, const TFirstFollowMap* g = NULL);
   int  operator += (const GSymbolVector& symbols);
   int  operator += (const GSymbol& sym) { return (GSymbolSet&)(*this) += sym; }
   int  operator += (const TFirst& join) { return (GSymbolSet&)(*this) += (GSymbolSet&)join; }
};

class TFollow : public TFirstFollow
{
public:
   TFollow(const TFirstFollowMap* g = NULL) :TFirstFollow(g) {}
};

class TFirstFollowMap : public std::map<const GSymbol, TFirstFollow>
{
public:
   TFirstFollowMap(TGrammar* g) :grammar(g) {}
   bool Add(const GSymbol& key, TFirstFollow& item);
   bool Have(const GSymbol& key, const GSymbol& sym) const;
   bool HaveEmpty(const GSymbol& key) const { return Have(key, GSymbol::empty); };
   bool FIRST(const GSymbolVector& alpha, TFirst& first) const;
   bool FIRST(const GSymbolVector& alpha, TFirst& first, int k) const;
   bool EFF(const GSymbolVector& alpha, TFirst& first, int k) const;
   bool FirstTail(const GSymbol& point, TFirst& first) const;
   bool FirstTail(const GSymbol& point, TFirst& first, int k) const;
   bool make_FIRSTs();
   bool make_FOLLOWs(const TFirstFollowMap& FIRSTs);
public:
   int  count() const;
   void print(const char* file_name = NULL, const char* title = NULL, int print_mode = 0x00) const;
   void print(FILE* file, int print_mode = 0x00) const;
public:
   TGrammar * grammar;
};

class TLangFirstMap;
class TLangFirst : public std::set<TFirst>
{
public:
   TLangFirst() :owner(NULL) {}
   bool Insert(const TFirst& item);
   void print(FILE* file, const TGrammar* grammar, int print_mode) const;
   void Merge(TFirstFollow& lang) const;
public:
   const TLangFirstMap* owner;
};

class TLangFirstMap : public std::map<const GSymbol, TLangFirst>
{
public:
   TLangFirstMap(TGrammar* g) :grammar(g) {}
   bool Add(const GSymbol& key, TLangFirst& item);
public:
   TGrammar * grammar;
};

class TFirstFollowTable
{
public:
   TFirstFollowTable() {}
   ~TFirstFollowTable() { Clear(); }
   GSymbol Add(const TFirstFollow& key);
   const TFirstFollow& Get(const GSymbol& sym) const;
   const TFirstFollow& Table(const GSymbol& tab) const { return Get(tab); }
   GSymbol Table(const TFirstFollow& key) { return Add(key); }
public:
   int  count() const { return (int)vector.size(); }
   void Clear();
   void Copy(const TFirstFollowTable& join);
   void print(FILE* file, const TGrammar* grammar, int print_mode = 0x00) const;
protected:
   struct Key {
      Key(const TFirstFollow *p) :key(p) {}
      bool operator == (const Key& k) const { return *key == *k.key; }
      bool operator <  (const Key& k) const { return *key <  *k.key; }
   public:
      const TFirstFollow *key;
   };
   std::map<const Key, const GSymbol> map;
   std::vector<const TFirstFollow*> vector;
};

class TNextTab : public TwoSymGSymbolSetMap {
public:
   TNextTab(TGrammar* g) :grammar(g) {}
public:
   void print(const char* title = NULL, int print_mode = 0x00) const;
public:
   TGrammar * grammar;
};

class GVectors
{
public:
   GVectors() {}
   ~GVectors() { clear(); }
   GSymbol Add(const GSymbolVector& key);
   const GSymbol& Find(const GSymbolVector& key) const;
   const GSymbolVector& Vector(const GSymbol& sym) const { return *vector[sym.group]; }
   bool Plus(const GSymbolSet& left, const GSymbolSet& right, GSymbolSet& result, int k);
   void Tails(GSymbolVector& from, GSymbolVector& to, const TLexemeSet& lexemes);
   int  MinLength(const TFirstFollow& alpha) const;
public:
   int  count() const { return (int)vector.size(); }
   void clear();
   void write(FILE* file, int print_mode) const;
   bool read(FILE* file, int print_mode);
public:
   struct Key {
      Key(const GSymbolVector *p) :key(p) {}
      bool operator == (const Key& k) const { return *key == *k.key; }
      bool operator <  (const Key& k) const { return *key <  *k.key; }
   public:
      const GSymbolVector *key;
   };
   std::map<const Key, const GSymbol> map;
   std::vector<const GSymbolVector*> vector;
};

class TGrammarBuilder;
class TableLLk;
class TGrammar
{
public:
   enum POption { opNone, 
      opGrammar     = 0x00000001, opFollow      = 0x00000002, opMaker          = 0x00000004, opLexeme        = 0x00000008,
      opFirst       = 0x00000010, opEFF         = 0x00000020, opBNF            = 0x00000040,
      opFormula     = 0x00000100, opRule        = 0x00000200, opOutput         = 0x00000400, opC2A           = 0x00000800,
      opAction      = 0x00001000, opTable       = 0x00002000, opFiUnattainable = 0x00004000, opSplitting     = 0x00008000,
      opState       = 0x00010000, opStateCore   = 0x00020000, opStateSort      = 0x00040000, opGoTo          = 0x00080000,
      opAssociation = 0x00100000, opCompression = 0x00200000,                                opNoPriorAssign = 0x00800000,
      opChainRule   = 0x01000000,
      opEof2Empty   = 0x10000000, 
      opCell = opAction, opAhead = opC2A, opLLk = opC2A, opFiUn = opC2A, opSplittingAddition = opFiUnattainable
   }; // 0x003910FF
public:
   TGrammar() :root(NULL), lexemes(this), FIRSTs(this), FOLLOWs(this), FIRSTsP(this), EFFs(this), SIGMAs(this), file(NULL), 
               Mtable(this), LRtable(this), type(gtNone), option(0), prefix(""), look_ahead(0), TabLLk(NULL), builder(NULL), makers(NULL), names(NULL) {}
   GFormula* Find(const char* title) const;
   const GFormula& Formula(const GSymbol &sym) const;
   const GProduce& Produce(const GSymbol &sym) const;
   int  Replace(const GSymbol &from, const GSymbol &to);
public:
   bool make(const GMakerTable* makers);
   void makers_used() const;
   bool make();
   bool Make(int type, A_Syntax::T_SyntaxMode syntax_mode, M_Syntax::M_Mode make_mode, const char* file);
   void make_lexemes();
   bool make_produces();
   bool make_start();
   bool make_start(GFormula* start) { root = start; return make_start(); }
   bool filter_makers(int filter);
   bool make_makers_head();
   bool make_makers_empty();
   bool make_FIRSTs() { return FIRSTs.make_FIRSTs(); };
   bool make_FIRSTsP();
   bool make_FOLLOWs() { return FOLLOWs.make_FOLLOWs(FIRSTs); };
   void grammar_type();
   bool make_Symple();
   bool make_Left();
   void change_group();
   void Used();
   bool NoEmptyLanguage(int mode = 0);
   bool UnacceptableSymbols(int mode = 0);
   bool ExcessRemoval(int mode = 0);
   int  ValidLLk();
   bool verify_LL();
   int  count() const { return (int)formulas.size(); }
   void Add(GFormula* f);
   int  Maker(const char* m) const;
   const GMaker* Maker(int m) const;
   const GSymbol& Cell(const MTableKey& key) const;
   const TAction& Action(MTableKey& key) const;
   bool IsStart(const GSymbol& sym) const;
public:
   GSymbol AddVector(const GSymbolVector& join) { return Vectors().Add(join); }
   const GSymbolVector& Vector(const GSymbol& sym) const { return Vectors().Vector(sym); }
   virtual GVectors& Vectors() { return vectors; }
   virtual const GVectors& Vectors() const { return vectors; }
private:
   GVectors vectors;
public:
   bool Plus(const TFirstFollow& left, const TFirstFollow& right, TFirstFollow& result, int k) { return Vectors().Plus(left, right, result, k); }
   bool make_FIRST_ks(int k = 1);
   bool make_EFF_ks(int k = 1);
   bool make_FOLLOW_ks(int k = 1);
   bool make_SIGMA_ks(int k = 1);
   int  look_ahead;
public:
   const GSymbol& GetLLkA(const GSymbol& tab) const;
   TableLLk *TabLLk;
   std::vector<int> references;
public:
   void YACC(const char* f, int print_mode = 0x00, const char* prefix = "yy") const;
   void BNF(const char* f, int print_mode = 0x00) const;
   void MACRO(const char* f, int print_mode = 0x00) const;
   void PROG(const char* f, int print_mode = 0x00) const;
   void write(FILE* file, int print_mode = 0x00) const;
   bool read(FILE* file, int print_mode = 0x00);
   void write(const char* title, int print_mode = 0x00) const;
   void write_LL(const char* title, int print_mode = 0x00) const;
   void write_LR(const char* title, int print_mode = 0x00) const;
   bool read(const char* title, int &table_type, int print_mode = 0x00);
   bool read(const char* title, int print_mode = 0x00);
public:
   GFormula* AddFormula(const char* title);
   GFormula* FindFormula(const char* title) { return formulas.Find(title); }
   void AddProduce(const GSymbol &sym);
   void AddProduce();
   void AddProduce(const GSymbol &sym, int count, const int I[][5]);
   void AddProduce(int count, const int I[][5]);
   void AddItem(const GSymbol &sym);
   void AddItems(int count, const int I[][5]);
   void AddAction(const MTableKey& key, const TAction& action);
   void AddActions(int count, const int A[][16]);
   void AddCell(const MTableKey& key, const GSymbol& cell);
   void AddCells(int count, const int C[][15]);
   void AddVector(int count, const int I[][5]);
public:
   TFirst & Eff(const GSymbol& key) { return (TFirst&)EFFs.at(key); }
   TFirst & First(const GSymbol& key) { return (TFirst&)FIRSTs.at(key); }
   TFollow& Follow(const GSymbol& key) { return (TFollow&)FOLLOWs.at(key); }
   const TFirst & First(const GSymbol& key) const { return (const TFirst&)FIRSTs.at(key); }
   const TFollow& Follow(const GSymbol& key) const { return (const TFollow&)FOLLOWs.at(key); }
   bool Split(GSymbolSet& main, GSymbolSet& half) const;
public:
   std::vector<int> used;
public:
   T_Grammar         type;
   const char*       prefix;
   const char*       file; // print
public:
   void print_(FILE* file, int print_mode = 0x00) const;
   void print(const char* title = NULL, int print_mode = 0x00) const;
   void output(const char* title = NULL, int print_mode = 0x00) const;
   GFormulaTable     formulas;
   std::vector<GSymbol> produces;
   TNameTable*       names;
   TGrammarBuilder*  builder;
   GFormula*         root;
   const GMakerTable*makers;
   TLexemeSet        lexemes;
   MTableMap         Mtable;
   LRTableMap        LRtable;
   int               option;
public:
   TFirstFollowMap   FIRSTs, FIRSTsP, EFFs;
   TFirstFollowMap   FOLLOWs;
   TLangFirstMap     SIGMAs;
};

class GSymbolSetMap : public std::map<GSymbol, GSymbolSet> {
public:
   bool Have(const GSymbol& A) const { return (find(A) != end()); }
   bool Have(const GSymbol& A, const GSymbol& B) const { return Get(A,B); }
   bool Add(const GSymbol& A, const GSymbol& B);
   bool Get(const GSymbol& A, const GSymbol& B) const;
   GSymbolSet& Get(const GSymbol& A);
   int  Count(const GSymbol& A) const;
   int  count() const { return (int)size(); }
};

class TDerivation : public GSymbolSetMap {
public:
   TDerivation(TGrammar* g) :GSymbolSetMap(), grammar(g) {}
   void Make(const GSymbolSet* filter = NULL);
public:
   void print(FILE* file, int print_mode = 0x00) const;
public:
   TGrammar* grammar;
};

#define FORMULA_DELETED_CONTINUE(F) if (F->IsDeleted()) continue;

const char* maker_title(int maker);

#endif
#ifndef TRN_GRAMMAR_CFG_H
#define TRN_GRAMMAR_CFG_H

#define DEFINE_RULE_FULL
//#define DEFINE_RULE_EXPR
//#define DEFINE_RULE_DEF
//#define DEFINE_RULE_STMT

//#define DEFINE_GRAMMAR_EXPR_LR
//#define DEFINE_GRAMMAR_ETF_LL
//#define DEFINE_GRAMMAR_ETF_LR
//#define DEFINE_GRAMMAR_EEE_LR
//#define DEFINE_GRAMMAR_EbEpE
//#define DEFINE_GRAMMAR_IFE
//#define DEFINE_GRAMMAR_SCC
//#define DEFINE_GRAMMAR_SLR

//#define DEFINE_GRAMMAR_NL
#define DEFINE_GRAMMAR_LL
//#define DEFINE_GRAMMAR_NR
//#define DEFINE_GRAMMAR_LR

#define PARSE_GRAMMAR

#if   defined(PARSE_GRAMMAR)
   #if   defined(DEFINE_GRAMMAR_LL)
//      #define PARSE_LL
      #define PARSE_LR1
   #elif defined(DEFINE_GRAMMAR_NL)
      #define PARSE_NLL
//      #define PARSE_YACC
   #elif defined(DEFINE_GRAMMAR_LR)
      #define PARSE_LR0
//      #define PARSE_LR1
//      #define PARSE_YACC
//      #define PARSE_LALR
   #elif defined(DEFINE_GRAMMAR_NR)
//      #define PARSE_LR0
      #define PARSE_NLR
//      #define PARSE_YACC
//      #define PARSE_LALR
   #elif defined(DEFINE_GRAMMAR_SLR) || defined(DEFINE_GRAMMAR_SCC)
//      #define PARSE_LR0
//      #define PARSE_LR1
      #define PARSE_LALR
//      #define PARSE_YACC
   #elif defined(DEFINE_GRAMMAR_ETF_LL)
//      #define PARSE_LL
//      #define PARSE_LR0
//      #define PARSE_LR1
      #define PARSE_LALR
   #elif defined(DEFINE_GRAMMAR_ETF_LR) || defined(DEFINE_GRAMMAR_EXPR_LR) || defined(DEFINE_GRAMMAR_EEE_LR) || defined(DEFINE_GRAMMAR_EbEpE)
//      #define PARSE_LR0
//      #define PARSE_LR1
      #define PARSE_LALR
   #endif
#endif

//#define NO_GEN_MAKE
#define MAKER_RULE_EMPTY
//#define MAKER_RULE_HEAD

#endif

#include "stdafx.h"

#include "GrammarStock.h"
#include "Grammar.h"

#undef  DEFINE_RULE_FULL
#define DEFINE_RULE_FULL
//#define DEFINE_RULE_EXPR

#include "Maker.h"

#define FORMULA_MACRO_DEFINE

#pragma optimize("", on)

#undef  DEFINE_GRAMMAR_LR
#define DEFINE_GRAMMAR_LL
#include "RuleMacro.h"

static bool build_formulas_ll(TGrammar &table, TRuleNames &names, int mode)
{
   GFormulaTable &formulas = table.formulas;

   T_Stock def_rule_mode = (T_Stock)(mode & T_Stock::msGrammar), make_mode = (T_Stock)(mode & T_Stock::msMake);

   if ((def_rule_mode == T_Stock::msETF_LL) && (make_mode == T_Stock::msNone)) {

     FORMULA(S_) 
        PRODUCE RULE(E) END
     END
     
     FORMULA(E)
        PRODUCE RULE(T) RULE(E_) END 
     END 
     
     FORMULA(E_)
        PRODUCE OPER(Add) RULE(T) MASTER END 
        EMPTY 
     END 
     
     FORMULA(T) 
        PRODUCE RULE(F) RULE(T_) END 
     END 
     
     FORMULA(T_)
        PRODUCE OPER(Multi) RULE(F) MASTER END 
        EMPTY 
     END 
     
     FORMULA(F)
        PRODUCE SYM(LeftBracket) RULE(E) SYM(RightBracket) END 
        PRODUCE LEX(Ident) END
     END

   } else if ((def_rule_mode == T_Stock::msETF_LL) && ((make_mode == T_Stock::msTree) || (make_mode == T_Stock::msCode))) {

      FORMULA(S_)
         PRODUCE RULE(_E) END
      END

      FORMULA(_E)
         PRODUCE MAKE(BegStmExpr) RULE(E) MAKE_TREE(AddToList) MAKE_CODE(EndBlock) END
      END

      FORMULA(E_)
         PRODUCE PRIOR(Term) RULE(T) MAKE(Binary) MASTER END
         EMPTY
      END

      FORMULA(E)
         PRODUCE RULE(T) RULE(E_) END
      END

      FORMULA(T_)
         PRODUCE PRIOR(Factor) RULE(F) MAKE(Binary) MASTER END
         EMPTY
      END

      FORMULA(T)
         PRODUCE RULE(F) RULE(T_) END
      END

      FORMULA(F)
         PRODUCE SYM(LeftBracket) RULE(E) SYM(RightBracket) END
         PRODUCE LEX(Integer) MAKE(Number) END
//         PRODUCE LEX(Number) MAKE(Number) END 
      END

   } else if (def_rule_mode == T_Stock::msLL) {

      #undef EXPRESSION
      #undef EXPRESSION_BODY
      #define EXPRESSION(PART) RULE(Expression##PART)
      #include "def_formula_LL.cpp"
      #define EXPRESSION_BODY(PART) FORMULA(Expression##PART) PRODUCE PARAM(MAKE_CODE(Part),T_Part::ps##PART) RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),T_Part::ps##PART) PARAM(MAKE_YACC(ExpressionS),T_Part::ps##PART) END END
      #include "def_rule_expression.cpp"
   } else if (def_rule_mode == T_Stock::msNL) {
      #undef EXPRESSION
      #undef EXPRESSION_BODY
      #define EXPRESSION(PART) RULE(Expression##PART)
      #include "def_formula_NL.cpp"
      #define EXPRESSION_BODY(PART) FORMULA(Expression##PART) PRODUCE RULE(Expressions) PARAM(MAKE_TREE(ExpressionS),T_Part::ps##PART) END END
      #include "def_rule_expression.cpp"
   }

   return formulas.count() != 0;
}

#undef  DEFINE_GRAMMAR_LL
#define DEFINE_GRAMMAR_LR
#include "RuleMacro.h"

static bool build_formulas_lr(TGrammar &table, TRuleNames &names, int mode)
{
   GFormulaTable &formulas = table.formulas;

   T_Stock def_rule_mode = (T_Stock)(mode & T_Stock::msGrammar), make_mode = (T_Stock)(mode & T_Stock::msMake);

   if (def_rule_mode == T_Stock::msEXPR_LR) {

     FORMULA(S_) 
        PRODUCE RULE(OrOr) END
     END
     
     FORMULA(OrOr   ) PRODUCE MASTER PRIOR(OrOr   ) RULE(AndAnd ) MAKE(Binary) END PRODUCE RULE(AndAnd ) END END
     FORMULA(AndAnd ) PRODUCE MASTER PRIOR(AndAnd ) RULE(Or     ) MAKE(Binary) END PRODUCE RULE(Or     ) END END
     FORMULA(Or     ) PRODUCE MASTER PRIOR(Or     ) RULE(XOr    ) MAKE(Binary) END PRODUCE RULE(XOr    ) END END
     FORMULA(XOr    ) PRODUCE MASTER PRIOR(XOr    ) RULE(And    ) MAKE(Binary) END PRODUCE RULE(And    ) END END
     FORMULA(And    ) PRODUCE MASTER PRIOR(And    ) RULE(Equ    ) MAKE(Binary) END PRODUCE RULE(Equ    ) END END
     FORMULA(Equ    ) PRODUCE MASTER PRIOR(Equ    ) RULE(Compare) MAKE(Binary) END PRODUCE RULE(Compare) END END
     FORMULA(Compare) PRODUCE MASTER PRIOR(Compare) RULE(Shift  ) MAKE(Binary) END PRODUCE RULE(Shift  ) END END
     FORMULA(Shift  ) PRODUCE MASTER PRIOR(Shift  ) RULE(Term   ) MAKE(Binary) END PRODUCE RULE(Term   ) END END
     FORMULA(Term   ) PRODUCE MASTER PRIOR(Term   ) RULE(Factor ) MAKE(Binary) END PRODUCE RULE(Factor ) END END
     FORMULA(Factor ) PRODUCE MASTER PRIOR(Factor ) RULE(Unary  ) MAKE(Binary) END PRODUCE RULE(Unary  ) END END
     
     FORMULA(Unary)
        PRODUCE SYM(LeftBracket) RULE(OrOr) SYM(RightBracket) END 
        PRODUCE LEX(Ident)   MAKE(Ident) END
        PRODUCE LEX(Integer) MAKE(Number) END
     END

   } else if (def_rule_mode == T_Stock::msETF_LR) {

      FORMULA(S_) 
         PRODUCE RULE(E) END
      END
      
      FORMULA(E)
         PRODUCE MASTER PRIOR(Term) RULE(T) END
         PRODUCE RULE(T) END 
      END
      
      FORMULA(T)
         PRODUCE MASTER PRIOR(Factor) RULE(F) END
         PRODUCE RULE(F) END 
      END
      
      FORMULA(F)
         PRODUCE SYM(LeftBracket) RULE(E) SYM(RightBracket) END 
         PRODUCE LEX(Ident) MAKE(Ident) END
      END

   } else if ((def_rule_mode == T_Stock::msETF_LR) && ((make_mode == T_Stock::msTree) || (make_mode == T_Stock::msCode))) {

      FORMULA(S_) 
         PRODUCE RULE(E) END
      END
      
      FORMULA(E)
         PRODUCE MASTER PRIOR(Term) RULE(T) MAKE(Binary) END
         PRODUCE RULE(T) END 
      END
      
      FORMULA(T)
         PRODUCE MASTER PRIOR(Factor) RULE(F) MAKE(Binary) END
         PRODUCE RULE(F) END 
      END
      
      FORMULA(F)
         PRODUCE SYM(LeftBracket) RULE(E) SYM(RightBracket) END 
         PRODUCE LEX(Ident) MAKE(Ident) END
      END

   } else if (def_rule_mode == T_Stock::msEEE) {

      FORMULA(S_) 
         PRODUCE RULE(E) END
      END
      
      FORMULA(E)
         PRODUCE MASTER PRIOR(Term) MASTER MAKE(Binary) END
         PRODUCE MASTER PRIOR(Factor) MASTER MAKE(Binary) END
         PRODUCE SYM(LeftBracket) MASTER SYM(RightBracket) END 
         PRODUCE LEX(Integer) MAKE(Number) END
//         PRODUCE LEX(Number) MAKE(Number) END
      END

   } else if (def_rule_mode == T_Stock::msEbEpE) {

      FORMULA(S_) 
         PRODUCE RULE(E) END
      END
      
      FORMULA(E)
         PRODUCE MASTER OPER(Sub) MASTER OPER(Add) MASTER END
         PRODUCE MASTER OPER(Sub) MASTER END
         PRODUCE MASTER OPER(Add) MASTER END
         PRODUCE SYM(LeftCramp) MASTER SYM(RightCramp) END 
         PRODUCE LEX(Ident) END
      END

   } else if (def_rule_mode == T_Stock::msLR) {

      #undef EXPRESSION
      #undef EXPRESSION_BODY
      #define EXPRESSION(PART) RULE(Expression##PART)
      #include "def_formula_LR.cpp"
      #define EXPRESSION_BODY(PART) FORMULA(Expression##PART) PRODUCE RULE(Expressions) PARAM(MAKE(ExpressionS),T_Part::ps##PART) MAKE_TURN(Command,Param,T_Part::ps##PART) END END
      #include "def_rule_expression.cpp"
   } else if (def_rule_mode == T_Stock::msNR) {

      #undef EXPRESSION
      #undef EXPRESSION_BODY
      #define EXPRESSION(PART) RULE(Expression##PART)
      #include "def_formula_NR.cpp"
      #define EXPRESSION_BODY(PART) FORMULA(Expression##PART) PRODUCE RULE(Expressions) PARAM(MAKE_ALL(ExpressionS),T_Part::ps##PART) END END
      #include "def_rule_expression.cpp"
   } else {
      return false;
   }

   return formulas.count() != 0;
}

static bool build_formulas(TRuleNames &names, TGrammar &table, int def_rule_mode, int make_mode) 
{
   GFormulaTable &formulas = table.formulas;
   bool ret = false;
   switch (def_rule_mode) {
      case 0x00: 
         table.type = T_Grammar::gtLL; table.prefix = "LL_"; 
         ret = build_formulas_ll(table, names, T_Stock::msLL | (make_mode << 12));
         break;
      case 0x01: 
         table.type = T_Grammar::gtLL; table.prefix = "NL_"; 
         ret = build_formulas_ll(table, names, T_Stock::msNL | (make_mode << 12));
         break;
      case 0x02: 
         table.type = T_Grammar::gtLR; table.prefix = "LR_"; 
         ret = build_formulas_lr(table, names, T_Stock::msLR | (make_mode << 12));
         break;
      case 0x03: 
         table.type = T_Grammar::gtLR; table.prefix = "NR_"; 
         ret = build_formulas_lr(table, names, T_Stock::msNR | (make_mode << 12));
         break;
      case 0x04: 
         table.type = T_Grammar::gtLL; table.prefix = "ETF_LL_"; 
         ret = build_formulas_ll(table, names, T_Stock::msETF_LL);
         break;
      case 0x05:
         table.type = T_Grammar::gtLL; table.prefix = "ETF_LL_";
         ret = build_formulas_ll(table, names, T_Stock::msETF_LL | (make_mode << 12));
         break;
      case 0x06: 
         table.type = T_Grammar::gtLR; table.prefix = "ETF_LR_"; 
         ret = build_formulas_lr(table, names, T_Stock::msETF_LR);
         break;
      case 0x07: 
         table.type = T_Grammar::gtLR; table.prefix = "ETF_LR_"; 
         ret = build_formulas_lr(table, names, T_Stock::msETF_LR | (make_mode << 12));
         break;
      case 0x08: 
         table.type = T_Grammar::gtLR; table.prefix = "EXPR_LR_"; 
         ret = build_formulas_lr(table, names, T_Stock::msEXPR_LR | (make_mode << 12));
         break;
      case 0x09: 
         table.type = T_Grammar::gtLR; table.prefix = "EEE_LR_"; 
         ret = build_formulas_lr(table, names, T_Stock::msEEE | (make_mode << 12));
         break;
      case 0x0A: 
         table.type = T_Grammar::gtLR; table.prefix = "IFE_LR_"; 
         ret = build_formulas_lr(table, names, T_Stock::msIFE);
         break;
      default:
         ret = false;
   }
   if (!ret) return ret;
   formulas.root = formulas.front();
   table.root = formulas.front();
   return ret;
}

bool build_grammar(TGrammar &table, int def_rule_mode, int make_mode, int mode) // 0x01 - formula, 0x02 - !make
{
   TRuleNames names;
   table.makers = &GMakerTable::maker_table;

   bool ret;
   if (mode & 0x01) { // formula
      ret = build_formulas(names, table, def_rule_mode, make_mode);
      if (ret && !(mode & 0x02)) ret = table.formulas.make(names, table.lexemes);
   } else {
   }
   if (ret && !(mode & 0x02)) { 
      table.make_produces();
      table.Used();
   }

   return ret;
}

bool build_grammar(TGrammar &table, int stock_mode, int mode) // 0x02 - !make
{
   TRuleNames names;
   table.makers = &GMakerTable::maker_table;

   bool ret = false;
   if ((stock_mode & T_Stock::msMedia) == T_Stock::msMFormula) {
      if (stock_mode & T_Stock::msLLLR) {
         table.type = T_Grammar::gtLL;
         ret = build_formulas_ll(table, names, stock_mode);
      } else {
         table.type = T_Grammar::gtLR;
         ret = build_formulas_lr(table, names, stock_mode);
      }
      if (ret && !(mode & 0x02)) ret = table.formulas.make(names, table.lexemes);
   } else {
   }
   if (ret && !(mode & 0x02)) { 
      table.make_produces();
      table.Used();
   }
   return ret;
}
#ifndef TRN_GRAMMAR_STOCK_H
#define TRN_GRAMMAR_STOCK_H

class TGrammar;

enum T_Stock {
              msNone     = 0x000000, 

              msMedia    = 0x0F0000, msMake = 0x00F000, 
                                     msTree = 0x001000, 
              msMFormula = 0x020000, msCode = 0x002000, 
              msMCpp     = 0x030000, msNode = 0x003000, 
              msMTab     = 0x040000, msTurn = 0x004000, 
              msMGrammar = 0x050000, 

              msGrammar  = 0x000FFF, msLLLR = 0x000800,
              msLL       = 0x000801,  
              msNL       = 0x000802, 
              msLR       = 0x000003, 
              msNR       = 0x000004,
              msETF_LL   = 0x000805,
              msETF_LR   = 0x000006,
              msEEE      = 0x000007,
              msEbEpE    = 0x000008,
              msIFE      = 0x000009,
              msEXPR_LR  = 0x00000C
             };

bool build_grammar(TGrammar &table, int def_rule_mode, int make_mode, int mode); // 0x01 - formula, 0x02 - !make
bool build_grammar(TGrammar &table, int stock_mode, int mode); // 0x02 - !make

#endif

#include "stdafx.h"

#include "Grammar.h"
#include "GSyntax.h"
#include "TSemantic.h"

// --------------------------- GSyntax ---------------------------

void GSyntax::print_symbol(const GSymbol& symbol, int print_mode)
{
   symbol.print(grammar,print_mode);
}

bool GSyntax::MatchAddLexeme(T_Lexeme& cur, const GSymbol& sym)
{
   const T_Lexeme must(T_Lexeme(T_Lexeme::T_Group((sym.type == GSymbol::gsEof) ? T_Lexeme::grEof : sym.group),sym.lexeme_type));
   bool ret = false;
   if (must.group == T_Lexeme::grSyntax) {
   	if (cur.Match(must.group,must.type)) {
         ret = true;
      } else if ((must.type == T_Lexeme::sxDefType) && ((cur.type == T_Lexeme::sxDefVar) || (cur.type == T_Lexeme::sxDefArr))) {
         ret = true;
      }
   } else {
      ret = cur.Match(must);
   }
   if (ret) {
      if ((make_mode != mmNone) && !(syntax_lexeme & T_SyntaxLexeme::slNoSave)) {
         if (sym.IsSaved()) {
            push_lexeme(cur);
         }
      }
      Lexeme(cur);
   }
   return ret;
}

void GSyntax::SaveLexeme(const T_Lexeme& cur, const GSymbol& must)
{
   if (((must.group == T_Lexeme::T_Group::grPriority) || (must.group == T_Lexeme::T_Group::grIdent) || 
        (must.group == T_Lexeme::T_Group::grInteger)  || (must.group == T_Lexeme::T_Group::grNumber) ||
        (must.group == T_Lexeme::T_Group::grReserv)   && ((must.lexeme_type == T_Lexeme::W_Type::rwDefine) || (must.lexeme_type == T_Lexeme::W_Type::rwVoid)))) {
      push_lexeme(forward);
   } else if ((cur.group == T_Lexeme::T_Group::grSyntax) && 
             !((cur.type == T_Lexeme::sxEmptyBracket) || (cur.type == T_Lexeme::sxEmptyCramp) || (cur.type == T_Lexeme::sxEmptyScrape))) {
      push_lexeme(cur);
   }
}

struct GSymbolLexeme {
public:
   T_Lexeme lexeme;
   GSymbol  symbol;
};

class TQueueLexeme {
public:
   TQueueLexeme(GSyntax* s) :syntax(s) {}
   void Fill(GSymbolLexeme& current);
   void Next(GSymbolLexeme& current);
protected:
   bool next(GSymbolLexeme& current);
   void cursor(GSymbolLexeme& current) const;
private:
   std::vector<T_Lexeme> lexeme_chain;
   GSymbolVector symbol_chain;
   GSyntax* syntax;
};

bool TQueueLexeme::next(GSymbolLexeme& current)
{
   if (current.lexeme.Match(T_Lexeme::grEof)) return false;
   lexeme_chain.push_back(current.lexeme);
   GSymbol current_sym;
   syntax->LexemeToSymbol(current.lexeme, current_sym);
   current_sym.value = 0; current_sym.mode = 0;
   symbol_chain << current_sym;
   return true;
}

void TQueueLexeme::cursor(GSymbolLexeme& current) const
{
   current.symbol = symbol_chain.empty() ? GSymbol::empty : syntax->grammar->Vectors().Find(symbol_chain);
   current.lexeme = lexeme_chain.empty() ? T_Lexeme(T_Lexeme::grEof, T_Lexeme::lxNone) : lexeme_chain.front();
}

void TQueueLexeme::Fill(GSymbolLexeme& current)
{
   while ((int)lexeme_chain.size() < syntax->look_ahead) {
      syntax->Lexeme(current.lexeme);
      if (!next(current)) break;
   }
   cursor(current);
}

void TQueueLexeme::Next(GSymbolLexeme& current)
{
   if (!lexeme_chain.empty()) lexeme_chain.erase(lexeme_chain.begin());
   if (!symbol_chain.empty()) symbol_chain.erase(symbol_chain.begin());
   next(current);
   cursor(current);
}

bool GSyntax::Translate()
{
   bool ret = false;
   if (syntax_mode == smParseLR0) {
      if (!Match(T_Lexeme::grEof)) {
         if ((make_mode == mmNode) || (make_mode == mmMade)) {
            if (look_ahead > 0) {
               ret = ParseLRk_SN();
            } else {
               ret = ParseLR0_SN();
            }
         } else if ((make_mode == mmNone) ||
                   ((make_mode == mmTree) || (make_mode == mmCode)) && (syntax_lexeme & (T_Grammar::mtTree | T_Grammar::mtCode)) ||
                    (make_mode == mmTurn) && (syntax_lexeme & T_Grammar::mtTurn)
                   ) {
            if (look_ahead > 0) {
               ret = ParseLRk();
            } else {
               ret = ParseLR0();
            }
         }
      } else {
         ret = true;
      }
   } else if (syntax_mode == smParseLL1) {
      if ((make_mode == mmNode) || (make_mode == mmMade)) {
         syntax_lexeme = T_SyntaxLexeme(syntax_lexeme | T_SyntaxLexeme::slNoSave);
         if (look_ahead > 0) {
            ret = ParseLLk_SN();
         } else {
            ret = ParseLL1_SN();
         }
      } else {
         if (look_ahead > 0) {
            ret = ParseLLk();
         } else {
            ret = ParseLL1();
         }
      }
   }
   printf("\nlevel=%d, step=%d", max_level, step);
   printf("\n--- semantic_tree = %d, syntax_tree = %d, lexemes = %d ----\n", (int)nodes.size(), tree ? 1 : 0, (int)lexemes.size());
   return ret;
}

bool GSyntax::ParseLL1()
{
   const GFormula& formula = *data->Root();
   entry(formula.head);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0);
   T_Lexeme current_lexeme; Lexeme(current_lexeme);
   GSymbol current_sym(current_lexeme);
   while (!empty()) {
      TStackRuleItem& item = top();
      const GSymbol& sym = item.sym;
      if (ret == -1) {
         if (print_rule) {
            print_offset(level, 0x03); print_symbol(sym,0x00); printf(", ret=%d", ret);
         }
         leave();
         continue;
      }
      if (sym.IsTerminal()) {
         if (print_rule) {
            printf("\n ? "); current_lexeme.print(&Scan()); printf("   "); print_symbol(sym,0x00); printf("\n");
         }
         int nodes_before=0, lexemes_before=0; Counts(nodes_before, lexemes_before);
         if (MatchAddLexeme(current_lexeme,sym)) { // current
            current_sym = current_lexeme;
            ret = 1; 
         } else {
            if (error_recovery & 0x01) {
               ErrorTable.Add(erSymbol,current_lexeme);
               error_recovery |= 0x02;
               ret = 1;
            } else {
               ret = -1;
            }
         }
         if (print_rule) {
            int nodes_after=0, lexemes_after=0; Counts(nodes_after, lexemes_after);
            print_offset(level, 0x03); print_symbol(sym,0x00); printf(", ret=%d", ret);
   	      printf(" [%d] -> [%d]\n", lexemes_before, lexemes_after);
         }
         leave(); 
      } else if (sym.IsMaker()) {
         if (Maker(sym)) {
            ret = 1; 
         } else {
            ret = -1; 
         }
         leave(); 
      } else if (sym.IsFormula()) {
         MTableKey key(sym,current_sym);
         if (print_rule) {
            print_offset(level,0x03); key.print(grammar,0x00);
         }
         const GSymbol& cell = Cell(key); 
         if (!cell.IsNone()) {
            if (cell.IsProduce()) {
               leave(); 
               const GProduce produce = Produce(cell);
               GProduce::const_reverse_iterator p = produce.rbegin();
               if (print_rule) {
                  print_offset(level, 0x03); printf(" <<");
               }
               while (p != produce.rend()) {
                  if (print_rule) {
                     printf(" "); print_symbol((*p),0x04);
                  }
                  entry((*p++));
               }
               if (print_rule) {
                  printf("\n");
               }
               ret = 0;
            } else if (cell.IsTerminal() && !sym.IsStart()) {
               leave();
               ret = 0;
            } else if (sym.IsStart() || sym.IsEof()) {
               if (error_recovery & 0x01) {
                  ErrorTable.Add(erSymbol,current_lexeme);
                  Lexeme(current_lexeme);
                  current_sym = current_lexeme;
                  error_recovery |= 0x02;
               } else {
                  ret = -1;
               }
            } else {
               print_offset(level, 0x03); printf(" ! "); print_symbol(sym,0x00);
               ret = -1;
            }
         } else {
            if (error_recovery & 0x01) {
               ErrorTable.Add(erSymbol,current_lexeme);
               Lexeme(current_lexeme);
               current_sym = current_lexeme;
               error_recovery |= 0x02;
               ret = 0;
            } else {
               ret = -1; 
            }
         }
      } else if (sym.IsEmpty()) {
         leave(); 
      } else {
         print_offset(level, 0x03); printf(" ! "); print_symbol(sym,0x00);
         ret = -1;
      }
   }
   return (ret != -1) && current_lexeme.Match(T_Lexeme::grEof);
}

bool GSyntax::ParseLLk()
{
   entry(GSymbol(GSymbol::gsTable)); // Table_00000

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0);

   TQueueLexeme queue(this);
   GSymbolLexeme current;
   queue.Fill(current);

   const GSymbol& current_sym = current.symbol;
   T_Lexeme& current_lexeme = current.lexeme;

   while (!empty()) {
      TStackRuleItem& item = top();
      const GSymbol& sym = item.sym;
      if (ret == -1) {
         if (print_rule) {
            print_offset(level, 0x03); print_symbol(sym, 0x00); printf(", ret=%d", ret);
         }
         leave();
         continue;
      }
      if (sym.IsTerminal()) {
         if (print_rule) {
            printf("\n ? "); current_lexeme.print(); printf("   "); print_symbol(sym, 0x00); printf("\n");
         }
         int nodes_before = 0, lexemes_before = 0; Counts(nodes_before, lexemes_before);
         if (MatchAddLexeme(current_lexeme, sym)) { // current
            queue.Next(current);
            ret = 1;
         } else {
            ret = -1;
         }
         if (print_rule) {
            int nodes_after = 0, lexemes_after = 0; Counts(nodes_after, lexemes_after);
            print_offset(level, 0x03); print_symbol(sym, 0x00); printf(", ret=%d", ret);
            printf(" [%d] -> [%d]\n", lexemes_before, lexemes_after);
         }
         leave();
      } else if (sym.IsMaker()) {
         if (Maker(sym)) {
            ret = 1;
         } else {
            ret = -1;
         }
         leave();
      } else if (sym.IsTable()) {
         MTableKey key(sym, current_sym);
         if (!grammar->references.empty()) {
            key.produce.table = grammar->references[key.produce.table];
         }
         key.sym.value = current_lexeme.value;
         if (print_rule) {
            print_offset(level, 0x03); key.print(grammar, 0x00);
         }
         const GSymbol& cell = Cell(key);
         if (cell.IsVector()) {
            leave();
            const GSymbolVector produce = grammar->Vector(cell);
            GProduce::const_reverse_iterator p = produce.rbegin();
            if (print_rule) {
               print_offset(level, 0x03); printf(" <<");
            }
            while (p != produce.rend()) {
               if (print_rule) {
                  printf(" "); print_symbol((*p), 0x04);
               }
               entry((*p++));
            }
            if (print_rule) {
               printf("\n");
            }
            ret = 0;
         } else if (cell.IsEmpty()) {
            leave();
            entry(GSymbol::empty);
         } else {
            print_offset(level, 0x03); printf(" ! "); print_symbol(sym, 0x00);  printf(" "); print_symbol(current_sym, 0x01);
            ret = -1;
         }
      } else if (sym.IsEmpty()) {
         leave();
      } else {
         print_offset(level, 0x03); printf(" ! "); print_symbol(sym, 0x00);
         ret = -1;
      }
   }
   return (ret != -1) && current_lexeme.Match(T_Lexeme::grEof);
}

bool GSyntax::ParseLL1_SN()
{
   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0);
   bool auto_tree = (option & T_OptionMode::omAutoTree) != 0;

   const GFormula& formula = *data->Root();
   entry(GSymbol()); // Action
   if (auto_tree) top().lexeme_node.unit = unit.New(GSymbol(GSymbol::gsProduce, formula.head.formula, 0));
   entry(formula.head); top().step = 1;

   T_Lexeme current_lexeme; Lexeme(current_lexeme);
   GSymbol current_sym(current_lexeme);

   const int S_count = 15;
   T_Lexeme_SNode* data_stack[S_count] = {};
   while (!empty()) {
      TStackRuleItem& item = top();
      const GSymbol& sym = item.sym;
      if (ret == -1) {
         if (print_rule) {
            print_offset(level, 0x03); print_symbol(sym,0x00); printf(", ret=%d", ret);
         }
         leave();
         continue;
      }
      if (sym.IsTerminal()) {
         if (print_rule) {
            printf("\n ? "); current_lexeme.print(); printf("   "); print_symbol(sym,0x00); printf("\n");
         }
         if (sym.IsSaved()) {
            int maker = item.step - 1;
            while ((maker >= 0) && !stack_item(filled() - item.step + maker).sym.IsMaker()) {
               maker--;
            }
            stack_item(filled() - item.step + maker).lexeme_node.lexeme = current_lexeme;
            if (auto_tree) stack_item(filled() - item.step - 1).lexeme_node.unit->Add(unit.New(current_lexeme), item.step); // Action
         }
         if (MatchAddLexeme(current_lexeme,sym)) { // current
            current_sym = current_lexeme;
            ret = 1; 
         } else {
            ret = -1;
         }
         if (print_rule) {
            print_offset(level, 0x03); print_symbol(sym,0x00); printf(", ret=%d\n", ret);
         }
         leave(); 
      } else if (sym.IsMaker()) {
         for (int s = 0, i = 0; i <= item.step; i++) {
            if (S_Syntax::rule_stack[filled() - 1 - i].sym.IsFormula()) continue;
            if (s >= S_count - 1) {
               ret = -1; 
               break;
            }
            data_stack[s + 1] = &S_Syntax::rule_stack[filled() - 1 - i].lexeme_node; s++;
            if (print_maker) {
               printf(" %03d", (filled() - 1 - i));
               const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 1 - i).lexeme_node;
               if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
               if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
               printf(" ");
            }
         }
         data_stack[0] = &S_Syntax::rule_stack[filled() - item.step - 1].lexeme_node;
         if (print_maker) printf(" %03d \n",(filled() - item.step - 1));
         const GSymbol& maker = sym;
         if (maker.IsMakerYACC()) {
            if (!MakerSyntaxNode(maker,data_stack)) {
               ret = -1; 
            }
         } else if (maker.IsMakerNode()) {
            if (!MakerSyntaxNode(maker,data_stack,GMakerTable::maker_table.maker_node)) {
               ret = -1; 
            }
         }
         leave(); 
      } else if (sym.IsFormula()) {
         MTableKey key(sym,current_sym);
         if (print_rule) {
            print_offset(level,0x03); key.print(grammar,0x00);
         }
         const GSymbol& cell = Cell(key); 
         if (cell.IsProduce()) {
            const GProduce produce = Produce(cell);
            T_SyntaxNode* node = NULL;
            if (auto_tree) {
               node = unit.New(produce.head);
               stack_item(filled() - item.step - 1).lexeme_node.unit->Add(node, item.step); // Action
            }
            leave();
            if (auto_tree) top().lexeme_node.unit = node;
            GProduce::const_reverse_iterator p = produce.rbegin();
            if (print_rule) {
               print_offset(level, 0x03); printf(" <<");
            }
            int len = 0;
            while (p != produce.rend()) {
               if (print_rule) {
                  printf(" "); print_symbol((*p),0x04);
               }
               if ((*p).IsFormula()) {
                  entry(GSymbol()); // Action
                  top().step = ++len;
               }
               entry((*p++));
               top().step = ++len;
            }
            if (print_rule) {
               printf("\n");
            }
            ret = 0;
         } else {
            print_offset(level, 0x03); printf(" ! "); print_symbol(sym,0x00);
            ret = -1;
         }
      } else if (sym.IsNone()) { // Action
         if (filled() > 1) {
            TStackRuleItem& next_item = stack_item(filled() - 2);
            if (next_item.sym.IsMaker() || next_item.sym.IsNone()) {
               if (item.lexeme_node.node) { next_item.lexeme_node.node = item.lexeme_node.node; }
               if (item.lexeme_node.tree) { next_item.lexeme_node.tree = item.lexeme_node.tree; }
               if (next_item.lexeme_node.lexeme.Match(T_Lexeme::grNone)) next_item.lexeme_node.lexeme = item.lexeme_node.lexeme;
            }
         }
         if ((filled() == 1)) { // Accept
            if (auto_tree) { Auto(item.lexeme_node.unit); }
            if (item.lexeme_node.node) Tree(item.lexeme_node.node);
            if (item.lexeme_node.tree) program = item.lexeme_node.tree;
         }
         leave();
      } else if (sym.IsEmpty()) {
         leave(); 
      } else {
         print_offset(level, 0x03); printf(" ! "); print_symbol(sym,0x00);
         ret = -1;
      }
   }
   return (ret != -1);
}

bool GSyntax::ParseLLk_SN()
{
   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0);
   bool auto_tree = (option & T_OptionMode::omAutoTree) != 0;

   entry(GSymbol()); // Action
   if (auto_tree) top().lexeme_node.unit = unit.New(GSymbol(GSymbol::gsProduce, 0, 0));
   entry(GSymbol(GSymbol::gsTable)); // Table_00000
   top().step = 1;

   TQueueLexeme queue(this);
   GSymbolLexeme current;
   queue.Fill(current);

   const GSymbol& current_sym = current.symbol;
   T_Lexeme& current_lexeme = current.lexeme;

   const int S_count = 15;
   T_Lexeme_SNode* data_stack[S_count] = {};
   while (!empty()) {
      TStackRuleItem& item = top();
      const GSymbol& sym = item.sym;
      if (ret == -1) {
         if (print_rule) {
            print_offset(level, 0x03); print_symbol(sym, 0x00); printf(", ret=%d", ret);
         }
         leave();
         continue;
      }
      if (sym.IsTerminal()) {
         if (print_rule) {
            printf("\n ? "); current_lexeme.print(); printf("   "); print_symbol(sym, 0x00); printf("\n");
         }
         if (sym.IsSaved()) {
            int maker = item.step - 1;
            while ((maker >= 0) && !stack_item(filled() - item.step + maker).sym.IsMaker()) {
               maker--;
            }
            stack_item(filled() - item.step + maker).lexeme_node.lexeme = current_lexeme;
            if (auto_tree) stack_item(filled() - item.step - 1).lexeme_node.unit->Add(unit.New(current_lexeme), item.step); // Action
         }
         if (MatchAddLexeme(current_lexeme, sym)) { // current
            queue.Next(current);
            ret = 1;
         } else {
            ret = -1;
         }
         if (print_rule) {
            print_offset(level, 0x03); print_symbol(sym, 0x00); printf(", ret=%d\n", ret);
         }
         leave();
      } else if (sym.IsMaker()) {
         for (int s = 0, i = 0; i <= item.step; i++) {
            if (S_Syntax::rule_stack[filled() - 1 - i].sym.IsTable()) continue;
            if (s >= S_count - 1) {
               ret = -1;
               break;
            }
            data_stack[s + 1] = &S_Syntax::rule_stack[filled() - 1 - i].lexeme_node; s++;
            if (print_maker) {
               printf(" %03d", (filled() - 1 - i));
               const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 1 - i).lexeme_node;
               if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
               if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
               printf(" ");
            }
         }
         data_stack[0] = &S_Syntax::rule_stack[filled() - item.step - 1].lexeme_node;
         if (print_maker) printf(" %03d \n", (filled() - item.step - 1));
         const GSymbol& maker = sym;
         if (maker.IsMakerYACC()) {
            if (!MakerSyntaxNode(maker, data_stack)) {
               ret = -1;
            }
         } else if (maker.IsMakerNode()) {
            if (!MakerSyntaxNode(maker, data_stack, GMakerTable::maker_table.maker_node)) {
               ret = -1;
            }
         }
         leave();
      } else if (sym.IsTable()) {
         MTableKey key(sym, current_sym);
         if (!grammar->references.empty()) {
            key.produce.table = grammar->references[key.produce.table];
         }
         if (key.produce.table == 787) {
            int i = 12; i++;
         }
         key.sym.value = current_lexeme.value;
         if (print_rule) {
            print_offset(level, 0x03); key.print(grammar, 0x00);
         }
         const GSymbol& cell = Cell(key);
         if (cell.IsVector()) {
            const GSymbolVector produce = grammar->Vector(cell);
            T_SyntaxNode* node = NULL;
            if (auto_tree) {
               node = unit.New(cell); // produce.head
               stack_item(filled() - item.step - 1).lexeme_node.unit->Add(node, item.step); // Action
            }
            leave();
            if (auto_tree) top().lexeme_node.unit = node;
            GProduce::const_reverse_iterator p = produce.rbegin();
            if (print_rule) {
               print_offset(level, 0x03); printf(" <<");
            }
            int len = 0;
            while (p != produce.rend()) {
               if (print_rule) {
                  printf(" "); print_symbol((*p), 0x04);
               }
               if ((*p).IsTable()) {
                  entry(GSymbol()); // Action
                  top().step = ++len;
               }
               entry((*p++));
               top().step = ++len;
            }
            if (print_rule) {
               printf("\n");
            }
            ret = 0;
         } else if (cell.IsEmpty()) {
            leave();
            entry(GSymbol::empty);
         } else {
            print_offset(level, 0x03); printf(" ! "); print_symbol(sym, 0x00);
            ret = -1;
         }
      } else if (sym.IsNone()) { // Action
         if (filled() > 1) {
            TStackRuleItem& next_item = stack_item(filled() - 2);
            if (next_item.sym.IsMaker() || next_item.sym.IsNone()) {
               if (item.lexeme_node.node) { next_item.lexeme_node.node = item.lexeme_node.node; }
               if (item.lexeme_node.tree) { next_item.lexeme_node.tree = item.lexeme_node.tree; }
               if (next_item.lexeme_node.lexeme.Match(T_Lexeme::grNone)) next_item.lexeme_node.lexeme = item.lexeme_node.lexeme;
            }
         }
         if ((filled() == 1)) { // Accept
            if (auto_tree) { Auto(item.lexeme_node.unit); }
            if (item.lexeme_node.node) Tree(item.lexeme_node.node);
         }
         leave();
      } else if (sym.IsEmpty()) {
         leave();
      } else {
         print_offset(level, 0x03); printf(" ! "); print_symbol(sym, 0x00);
         ret = -1;
      }
   }
   return (ret != -1);
}

// Green(v=2,p=221,9.2.4)
bool GSyntax::ParseLR0()
{
   GSymbol start(GSymbol::gsSituation);
   entry(start);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0), print_stack = (option & T_OptionMode::omPrintStack) != 0; 
   bool auto_tree = (option & T_OptionMode::omAutoTree) != 0;
   T_Lexeme current_lexeme; Lexeme(current_lexeme);
   GSymbol current_sym(current_lexeme);
   if (print_rule) {
      printf("\n>> "); current_lexeme.print(&Scan());
   }
   while (!empty()) {
      TStackRuleItem& item = top();
      if (ret == -1) {
         if (print_rule) {
            printf(">%d ",filled()); print_symbol(item.sym,0x00); printf(", ret=%d\n", ret);
         }
         leave();
         continue;
      }
      const GSymbol& situation = item.sym;
      MTableKey key(situation,current_sym);
      const TAction& action = Action(key); 
      if (print_rule) {
         key.print(grammar,0x00); printf(" -> "); action.print(grammar, 0x00); printf("\n");
      }
      if (action.IsAccept()) {
         if (auto_tree) {
            T_SyntaxNode* S_unit = unit.New(GSymbol(GSymbol::gsProduce)); // unit.New(action.sym);
            S_unit->Insert(item.lexeme_node.unit, 1);
            Auto(S_unit);
         }
         if (!SEmpty()) {
            SNode* node = SPop();
            Tree(node);
         }
         ret = 1;
         break;
      } else if (action.IsShift()) {
         int nodes_before=0, lexemes_before=0;
         if (print_rule) {
            Counts(nodes_before, lexemes_before); 
         }
         if ((make_mode != mmNone) && !(syntax_lexeme & T_SyntaxLexeme::slNoSave)) {
            if (current_lexeme.IsSaved()) {
               push_lexeme(current_lexeme);
            }
         }
         entry(action.sym);  // S
         if (auto_tree) top().lexeme_node.lexeme = current_lexeme; // AutoTree
         if (print_stack) {
            printf("<%d ",filled()); action.sym.print(grammar,0x00); printf("\n");
         }
         Lexeme(current_lexeme);
         current_sym = current_lexeme;
         int nodes_after=0, lexemes_after=0; 
         if (print_rule) {
            Counts(nodes_after, lexemes_after);
            printf("\n>> [%d] -> [%d] ", lexemes_before, lexemes_after); current_lexeme.print(&Scan());
         }
      } else if (action.IsReduce()) {
         const GProduce& produce = Produce(action.sym);
         int produce_len = produce.Count();
         if (produce.maker.IsMaker()) {
            if (!Maker(produce.maker)) {
               ret = -1; 
            }
         }
         T_Lexeme_SNode S0;
         if (produce_len && auto_tree) {
            S0.unit = unit.New(action.sym);
         }
         for (int r = produce_len; r; r--) {
            const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 1).lexeme_node;
            if (auto_tree) {
               if (lexeme_node.unit) { S0.unit->Insert(lexeme_node.unit, r); }
               if (lexeme_node.lexeme.IsSaved()) { S0.unit->Insert(unit.New(lexeme_node.lexeme), r); }
            }
            if (print_stack) {
               printf(">%d ",filled()); top().sym.print(grammar,0x00);  
               if (auto_tree) {
                  if (lexeme_node.unit) printf("<.%s.>", lexeme_node.unit->title());
                  if (!lexeme_node.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(lexeme_node.lexeme.group));
               }
            }
            leave(); 
         }
         if (print_stack) printf("\n");
         GSymbol A(GSymbol::gsFormula,action.sym.formula);
         MTableKey key(top().sym,A);
         const TAction& go_to = Action(key); 
         if (print_rule) {
            key.print(grammar,0x00); printf(" => "); go_to.print(grammar, 0x00); printf("\n");
         }
         if (go_to.IsGoto()) {
            entry(go_to.sym);  // S
            if (auto_tree) top().lexeme_node = S0;
            if (print_stack) {
               printf("<%d ",filled()); go_to.sym.print(grammar,0x00); printf("\n");
               if (auto_tree) {
                  if (S0.unit) printf("<.%s.>", S0.unit->title());
                  if (!S0.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(S0.lexeme.group));
               }
            }
         } else {
            ret = -1;
         }
      } else if (action.IsNone()) {
         ret = -1;
      } else {
         ret = -1;
      }
   }

   return (ret != -1);
}

// Green(v=2,p=218,9.2.3) - AutoTree
bool GSyntax::ParseLRk()
{
   GSymbol start(GSymbol::gsSituation);
   entry(start);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0), print_stack = (option & T_OptionMode::omPrintStack) != 0;
   bool auto_tree  = (option & T_OptionMode::omAutoTree) != 0;

   TQueueLexeme queue(this);
   GSymbolLexeme current;
   queue.Fill(current);

   const GSymbol& current_sym = current.symbol;
   T_Lexeme& current_lexeme = current.lexeme;

   while (!empty()) {
      TStackRuleItem& item = top();
      if (ret == -1) {
         if (print_rule) {
            printf(">%d ", filled()); print_symbol(item.sym, 0x00); printf(", ret=%d\n", ret);
         }
         leave();
         continue;
      }
      const GSymbol& situation = item.sym;
      MTableKey key(situation, current_sym);
      key.sym.value = current_lexeme.value;
      TAction action = Action(key);
      if (action.IsNone()) {
         if (print_rule) {
            key.print(grammar, 0x00); printf(" !> "); action.print(grammar, 0x00); printf("\n");
         }
         GSymbol my_sym(current_lexeme);
         my_sym.value = 0; my_sym.mode = 0;
         GSymbolVector vec; vec << my_sym;
         key.sym = data->grammar->Vectors().Find(vec);
         key.sym.value = current_lexeme.value;
         action = Action(key);
      }
      if (print_rule) {
         key.print(grammar, 0x00); printf(" -> "); action.print(grammar, 0x00); printf("\n");
      }
      if (action.IsAccept()) {
         if (auto_tree) {
            T_SyntaxNode* S_unit = unit.New(GSymbol(GSymbol::gsProduce)); // unit.New(action.sym);
            S_unit->Insert(item.lexeme_node.unit, 1);
            Auto(S_unit);
         }
         if (!SEmpty()) {
            SNode* node = SPop();
            Tree(node);
         }
         ret = 1;
         break;
      } else if (action.IsShift()) {
         int nodes_before = 0, lexemes_before = 0;
         if (print_rule) {
            Counts(nodes_before, lexemes_before);
         }
         if ((make_mode != mmNone) && !(syntax_lexeme & T_SyntaxLexeme::slNoSave)) {
            if (current_lexeme.IsSaved()) {
               push_lexeme(current_lexeme);
            }
         }
         entry(action.sym);  // S
         if (auto_tree) top().lexeme_node.lexeme = current_lexeme; // AutoTree
         if (print_stack) {
            printf("<%d ", filled()); action.sym.print(grammar, 0x00); printf("\n");
         }

         Lexeme(current.lexeme);
         queue.Next(current);

         int nodes_after = 0, lexemes_after = 0;
         if (print_rule) {
            Counts(nodes_after, lexemes_after);
            printf("\n>> [%d] -> [%d] ", lexemes_before, lexemes_after); current_lexeme.print(&Scan());
         }
      } else if (action.IsReduce()) {
         const GProduce& produce = Produce(action.sym);
         int produce_len = produce.Count();
         if (produce.maker.IsMaker()) {
            if (!Maker(produce.maker)) {
               ret = -1;
            }
         }
         T_Lexeme_SNode S0;
         if (produce_len && auto_tree) {
            S0.unit = unit.New(action.sym);
         }
         for (int r = produce_len; r; r--) {
            const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 1).lexeme_node;
            if (auto_tree) {
               if (lexeme_node.unit) { S0.unit->Insert(lexeme_node.unit, r); }
               if (lexeme_node.lexeme.IsSaved() || (Scan().mask & (A_Symbol::mmBNF | A_Symbol::mmSQL)) && (lexeme_node.lexeme.group != T_Lexeme::grNone)) { 
                  S0.unit->Insert(unit.New(lexeme_node.lexeme), r); 
               }
            }

            if (print_stack) {
               printf(">%d ", filled() - 1); top().sym.print(grammar, 0x00);
               if (auto_tree) {
                  if (lexeme_node.unit) printf("<.%s.>", lexeme_node.unit->title());
                  if (!lexeme_node.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(lexeme_node.lexeme.group));
               }
               printf(" ");
            }
            leave();
         }
         if (print_stack) printf("\n");
         GSymbol A(GSymbol::gsFormula, action.sym.formula);
         MTableKey key(top().sym, A);
         if (!grammar->references.empty()) {
            key.sym.formula = grammar->references[key.sym.formula];
         }
         const TAction& go_to = Action(key);
         if (print_rule) {
            key.print(grammar, 0x00); printf(" => "); go_to.print(grammar, 0x00); printf("\n");
         }
         if (go_to.IsGoto()) {
            entry(go_to.sym);  // S
            top().lexeme_node = S0;
            if (print_stack) {
               printf("<%d ", filled()); go_to.sym.print(grammar, 0x00); printf("\n");
               if (auto_tree) {
                  if (S0.unit) printf("<.%s.>", S0.unit->title());
                  if (!S0.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(S0.lexeme.group));
               }
            }
         } else {
            ret = -1;
         }
      } else if (action.IsNone()) {
         ret = -1;
      } else {
         ret = -1;
      }
   }

   return (ret != -1);
}

bool GSyntax::VerifyLR0(const GSymbol& current_sym)
{
   va_clear();
   int ret = 0;
   while (!va_empty()) {
      TStackRuleItem& item = va_top();
      const GSymbol& situation = item.sym;
      MTableKey key(situation,current_sym);
      const TAction& action = Action(key); 
      if (action.IsAccept()) {
         ret = 1;
         break;
      } else if (action.IsShift()) {
         break;
      } else if (action.IsReduce()) {
         const GProduce& produce = Produce(action.sym);
         int produce_len = produce.Count();
         for (int r = 1; r <= produce_len; r++) { 
            va_leave(); 
         }
         GSymbol A(GSymbol::gsFormula,action.sym.formula);
         MTableKey key(va_top().sym,A);
         const TAction& go_to = Action(key); 
         if (go_to.IsGoto()) {
            va_entry(go_to.sym);  // S
         } else {
            ret = -1;
            break;
         }
      } else {
         ret = -1;
         break;
      }
   }

   return (ret != -1);
}

bool GSyntax::ParseLR0_SN()
{
   GSymbol start(GSymbol::gsSituation);
   entry(start);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0), print_stack = (option & T_OptionMode::omPrintStack) != 0; 
   bool auto_tree = (option & T_OptionMode::omAutoTree) != 0;
   T_Lexeme current_lexeme; Lexeme(current_lexeme);
   GSymbol current_sym(current_lexeme);
   const int S_count = 15;
   T_Lexeme_SNode* data_stack[S_count] = {};
   if (print_rule) {
      printf("\n>> "); current_lexeme.print(&Scan());
   }
   while (!empty()) {
      TStackRuleItem& item = top();
      if (ret == -1) {
         if (print_rule) {
            printf(">%d ",filled()); print_symbol(item.sym,0x00); printf(", ret=%d\n", ret);
         }
         leave();
         continue;
      }
      const GSymbol& situation = item.sym;
      MTableKey key(situation,current_sym);
      const TAction& action = Action(key); 
      if (print_rule) {
         key.print(grammar,0x00); printf(" -> "); action.print(grammar, 0x00); printf("\n");
      }
      if (action.IsAccept()) {
         if (auto_tree) {
            T_SyntaxNode* S_unit = unit.New(GSymbol(GSymbol::gsProduce)); // unit.New(action.sym);
            S_unit->Insert(item.lexeme_node.unit, 1);
            Auto(S_unit);
         }
         if (item.lexeme_node.node) Tree(item.lexeme_node.node);
         if (item.lexeme_node.tree) program = item.lexeme_node.tree;
         ret = 1;
         break;
      } else if (action.IsShift()) {
         entry(action.sym);  // S
         top().lexeme_node.lexeme = current_lexeme;
         if (print_stack) {
            printf("<%d ",filled()); action.sym.print(grammar,0x00); printf("\n");
         }
         Lexeme(current_lexeme);
         current_sym = current_lexeme;
      } else if (action.IsReduce()) {
         const GProduce& produce = Produce(action.sym);
         int produce_len = produce.Count();
         T_Lexeme_SNode S0;
         if (produce_len && auto_tree) {
            S0.unit = unit.New(action.sym);
         }
         if (produce.maker.IsMaker()) {
            for (int s = 0; s < produce_len; s++) {
               if (s >= S_count - 1) {
                  ret = -1; 
                  break;
               }
               data_stack[s + 1] = &S_Syntax::rule_stack[filled() - produce_len + s].lexeme_node;
               if (print_maker) {
                  printf(" %03d", filled() - produce_len + s);
                  const T_Lexeme_SNode& lexeme_node = stack_item(filled() - produce_len + s).lexeme_node;
                  if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
                  if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
                  printf(" ");
               }
            }
            if (produce_len && print_maker) printf("\n");
            data_stack[0] = &S0;
            GSymbol maker(produce.maker);
            if (maker.IsMakerYACC()) {
               if (!MakerSyntaxNode(maker,data_stack)) {
                  ret = -1; 
               }
            } else if (maker.IsMakerNode()) {
               if (!MakerSyntaxNode(maker,data_stack,GMakerTable::maker_table.maker_node)) {
                  ret = -1; 
               }
            }
         } else if (produce.count()) {
            T_SyntaxNode* unit = S0.unit;
            S0 = S_Syntax::rule_stack[filled() - produce.count()].lexeme_node; // $1
            S0.unit = unit;
         }
         for (int r = produce_len; r; r--) {
            const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 1).lexeme_node;
            if (auto_tree) {
               if (lexeme_node.unit) { S0.unit->Insert(lexeme_node.unit, r); }
               if (lexeme_node.lexeme.IsSaved()) { S0.unit->Insert(unit.New(lexeme_node.lexeme), r); }
            }
            if (print_stack) {
               printf(">%d ",filled() - 1); top().sym.print(grammar,0x00);  
               if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
               if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
               if (auto_tree) {
                  if (lexeme_node.unit) printf("<.%s.>", lexeme_node.unit->title());
                  if (!lexeme_node.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(lexeme_node.lexeme.group));
               }
               printf(" ");
            }
            leave(); 
         }
         if (print_stack) printf("\n");
         GSymbol A(GSymbol::gsFormula,action.sym.formula);
         MTableKey key(top().sym,A);
         const TAction& go_to = Action(key); 
         if (print_rule) {
            key.print(grammar,0x00); printf(" => "); go_to.print(grammar, 0x00); printf("\n");
         }
         if (go_to.IsGoto()) {
            entry(go_to.sym);  // S
            top().lexeme_node = S0;
            if (print_stack) {
               printf("<%d ",filled() - 1); go_to.sym.print(grammar,0x00); 
               if (S0.node) printf("<%s>", snode_title(S0.node->type));
               if (S0.tree) printf("<%s>", S0.tree->title());
               if (auto_tree) {
                  if (S0.unit) printf("<.%s.>", S0.unit->title());
                  if (!S0.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(S0.lexeme.group));
               }
               printf("\n");
            }
         } else {
            ret = -1;
         }
      } else if (action.IsNone()) {
         ret = -1;
      } else {
         ret = -1;
      }
   }
   return (ret != -1);
}

bool GSyntax::ParseLRk_SN()
{
   GSymbol start(GSymbol::gsSituation);
   entry(start);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0), print_stack = (option & T_OptionMode::omPrintStack) != 0;
   bool auto_tree = (option & T_OptionMode::omAutoTree) != 0;

   TQueueLexeme queue(this);
   GSymbolLexeme current;
   queue.Fill(current);

   const GSymbol& current_sym = current.symbol;
   T_Lexeme& current_lexeme = current.lexeme;

   const int S_count = 15;
   T_Lexeme_SNode* data_stack[S_count] = {};
   if (print_rule) {
      printf("\n>> "); current_lexeme.print(&Scan());
   }
   while (!empty()) {
      TStackRuleItem& item = top();
      if (ret == -1) {
         if (print_rule) {
            printf(">%d ", filled()); print_symbol(item.sym, 0x00); printf(", ret=%d\n", ret);
         }
         leave();
         continue;
      }
      const GSymbol& situation = item.sym;
      MTableKey key(situation, current_sym);
      key.sym.value = current_lexeme.value;
      TAction action = Action(key);
      if (action.IsNone()) {
         if (print_rule) {
            key.print(grammar, 0x00); printf(" !> "); action.print(grammar, 0x00); printf("\n");
         }
         GSymbol my_sym(current_lexeme);
         my_sym.value = 0; my_sym.mode = 0;
         GSymbolVector vec; vec << my_sym;
         key.sym = data->grammar->Vectors().Find(vec);
         key.sym.value = current_lexeme.value;
         action = Action(key);
      }
      if (print_rule) {
         key.print(grammar, 0x00); printf(" -> "); action.print(grammar, 0x00); printf("\n");
      }
      if (action.IsAccept()) {
         if (auto_tree) {
            T_SyntaxNode* S_unit = unit.New(GSymbol(GSymbol::gsProduce)); // unit.New(action.sym);
            S_unit->Insert(item.lexeme_node.unit, 1);
            Auto(S_unit);
         }
         if (item.lexeme_node.node) Tree(item.lexeme_node.node);
         if (item.lexeme_node.tree) program = item.lexeme_node.tree;
         ret = 1;
         break;
      } else if (action.IsShift()) {
         entry(action.sym);  // S
         top().lexeme_node.lexeme = current_lexeme;
         if (print_stack) {
            printf("<%d ", filled()); action.sym.print(grammar, 0x00); printf("\n");
         }

         Lexeme(current.lexeme);
         queue.Next(current);

      } else if (action.IsReduce()) {
         const GProduce& produce = Produce(action.sym);
         int produce_len = produce.Count();
         T_Lexeme_SNode S0;
         if (produce_len && auto_tree) {
            S0.unit = unit.New(action.sym);
         }
         if (produce.maker.IsMaker()) {
            for (int s = 0; s < produce_len; s++) {
               if (s >= S_count - 1) {
                  ret = -1;
                  break;
               }
               data_stack[s + 1] = &S_Syntax::rule_stack[filled() - produce_len + s].lexeme_node;
               if (print_maker) {
                  printf(" %03d", filled() - produce_len + s);
                  const T_Lexeme_SNode& lexeme_node = stack_item(filled() - produce_len + s).lexeme_node;
                  if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
                  if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
                  printf(" ");
               }
            }
            data_stack[0] = &S0;
            GSymbol maker(produce.maker);
            if (maker.IsMakerYACC()) {
               if (!MakerSyntaxNode(maker, data_stack)) {
                  ret = -1;
               }
            } else if (maker.IsMakerNode()) {
               if (!MakerSyntaxNode(maker, data_stack, GMakerTable::maker_table.maker_node)) {
                  ret = -1;
               }
            }
         } else if (produce.count()) {
            T_SyntaxNode* unit = S0.unit;
            S0 = S_Syntax::rule_stack[filled() - produce.count()].lexeme_node; // $1
            S0.unit = unit;
         }
         for (int r = produce_len; r; r--) {
            const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 1).lexeme_node;
            if (auto_tree) {
               if (lexeme_node.unit) { S0.unit->Insert(lexeme_node.unit, r); }
               if (lexeme_node.lexeme.IsSaved()) { S0.unit->Insert(unit.New(lexeme_node.lexeme), r); }
            }
            if (print_stack) {
               printf(">%d ", filled() - 1); top().sym.print(grammar, 0x00);
               if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
               if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
               if (auto_tree) {
                  if (lexeme_node.unit) printf("<.%s.>", lexeme_node.unit->title());
                  if (!lexeme_node.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(lexeme_node.lexeme.group));
               }
               printf(" ");
            }
            leave();
         }
         if (print_stack) printf("\n");
         GSymbol A(GSymbol::gsFormula, action.sym.formula);
         MTableKey key(top().sym, A);
         if (!grammar->references.empty()) {
            key.sym.formula = grammar->references[key.sym.formula];
         }
         const TAction& go_to = Action(key);
         if (print_rule) {
            key.print(grammar, 0x00); printf(" => "); go_to.print(grammar, 0x00); printf("\n");
         }
         if (go_to.IsGoto()) {
            entry(go_to.sym);  // S
            top().lexeme_node = S0;
            if (print_stack) {
               printf("<%d ", filled() - 1); go_to.sym.print(grammar, 0x00);
               if (S0.node) printf("<%s>", snode_title(S0.node->type));
               if (S0.tree) printf("<%s>", S0.tree->title());
               if (auto_tree) {
                  if (S0.unit) printf("<.%s.>", S0.unit->title());
                  if (!S0.lexeme.Match(T_Lexeme::grNone)) printf("<.%s.>", group_title(S0.lexeme.group));
               }
               printf("\n");
            }
         }  else {
            ret = -1;
         }
      } else if (action.IsNone()) {
         ret = -1;
      } else {
         ret = -1;
      }
   }
   return (ret != -1);
}

// Green(v=2,p=218,9.2.3)
const GFormula& GSyntax::Formula(const GSymbol &sym) const
{
   return data->Formula(sym);
}

const GProduce& GSyntax::Produce(const GSymbol &sym) const
{
   return data->Produce(sym);
}

const GSymbol&  GSyntax::Cell(const MTableKey& key) const
{
   return data->Cell(key);
}

const TAction&  GSyntax::Action(const MTableKey& key) const
{
   return data->Action(key);
}
#ifndef TRN_GSYNTAX_H
#define TRN_GSYNTAX_H

#include "Maker.h"

// --------------------------- GSyntax ---------------------------
class GSyntax : public MC_Syntax, public S_Syntax
{
public:
   GSyntax(T_Scan *s, TGrammar* g) :S_Syntax(g), MC_Syntax(s), look_ahead(-1), rule_top(0) { unit.grammar = g; }

   virtual bool MatchAddLexeme(T_Lexeme& cur, const GSymbol& must);
	virtual bool error_code(T_Error code, int value = 0) { return A_Syntax::error(code,value); }
   virtual void print_symbol(const GSymbol& symbol, int print_mode = 0x01);
   void SaveLexeme(const T_Lexeme& cur, const GSymbol& must);

   virtual bool ParseLL1();
   virtual bool ParseLLk();
   virtual bool ParseLL1_SN();
   virtual bool ParseLLk_SN();

   virtual bool ParseLR0();
   virtual bool ParseLRk();
   virtual bool ParseLR0_SN();
   virtual bool ParseLRk_SN();
   virtual bool VerifyLR0(const GSymbol& sym);

   virtual bool Translate();
public:
   virtual void LexemeToSymbol(T_Lexeme& lexeme, GSymbol& sym) { sym = GSymbol(lexeme); }
public:
   int look_ahead;
public:
   const GFormula& Formula(const GSymbol &sym) const;
   const GProduce& Produce(const GSymbol &sym) const;
   const GSymbol&  Cell(const MTableKey& key) const;
   const TAction&  Action(const MTableKey& key) const;
private:
   void va_entry(const GSymbol& symbol) { va_stack.push_back(TStackRuleItem(symbol)); }
   void va_leave()          { if (!va_stack.empty()) va_stack.pop_back(); else rule_top--; }
   TStackRuleItem& va_top() { return va_stack.empty() ? rule_stack[rule_top - 1] : va_stack.back(); }
   bool va_empty() const    { return va_stack.empty() && (rule_top <= 0); }
   void va_clear()          { va_stack.clear(); rule_top = (int)rule_stack.size(); }
private:
   TStackRule va_stack;
   int  rule_top;
};

#endif

#include "stdafx.h"

#if defined(_MSC_VER)
#define SSCANF(B,F,V)   sscanf_s(B,F,V)
#elif defined(__GNUC__)
#define SSCANF(B,F,V)   sscanf(B,F,V)
#endif

#include "InHelp.h"

TInHelp::TInHelp(int m) :mode(m), count(0), type(0), option(0), file(NULL), table(NULL)
{
   start = std::chrono::system_clock::now();
}

TInHelp::~TInHelp()
{
   end = std::chrono::system_clock::now();
   int elapsed_seconds = (int)std::chrono::duration_cast<std::chrono::milliseconds> (end - start).count();
   printf("\ntime: %d.%03ds\n", elapsed_seconds / 1000, elapsed_seconds % 1000);
}

void TInHelp::option_mode() const
{
   printf("\nprint_mode:");
   printf("\n   0x00000001 - print_other,   0x00000002 - print_space,0x00000004 - print_line,  0x00000008 - print_Lexeme,");
   printf("\n   0x00000010 - print_tree,    0x00000020 - erase_code, 0x00000040 - print_code,  0x00000080 - print_operator,");
   printf("\n   0x00000100 - print_rule,    0x00000200 - print_maker,0x00000400 - print_stack, 0x00000800 - print_Code,");
   printf("\n   0x00001000 - print_SNode,   0x00002000 - print_Tree, 0x00004000 - print_source,0x00008000 - print_semantic");
   printf("\n   0x00010000 - select_produce,0x00020000 - trim_unit");
   printf("\n");
}

void TInHelp::table_mode() const
{
   printf("\ntable_mode:");
   printf("\n   Grammar     - 0x00000001, Follow      - 0x00000002, Maker      - 0x00000004, Lexeme - 0x00000008, ");
   printf("\n   First       - 0x00000010, EFF         - 0x00000020, ");
   printf("\n   Formula     - 0x00000100, Rule        - 0x00000200, Output     - 0x00000400, C2A    - 0x00000800, Ahead = 0x00000800, ");
   printf("\n   Action      - 0x00001000, Table       - 0x00002000, Cell       - 0x00001000, ");
   printf("\n   State       - 0x00010000, StateCore   - 0x00020000, StateSort  - 0x00040000, GoTo   - 0x00080000, ");
   printf("\n   Association - 0x00100000, Compression - 0x00200000, AssignOper - 0x00400000 ");
   printf("\n");
}

void TInHelp::parse_mode() const
{
   printf("\nparse_mode:");
   printf("\n   0 - source");
   printf("\n   1 - scan");
   printf("\n   2 - next");
   printf("\n   3 - control");
   printf("\n   4 - lexeme");
   printf("\n   5 - prior");
   printf("\n   6 - syntax");
   printf("\n   7 - restore");
   printf("\n   8 - Z(),E(),T(),F()");
   printf("\n   9 - write");
   printf("\n   A - lexer");
   printf("\n");
}

void TInHelp::make_mode() const
{
   printf("\nmake_mode:");
   printf("\n   0 - none");
   printf("\n   1 - Tree");
   printf("\n   2 - Code");
   printf("\n   3 - Node");
   printf("\n   4 - Turn");
   printf("\n");
}

void TInHelp::build_mode() const
{
   printf("\nbuild_mode:");
   printf("\n   0 - none");
   printf("\n   4 - PROG(LL<Tree,Code>,NL<Tree>)");
   printf("\n   5 - LL1(LL)");
   printf("\n   6 - LR0(LL,LR,NR)");
   printf("\n   7 - LR0_Core(LL,LR,NR)");
   printf("\n   8 - LR1(LL,LR,NR)");
   printf("\n   9 - LR1_Core(LL,LR,NR)");
   printf("\n   A - LALR(LL,LR,NR)");
   printf("\n   B - LALR_Tab(LL,LR,NR)");
   printf("\n   C - LALR_Full(LL,LR,NR)");
   printf("\n   D - LALR_Core(LL,LR,NR)");
   printf("\n   E - YACC(LL<Tree,Code>,LR<Tree,Code>,NR<Tree,Code,Node>)");

   printf("\n");
}

void TInHelp::grammar_mode() const
{
   printf("\ngrammar_mode:");
   printf("\n   0 - LL(Tree,Code,Node,Made)");
   printf("\n   1 - NL(Tree)");
   printf("\n   2 - LR(Tree,Code,Turn)");
   printf("\n   3 - NR(Tree,Code,Node,Made)");
   printf("\n   4 - ETF_LL()");
   printf("\n   5 - ETF_LL(Tree,Code)");
   printf("\n   6 - ETF_LR()");
   printf("\n   7 - ETF_LR(Tree,Code)");
   printf("\n   9 - EEE_LR()");
   printf("\n   A - IFE_LR()");
   printf("\n   C - BNF");
   printf("\n   D - FSyntax.y");
   printf("\n   E - FSyntax.cpp");
   printf("\n   F - Table");
   printf("\n");
}

void TInHelp::parse_help() const
{
   printf("\nTranParse parse_mode print_mode file");
   parse_mode();
   option_mode();
}

void TInHelp::rules_help() const
{
   printf("\nTranRules FGMP print_mode file table");
   printf("\nFGMP:");
   printf("\n   Forma  : 0 - <Rule>, 1 - <Formula>, 2 - <Table> && table && ~Grammar");
   printf("\n   Grammar: 0 - LL(Tree,Code,Node), 1 - NL(Tree), 4 - ETF_LL(), 5 - ETF_LL(Tree,Code)");
   printf("\n   Make   : 0 - none, 1 - Tree, 2 - Code, 3 - Node, 5 - Made");
   printf("\n   Parse  : 0 - none, 1 - ParseStack, 2 - ParseStackFormula, 3 - ParseRule, 4 - ParseFormula");
   printf("\n");
   option_mode();
}

void TInHelp::syntax_help() const
{
   printf("\nTranSyntax mode print_mode file");
   printf("\nmode:");
   printf("\n   0 - none, 1 - Syntax, 2 - TSyntax(Tree), 3 - CSyntax(Code), 4 - MSyntax(Tree), 5 - MSyntax(Code)");
   printf("\n");
   option_mode();
}

void TInHelp::yacc_help() const
{
   printf("\nTranYACC GrammarMakeParse print_mode file");
   printf("\n   Grammar: 0 - LL<PROG,YACC>(Tree,Code), 1 - NL<PROG>(Tree), 2 - LR<YACC>(Tree,Code), 3 - NR<YACC>(Tree,Code,Node)");
   printf("\n            C - C_Grammar<YACC>(Tree)");
   printf("\n   Make   : 0 - none, 1 - Tree, 2 - Code, 3 - Node, 5 - Made");
   printf("\n   Parse  : 0 - none, 3 - TAB , 4 - PROG, E - YACC");
   printf("\n");
   option_mode();
}

void TInHelp::grammar_help() const
{
   printf("\nTranGrammar SM print_mode file table");
   printf("\nS - scan_type:");
   printf("\n   0 - Scan, 1 - Flex");
   printf("\nM - make_mode:");
   printf("\n   0 - none, 1 - Tree, 2 - Code, 3 - Node, 4 - Turn, 5 - C_Grammar, 6 - C99_Grammar");
   printf("\n");
   option_mode();
}

void TInHelp::table_help() const
{
   printf("\nTableBuilder k_scan_grammar_make_build table_mode file table");
   printf("\nk_mode: k - LookAhead");
   printf("\nscan_mode: 0 - MyScan, 1 - FlexLexer");
   grammar_mode();
   make_mode();
   build_mode();
   table_mode();
}

void TInHelp::help() const
{
   switch (mode) {
   case None:     table_mode(); make_mode(); option_mode(); break;
   case Parse:    parse_help();    break;
   case Syntax:   syntax_help();   break;
   case Rules:    rules_help();    break;
   case Table:    table_help();    break;
   case YACC:     yacc_help();     break;
   case Grammar:  grammar_help();  break;
   }

}

int TInHelp::input(int argc, const char* argv[])
{
   
   if (argc <= 1) {
      help();
      return false;
   }
   
   for (int i = 0; i < argc; i++)
   {
       printf("%s\n", argv[i]);
   }
   printf("\n");

   if (argc > 1) {
      SSCANF(argv[1],"%x",&type);
   }
   if (argc > 2) {
      SSCANF(argv[2],"%x",&option);
   }
   if (argc > 3) {
      file = argv[3];
   }
   if (argc > 4) {
      table = argv[4];
   }

   count = argc;

   return true;
}
#ifndef TRN_INHELP_H
#define TRN_INHELP_H

#include <chrono>

class TInHelp {
public:
   enum T_Mode { None, Parse, Syntax, Rules, Table, YACC, Grammar };
public:
   TInHelp(int m);
   ~TInHelp();
   int  input(int argc, const char* argv[]);
public:
   void option_mode() const;
   void table_mode() const;
   void parse_mode() const;
   void make_mode() const;
   void grammar_mode() const;
   void build_mode() const;
public:
   void parse_help() const;
   void rules_help() const;
   void syntax_help() const;
   void yacc_help() const;
   void grammar_help() const;
   void table_help() const;
   void help() const;
public:
   int count;
   int type;
   int option;
   const char* file;
   const char* table;
public:
   std::chrono::time_point<std::chrono::system_clock> start, end;
protected:
   int mode;
};

#endif#include "stdafx.h"

#include "RSyntax.h"
#include "Maker.h"
#include "GBuilder.h"
#include "LRBuilder.h"

extern int not_find, count_empty, shift_count, reduce_count, goto_count, equ_count;
extern int delete_count, empty_count, add_count;

// Green(v=1,5.1)
// -------------------------------------------------- LL(k) --------------------------------------------------
class TLLkItem
{
public:
   TLLkItem() {}
public:
   GSymbol produce, source;
public:
   TGrammar * grammar;
};

class TableLLk;
class TLLk : public std::map<const GSymbol, TLLkItem>
{
public:
   TLLk(const GSymbol& a, const TFirst& l, TGrammar *g, int t) : A(a), L(l), del(false), table(t), grammar(g) {}
   bool make(TableLLk& owner);
   TLLkItem& Get(const GSymbol& u) { return at(u);  }
   bool Add(const GSymbol& u, const GSymbol& produce, const GSymbol& source);
   int  Compare(const TLLk& join, TLXkReference& references) const;
   void Merge(const TLLk& join);
public:
   void print(FILE* file, int print_mode = 0x00) const;
   int  count() const { return (int)size(); }
public:
   GSymbol A;
   TFirst  L;
   TGrammar *grammar;
   bool del;
   int table;
};

class TableLLk
{
public:
   TableLLk(TGrammar *g) :grammar(g) {}
   ~TableLLk() { Clear(); }
   const GSymbol Add(const GSymbol& key_A, const TFirst&  key_L);
   TLLk& Get(const GSymbol& tab) { return *vector[tab.table]; }
   int  Compression();
public:
   int  count() const { return (int)vector.size(); }
   void print(const char* title = NULL, int print_mode = 0x00) const;
   void Clear();
public:
   struct Key {
      Key(const GSymbol* a, const TFirst* l) :A(a), L(l) {}
      bool operator == (const Key& k) const { return (*A == *k.A) && (*L == *k.L); }
      bool operator <  (const Key& k) const { return (*A <  *k.A) || (*A == *k.A) && (*L < *k.L); }
   public:
      const GSymbol* A;
      const TFirst*  L;
   };
   std::map<const Key, const GSymbol> map;
   std::vector<TLLk*> vector;
public:
   TGrammar * grammar;
};

bool TLLk::Add(const GSymbol& u, const GSymbol& produce, const GSymbol& source)
{
   const_iterator ip = find(u);
   if (ip != end()) return false;
   std::pair<const GSymbol&, TLLkItem> item(u, TLLkItem());
   item.second.produce = produce; item.second.source = source;
   insert(item);
   return true;
}

int  TLLk::Compare(const TLLk& join, TLXkReference& references) const
{
   int compare = 0;
   for (std::pair<const GSymbol&, const TLLkItem&> item : (*this)) {
      const_iterator ip = join.find(item.first);
      if (ip == join.end()) continue;
      const TLLkItem& this_item = item.second;
      const TLLkItem& join_item = (*ip).second;
      if (!(this_item.source == join_item.source)) {
         return -1;
      } else {
//         compare++; continue; // LL1 = LLk(1)
      }
      if (this_item.produce == join_item.produce) { compare++; continue; }
      const GSymbolVector& vec_this = grammar->Vector(this_item.produce);
      const GSymbolVector& vec_join = grammar->Vector(join_item.produce);
      for (int i = 0; i < vec_this.count(); i++) {
         const GSymbol& sym_this = vec_this[i];
         if (!sym_this.IsTable()) continue;
         if (sym_this.table == table) continue;
         const GSymbol& sym_join = vec_join[i];
         if (references.Ref(sym_this.table) != references.Ref(sym_join.table)) return -1;
      }
      compare++;
   }
   if ((compare == count()) && (compare == join.count())) return 0; // this == join
   if (compare == join.count()) return 1; // this > join
   if (compare ==      count()) return 2; // this < join
   return compare ? 3 : -1; // this != join
}

void TLLk::Merge(const TLLk& join)
{
   for (std::pair<const GSymbol&, const TLLkItem&> item : join) {
      const_iterator ip = find(item.first);
      if (ip == end()) {
         insert(item);
      }
   }
}

void TLLk::print(FILE* file, int print_mode) const
{
   for (const std::pair<const GSymbol&, const TLLkItem&> item : *this) {
      const GSymbol& u = item.first;
      u.print(grammar, print_mode, file);
      item.second.produce.print(grammar, print_mode, file);
      fprintf(file, "\n");
   }
}

// Green(v=1,p=390,a=5.2)
bool TLLk::make(TableLLk& owner)
{

   const GFormula& formula_A = grammar->Formula(A);
   int k = grammar->look_ahead;
   for (const GProduce& produce : formula_A) {
      TFirst first, U;
      if (!produce.empty() && !produce.IsEmpty()) {
         if (!grammar->FIRSTs.FIRST(produce, first, k)) continue;
      } else {
         first << GSymbol::empty;
      }
      grammar->Vectors().Plus(first, L, U, k);

      GSymbolVector reduce;
      int i = 0;
      while (i < produce.count()) {
         while ((i < produce.count()) && !produce[i].IsFormula()) {
            reduce << produce[i];
            i++; // x0, x1, ... xM
         }
         if ((i < produce.count()) && produce[i].IsFormula()) {
            const GSymbol sym_B = produce[i];
            i++;
            GSymbolVector alpha;
            produce.TailWithoutMaker(i, alpha);
            TFirst first, Y;
            if (!alpha.empty()) {
               if (!grammar->FIRSTs.FIRST(alpha, first, k)) continue;
            } else {
               first << GSymbol::empty;
            }
            grammar->Vectors().Plus(first, L, Y, k);
            const GSymbol B_Y = owner.Add(sym_B, Y);
            reduce << B_Y;
         }
      }
      const GSymbol head = (reduce.empty() || reduce.IsEmpty()) ? GSymbol::empty : grammar->AddVector(reduce);
      for (const GSymbol& u : U) {
         Add(u, head, produce.head);
      }
   }
   return true;
}

const GSymbol TableLLk::Add(const GSymbol& key_A, const TFirst&  key_L)
{
   const Key my_key(&key_A, &key_L);
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(my_key);
   if (ip != map.end()) return (*ip).second;
   TLLk* table = new TLLk(key_A, key_L, grammar, (int)vector.size());
   std::pair<const Key, const GSymbol> item(Key(&table->A, &table->L), GSymbol(GSymbol::gsTable, (int)vector.size()));
   vector.push_back(table);
   map.insert(item);
   return item.second;
}

struct TTwoInt {
   TTwoInt() :one(0), two(0) {}
   TTwoInt(int o, int t) :one(o), two(t) {}
   int one, two;
};

int  TableLLk::Compression()
{
   if (!map.size()) return 0;
   std::vector<TTwoInt> begs_ends;  begs_ends.resize(grammar->count(), TTwoInt());
   std::vector<int>        indexs;     indexs.resize(count());
   TLXkReference references(count());
   GSymbol A_old = vector.front()->A; // S_
   int table_index = 0;
   begs_ends[A_old.formula].one = table_index;
   for (const std::pair<const TableLLk::Key&, const GSymbol&> item : map) {
      indexs[table_index] = item.second.table;
      references[table_index] = table_index;
      const GSymbol& A = *item.first.A;
      if (!(A == A_old)) {
         begs_ends[A_old.formula].two = table_index - 1;
         A_old = A;
         begs_ends[A_old.formula].one = table_index;
      }
      table_index++;
   }
   begs_ends[A_old.formula].two = table_index - 1;
   fprintf(stdout, "\nbegs_ends=%d", (int)begs_ends.size());

   int step = 0;
   int compare_all = 0, merge_all = 0;
   bool cycle;
   do {
      cycle = false;

      int compare_change = 0, merge_change = 0;
      for (const TTwoInt& beg_end : begs_ends) {
         const TLLk& table = *vector[indexs[beg_end.one]];
         int merge_A = 0, compare_A = 0;
         for (int i = beg_end.one; i < beg_end.two; i++) {
            if (references.Deleted(indexs[i])) continue;
            int ref_i = references.Ref(indexs[i]);
            TLLk& table_i = *vector[indexs[i]];
            for (int j = i + 1; j <= beg_end.two; j++) {
               if (references.Deleted(indexs[j])) continue;
               int ref_j = references.Ref(indexs[j]);
               TLLk& table_j = *vector[indexs[j]];
               int merge = table_i.Compare(table_j, references);
               if ((merge < 0) || (merge > 0)) continue; // > 3
               if (merge == 0) { // this == join
                  compare_change++; compare_A++;
               } else if (merge == 1) { // this > join
                  if (ref_i > ref_j) {
                     table_j.Merge(table_i);
                  }
               } else if (merge == 2) { // this < join
                  if (ref_i < ref_j) {
                     table_i.Merge(table_j);
                  }
               } else { // 3 - this != join
                  if (ref_i > ref_j) {
                     table_j.Merge(table_i);
                  } else {
                     table_i.Merge(table_j);
                  }
               }
               cycle = true;
               if (merge != 0) {
                  merge_change++; merge_A++;
               }
               if (references.Ref(ref_i, ref_j) > 0) {
                  TLLk& table_ref_j = *vector[ref_j];
                  table_ref_j.del = true;
               } else {
                  TLLk& table_ref_i = *vector[ref_i];
                  table_ref_i.del = true;
                  break;
               }
            }
         }
//         fprintf(stdout, "  compare=%d, merge=%d", compare_A, merge_A);
      }
      fprintf(stdout, "\ncompare_change=%d, merge_change=%d", compare_change, merge_change);
      compare_all += compare_change; merge_all += merge_change;
      step++;
   } while (cycle);
   printf("\nstep=%d, compare_all=%d, merge_all=%d", step, compare_all, merge_all);

   int old_count = count(), new_count = 0;
   for (int item = 0; item < old_count; item++ ) {
      if (!references.Deleted(item)) new_count++;
   }
   if (old_count) {
      printf("\nCompression: %d%%, %d -> %d\n", ((old_count - new_count) * 100) / old_count, old_count, new_count);
   }

   grammar->references = references;

   return 0;
}

void TableLLk::Clear()
{
   map.clear();
   for (TLLk* item : vector) {
      delete item; item = NULL;
   }
   vector.clear();
}

void TableLLk::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if (!title) {
      fprintf(file, "\n--- TLLk table --- <%d> ---\n", count());
   }
   if (print_mode == 0x00) return;
   GSymbol A_old; A_old.formula = -1;
   for (const std::pair<const TableLLk::Key&, const GSymbol&> item : map) {
      const TLLk& table = *vector[item.second.table];
      if (table.del) continue;
      GSymbol A = *item.first.A;
      if (!(A == A_old)) {
         A_old = A;
      } else {
         A.type = GSymbol::gsNone;
      }
      fprintf(file, "[");
      if (!A.IsNone() || !(print_mode & T_PrintMode::pmNoPrintNone)) {
         A.print(grammar, print_mode, file);
      } else {
         int len = SYMBOL_PRINT_TITLE_LEN;
         fprintf(file, "%*c", len, ' ');
      }
      item.second.print(grammar, print_mode, file); // Table
      const TFirst& L = *item.first.L;
      L.print(file, grammar, print_mode);

      fprintf(file, "]");
      fprintf(file, "\n");
      table.print(file, print_mode);
      fprintf(file, "\n");
   }
   if (title) {
      fclose(file);
   }
}

/** /
const GSymbol& TGrammar::GetLLkA(const GSymbol& tab) const
{
   if (TabLLk) {
      return TabLLk->vector[tab.table]->A;
   } else {
      return GSymbol::none;
   }
}
/ **/

// Green(v=1,p=391,a=5.3)
bool TGrammarBuilder::make_LLkTable(int k)
{
   bool ret = true;
   look_ahead = k;
   grammar->look_ahead = k;

   TableLLk TLLks(grammar);

   TFirst L; L << GSymbol::empty;
   TLLk S_e(grammar->root->head, L, grammar, 0);
   TLLks.Add(S_e.A, S_e.L);

   for (GSymbol table(GSymbol::gsTable); table.table < TLLks.count(); table.table++) {
      if ((table.table % 100) == 0) {
         printf("\n%07d,%07d, vector = %4d", table.table, TLLks.count(), grammar->Vectors().count());
      }
      TLLk& table_B_Y = TLLks.Get(table);
      table_B_Y.make(TLLks);
   }
   printf("\n%07d, vector = %4d", TLLks.count(), grammar->Vectors().count());

   if (grammar->option & TGrammar::POption::opCompression) {
      TLLks.Compression();
   }

   for (GSymbol table(GSymbol::gsTable); table.table < TLLks.count(); table.table++) {
      if ((table.table % 100) == 0) {
         printf("\n%07d,%07d", table.table, Mtable.count());
      }
      const TLLk& table_A_L = TLLks.Get(table);
      if (table_A_L.del) continue;
      for (std::pair<const GSymbol&, const TLLkItem&> item : table_A_L) {
         const GSymbol& u = item.first;
         MTableKey key(table, u); key.produce.table = table_A_L.table;
         Mtable.Add(key, item.second.produce);
      }
   }
   printf("\n%07d,%07d", TLLks.count(), Mtable.count());

   printf("\n\nLLkTable: %07d, Cell: %07d", TLLks.count(), Mtable.count());
   if (Mtable.duplicate) printf("\nDuplicate: %d\n", Mtable.duplicate);
   if (Mtable.warning) printf("\nWarning: %d\n", Mtable.warning);

   if (grammar->option & TGrammar::POption::opLLk) {
      grammar->TabLLk = &TLLks;

      char *file_LLk = NULL;
      if (file) file_LLk = get_file_name(file, "LLk");
      TLLks.print(file_LLk, T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
      if (file_LLk) free(file_LLk);

      char *file_LLkTab = NULL;
      if (file) file_LLkTab = get_file_name(file, "LLkTab");
//      Mtable.print(file_LLkTab, T_PrintMode::pmTableLLk | T_PrintMode::pmNoPrintNone | T_PrintMode::pmPrintItem);
      if (file_LLkTab) free(file_LLkTab);

      grammar->TabLLk = NULL;
   }

   return ret;
}

// Red(p=244)
// ------------------------------------------------ TC2A -----------------------------------------------

bool TAmus::Add(const TAmu& mu_)
{
   TAmu mu = mu_; if (mu.mu.empty()) mu.mu << GSymbol::empty;
   iterator ip = find(mu.point);
   if (ip != end()) {
      return ((*ip).second.mu += mu.mu) != 0;
   }
   std::pair<const GSymbol, TAmu> item(mu.point, TAmu(mu.point));
   item.second.mu << mu.mu;
   insert(item);
   return true;
}

const TAmus TAmus::none;

TBTailItem* TBTails::Get(const GSymbol& point)
{
   iterator ip = find(point);
   if (ip == end()) {
      std::pair<const GSymbol, TBTailItem> item(point, TBTailItem());
      item.second.count++;
      insert(item);
      ip = find(point);
      GSymbolVector beta;
      const GProduce& produce = grammar->Produce(point);
      produce.Tail(point, beta); // delta
      if (!beta.empty()) {
         if (grammar->look_ahead) {
            grammar->FIRSTs.FIRST(beta, (*ip).second.delta, grammar->look_ahead);
         } else {
            grammar->FIRSTs.FIRST(beta, (*ip).second.delta);
         }
      } else {
         (*ip).second.delta << GSymbol::empty;
      }
      grammar->Split((*ip).second.delta, (*ip).second.half);
   } else {
      (*ip).second.count++;
   }
   return &(*ip).second;
}

void TBTails::print(const TGrammar *grammar, int print_mode, FILE* file) const
{
   int volume = 0, delta = 0, half = 0;
   for (std::pair<const GSymbol&, const TBTailItem&> item : *this) {
      volume += item.second.count; delta += !item.second.delta.empty(); half += !item.second.half.empty();
      fprintf(file, "\n%7d ", item.second.count); item.first.print(grammar, print_mode, file);
      item.second.print(grammar, print_mode, file);
   }
   fprintf(file, "\ncount=%d, volume=%d, delta=%d, half=%d\n", (int)size(), volume, delta, half);
}

void TBTailItem::print(const TGrammar *grammar, int print_mode, FILE* file) const
{
   fprintf(file, "\n"); delta.print(file, grammar, print_mode);
   fprintf(file, "\n"); half.print(file, grammar, print_mode);
}

bool Tc2a::Add(const GSymbol& A, const TAmu& mu)
{
   iterator ip = find(A);
   if (ip == end()) {
      std::pair<const GSymbol, TAmus> item(A, TAmus());
      insert(item); ip = find(A);
   }
   int add = (*ip).second.Add(mu);
   return add != 0;
}

const TAmus& Tc2a::Get(const GSymbol& C)
{
   iterator ip = find(C);
   if (ip != end()) return (*ip).second;
   return TAmus::none;
}

Tc2a& TC2A::Get(const GSymbol& C)
{
   iterator ip = find(C);
   if (ip != end()) return (*ip).second;
   std::pair<const GSymbol, Tc2a> item(C, Tc2a());
   insert(item); ip = find(C);
   return (*ip).second;
}

TAmus& TC2A::Get(const GSymbol& C, const GSymbol& A)
{
   Tc2a& c2a = Get(C);
   Tc2a::iterator ip = c2a.find(A);
   if (ip == c2a.end()) {
      std::pair<const GSymbol, TAmus> item(A, TAmus());
      c2a.insert(item); ip = c2a.find(A);
   }
   return (*ip).second;
}

void TC2A::Init()
{
   for (const GFormula* formula : grammar->formulas) {
      Tc2a& c2a_C = Get(formula->head);
      for (const GProduce& produce : *formula) {
         GSymbol A = produce.IsEmpty() ? GSymbol::empty : produce.front();
         const GSymbol point(GSymbol::gsPoint, produce.head.formula, produce.head.produce, 0);
         TAmu mu_C_A(point);
         c2a_C.Add(A, mu_C_A);
#ifdef TC2A_MAKE_QUEUE
         if (A.IsFormula()) {
            Tc2a& c2a_A = Get(A);
            c2a_A.points << point;
            queue.Push(A);
         }
#endif
      }
   }
}

#ifdef TC2A_MAKE_QUEUE
void TC2A::Make(const GSymbol& point, const GSymbol& C)
{
   int modif = 0;
   GSymbol B(GSymbol::gsFormula, point.formula);
   const Tc2a& c2a_C = Get(C);
   TFirst first_B_C;
   if (grammar->look_ahead) {
      grammar->FIRSTs.FirstTail(point, first_B_C, grammar->look_ahead);
   } else {
      grammar->FIRSTs.FirstTail(point, first_B_C);
   }
   for (std::pair<const GSymbol&, const TAmus&> item : c2a_C) {
      const GSymbol& A = item.first;
      const TAmus& mus_C_A = item.second;
      TAmus& mus_B_A = Get(B, A);
      for (std::pair<const GSymbol&, const TAmu&> item : mus_C_A) {
         const TAmu& mu_C_A = item.second;
         TAmu mu_B_A(mu_C_A.point);
         if (grammar->look_ahead) {
            grammar->Vectors().Plus(mu_C_A.mu, first_B_C, mu_B_A.mu, grammar->look_ahead);
         } else {
            mu_B_A.mu.Plus(mu_C_A.mu, first_B_C);
         }
         if (mus_B_A.Add(mu_B_A)) {
            modif++;
         }
      }
   }
   if (modif) {
      queue.Push(B);
      modif_count += modif;
   }
}

void TC2A::Make(const GSymbol& C)
{
   int ret = 0;
   step++; modif_count = 0;
   const Tc2a& c2a_C = Get(C);
   for (const GSymbol point : c2a_C.points) {
      Make(point, C);
   }
}

#else

int TC2A::Make(const GSymbol& B, const GSymbol& C, const GSymbol& point)
{
   int ret = 0;
   const Tc2a& c2a_C = Get(C);
   Tc2a& c2a_B = Get(B);
   TFirst first_B_C;
   if (grammar->look_ahead) {
      grammar->FIRSTs.FirstTail(point, first_B_C, grammar->look_ahead);
   } else {
      grammar->FIRSTs.FirstTail(point, first_B_C);
   }
   for (std::pair<const GSymbol&, const TAmus&> item : c2a_C) {
      const GSymbol& A = item.first;
      const TAmus& mus_C_A = item.second;
      TAmus& mus_B_A = Get(B, A);
      for (std::pair<const GSymbol&, const TAmu&> item : mus_C_A) {
         const TAmu& mu_C_A = item.second;
         TAmu mu_B_A(mu_C_A.point);
         if (grammar->look_ahead) {
            grammar->Vectors().Plus(mu_C_A.mu, first_B_C, mu_B_A.mu, grammar->look_ahead);
         } else {
            mu_B_A.mu.Plus(mu_C_A.mu, first_B_C);
         }
         if (mus_B_A.Add(mu_B_A)) {
            ret++;
            if (c2a_B.step < step) { c2a_B.step = step; modif_count++; }
         }
      }
   }
   return ret;
}

int TC2A::Make()
{
   int ret = 0;
   step++; modif_count = 0;
   for (const GFormula* formula : grammar->formulas) {
      const GSymbol& B = formula->head;
      for (const GProduce& produce : *formula) {
         if (produce.IsEmpty()) continue;
         const GSymbol& C = produce.front();
         if (!C.IsFormula()) continue;
         const Tc2a& c2a_C = Get(C);
         if (c2a_C.step < step - 1) continue;
         const GSymbol point(GSymbol::gsPoint, produce.head.formula, produce.head.produce, 0);
         ret += Make(B, C, point);
      }
   }
   return ret;
}
#endif

void TC2A::Split()
{
   for (std::pair<const GSymbol&, const Tc2a&> item : *this) {
      for (std::pair<const GSymbol&, const TAmus&> tail : item.second) {
         for (std::pair<const GSymbol&, const TAmu&> item_mu : tail.second) {
            const TAmu& amu = item_mu.second;
            const GProduce& produce = grammar->Produce(amu.point);
            amu.produce = produce.head.value;
            grammar->Split(amu.mu, amu.half);
         }
      }
   }
}

void TC2A::Merge()
{
   for (std::pair<const GSymbol&, const Tc2a&> item : *this) {
      for (std::pair<const GSymbol&, const TAmus&> tail : item.second) {
         for (std::pair<const GSymbol&, const TAmu&> item_mu : tail.second) {
            const TAmu& amu = item_mu.second;
            amu.mu << amu.half;
            amu.half.clear();
         }
      }
   }
}

bool TC2A::Verify() const
{
   int different = 0;
   for (std::pair<const GSymbol&, const Tc2a&> item : *this) {
      const GSymbol& A = item.first;
      const Tc2a& C_A = item.second;
      const TFirst& eff_A = grammar->Eff(A);
      TFirst first_A;
      for (const GSymbol& sym : eff_A) {
         if (sym.IsVector()) {
            const GSymbolVector& vec = grammar->Vector(sym);
            first_A << vec.front();
         } else {
            first_A << sym;
         }
      }
      if (C_A.terminals != first_A) {
         fprintf(stdout, "\neff != terminals: "); A.print(grammar, 0x00, stdout);
         different++;
      }
   }
   if (different) {
      fprintf(stdout, "\nDifferent : %d\n", different);
   }
   return !different;
}

void TC2A::Core()
{
   Init();

#ifdef TC2A_MAKE_QUEUE
   int m_all = 0;
   for (GSymbol C; queue.Pop(C); ) {
      Make(C);
      if ((step % 100) == 0) {
         printf("\n%05d,%05d,%05d", step, (int)queue.size(), modif_count);
      }
      m_all += modif_count;
   }
   printf("\n%05d,%05d\n", step, m_all);

#else
   int i_all = 0, m_all = 0;
   while (int i = Make()) {
      printf("\n%05d,%05d,%05d",step, modif_count, i);
      i_all += i; m_all += modif_count;
   }
   printf("\n%05d,%05d\n", m_all, i_all);
#endif

   // Make Terminals
   iterator ip = begin();
   while (ip != end()) {
      Tc2a& c2a_C = (*ip).second;
      for (std::pair<const GSymbol&, const TAmus&> tail : c2a_C) {
         if (tail.first.IsTerminal()) c2a_C.terminals << tail.first;
      }
      ip++;
   }

   if (grammar->look_ahead) Verify();

}

void TC2A::print(const char* title, const TGrammar* grammar, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   int A_count = 0, T_C_count = 0;
   for (std::pair<const GSymbol&, const Tc2a&> item : *this) {
      A_count += (int)item.second.size();
      for (std::pair<const GSymbol&, const TAmus&> tail : item.second) {
         T_C_count += (int)tail.second.size();
      }
   }
   fprintf(file, "\n--- TC2A table --- <%d> --- <%d> --- <%d> ---\n", (int)size(), A_count, T_C_count);

   for (std::pair<const GSymbol&, const Tc2a&> item : *this) {
      fprintf(file, "\n--- <%d> --- ", (int)item.second.size());
      item.first.print(grammar, print_mode, file);
      item.second.print(grammar, print_mode, file);
   }

   point_tails.print(grammar, print_mode, file);

   fprintf(file, "\n");
   if (title) {
      fclose(file);
   }
}

void Tc2a::print(const TGrammar *grammar, int print_mode, FILE* file) const
{
   fprintf(file, "\nLs:");
   terminals.print(grammar, print_mode, file);
   fprintf(file, "\nXc:");
   for (std::pair<const GSymbol&, const TAmus&> item : *this) {
      item.first.print(grammar, print_mode, file);
      fprintf(file, "   ");
   }
   fprintf(file, "\n");
   for (std::pair<const GSymbol&, const TAmus&> item : *this) {
      item.first.print(grammar, print_mode, file);
      fprintf(file, " => --- (%d) ---", (int)item.second.size());
      for (std::pair<const GSymbol&, const TAmu&> item_mu : item.second) {
         const TAmu& mu = item_mu.second;
         fprintf(file, "\n"); mu.point.print(grammar, print_mode, file); fprintf(file, " "); mu.mu.print(file, grammar, print_mode);
         fprintf(file, "\n"); mu.half.print(file, grammar, print_mode);
      }
      fprintf(file, "\n");
   }
}

// ---------------------------- make_Table -----------------------------------
// Green(v=2,p=94,7.4.1,a=7.10)
bool TGrammarBuilder::make_SLRkTable(int k) // T_SyntaxMode::smParseLR0
{
   bool ret = true;
   look_ahead = k;

   TLR0Builder LR0_builder(grammar);
   LR0_builder.Stable = &Stable;
   LR0_builder.look_ahead = 0;
   LR0_builder.make_States();

   if (k) {
      TSLRBuilder builder(grammar);
      builder.Stable = &Stable;
      builder.LRtable = &LRtable;
      builder.look_ahead = k;
      builder.GOTOtable = LR0_builder.GOTOtable;

      int invalid = LR0_builder.Stable->ValidSLRk();
      if (invalid) printf("\nInvalid: %d\n", invalid);

      builder.mode |= builder.tmGOTO;
      builder.make_Table(); // go_to

      TablePrint.Copy(*builder.Stable); // print
      GOTOtable = builder.GOTOtable;
   } else {
      LR0_builder.LRtable = &LRtable;
      LR0_builder.mode |= LR0_builder.tmGOTO;
      LR0_builder.make_Table(); // go_to

      GOTOtable = LR0_builder.GOTOtable;
   }
   return ret;
}

bool TGrammarBuilder::make_LRkTable(int k) // T_SyntaxMode::smParseLR1
{
   bool ret = true;
   look_ahead = k;
#ifdef LRK_TABLE_BUILDER
   TLRTabBuilder builder(grammar);
#else
   TLRBuilder builder(grammar);
#endif
   builder.Stable = &Stable;
   builder.LRtable = &LRtable;
   builder.look_ahead = k;

   builder.make_States();

   builder.mode = A_LRBuilder::tmGOTO;
   builder.make_Table(); // go_to

/*
   TNextTab NEXTs(grammar);
   Stable.make_NEXTs(builder.GOTOtable, NEXTs);
   char* file_next = get_file_name(file, "next");
   NEXTs.print(file_next, 0x0200);
   free(file_next);

   TNextTab PREDs(grammar);

   for (const std::pair<const MTableKey&, const GSymbolSet&> item : NEXTs) {
      for (const GSymbol to : item.second) {
         MTableKey key_pred(to, item.first.sym);
         PREDs.Add(key_pred, item.first.produce);
      }
   }

   char* file_pred = get_file_name(file, "pred");
   PREDs.print(file_pred, 0x0200);
   free(file_pred);
*/

   GOTOtable = builder.GOTOtable;
   TablePrint.Copy(Stable); // print

#ifdef LRK_TABLE_BUILDER
   builder.Stable->Expansion(builder.table, TablePrint);
   int invalid = TablePrint.ValidLRk();
   if (invalid) printf("\nInvalid: %d\n", invalid);
#else
   int invalid = builder.Stable->ValidLRk();
   if (invalid) printf("\nInvalid: %d\n", invalid);
#endif

   return ret;
}

bool TGrammarBuilder::make_LR0Core() // T_SyntaxMode::smParseLR0_Core
{
   bool ret = true;

   TLR0CoreBuilder builder(grammar);
   builder.Stable = &Stable;
   builder.LRtable = &LRtable;
   builder.look_ahead = 0;
   builder.mode = builder.tmLR0 | builder.tmFormulaAndLexeme;
   builder.make_States();

   int before = builder.LRtable->count();
   builder.LRtable->GOTO(builder.GOTOtable);
   goto_count += (builder.LRtable->count() - before);

   builder.mode |= builder.tmGOTO;
   builder.make_Table();

   GOTOtable = builder.GOTOtable;

   return ret;
}

bool TGrammarBuilder::make_LRkCore(int k) // T_SyntaxMode::smParseLR1_Core
{
   bool ret = true;
   look_ahead = k;
#ifdef CORE_TABLE_BUILDER
   TLRkCoreTabBuilder builder(grammar);
#else
   TLRkCoreBuilder builder(grammar);
#endif
   builder.Stable = &Stable;
   builder.LRtable = &LRtable;
   builder.look_ahead = k;
   builder.mode = builder.tmFormulaAndLexeme;
   builder.make_States();
   builder.CtoAa.Merge();

   printf("\n!add=%d, %d, %d", builder.add_count, builder.empty_count, builder.count_empty);
   printf("\ntrue_count=%d, false_count=%d, closure_count=%d\n", builder.true_count, builder.false_count, builder.Added.Current());

   int before = builder.LRtable->count();
   builder.LRtable->GOTO(builder.GOTOtable);
   goto_count += (builder.LRtable->count() - before);

   builder.mode |= builder.tmGOTO;
   builder.make_Table();
   LRtable.print(0x00);

   GOTOtable = builder.GOTOtable;

   if (builder.CtoAa.size() && (grammar->option & TGrammar::POption::opC2A)) {
      char* file_C2A = get_file_name(grammar->file, "C2A");
      builder.CtoAa.print(file_C2A, grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmSortMode | T_PrintMode::pmCompact);
      free(file_C2A);
   }

#ifdef CORE_TABLE_BUILDER
   builder.Stable->Expansion(builder.table, TablePrint);
//   builder.table.print(stdout, grammar, 0x00);
#endif

   return ret;
}

bool TGrammarBuilder::make_LALRkCore(int k) // T_SyntaxMode::smParseLALR_Core
{
   bool ret = true;
   look_ahead = k;

#ifdef CORE_TABLE_BUILDER
   TLALRkCoreTabBuilder builder(grammar);
#else
   TLALRkCoreBuilder builder(grammar);
#endif
   builder.Stable = &LALRStable;
   builder.LALRStable = &LALRStable;
   builder.LALRStable->yes_queue = true;
   builder.LRtable = &LRtable;
   builder.look_ahead = k;
   builder.mode = builder.tmFormulaAndLexeme;
   builder.make_States();
   builder.CtoAa.Merge();

   int before = builder.LRtable->count();
   builder.LRtable->GOTO(builder.GOTOtable);
   goto_count += (builder.LRtable->count() - before);

   builder.mode |= builder.tmGOTO;
   builder.make_Table();

   LRtable.print(0x00);

   if (builder.CtoAa.size() && (grammar->option & TGrammar::POption::opC2A)) {
      char* file_C2A = get_file_name(grammar->file, "C2A");
      builder.CtoAa.print(file_C2A, grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmSortMode | T_PrintMode::pmCompact);
      free(file_C2A);
   }

   Stable.Copy(*builder.LALRStable);
   GOTOtable = builder.GOTOtable;

#ifdef CORE_TABLE_BUILDER
   builder.Stable->Expansion(builder.table, TablePrint);
   int invalid = TablePrint.ValidLRk();
   if (invalid) printf("\nInvalid: %d\n", invalid);
//   builder.table.print(stdout, grammar, 0x00);
#else
   int invalid = builder.Stable->ValidLRk();
   if (invalid) printf("\nInvalid: %d\n", invalid);
#endif

   return ret;
}

bool TGrammarBuilder::make_LALRk_FullTable(A_Syntax::T_SyntaxMode syntax_mode, int k) // T_SyntaxMode::smParseLALR_Tab, T_SyntaxMode::smParseLALR_Full
{
   bool ret = true;
   look_ahead = k;

#ifdef LRK_TABLE_BUILDER
   TLRTabBuilder LRk_builder(grammar);
#else
   TLRBuilder LRk_builder(grammar);
#endif
   LRk_builder.Stable = &Stable;
   LRk_builder.look_ahead = k;

   LRk_builder.make_States(); // Stable, GOTOtable

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable.count(); situation.situation++) {
      const TParaSet* item = Stable.Get(situation);
      TParaSet* core = item->Core();
      COREtable.Add(core, situation.situation);
   }
   const TCoreArr& core_arr = COREtable.Core();

   std::vector<int> move; move.resize(Stable.count(), -1);
   GSymbol situation(GSymbol::gsSituation);

   for (const TCoreArrItem &core : core_arr) {
      TParaSet *I = new TParaSet(grammar);
      for (int item : core) {
         situation.situation = item;
         (*I) << *Stable.Get(situation); move[situation.situation] = LALRStable.count();
      }
      LALRStable.Add(I);
   }

   for (int i = 0; i < (int)move.size(); i++) {
      if (move[i] < 0) {
         situation.situation = i; move[situation.situation] = LALRStable.count();
         LALRStable.Add(new TParaSet(grammar, *Stable.Get(situation)));
      }
   }

#ifdef LRK_TABLE_BUILDER
   TLRTabBuilder LALRk_builder(grammar);
   LALRk_builder.table.Copy(LRk_builder.table);
#else
   TLRBuilder LALRk_builder(grammar);
#endif
   LALRk_builder.Stable = &LALRStable;
   LALRk_builder.LRtable = &LRtable;
   LALRk_builder.look_ahead = k;

   if (syntax_mode == A_Syntax::smParseLALR_Full) {
      LALRk_builder.mode = A_LRBuilder::tmMakeGOTO;
      ret = LALRk_builder.make_Table(); // make_go_to
   } else {
      MTableMap  old_GOTOtable(LRk_builder.GOTOtable);
      LALRk_builder.GOTOtable.clear();
      for (const std::pair<const MTableKey&, const GSymbol&> item : old_GOTOtable) {
         MTableKey key = item.first; key.produce.situation = move[key.produce.situation];
         GSymbol go_to = item.second; go_to.situation = move[go_to.situation];
         LALRk_builder.GOTOtable.Add(key, go_to);
      }

      LALRk_builder.mode = A_LRBuilder::tmGOTO;
      ret = LALRk_builder.make_Table(); // goto
   }

   GOTOtable = LALRk_builder.GOTOtable;

   Stable.Clear();
#ifdef LRK_TABLE_BUILDER
   LALRStable.Expansion(LALRk_builder.table, Stable);
#else
   Stable.Copy(LALRStable); // print
#endif
   LALRStable.Clear();
   LRtable.print(0x00);

   ret = LRtable.verify(GOTOtable);

   return ret;
}

bool TGrammarBuilder::make_LALRkTable(int k) // T_SyntaxMode::smParseLALR
{
   TLR0Builder LR0_builder(grammar);
   LR0_builder.Stable = &Stable;
   LR0_builder.look_ahead = 0;
   bool ret =  LR0_builder.make_States(); // Stable, GOTOtable

   Stable.Basic();
   Stable.print(NULL, 0x0000);

   true_count = 0; false_count = 0;

   {
      TFirstFollow FIRST(&grammar->FIRSTs); FIRST += GSymbol::sharp;
      grammar->FIRSTs.Add(GSymbol::sharp, FIRST);
      grammar->EFFs.Add(GSymbol::sharp, FIRST);
   }

   // Red(p=245,a=4.12)
   bool start = true;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < LR0_builder.Stable->count(); situation.situation++) {
      const TParaSet *I = LR0_builder.Stable->Get(situation);
      for (const TPara& para : *I) {
         TLookAhead::TElement key(situation, para);
         LookAhead.Add(key);
         if (start) { start = false; (*LookAhead.map.begin()).second.symbols.Add(GSymbol::empty); }
      }
   }

//   LookAhead.print("1.look", 0x04);

   TSituationMap  LALRStable;
   TLRBuilder LRk_builder(grammar);
   LRk_builder.look_ahead = k;
   LRk_builder.Stable = &LALRStable;
   LRk_builder.LRtable = &LRtable;
   LRk_builder.Init();

   int step = 0, para_count = 0, sym_count = 0;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < LR0_builder.Stable->count(); situation.situation++) {
      const TParaSet *I = LR0_builder.Stable->Get(situation);
      if ((step % 100) == 0) {
         printf("\n%05d,%05d,%05d", step, para_count, sym_count);
      }
      step++;
      for (const TPara& A_ab : *I) {
         TLookAhead::TElement key_core(situation, A_ab); 
         TLookAhead::TItem& item_from = LookAhead.Get(key_core);

         TPara sharp_para((GSymbol)A_ab, GSymbol::sharp);
         TParaSet P(grammar, sharp_para);
         TParaSet* J = LRk_builder.CLOSURE(P);
         for (const TPara& B_gXd : *J) {
            const GProduce& produce = grammar->Produce(B_gXd);
            if ((B_gXd.point < produce.count()) && !produce.IsEmpty()) {
               const GSymbol& X = produce[B_gXd.point];
               const MTableKey key_goto(situation, X);
               const GSymbol& goto_X = LR0_builder.GOTOtable.Find(key_goto);
               TPara to_para(B_gXd); to_para.point++; to_para.sym = GSymbol::none;
               const TLookAhead::TElement key_to(goto_X, to_para);
               TLookAhead::TItem& to_item = LookAhead.Get(key_to);
               GSymbolSet& to_symbols = to_item.symbols;
               TLookAhead::TElement expansion(goto_X, to_para);
               if (B_gXd.sym == GSymbol::sharp) {
                  item_from.Add(expansion);
               } else {
                  if (B_gXd.sym.IsVector()) {
                     const GSymbolVector& vec = grammar->Vector(B_gXd.sym);
                     GSymbolVector vector;
                     bool yes_sharp = false;
                     for (const GSymbol& sym : vec) {
                        if (sym == GSymbol::sharp) { yes_sharp = true; continue; }
                        vector << sym;
                     }
                     if (yes_sharp) {
                        expansion.para.sym = grammar->AddVector(vector); // B_gXd.sym - sharp
                        item_from.Add(expansion);
                     } else {
                        to_symbols.Add(B_gXd.sym);
                     }
                  } else {
                     to_symbols.Add(B_gXd.sym);
                  }
               }
               sym_count++;
            }
         }
         delete J;
         para_count++;
      }
   }
   printf("\n%05d,%05d,%05d\n", step, para_count, sym_count);
   printf("\ntrue_count=%d, false_count=%d, closure_count=%d\n", LRk_builder.true_count, LRk_builder.false_count, LRk_builder.Added.Current());

 //  LookAhead.print("2.look", 0x04);

   // Red(p=246,a=4.13)
   T_SetQueue<TLookAhead::TElement> queue;
   for (std::pair<const TLookAhead::TElement&, const TLookAhead::TItem&> item : LookAhead.map) {
      if (item.second.expansions.empty()) continue;
      queue.Push(item.first);
   }

   step = 0;
   for (TLookAhead::TElement queue_item; queue.Pop(queue_item); ) {
      int all_work = 0;
      TLookAhead::TItem& from_item = LookAhead.Get(queue_item);
      const GSymbolSet&  from_symbols = from_item.symbols;
      for (TLookAhead::TElement& expansion : from_item.expansions) {
         TLookAhead::TElement key_to(expansion); key_to.para.sym = GSymbol::none;
         TLookAhead::TItem& to_item = LookAhead.Get(key_to);
         GSymbolSet& to_symbols = to_item.symbols;
         int work = 0;
         if (!expansion.para.sym.IsNone()) { // B_gXd.sym - sharp
            const GSymbolVector& vec_u = grammar->Vector(expansion.para.sym);
            bool yes_empty = false;
            for (const GSymbol sym : from_symbols) {
               if (sym.IsEmpty()) {
                  yes_empty = true;
                  continue;
               }
               const GSymbolVector& vec_b = grammar->Vector(sym);
               GSymbolVector vector;
               int len = 0;
               for (const GSymbol& sym : vec_u) {
                  if (len++ >= k) break;
                  vector << sym;
               }
               for (const GSymbol& sym : vec_b) {
                  if (len++ >= k) break;
                  vector << sym;
               }
               const GSymbol header = grammar->AddVector(vector);
               if (to_symbols.Add(header)) work++;
            }
            if (yes_empty) {
               if (to_symbols.Add(expansion.para.sym)) work++;
            }
         } else {
            for (const GSymbol sym : from_symbols) {
               if (to_symbols.Add(sym)) work++;
            }
         }
         if (work) {
            queue.Push(key_to);
         }
         all_work += work;
      }
      if ((step % 100) == 0) {
         printf("\n%05d,%05d", step, all_work);
      }
      step++;
   }
   printf("\n%05d\n", step);

   step = 0;
   para_count = 0;
   LRk_builder.true_count = 0; LRk_builder.false_count = 0;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < LR0_builder.Stable->count(); situation.situation++) {
      if ((step % 100) == 0) {
         printf("\n%05d,%05d", step, para_count);
      }
      step++;
      const TParaSet *I = LR0_builder.Stable->Get(situation);
      TParaSet LALR_I(grammar);
      for (const TPara& A_ab : *I) {
         TLookAhead::TElement key_core(situation, A_ab);
         const TLookAhead::TItem& item = LookAhead.Get(key_core);
         const GSymbolSet& symbols = item.symbols;
         for (const GSymbol sym : symbols) {
            TPara LALR_para((const GSymbol)A_ab, sym);
            LALR_I.Add(LALR_para);
         }
         para_count++;
      }

      TParaSet* I_X = LRk_builder.CLOSURE(LALR_I);
      TParaSet *I_X_P = new TParaSet(grammar, LALR_I); TablePrint.Add(I_X_P);
      int before_count = LALRStable.count();
      const GSymbol go_to = LALRStable.Add(I_X);
      if (LALRStable.count() == before_count) {
         delete I_X;
      }
   }
   printf("\n%05d,%05d", step, para_count);
   printf("\ntrue_count=%d, false_count=%d, closure_count=%d", LRk_builder.true_count, LRk_builder.false_count, LRk_builder.Added.Current());

   LALRStable.print(NULL, 0x00);

   LRk_builder.GOTOtable = LR0_builder.GOTOtable;
   LRk_builder.mode |= A_LRBuilder::tmGOTO;
   ret = LRk_builder.make_Table(); // go_to
   GOTOtable = LRk_builder.GOTOtable;

   LRtable.print(0x00);
   Stable.Clear();
   Stable.Copy(*LRk_builder.Stable); // print
   LALRStable.Clear();

   ret = LRtable.verify(GOTOtable);

   return ret;
}

// ------------------------------ GrammarSplitting -------------------------------
// Green(v=2,7.4.3)
// Green(v=2,p=104,a=7.12)
#define FORMULA_GROUP_LR_
#define FORMULA_GROUP_ETF
bool TGrammarBuilder::make_GrammarSplitting(int k)
{
   bool ret = true;
   look_ahead = k;
   if (!grammar->root) return false;
   grammar->make_start();

   TGrammarGroup group(grammar);
   group.AddGrammar(grammar->root->head);
#if defined(FORMULA_GROUP_LR)
   if (GFormula* part = grammar->FindFormula("Expressions")) { group.AddGrammar(part->head); }
   if (GFormula* part = grammar->FindFormula("Assign")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("ExpressionValue")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("ExpressionExpression")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("ExpressionCondition")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("ExpressionNone")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("ExpressionValueList")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("DefFunc")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("Define")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("DefItem")) { group.AddGrammar(part->head); }
//   if (GFormula* part = grammar->FindFormula("DefType")) { group.AddGrammar(part->head); }
   if (GFormula* part = grammar->FindFormula("DefFAV")) { group.AddGrammar(part->head); }
   if (GFormula* part = grammar->FindFormula("Ranges")) { group.AddGrammar(part->head); }
#elif defined(FORMULA_GROUP_ETF)
//   if (GFormula* part = grammar->FindFormula("E")) { group.AddGrammar(part->head); }
   if (GFormula* part = grammar->FindFormula("T")) { group.AddGrammar(part->head); }
   if (GFormula* part = grammar->FindFormula("F")) { group.AddGrammar(part->head); }
#else
   for (GFormula* formula : grammar->formulas) {
      if (!formula->IsEmpty() && !grammar->IsStart(formula->head)) {
         group.AddGrammar(formula->head);
      }
   }
#endif
   TGrammarGroup::iterator ig;

   ig = group.begin();
   if (ig == group.end()) return false;

// Green(v=2,p=102,a=7.11)
   while (ig != group.end()) {
      TGrammar& item_grammar = *(*ig).second;
      for (GFormula* formula : item_grammar.formulas) {
         for (GProduce& produce : (*formula)) {
            for (GSymbol& sym : produce) {
               group.FormulaToTerminal(sym);
            }
         }
      }
      ig++;
   }

   ig = group.begin();
   while (ig != group.end()) {
      const GSymbol& sym = (*ig).first;
      TGrammarGroupItem& item_grammar = *(*ig).second;
      sym.print(&item_grammar);
      item_grammar.NoEmptyLanguage();
      item_grammar.UnacceptableSymbols();

      if (grammar->option & TGrammar::opSplittingAddition) {
         GSymbol S_(item_grammar.S_);
         GProduce& produce = item_grammar.formulas[S_.formula]->front();
         if ((S_.point < produce.count()) && !grammar->IsStart(S_)) {
            GSymbol& sym_B = produce[S_.point];
            if (sym_B.IsTerminal() && (sym_B.group == T_Lexeme::grGrammar)) {
               sym_B.type = GSymbol::gsFormula; sym_B.formula = sym_B.lexeme_type; sym_B.produce = 0;
            }
         }
      }

      item_grammar.make_FIRST_ks(look_ahead);
      item_grammar.make_EFF_ks(look_ahead);
      item_grammar.make_FOLLOW_ks(look_ahead);

      ig++;
   }

   if (grammar->option & TGrammar::opSplittingAddition) {
      grammar->make_FIRST_ks(look_ahead);
      grammar->make_EFF_ks(look_ahead);
      grammar->make_FOLLOW_ks(look_ahead);
   }

// Green(v=2,p=104,a=7.12)
   ig = group.begin();
   while (ig != group.end()) {
      TGrammarGroupItem& item_grammar = *(*ig).second;
      TSituationMap& Stable = item_grammar.Stable;
      TGGBuilder builder(&group, &item_grammar);
      builder.Stable = &Stable;
      builder.look_ahead = k;

      builder.make_States();

      item_grammar.GOTOtable = builder.GOTOtable;

      int invalid = Stable.ValidLRk();
      if (invalid) printf("\nInvalid: %d\n", invalid);

      ig++;
   }

// Green(v=2,p=106,a=7.13)
   TGGroupBuilder builder_group(&group);
   builder_group.Stable = &TablePrint;
   builder_group.look_ahead = k;
   builder_group.mode = builder_group.tmFormulaAndLexeme;

   builder_group.make_States();

   group.Disclosure(*builder_group.Stable, Stable);

   int invalid = Stable.ValidLRk();
   if (invalid) printf("\nInvalid: %d\n", invalid);

   if (grammar->option & TGrammar::opSplittingAddition) {
      TSLRBuilder builder(grammar);
      builder.Stable = &Stable;
      builder.LRtable = &LRtable;
      builder.mode = builder.tmGOTO;
      builder.look_ahead = k;
      builder.GOTOtable = builder_group.GOTOtable;

      builder.make_Table();
   } else {
      TLRBuilder builder(grammar);
      builder.Stable = &Stable;
      builder.LRtable = &LRtable;
      builder.mode = builder.tmGOTO;
      builder.look_ahead = k;
      builder.GOTOtable = builder_group.GOTOtable;

      builder.make_Table();
   }

   GOTOtable = builder_group.GOTOtable;

   char *file_grammar = get_file_name(file, "group");
   group.print(file_grammar, T_PrintMode::pmProduceHead | T_PrintMode::pmPrintItem); // T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup);
   free(file_grammar);

   return ret;
}

bool TGrammarBuilder::make_FiUnattainable(int k)
{
   look_ahead = k;

   LRFiTableMap LRFiTable(grammar);
   LRFiTable.Make(LRtable);
/*
   char* file_next = get_file_name(file, "next");
   NEXTs.print(file_next, 0x0200);
   free(file_next);
*/

//      LRFiTable.references.Init(LRFiTable.count());
   LRFiTable.FiUnattainable(k);

   if (grammar->option & TGrammar::opChainRule) {
      LRFiTable.ChainRule();
//      LRFiTable.JointSplitting();

      int table_count, item_count;
      LRFiTable.Statistic(table_count, item_count);
      printf("\n%05d,%05d\n", table_count, item_count);
   }

   if (grammar->option & TGrammar::opFiUnattainable) {
      LRFiTable.JointSplitting();
//      LRFiTable.ChainRule();

      int table_count, item_count;
      LRFiTable.Statistic(table_count, item_count);
      printf("\n%05d,%05d\n", table_count, item_count);
   }

   LRFiTable.Copy(LRtable,GOTOtable);

   if (grammar->option & TGrammar::POption::opFiUn) {
      char* file_Fi = get_file_name(grammar->file, "Fi");
      LRFiTable.print(file_Fi, T_PrintMode::pmNoPrintNone | T_PrintMode::pmMultiLine);
      free(file_Fi);
   }
/*
   LRFiTableMap NewFiTable(grammar);
   LRFiTable.Copy(NewFiTable);
   if (grammar->option & TGrammar::POption::opFiUn) {
      char* file_Fi = get_file_name(grammar->file, "NewFi");
      NewFiTable.print(file_Fi, T_PrintMode::pmNoPrintNone | T_PrintMode::pmMultiLine);
      free(file_Fi);
   }
*/
   return true;
}

void test_grammar(int k)
{
   TGrammar        table; table.option = 0;
   table.makers = &GMakerTable::maker_table;
   TGrammarBuilder my_builder(&table);
   table.builder = &my_builder;

   if (!table.read("..\\Grammar\\NL.tab", 0x00)) return;
   table.print(NULL, 0x00);
   table.root = table.formulas.front();
   table.make_lexemes();

//   int filter = 0;
//   table.filter_makers(filter);

   table.change_group();
   table.Used();

//   table.make_FIRSTs();
//   table.FIRSTs.print("FIRSTs", "", 0x0702);
//   table.make_FOLLOWs();
//   table.FOLLOWs.print("FOLLOWs", "", 0x0702);
   table.make_FIRST_ks(k);
//   table.FIRSTs.print("FIRST_ks", "", 0x0702);
//   table.make_EFF_ks(k);
//   table.make_FOLLOW_ks(k);
//   table.FOLLOWs.print("FOLLOW_ks", "", 0x0702);
/*
   my_builder.make_LRkTable(k);
   //   my_builder.make_LR1Table();
   if (my_builder.LRtable.duplicate) printf("\nDuplicate: %d\n", my_builder.LRtable.duplicate);
   if (my_builder.Mtable.warning) printf("\nWarning: %d\n", my_builder.Mtable.warning);

   int option_state = 0x0C00; // compact, !sort 
   my_builder.Stable.print("ETF_LR_Stable.txt", option_state);
   my_builder.GOTOtable.print("ETF_LR_GOTO.txt", 0x0201);
   my_builder.LRtable.print("ETF_LR_Action.txt", 0x0201);

   table.write_LR("ETF_LR.tab", 0x01);
*/
   my_builder.make_LLkTable(k);
   my_builder.Mtable.print("NL_Cell.txt", 0x0201);
   table.write_LL("NL.tab", 0x01);
   return;
}
#include "stdafx.h"

#include "LRBuilder.h"

void A_LRBuilder::clear_count()
{
   not_find = 0; count_empty = 0; shift_count = 0; reduce_count = 0; goto_count = 0; equ_count = 0;
   delete_count = 0; empty_count = 0; add_count = 0;
   true_count = 0; false_count = 0;
}

bool A_LRBuilder::AddAction(const MTableKey& key, const TAction& action)
{
   int before = LRtable->count();
   bool ret = LRtable->Add(key, action);
   if (before == LRtable->count()) equ_count++; else { if (action.IsShift()) shift_count++; else reduce_count++; }
   return ret;
}

const GSymbol A_LRBuilder::Find(const MTableKey& key_goto)
{
   GSymbol I_j;
   bool go_to = (mode & tmGOTO) != 0, make_go_to = (mode & tmMakeGOTO) != 0;
   if (go_to) {
      I_j = GOTOtable.Find(key_goto);
   } else {
      const TParaSet& situation_items = *Stable->Get(key_goto.produce);
      TParaSet* I_A = GOTO(situation_items, key_goto.sym);
      if (!I_A->empty()) {
         I_j = Stable->Find(*I_A);
      } else {
         count_empty++;
      }
      delete I_A;

      if (make_go_to && I_j.IsSituation()) {
         GOTOtable.Add(key_goto, I_j);
      }
   }
   if (!I_j.IsSituation()) {
      not_find += go_to ? -1 : 1;
   }
   return I_j;
}

void A_LRBuilder::FirstTailSym(const TPara& para, TFirst& first_beta_a) const
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& a = para.sym;

   GSymbolVector beta;
   produce.Tail(para, beta);
   if (a.IsVector()) {
      beta << grammar->Vector(a);
   } else {
      beta << a;
   }
   grammar->FIRSTs.FIRST(beta, first_beta_a, grammar->look_ahead);
}

void A_LRBuilder::make_Action(const GSymbol& situation)
{
   const TParaSet& situation_items = *Stable->Get(situation);
   bool go_to = (mode & tmGOTO) != 0, make_go_to = (mode & tmMakeGOTO) != 0;
   for (const TPara& para : situation_items) {
      const GProduce& produce = grammar->Produce(para);
      if ((para.point < produce.count()) && produce[para.point].IsTerminal()) {
         const GSymbol& a = produce[para.point];

         TFirst eff_beta2_v;
         ActionShift(para, eff_beta2_v);

         MTableKey key_goto(situation, a);
         GSymbol I_j = Find(key_goto);

         if (I_j.IsSituation()) {
            TAction action(TAction::taShift, I_j);
            for (const GSymbol& u : eff_beta2_v) {
               MTableKey key(situation, u);
               AddAction(key, action);
            }
         }
      }
      if ((para.point == produce.count()) || produce.IsEmpty()) {
         if (grammar->IsStart(produce.head)) {
            TAction action(TAction::taAccept, produce.head);
            MTableKey key(situation, GSymbol::empty);
            AddAction(key, action);
         } else {
            TAction action(TAction::taReduce, produce.head);

            TFirstFollow follow;
            ActionReduce(para, follow);

            for (const GSymbol& a : follow) {
               MTableKey key(situation, a);
               AddAction(key, action);
            }
         }
      }
   }
   for (const GFormula* formula : grammar->formulas) {
      const GSymbol& A = formula->head;
      if (grammar->IsStart(A)) continue;

      MTableKey key(situation, A);
      GSymbol I_j = Find(key);

      if (I_j.IsSituation()) {
         TAction action(TAction::taGoto, I_j);
         AddAction(key, action);
      }
   }
}

bool A_LRBuilder::make_Table()
{
   bool ret = true;
   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable->count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d", situation.situation, LRtable->count());
      }
      const TParaSet& situation_items = *Stable->Get(situation);
      make_Action(situation);
   }
   printf("\n%05d,%05d, not_find=%d, empty=%d, shift=%d, reduce=%d, goto=%d, equ=%d\n", Stable->count(), LRtable->count(), not_find, count_empty, shift_count, reduce_count, goto_count, equ_count);

   return ret;
}

void A_LRBuilder::make_State(const GSymbol& situation, const GSymbol& X)
{
   const TParaSet *I = Stable->Get(situation);
   TParaSet *I_X = GOTO(*I, X);
   if (I_X->empty()) { delete I_X; delete_count++; empty_count++; return; }
   //   I_X->print(NULL, 0x00, stdout);
   int before = Stable->count();
   const GSymbol go_to = Stable->Add(I_X);
   if (before == Stable->count()) {
      delete I_X;
      delete_count++;
   } else {
      add_count++;
   }
   MTableKey key(situation, X);
   GOTOtable.Add(key, go_to);
}

void A_LRBuilder::make_State(const GSymbol& situation)
{
   bool FormulaAndLexeme = (mode & tmFormulaAndLexeme) != 0;
   TParaSet *I = Stable->Get(situation);
   I->mode = -1;
   int new_step = Stable->step++;
   if (FormulaAndLexeme || (I->count() > (grammar->lexemes.count() + grammar->formulas.count()))) {
      for (const GFormula* formula : grammar->formulas) {
         FORMULA_DELETED_CONTINUE(formula);
         const GSymbol& X = formula->head;
         make_State(situation, X);
      }
      for (const std::pair<const GSymbol&, int> item : grammar->lexemes) {
         const GSymbol& X = item.first;
         make_State(situation, X);
      }
   } else {
      GSymbolSet symbols;
      for (const TPara& para : *I) {
         const GProduce& produce = grammar->Produce(para);
         if (para.point < produce.count()) {
            const GSymbol& sym_B = produce[para.point];
            if (sym_B.IsTerminal() || sym_B.IsFormula()) {
               symbols << sym_B;
            }
         }
      }
      for (const GSymbol& X : symbols) {
         make_State(situation, X);
      }
   }
   I->mode = new_step;
}

bool A_LRBuilder::make_States()
{
   bool ret = true;

   Init();

   clear_count();

   for (GSymbol situation(GSymbol::gsSituation); situation.situation < Stable->count(); situation.situation++) {
      if ((situation.situation % 100) == 0) {
         printf("\n%05d,%05d,%05d", situation.situation, Stable->count(), (int)GOTOtable.size());
      }
      make_State(situation);
   }
   printf("\n%05d,%05d", Stable->count(), GOTOtable.count());
   Stable->print(NULL, 0x00);
   printf("\n--- GOTOtable --- <%d> ---\n", GOTOtable.count());

   return ret;
}

TParaSet* A_LRBuilder::CLOSURE(const TParaSet& I)
{
   TParaSet* closure = new TParaSet(grammar, I);
   Added.Next();
   int work;
   do {
      work = 0;
      const TParaSet J(*closure);
      for (const TPara& para : J) {
         const GSymbol& a = para.sym;
         const GProduce& produce = grammar->Produce(para);
         if (para.point < produce.count()) {
            const GSymbol& sym_B = produce[para.point];
            if (!sym_B.IsFormula()) continue;
            const GFormula& formula_B = grammar->Formula(sym_B);

            TFirst first_beta_a;
            Closure(para, first_beta_a);

            for (const GSymbol& b : first_beta_a) {
               bool added = Added.Added(sym_B, b);
               if (added) { false_count--; continue; }
               TPara gamma(GSymbol(GSymbol::gsPara, sym_B.formula), b);
               for (gamma.produce = 0; gamma.produce < formula_B.count(); gamma.produce++) {
                  if (!closure->Have(gamma)) {
                     (*closure) << gamma; work++;
                     true_count++;
                  } else {
                     false_count++;
                  }
               }
            }
         }
      }
   } while (work);
   return closure;
}

TParaSet* A_LRBuilder::GOTO(const TParaSet& I, const GSymbol& X)
{
   TParaSet closure(grammar);
   for (const TPara& para : I) {
      const GProduce& produce = grammar->Produce(para);
      if (para.point < produce.count()) {
         const GSymbol& sym_B = produce[para.point];
         if (!(sym_B == X)) continue; // (B !== X) 
         TPara shift_para(para); shift_para.point++;
         closure << shift_para;
      }
   }
   return CLOSURE(closure);
}

// ---------------------------- T_LRBuilderInit3 -------------------------
void T_LRBuilderInit3::Init()
{
   Added.Init(3);

   const GSymbol eof(GSymbol::empty);
   TPara S(GSymbol(GSymbol::T_Type::gsPara), eof);
   TParaSet I(grammar, S);
   TParaSet* J = CLOSURE(I);
   Stable->Add(J);
}

// ---------------------------- T_LRBuilderParaSymReduce -------------------------
void T_LRBuilderParaSymReduce::ActionReduce(const TPara& para, TFirstFollow& follow) const
{
   follow << para.sym;
}

// ---------------------------- T_LRBuilderFollowReduce ----------------------
void T_LRBuilderFollowReduce::ActionReduce(const TPara& para, TFirstFollow& follow) const
{
   GSymbol A(GSymbol::gsFormula, para.formula);
   follow = grammar->Follow(A);
}

// ---------------------------- T_LRBuilderSymShift -------------------------
void T_LRBuilderSymShift::ActionShift(const TPara& para, TFirst& first) const
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& a = produce[para.point];
   //   first.owner = &grammar->FIRSTs;
   first << a;
}

// ---------------------------- T_LRBuilderEFFShift -------------------------
void T_LRBuilderEFFShift::ActionShift(const TPara& para, TFirst& eff_beta2_v) const
{
   const GProduce& produce = grammar->Produce(para);
   //   eff_beta2_v.owner = &grammar->EFFs;

   GSymbolVector beta2_v;
   produce.SymAndTail(para, beta2_v);
   if (para.sym.IsVector()) {
      beta2_v << grammar->Vector(para.sym);
   } else {
      beta2_v << para.sym;
   }
   grammar->EFFs.EFF(beta2_v, eff_beta2_v, look_ahead);
}

// ---------------------------- T_LRBuilderBetaFirstKClosure -------------------------
void T_LRBuilderBetaFirstKClosure::Closure(const TPara& para, TFirst& first_beta_a) const
{
   FirstTailSym(para, first_beta_a);
}

#ifdef LRK_TABLE_BUILDER
TEmptyChain& TEmptyChainTab::Get(const GSymbol& key)
{
   iterator ip = find(key);
   if (ip != end()) return (*ip).second;
   std::pair<const GSymbol, TEmptyChain> item(key, TEmptyChain());
   insert(item);
   return (*find(key)).second;
}

TParaSet* TLRTabBuilder::CLOSURE(const TParaSet& I)
{
   TParaSet queue(grammar, I);
   TEmptyChainTab Us;

   while (!queue.empty()) {
      const TPara para = *queue.begin(); queue.erase(queue.begin());
      const GProduce& produce = grammar->Produce(para);
      if (para.point < produce.count()) {
         const GSymbol& sym_B = produce[para.point];
         if (!sym_B.IsFormula()) continue;
         const GFormula& formula_B = grammar->Formula(sym_B);

         TFirst first_beta_a;
         Closure(para, first_beta_a);

#ifdef LRK_EMPTY_TABLE_BUILDER
         bool yes_empty = first_beta_a.Del(GSymbol::empty);
#else
         bool yes_empty = false;
#endif
         GSymbol u;

         bool change_empty = false, change_chain = false;
         TPara gamma(GSymbol(GSymbol::gsPara, sym_B.formula));
         for (gamma.produce = 0; gamma.produce < formula_B.count(); gamma.produce++) {
            TEmptyChain& U = Us.Get(gamma);
            if (!gamma.produce) {
               change_empty = yes_empty && !U.empty.IsEmpty();

               if (!first_beta_a.empty()) {
                  if (U.chain.IsNone()) {
                     u = table.Table(first_beta_a);
                     change_chain = true;
                  } else {
                     TFirstFollow look_ahead_symbols = table.Table(U.chain);
                     if (look_ahead_symbols += first_beta_a) {
                        u = table.Table(look_ahead_symbols);
                        change_chain = true;
                     }
                  }
               }
               if (!change_empty && !change_chain) break;
            }
            if (change_empty) {
               gamma.sym = U.empty = GSymbol::empty;
               queue << gamma;
            }
            if (change_chain) {
               gamma.sym = U.chain = u;
               queue << gamma;
            }
         }
      }
   }

   TParaSet* closure = new TParaSet(grammar, I);
   for (std::pair<const GSymbol&, const TEmptyChain&> item : Us) {
      TPara gamma(item.first);
      const TEmptyChain& U = item.second;
      if (!U.empty.IsNone()) {
         gamma.sym = U.empty;
         (*closure) << gamma;
      }
      if (!U.chain.IsNone()) {
         gamma.sym = U.chain;
         (*closure) << gamma;
      }
   }
   return closure;
}

void TLRTabBuilder::Closure(const TPara& para, TFirst& first_beta_a) const
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& para_sym = para.sym;

   GSymbolVector beta;
   produce.Tail(para, beta);
   if (para_sym.IsTable()) {
      const TFirstFollow& tab = table.Table(para_sym);
      for (const GSymbol& sym : tab) {
         GSymbolVector my_beta(beta);
         if (sym.IsVector()) {
            my_beta << grammar->Vector(sym);
         } else {
            my_beta << sym;
         }
         TFirst first_delta_b;
         grammar->FIRSTs.FIRST(my_beta, first_delta_b, look_ahead);
         first_beta_a << first_delta_b;
      }
   } else {
      if (para_sym.IsVector()) {
         beta << grammar->Vector(para_sym);
      } else {
         beta << para_sym;
      }
      grammar->FIRSTs.FIRST(beta, first_beta_a, look_ahead);
   }
}

void TLRTabBuilder::ActionReduce(const TPara& para, TFirstFollow& follow) const
{
   const GSymbol& para_sym = para.sym;
   if (para_sym.IsTable()) {
      const TFirstFollow& tab = table.Table(para_sym);
      for (const GSymbol& sym : tab) {
         follow << sym;
      }
   } else {
      follow << para_sym;
   }
}

void TLRTabBuilder::ActionShift(const TPara& para, TFirst& eff_beta2_v) const
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& para_sym = para.sym;

   GSymbolVector beta;
   produce.SymAndTail(para, beta);
   if (para_sym.IsTable()) {
      TFirst first_delta_b;
      const TFirstFollow& tab = table.Table(para_sym);
      for (const GSymbol& sym : tab) {
         GSymbolVector my_beta(beta);
         if (sym.IsVector()) {
            my_beta << grammar->Vector(sym);
         } else {
            my_beta << sym;
         }
         first_delta_b.clear();
         grammar->EFFs.EFF(my_beta, first_delta_b, look_ahead);
         eff_beta2_v << first_delta_b;
      }
   } else {
      if (para_sym.IsVector()) {
         beta << grammar->Vector(para_sym);
      } else {
         beta << para_sym;
      }
      grammar->EFFs.EFF(beta, eff_beta2_v, look_ahead);
   }
}

#endif

// ---------------------------- TSLRBuilder -----------------------------------
// Green(v=2,p=94,7.4.1,a=7.10)
void TSLRBuilder::ActionShift(const TPara& para, TFirst& eff) const
{
   const GProduce& produce = grammar->Produce(para);
   //   eff.owner = &grammar->EFFs;

   GSymbolVector beta;
   produce.SymAndTail(para, beta);
   GSymbol A(GSymbol::gsFormula, para.formula);
   const TFirstFollow& follow_A = grammar->Follow(A);
   for (const GSymbol& a : follow_A) {
      GSymbolVector beta_follow(beta);
      if (a.IsVector()) {
         beta_follow << grammar->Vector(a);
      } else {
         beta_follow << a;
      }
      TFirst eff_follow;
      grammar->EFFs.EFF(beta_follow, eff_follow, look_ahead);
      eff << eff_follow;
   }
}

// ---------------------------- TLR0Builder -----------------------------------
void TLR0Builder::Init()
{
   Added.Init(0);

   TPara S(GSymbol::gsPara);
   TParaSet I(grammar, S);
   TParaSet* J = CLOSURE(I);
   Stable->Add(J); Stable->step++;
}

void TLR0Builder::Closure(const TPara& para, TFirst& first_beta_a) const
{
   first_beta_a << GSymbol::none;
}

// ---------------------------- TLR1Builder -----------------------------------
void TLR1Builder::Init()
{
   Added.Init(1);

   const GSymbol eof(GSymbol::empty);
   TPara S(GSymbol(GSymbol::T_Type::gsPara), eof);
   TParaSet I(grammar, S);
   TParaSet* J = CLOSURE(I);
   Stable->Add(J); Stable->step++;
}

void TLR1Builder::Closure(const TPara& para, TFirst& first_beta_a) const
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& a = para.sym;

   GSymbolVector beta;
   produce.Tail(para, beta);
   beta << a;

   first_beta_a = TFirst(beta, &grammar->FIRSTs);
}

// ---------------------------- T_LRCoreBuilder -----------------------------------
void T_LRCoreBuilder::Init()
{
   CtoAa.Core();
   Added.Init((mode & tmLR0) ? 0 : 4);
   CtoAa.Split();

   TPara S(GSymbol(GSymbol::T_Type::gsPara), GSymbol::none);
   if (!(mode & tmLR0)) S.sym = GSymbol::empty;
   TParaSet* I = new TParaSet(grammar, S);
   Stable->Add(I); Stable->step++;
}

void T_LRCoreBuilder::make_Action(const GSymbol& situation)
{
   const TParaSet& situation_items = *Stable->Get(situation);
   for (const TPara& para_B : situation_items) { // [B -> gamma . ? delta, b ]
      const GProduce& produce_B = grammar->Produce(para_B);
      if (para_B.point < produce_B.count()) {
         const GSymbol& sym_B = produce_B[para_B.point];
         if (sym_B.IsFormula()) { // [B -> gamma . C delta, b ]
            const GSymbol& C = sym_B;
            Tc2a& C_A = CtoAa.Get(C);

            TFirst eff_beta2_v;
            ActionShift(para_B, eff_beta2_v);
            for (const GSymbol& u : eff_beta2_v) {
               MTableKey key_goto(situation, u);
               if (u.IsVector()) {
                  const GSymbolVector& u_vector = grammar->Vector(u);
                  key_goto.sym = u_vector.front();
               }
               GSymbol I_j = GOTOtable.Find(key_goto);
               if (I_j.IsSituation()) {
                  TAction action(TAction::taShift, I_j);
                  MTableKey key(situation, u);
                  AddAction(key, action);
               } else {
                  not_find += -1;
               }
            }
            const TAmus& tails = C_A.Get(GSymbol::empty);
            for (std::pair<const GSymbol&, const TAmu&> item_mu : tails) {
               const TAmu& tail = item_mu.second;

               TFirst first_mu_A;
               MuFirstTailSym(para_B, tail, first_mu_A);

               GSymbol A(GSymbol::gsProduce, tail.point.formula, tail.point.produce);
               const GProduce& produce_A = grammar->Produce(A);
               TAction action(TAction::taReduce, produce_A.head);
               for (const GSymbol& a : first_mu_A) {
                  MTableKey key(situation, a); key.sym.value = 0;
                  AddAction(key, action);
               }
            }
         } else if (sym_B.IsTerminal()) {
            MTableKey key_goto(situation, sym_B); key_goto.sym.value = 0;
            GSymbol I_j = GOTOtable.Find(key_goto);

            if (I_j.IsSituation()) {
               TAction action(TAction::taShift, I_j);
               TFirst eff_beta2_v;
               ActionShift(para_B, eff_beta2_v);
               for (const GSymbol& u : eff_beta2_v) {
                  MTableKey key(situation, u);
                  AddAction(key, action);
               }
            } else {
               not_find += -1;
            }
         }
      }
      if ((para_B.point == produce_B.count()) || produce_B.IsEmpty()) {
         if (produce_B.head.IsStart()) {
            TAction action(TAction::taAccept, produce_B.head);
            MTableKey key(situation, (mode & tmLR0) ? GSymbol::eof : GSymbol::empty);
            AddAction(key, action);
         } else {
            TAction action(TAction::taReduce, produce_B.head);
            TFirstFollow follow;
            ActionReduce(para_B, follow);

            for (const GSymbol& a : follow) {
               MTableKey key(situation, a);
               AddAction(key, action);
            }
         }
      }
   }
}

// ---------------------------- TLR0CoreBuilder -----------------------------------
void TLR0CoreBuilder::MuFirstTailSym(const TPara& para, const TAmu& tail, TFirst& first_mu_A)
{
   first_mu_A = (TFirst&)grammar->Follow(GSymbol(GSymbol::gsFormula, tail.point.formula));
}

void TLR0CoreBuilder::ActionShift(const TPara& para, TFirst& eff_beta2_v) const
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& sym_B = produce[para.point];
   if (sym_B.IsFormula()) { // [B -> gamma . C delta, b ]
      const GSymbol& C = sym_B;
      const Tc2a& C_A = (const Tc2a)CtoAa.Get(C);
      (GSymbolSet&)eff_beta2_v = C_A.terminals;
   } else if (sym_B.IsTerminal()) {
      eff_beta2_v << sym_B;
   }
}

TParaSet* TLR0CoreBuilder::GOTO(const TParaSet& I, const GSymbol& X)
{
   TParaSet* go_to = new TParaSet(grammar);
   for (const TPara& para_B : I) {
      if ((I.mode > 0) && (para_B.sym.value <= I.mode)) continue;
      const GProduce& produce_B = grammar->Produce(para_B); // [B -> gamma . ? delta, b ]
      if (para_B.point < produce_B.count()) {
         const GSymbol& sym_B = produce_B[para_B.point];
         if (sym_B == X) {  // [B -> gamma . X delta, b ]
            TPara shift_para(para_B); shift_para.point++;
            (*go_to) << shift_para;
         }
         if (sym_B.IsFormula()) { // [B -> gamma . C delta, b ]
            const GSymbol& C = sym_B;
            Tc2a& C_A = CtoAa.Get(C);
            const TAmus& tails = C_A.Get(X);
            for (std::pair<const GSymbol&, const TAmu&> item_mu : tails) {
               const TAmu& tail = item_mu.second;
               GSymbol para(GSymbol::gsPara, tail.point.formula, tail.point.produce, tail.point.point + 1);

               int before = go_to->count();
               (*go_to) << TPara(para, GSymbol::none);
               if (go_to->count() == before) add_count++;

            }
         }
      }
   }
   return go_to;
}

// ---------------------------- TLRkCoreBuilder -----------------------------------
void TLRkCoreBuilder::MuFirstTailSym(const TPara& para, const TAmu& tail, TFirst& first_mu_A)
{
#ifndef CORE_POINT_TAILS
   FirstTailSym(para, first_mu_A);
#else
   TBTailItem* delta = CtoAa.point_tails.Get(para);
   if (!delta->delta.empty()) {
      first_delta_b = delta->delta;
   }
   if (!delta->half.empty()) {
      TFirst first, first_b;
      first_b << para.sym; // b
      grammar->Vectors().Plus(delta->half, first_b, first, look_ahead);
      first_delta_b << first;
   }
   grammar->Vectors().Plus(tail.mu, first_delta_b, first_mu_A, look_ahead);
#endif
}

TParaSet* TLRkCoreBuilder::GOTO(const TParaSet& I, const GSymbol& X)
{
   Added.Next(); GSymbol added_produce(GSymbol::gsProduce);
   TParaSet* go_to = new TParaSet(grammar);
   for (const TPara& para_B : I) {
      if ((I.mode > 0) && (para_B.sym.value <= I.mode)) continue;
      const GProduce& produce_B = grammar->Produce(para_B); // [B -> gamma . ? delta, b ]
      if (para_B.point < produce_B.count()) {
         const GSymbol& sym_B = produce_B[para_B.point];
         if (sym_B == X) {  // [B -> gamma . X delta, b ]
            TPara shift_para(para_B); shift_para.point++;
            (*go_to) << shift_para;
         }
         if (sym_B.IsFormula()) { // [B -> gamma . C delta, b ]
            const GSymbol& C = sym_B;
            Tc2a& C_A = CtoAa.Get(C);
            const TAmus& tails = C_A.Get(X);
            if (tails.empty()) continue;

            TFirst first_delta_b;
#ifndef CORE_POINT_TAILS
            FirstTailSym(para_B, first_delta_b);
#else
            TBTailItem* delta = CtoAa.point_tails.Get(para_B);
            if (!delta->delta.empty()) {
               first_delta_b = delta->delta;
            }
            if (!delta->half.empty()) {
               TFirst first, first_b;
               first_b << para_B.sym; // b
               grammar->Vectors().Plus(delta->half, first_b, first, look_ahead);
               first_delta_b << first;
            }
#endif
            for (std::pair<const GSymbol&, const TAmu&> item_mu : tails) {
               const TAmu& tail = item_mu.second;
               added_produce.value = tail.produce;
               GSymbol para(GSymbol::gsPara, tail.point.formula, tail.point.produce, tail.point.point + 1);
               TFirst first_mu_A;
               // [ A -> X . beta , ?]
               if (!tail.half.empty()) {
                  grammar->Vectors().Plus(tail.half, first_delta_b, first_mu_A, look_ahead);
               }
               if (!tail.mu.empty() && (tail.step != Added.Current())) {
                  for (const GSymbol& a : tail.mu) {
                     bool added = Added.Added(added_produce, a);
                     if (added) { false_count--; continue; }
                     (*go_to) << TPara(para, a);
                  }
               } else {
                  count_empty++;
               }
               for (const GSymbol& a : first_mu_A) {
                  bool added = Added.Added(added_produce, a);
                  if (added) { false_count--; continue; }
                  (*go_to) << TPara(para, a);
               }
               tail.step = Added.Current();
            }
         }
      }
   }
   return go_to;
}

// ---------------------------- T_LALRCoreBuilder -----------------------------------
bool T_LALRCoreBuilder::make_States()
{
   bool ret = true;
   Init();

   int step = 0;
   for (GSymbol situation; LALRStable->queue.Pop(situation); ) {
      if ((++step % 100) == 0) {
         printf("\n%05d,%05d,%05d,%05d", situation.situation, LALRStable->count(), (int)GOTOtable.size(), (int)LALRStable->queue.size());
      }
      make_State(situation);
   }
   printf("\n%05d,%05d", LALRStable->count(), GOTOtable.count());
   LALRStable->print(NULL, 0x00);
   printf("\n--- GOTOtable --- <%d> ---\n", GOTOtable.count());

   return ret;
}

#ifdef CORE_TABLE_BUILDER
void TLRkCoreTabBuilder::ActionReduce(const TPara& para, TFirstFollow& follow) const
{
   const GSymbol& para_sym = para.sym;
   if (para_sym.IsTable()) {
      const TFirstFollow& tab = table.Table(para_sym);
      for (const GSymbol& sym : tab) {
         follow << sym;
      }
   } else {
      follow << para_sym;
   }
}

void TLRkCoreTabBuilder::ActionShift(const TPara& para, TFirst& eff_beta2_v) const
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& para_sym = para.sym;

   GSymbolVector beta;
   produce.SymAndTail(para, beta);
   if (para_sym.IsTable()) {
      TFirst first_delta_b;
      const TFirstFollow& tab = table.Table(para_sym);
      for (const GSymbol& sym : tab) {
         GSymbolVector my_beta(beta);
         if (sym.IsVector()) {
            my_beta << grammar->Vector(sym);
         } else {
            my_beta << sym;
         }
         first_delta_b.clear();
         grammar->EFFs.EFF(my_beta, first_delta_b, look_ahead);
         eff_beta2_v << first_delta_b;
      }
   } else {
      if (para_sym.IsVector()) {
         beta << grammar->Vector(para_sym);
      } else {
         beta << para_sym;
      }
      grammar->EFFs.EFF(beta, eff_beta2_v, look_ahead);
   }
}

void TLRkCoreTabBuilder::MuFirstTailSym(const TPara& para, const TAmu& tail, TFirst& first_mu_A)
{
   const GProduce& produce = grammar->Produce(para);
   const GSymbol& para_sym = para.sym;

   GSymbolVector beta;
   produce.Tail(para, beta);
   if (para_sym.IsTable()) {
      const TFirstFollow& tab = table.Table(para_sym);
      for (const GSymbol& sym : tab) {
         GSymbolVector my_beta(beta);
         if (sym.IsVector()) {
            my_beta << grammar->Vector(sym);
         } else {
            my_beta << sym;
         }
         TFirst first_delta_b, my_first_mu_A;
         grammar->FIRSTs.FIRST(my_beta, first_delta_b, look_ahead);
         grammar->Vectors().Plus(tail.mu, first_delta_b, my_first_mu_A, look_ahead);
         first_mu_A << my_first_mu_A;
      }
   } else {
      if (para_sym.IsVector()) {
         beta << grammar->Vector(para_sym);
      } else {
         beta << para_sym;
      }
      TFirst first_delta_b;
      grammar->FIRSTs.FIRST(beta, first_delta_b, look_ahead);
      grammar->Vectors().Plus(tail.mu, first_delta_b, first_mu_A, look_ahead);
   }
}

TParaSet* TLRkCoreTabBuilder::GOTO(const TParaSet& I, const GSymbol& X)
{
   Added.Next();
   TEmptyChainTab Us;
   for (const TPara& para_B : I) {
      if ((I.mode > 0) && (para_B.sym.value <= I.mode)) continue;
      const GProduce& produce_B = grammar->Produce(para_B); // [B -> gamma . ? delta, b ]
      if (para_B.point < produce_B.count()) {
         const GSymbol& sym_B = produce_B[para_B.point];
         if (sym_B == X) {  // [B -> gamma . X delta, b ]
            TPara shift_para(para_B); shift_para.point++;
            TEmptyChain& U = Us.Get(shift_para);
            if (U.chain.IsNone()) {
               U.chain = shift_para.sym;
            } else {
               TFirstFollow symbols = table.Table(U.chain);
               const TFirstFollow& symbols_para = table.Table(shift_para.sym);
               if (symbols += symbols_para) {
                  U.chain = table.Table(symbols);
               }
            }
         }
         if (sym_B.IsFormula()) { // [B -> gamma . C delta, b ]
            const GSymbol& C = sym_B;
            Tc2a& C_A = CtoAa.Get(C);
            const TAmus& tails = C_A.Get(X);
            if (tails.empty()) continue;

            std::vector<TFirst> first_delta_b_s;
            const GSymbol& para_sym = para_B.sym;

            GSymbolVector beta;
            produce_B.Tail(para_B, beta);
            if (para_sym.IsTable()) {
               const TFirstFollow& tab = table.Table(para_sym);
               for (const GSymbol& sym : tab) {
                  GSymbolVector my_beta(beta);
                  if (sym.IsVector()) {
                     my_beta << grammar->Vector(sym);
                  } else {
                     my_beta << sym;
                  }
                  TFirst first_delta_b;
                  grammar->FIRSTs.FIRST(my_beta, first_delta_b, grammar->look_ahead);
                  first_delta_b_s.push_back(first_delta_b);
                  CtoAa.point_tails.Add(para_B);
               }
            } else {
               if (para_sym.IsVector()) {
                  beta << grammar->Vector(para_sym);
               } else {
                  beta << para_sym;
               }
               TFirst first_delta_b;
               grammar->FIRSTs.FIRST(beta, first_delta_b, grammar->look_ahead);
               first_delta_b_s.push_back(first_delta_b);
            }

            for (std::pair<const GSymbol&, const TAmu&> item_mu : tails) {
               const TAmu& tail = item_mu.second;
               GSymbol para(GSymbol::gsPara, tail.point.formula, tail.point.produce, tail.point.point + 1);
               // [ A -> X . beta , ?]
               TFirstFollow look_ahead_symbols;
               if (!tail.half.empty()) {
                  for (const TFirst& first_delta_b : first_delta_b_s) {
                     TFirst first_mu_A;
                     grammar->Vectors().Plus(tail.half, first_delta_b, first_mu_A, look_ahead);
                     look_ahead_symbols << first_mu_A;
                  }
               }

               look_ahead_symbols << tail.mu;
               if (look_ahead_symbols.empty()) continue;

               TEmptyChain& U = Us.Get(para);
               if (U.chain.IsNone()) {
                  U.chain = table.Table(look_ahead_symbols);
               } else {
                  TFirstFollow symbols = table.Table(U.chain);
                  if (symbols += look_ahead_symbols) {
                     U.chain = table.Table(symbols);
                  }
               }
            }
         }
      }
   }

   TParaSet* go_to = new TParaSet(grammar);
   for (std::pair<const GSymbol&, const TEmptyChain&> item : Us) {
      const TEmptyChain& U = item.second;
      TPara para(item.first); para.sym = U.chain;
      (*go_to) << para;
   }
   return go_to;
}

#endif

// ------------------------------ GrammarSplitting -------------------------------
// Green(v=2,7.4.3)
// Green(v=2,p=104,a=7.12)
void TGGBuilder::Init()
{
   Added.Init(3);
   GFormula* formula = grammar->root;
   TParaSet I(grammar);

   if (grammar->option & TGrammar::opSplittingAddition) {
      GSymbol S_(((TGrammarGroupItem*)grammar)->S_);
      TPara S(GSymbol(GSymbol::T_Type::gsPara, S_.formula, 0, 0), GSymbol::empty);
      I.Add(S);
   } else {
      const TFollow& follow = ((TGrammarGroupItem*)grammar)->general->Follow(formula->head);
      for (const GSymbol& a : follow) {
         TPara S(GSymbol(GSymbol::T_Type::gsPara, formula->head.formula, 0, 0), a);
         for (; S.produce < formula->count(); S.produce++) {
            I.Add(S);
         }
      }
   }

   TParaSet* J = CLOSURE(I);
   Stable->Add(J);
}

void TGGBuilder::FirstTailSym(const TPara& para, TFirst& first_beta_a) const
{
   if (grammar->option & TGrammar::opSplittingAddition) {
      first_beta_a << GSymbol::none;
   } else {
      const GProduce& produce = grammar->Produce(para);
      const GSymbol& a = para.sym;

      GSymbolVector beta;
      produce.Tail(para, beta);
      if (a.IsVector()) {
         beta << grammar->Vector(a);
      } else {
         beta << a;
      }
      for (GSymbol& sym : beta) {
         group->TerminalToFormula(sym);
      }
      ((TGrammarGroupItem*)grammar)->general->FIRSTs.FIRST(beta, first_beta_a, grammar->look_ahead);
   }
}

// Green(v=2,p=106,a=7.13)
void TGGroupBuilder::Init()
{
   GSymbolSet filter;
   for (std::pair<const GSymbol&, const TGrammarGroupItem*> item : (*group)) {
      filter.Add(item.first);
   }
   derivation.Make(&filter);
   for (const GSymbol& S : filter) {
      if (!derivation.Count(S)) {
         derivation.Add(S, S);
      }
   }

   Added.Init(-1);
   GFormula* formula = grammar->root;
   TParaSet I(grammar);
   if (grammar->option & TGrammar::opSplittingAddition) {
      TPara S_P(GSymbol(GSymbol::gsPara, formula->head.formula, 0, 0), GSymbol::empty); I.Add(S_P);
   } else {
      TPara S_S(GSymbol(GSymbol::gsSituation, 0), GSymbol(GSymbol::gsFormula, 0)); I.Add(S_S);
   }

   TParaSet* J = CLOSURE(I);
   Stable->Add(J);
}

TParaSet* TGGroupBuilder::CLOSURE(const TParaSet& I)
{
   TParaSet* closure = new TParaSet(grammar, I);
   int work;
   do {
      work = 0;
      const TParaSet J(*closure);
      for (const TPara& para_B : J) {
         TParaSet para_set(grammar); const TParaSet* pointer;
         if (para_B.IsPara()) {
            para_set << para_B;
            pointer = &para_set;
         } else { // situation
            TGrammarGroup::const_iterator ig = group->find(para_B.sym);
            const TGrammarGroupItem& item_grammar = *(*ig).second;
            pointer = item_grammar.Stable.Get(para_B);
         }
         for (const TPara& para : *pointer) {
            const GProduce& produce = grammar->Produce(para);
            if (para.point < produce.count()) {
               const GSymbol& sym_B = produce[para.point];
               if (sym_B.IsFormula() && derivation.Count(sym_B)) {
                  const GSymbolSet& set_S = derivation.Get(sym_B);
                  for (const GSymbol& Si : set_S) {
                     TPara para_Si(GSymbol(GSymbol::gsSituation, 0), Si);
                     if ((*closure) += para_Si) work++;
                  }
               }
            }
         }
      }
   } while (work);
   return closure;
}

TParaSet* TGGroupBuilder::GOTO(const TParaSet& I, const GSymbol& X)
{
   TParaSet closure(grammar);
   for (const TPara& para : I) {
      if (para.IsPara()) {
         const GProduce& produce = grammar->Produce(para);
         if (para.point < produce.count()) {
            const GSymbol& sym_B = produce[para.point];
            if (!(sym_B == X)) continue; // (B !== X) 
            TPara shift_para(para); shift_para.point++;
            closure << shift_para;
         }
      } else { // situation
         TGrammarGroup::const_iterator ig = group->find(para.sym);
         const TGrammarGroupItem& item_grammar = *(*ig).second;
         MTableKey key_goto((const GSymbol&)para, X);
         group->FormulaToTerminal(key_goto.sym);
         const GSymbol& I_j = item_grammar.GOTOtable.Find(key_goto);
         if (!I_j.IsNone()) {
            TPara para_goto(I_j, para.sym);
            closure << para_goto;
         }
      }
   }
   return CLOSURE(closure);
}
#ifndef TRN_LRBUILDER_H
#define TRN_LRBUILDER_H

#include "GBuilder.h"

// ------------------------------------------------ A_LRBuilder -----------------------------------------------
#pragma warning( disable : 4250 )
class A_LRBuilder
{
public:
   A_LRBuilder(TGrammar* g) :grammar(g), Added(g), GOTOtable(g), mode(0) { clear_count(); }
   enum T_Mode {
      tmNone = 0x0000, tmBasic = 0x0001, tmGOTO = 0x0002, tmLALR = 0x0004, tmMakeGOTO = 0x0008, tmLR0 = 0x0010, tmFormulaAndLexeme = 0x0020
   };
public:
   bool make_Table();
   void make_State(const GSymbol& situation, const GSymbol& X);
   void make_State(const GSymbol& situation);
   bool AddAction(const MTableKey& key, const TAction& action);
   const GSymbol Find(const MTableKey&);
   virtual void FirstTailSym(const TPara& para, TFirst& first_beta_a) const;
   virtual bool make_States();
   virtual void make_Action(const GSymbol& situation); // 0x01 - basic, 0x02 - GOTO, 0x04 - LALR, 0x08 - make_go_to
   virtual void Init() = 0;
   virtual void Closure(const TPara& para, TFirst& beta) const = 0;
   virtual void ActionShift(const TPara& para, TFirst& beta) const = 0;
   virtual void ActionReduce(const TPara& para, TFirstFollow& follow) const = 0;
public:
   virtual TParaSet* CLOSURE(const TParaSet& I);
   virtual TParaSet* GOTO(const TParaSet& I, const GSymbol& X);
public:
   TSituationMap* Stable;
   LRTableMap*    LRtable;
   MTableMap      GOTOtable;
   TGrammar*      grammar;
   int            look_ahead;
   int            mode;  // T_Mode
   TClosureAdded  Added;
protected:
   void clear_count();
public: // print
   int not_find, count_empty, shift_count, reduce_count, goto_count, equ_count;
   int delete_count, empty_count, add_count;
   int true_count, false_count;
};

// ---------------------------- T_LRBuilderInit3 -------------------------
class T_LRBuilderInit3 : public virtual A_LRBuilder
{
public:
   T_LRBuilderInit3(TGrammar* g) :A_LRBuilder(g) {}
   virtual void Init();
};

// ---------------------------- T_LRBuilderParaSymReduce -------------------------
class T_LRBuilderParaSymReduce : public virtual A_LRBuilder
{
public:
   T_LRBuilderParaSymReduce(TGrammar* g) :A_LRBuilder(g) {}
   virtual void ActionReduce(const TPara& para, TFirstFollow& follow) const;
};

// ---------------------------- T_LRBuilderFollowReduce ----------------------
class T_LRBuilderFollowReduce : public virtual A_LRBuilder
{
public:
   T_LRBuilderFollowReduce(TGrammar* g) :A_LRBuilder(g) {}
   virtual void ActionReduce(const TPara& para, TFirstFollow& follow) const;
};

// ---------------------------- T_LRBuilderSymShift -------------------------
class T_LRBuilderSymShift : public virtual A_LRBuilder
{
public:
   T_LRBuilderSymShift(TGrammar* g) :A_LRBuilder(g) {}
   void ActionShift(const TPara& para, TFirst& follow) const;
};

// ---------------------------- T_LRBuilderEFFShift -------------------------
class T_LRBuilderEFFShift : public virtual A_LRBuilder
{
public:
   T_LRBuilderEFFShift(TGrammar* g) :A_LRBuilder(g) {}
   void ActionShift(const TPara& para, TFirst& follow) const;
};

// ---------------------------- T_LRBuilderBetaFirstKClosure -------------------------
class T_LRBuilderBetaFirstKClosure : public virtual A_LRBuilder
{
public:
   T_LRBuilderBetaFirstKClosure(TGrammar* g) :A_LRBuilder(g) {}
   virtual void Closure(const TPara& para, TFirst& beta) const;
};

// Green(v=1,5.2.5)
// ---------------------------- TLRBuilder -----------------------------------
class TLRBuilder : public virtual A_LRBuilder, public T_LRBuilderInit3, public T_LRBuilderEFFShift, public T_LRBuilderParaSymReduce, public T_LRBuilderBetaFirstKClosure
{
public:
   TLRBuilder(TGrammar* g) :A_LRBuilder(g), T_LRBuilderInit3(g), T_LRBuilderEFFShift(g), T_LRBuilderParaSymReduce(g), T_LRBuilderBetaFirstKClosure(g) {}
public:
};

#define LRK_TABLE_BUILDER_
#define LRK_EMPTY_TABLE_BUILDER

#ifdef LRK_TABLE_BUILDER
// ---------------------------- TLRTabBuilder -----------------------------------
class TLRTabBuilder : public virtual A_LRBuilder, public T_LRBuilderInit3, public T_LRBuilderEFFShift
{
public:
   TLRTabBuilder(TGrammar* g) :A_LRBuilder(g), T_LRBuilderInit3(g), T_LRBuilderEFFShift(g) {}
public:
   virtual TParaSet* CLOSURE(const TParaSet& I);
   virtual void Closure(const TPara& para, TFirst& beta) const;
   virtual void ActionShift(const TPara& para, TFirst& beta) const;
   virtual void ActionReduce(const TPara& para, TFirstFollow& follow) const;
public:
   TFirstFollowTable table;
};

struct TEmptyChain
{
public:
   TEmptyChain() {}
   TEmptyChain(const GSymbol& e, const GSymbol& c) :empty(e), chain(c) {}
public:
   GSymbol empty, chain;
};

class TEmptyChainTab : public std::map<const GSymbol, TEmptyChain>
{
public:
   TEmptyChain& Get(const GSymbol& key);
};
#endif

// ---------------------------- TSLRBuilder -----------------------------------
// Green(v=2,p=94,7.4.1,a=7.10)
class TSLRBuilder : public virtual A_LRBuilder, public T_LRBuilderInit3, public T_LRBuilderFollowReduce, public T_LRBuilderBetaFirstKClosure
{
public:
   TSLRBuilder(TGrammar* g) :A_LRBuilder(g), T_LRBuilderInit3(g), T_LRBuilderFollowReduce(g), T_LRBuilderBetaFirstKClosure(g) {}
public:
   virtual void ActionShift(const TPara& para, TFirst& beta) const;
};

// ---------------------------- TLR0Builder -----------------------------------
class TLR0Builder : public virtual A_LRBuilder, public T_LRBuilderFollowReduce, public T_LRBuilderSymShift
{
public:
   TLR0Builder(TGrammar* g) :A_LRBuilder(g), T_LRBuilderFollowReduce(g), T_LRBuilderSymShift(g) { mode = tmLR0; }
public:
   virtual void Init();
   virtual void Closure(const TPara& para, TFirst& beta) const;
};

// ---------------------------- TLR1Builder -----------------------------------
class TLR1Builder : public virtual A_LRBuilder, public T_LRBuilderParaSymReduce, public T_LRBuilderSymShift
{
public:
   TLR1Builder(TGrammar* g) :A_LRBuilder(g), T_LRBuilderParaSymReduce(g), T_LRBuilderSymShift(g) {}
public:
   virtual void Init();
   virtual void Closure(const TPara& para, TFirst& beta) const;
};

// ---------------------------- T_LRCoreBuilder -----------------------------------
class T_LRCoreBuilder : public virtual A_LRBuilder
{
public:
   T_LRCoreBuilder(TGrammar* g) :A_LRBuilder(g), CtoAa(g) {}
public:
   virtual void Init();
   virtual void make_Action(const GSymbol& situation);
   virtual void Closure(const TPara& para, TFirst& beta) const {}
   virtual void MuFirstTailSym(const TPara& para, const TAmu& tail, TFirst& first_mu_A) {}
public:
   TC2A CtoAa;
};

// ---------------------------- TLR0CoreBuilder -----------------------------------
class TLR0CoreBuilder : public T_LRCoreBuilder, public T_LRBuilderFollowReduce
{
public:
   TLR0CoreBuilder(TGrammar* g) :A_LRBuilder(g), T_LRCoreBuilder(g), T_LRBuilderFollowReduce(g) { mode = tmLR0 | tmFormulaAndLexeme; }
public:
   virtual TParaSet* GOTO(const TParaSet& I, const GSymbol& X);
   virtual void ActionShift(const TPara& para, TFirst& beta) const;
   virtual void MuFirstTailSym(const TPara& para, const TAmu& tail, TFirst& first_mu_A);
};

// ---------------------------- TLRkCoreBuilder -----------------------------------
class TLRkCoreBuilder : public T_LRCoreBuilder, public T_LRBuilderEFFShift, public T_LRBuilderParaSymReduce
{
public:
   TLRkCoreBuilder(TGrammar* g) :A_LRBuilder(g), T_LRCoreBuilder(g), T_LRBuilderEFFShift(g), T_LRBuilderParaSymReduce(g) { mode = tmFormulaAndLexeme; }
public:
   virtual TParaSet* GOTO(const TParaSet& I, const GSymbol& X);
   virtual void MuFirstTailSym(const TPara& para, const TAmu& tail, TFirst& first_mu_A);
};

#define CORE_POINT_TAILS_
#define CORE_TABLE_BUILDER_

#ifdef CORE_TABLE_BUILDER
// ---------------------------- TLRkCoreTabBuilder -----------------------------------
class TLRkCoreTabBuilder : public TLRkCoreBuilder
{
public:
   TLRkCoreTabBuilder(TGrammar* g) :A_LRBuilder(g), TLRkCoreBuilder(g) { }
public:
   virtual TParaSet* GOTO(const TParaSet& I, const GSymbol& X);
   virtual void ActionShift(const TPara& para, TFirst& beta) const;
   virtual void MuFirstTailSym(const TPara& para, const TAmu& tail, TFirst& first_mu_A);
   virtual void ActionReduce(const TPara& para, TFirstFollow& follow) const;
public:
   TFirstFollowTable table;
};

#endif

// ---------------------------- T_LALRCoreBuilder -----------------------------------
class T_LALRCoreBuilder : public virtual A_LRBuilder
{
public:
   T_LALRCoreBuilder(TGrammar* g) :A_LRBuilder(g) {}
public:
   virtual bool make_States();
public:
   TSituationKernel* LALRStable;
};

// ---------------------------- TLALRkCoreBuilder -----------------------------------
class TLALRkCoreBuilder : public T_LALRCoreBuilder, public TLRkCoreBuilder
{
public:
   TLALRkCoreBuilder(TGrammar* g) :A_LRBuilder(g), T_LALRCoreBuilder(g), TLRkCoreBuilder(g) {}
public:
};

#ifdef CORE_TABLE_BUILDER
// ---------------------------- TLALRkCoreTabBuilder -----------------------------------
class TLALRkCoreTabBuilder : public T_LALRCoreBuilder, public TLRkCoreTabBuilder
{
public:
   TLALRkCoreTabBuilder(TGrammar* g) :A_LRBuilder(g), T_LALRCoreBuilder(g), TLRkCoreTabBuilder(g) {}
public:
};

#endif

// ------------------------------ GrammarSplitting -------------------------------
// Green(v=2,7.4.3)
// Green(v=2,p=104,a=7.12)
class TGGBuilder : public virtual A_LRBuilder, public T_LRBuilderBetaFirstKClosure
{
public:
   TGGBuilder(TGrammarGroup* gr, TGrammar* g) :A_LRBuilder(g), T_LRBuilderBetaFirstKClosure(g), group(gr) {}
   virtual void Init();
   virtual void FirstTailSym(const TPara& para, TFirst& first_beta_a) const;
   virtual void ActionShift(const TPara& para, TFirst& beta) const {}
   virtual void ActionReduce(const TPara& para, TFirstFollow& follow) const {}
public:
   TGrammarGroup* group;
};

// Green(v=2,p=106,a=7.13)
class TGGroupBuilder : public virtual A_LRBuilder
{
public:
   TGGroupBuilder(TGrammarGroup* gr) :A_LRBuilder(gr->general), derivation(gr->general), group(gr) { group->derivation = &derivation; }
   virtual void Init();
   virtual void Closure(const TPara& para, TFirst& beta) const {};
   virtual void ActionShift(const TPara& para, TFirst& beta) const {}
   virtual void ActionReduce(const TPara& para, TFirstFollow& follow) const {}
   virtual TParaSet* CLOSURE(const TParaSet& I);
   virtual TParaSet* GOTO(const TParaSet& I, const GSymbol& X);
public:
   TDerivation derivation;
   TGrammarGroup* group;
};

#endif#include "stdafx.h"
#include "maker.h"
#include "TSemantic.h"

// --------------------------- GMaker ---------------------------
GMakerTable GMakerTable::maker_table;

GMaker::GMaker(const char* t, GMakerTable* table) 
   :make_tree(NULL), make_code(NULL), make_yacc(NULL), title(t), used(0)
{
   int index = table->Find(t);
   if (index >= 0) {
   } else {
      table->Add(*this);
   }
}

GMaker::GMaker(bool (*f)(const GSymbol&, M_Syntax*), const char* t, GMakerTable* table) 
   :make_tree(f), make_code(NULL), make_yacc(NULL), title(t), used(0) 
{
   int index = table->Find(t);
   if (index >= 0) {
      GMaker* maker = (*table)[index];
      maker->make_tree = f;
   } else {
      table->Add(*this);
   }
}

GMaker::GMaker(bool (*f)(const GSymbol&, MC_Syntax*, TSemantic*), const char* t, GMakerTable* table) 
   :make_tree(NULL), make_code(f), make_yacc(NULL), title(t), used(0) 
{
   int index = table->Find(t);
   if (index >= 0) {
      GMaker* maker = (*table)[index];
      maker->make_code = f;
   } else {
      table->Add(*this);
   }
}

GMaker::GMaker(bool (*f)(const GSymbol&, M_Syntax*, T_Lexeme_SNode*[]), const char* t, GMakerTable* table) 
   :make_tree(NULL), make_code(NULL), make_yacc(f), title(t), used(0) 
{
   int index = table->Find(t);
   if (index >= 0) {
      GMaker* maker = (*table)[index];
      maker->make_yacc = f;
   } else {
      table->Add(*this);
   }
}

void GMaker::print(FILE* file, int print_mode) const
{
   if (!(print_mode & T_PrintMode::pmMakerCompact)) {
   	fprintf(file,"\n%-25s:", title);
      if (make_tree) fprintf(file," tree"); else fprintf(file,"     ");
      if (make_code) fprintf(file," code"); else fprintf(file,"     ");
      if (make_yacc) fprintf(file," yacc"); else fprintf(file,"     ");
      fprintf(file, " %d", used);
   } else {
   	fprintf(file,"%s", title);
   }
}

GMakerTable::~GMakerTable()
{
   Clear();
}

void GMakerTable::Clear()
{
   indexs.clear();
   clear();
}

void GMakerTable::Add(GMaker& m) 
{ 
   const std::pair<const Key, int> item(Key(m.title),count());
   push_back(&m);
   indexs.insert(item); 
}
int  GMakerTable::Find(const char* k) const
{
   TMakerIndex::const_iterator ip = indexs.find(k); 
   if (ip != indexs.end()) {
      const std::pair<const Key, int> item = (*ip);
      return item.second;
   } else {
      return -1;
   }
}

void GMakerTable::print(const char* file_name, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   fprintf(file,"\n--- MakerTable --- <%d> ---\n", count());
   if (print_mode == T_PrintMode::pmMakerNone) return;
   for (const GMaker* maker : *this) {
      maker->print(file, print_mode);
   } 
   if (file_name) {
      fclose(file);
   }
}

const char* maker_title(int maker)
{
   if ((maker < 0) || (maker >= GMakerTable::maker_table.count())) return "unknown_maker";
   return GMakerTable::maker_table[maker]->title;
}

// --------------------------- TStackRule ---------------------------
void TStackRuleItem::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   sym.print(grammar, print_mode);
   lexeme_node.lexeme;
   if (lexeme_node.node) lexeme_node.node->print(0, file);
   if (lexeme_node.tree) lexeme_node.tree->TNode::print(0, file);
   if (lexeme_node.unit) lexeme_node.unit->print(grammar, 0, file);
}

void TStackRule::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   fprintf(file, "\n");
   int index = (int)size() - 1;
   for (const_reverse_iterator r = rbegin(); r < rend(); r++, index--) {
      fprintf(file, "*%05d* ", index);
      r->print(grammar, print_mode, file);
      fprintf(file,"\n");
   }
}

// --------------------------- M_Syntax ---------------------------
M_Syntax::M_Syntax(T_Scan *s) :A_Syntax(s), program(NULL), trunc_node(0), trunc_snode(0), trunc_lexeme(0), tree(NULL) { makers = &GMakerTable::maker_table;}

M_Syntax::~M_Syntax()
{
}

void M_Syntax::ClearProgram() 
{
   if (program) {
      program->clear();
      GarbageCollectorAdd(program, 0x01);
      program = NULL;
   }
   if (tree) {
      tree->clear();
      delete tree;
      tree = NULL;
   }
   if (Auto()) {
      Auto()->clear();
   }
}

void M_Syntax::push_lexeme(const T_Lexeme& lexeme)
{ 
   if ((make_mode != mmTree) && (make_mode != mmCode) && (make_mode != mmTurn)) return;
   bool print_lexeme = (option & T_OptionMode::omPrintOther) != 0, print_stack = (option & T_OptionMode::omPrintStack) != 0;
   if (print_lexeme && print_stack) {
      printf("l<%d ",CountLexemes() + 1); lexeme.print(&Scan()); 
   }
   lexemes.push(lexeme); 
}

void M_Syntax::PushLexeme(const T_Lexeme& lexeme) 
{ 
   if (((lexeme.group == T_Lexeme::T_Group::grPriority) || (lexeme.group == T_Lexeme::T_Group::grIdent) || 
        (lexeme.group == T_Lexeme::T_Group::grInteger)  || (lexeme.group == T_Lexeme::T_Group::grNumber) ||
        (lexeme.group == T_Lexeme::T_Group::grReserv)   && ((lexeme.type == T_Lexeme::W_Type::rwDefine) || (lexeme.type == T_Lexeme::W_Type::rwVoid)))) {
      push_lexeme(forward);
   } else if (lexeme.group == T_Lexeme::T_Group::grOper) {
      push_lexeme(forward);
   } else if ((lexeme.group == T_Lexeme::T_Group::grSyntax) && 
             !((lexeme.type == T_Lexeme::sxEmptyBracket) || (lexeme.type == T_Lexeme::sxEmptyCramp) || (lexeme.type == T_Lexeme::sxEmptyScrape))) {
      push_lexeme(lexeme);
   }
}

T_Lexeme M_Syntax::PopLexeme()
{ 
   T_Lexeme lexeme = lexemes.top(); lexemes.pop(); 
   bool print_lexeme = (option & T_OptionMode::omPrintOther) != 0, print_stack = (option & T_OptionMode::omPrintStack) != 0;
   if (print_lexeme && print_stack) {
      printf("l>%d ",CountLexemes() + 1); lexeme.print(&Scan()); 
   }
   return lexeme; 
}

TNode* M_Syntax::Program() 
{ 
   if (!program && !nodes.empty()) {
      program = PopNode();
      if (!nodes.empty()) printf("\n--- Stack ----\n");
      while (!nodes.empty()) {
         TNode* node = PopNode();
         node->print(0x00);
      }
   }
   return program; 
}

void M_Syntax::Store(T_ScanStore& store)
{
   A_Syntax::Store(store);
   store.store_lexeme = CountLexemes();
   store.store_tree = CountNodes();
   store.store_node = CountSNodes();
}
bool M_Syntax::Restore(const T_ScanStore& store)
{
   TruncLexemes(store.store_lexeme);
   TruncNodes(store.store_tree);
   TruncSNodes(store.store_node);
   return A_Syntax::Restore(store);
}
void M_Syntax::print_store(FILE* file) const
{
   A_Syntax::print_store(file);
   printf("trunc_node=%d, trunc_lexeme=%d, trunc_snode=%d\n", trunc_node, trunc_lexeme, trunc_snode);
}

// --------------------------- MC_Syntax ---------------------------
bool MC_Syntax::Match(T_Lexeme::T_Syntax type)
{
   T_Lexeme lexeme(T_Lexeme::T_Group::grSyntax,type);
   return MatchLexeme(lexeme);
}
bool MC_Syntax::Match(T_Lexeme::T_Group g)
{
   T_Lexeme lexeme(g,0);
   return MatchLexeme(lexeme);
}
bool MC_Syntax::Match(T_Lexeme::T_Group g, T_Symbol::T_Type type)
{
   T_Lexeme lexeme(g,type);
   return MatchLexeme(lexeme);
}
bool MC_Syntax::Match(A_Symbol::T_Priority priority)
{
   T_Lexeme lexeme(T_Lexeme::T_Group::grPriority,priority);
   return MatchLexeme(lexeme);
}
bool MC_Syntax::Match(T_Lexeme::W_Type keyword)
{
   T_Lexeme lexeme(T_Lexeme::T_Group::grReserv,keyword);
   return MatchLexeme(lexeme);
}

void MC_Syntax::Store(T_ScanStore& store)
{
   M_Syntax::Store(store);
   store.store_type = CountTypes();
}
bool MC_Syntax::Restore(const T_ScanStore& store)
{
   TruncTypes(store.store_type);
   return M_Syntax::Restore(store);
}
void MC_Syntax::print_store(FILE* file) const
{
   M_Syntax::print_store(file);
   printf("trunc_type=%d\n", trunc_type);
}

bool MC_Syntax::Maker(const GSymbol& sym)
{
   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0), print_stack = (option & T_OptionMode::omPrintStack) != 0; 
   int nodes_before=0, lexemes_before=0, types_before=0, turn_before=CountSNodes();;
   Counts(nodes_before, lexemes_before, types_before); 
   int execs_before  = (int)semantic->ExecStack.size();
   int blocks_before = (int)semantic->BlockTable.size();
   int idents_before = (int)semantic->IdentTable.size();
   GSymbol maker(sym);
   if (maker.maker >= 0) {
      const GMaker& maker_body = *(*makers)[sym.IsMakerTurn() ? (*makers).maker_turn : maker.maker];
      ret = -2;
      if ((make_mode == mmTree) && sym.IsMakerTree()) {
         if (!maker_body.make_tree || !maker_body.make_tree(sym,this)) {
            ret = -1; 
         } else {
            ret = 1; 
         }
      }
      if ((make_mode == mmTurn) && sym.IsMakerTurn()) {
         if (!maker_body.make_tree || !maker_body.make_tree(sym,this)) {
            ret = -1; 
         } else {
            ret = 1; 
         }
      }
      if ((make_mode == mmCode) && sym.IsMakerCode()) {
         if (!maker_body.make_code || !maker_body.make_code(sym,this,semantic)) {
            ret = -1;
         } else {
            ret = 1; 
         }
      }
      if ((ret > -2) && print_maker) {
         static char buffer[20] = {};
         SPRINTF(buffer,"%d",maker.param);
         if (make_mode == mmTurn) {
            printf("Turner[%s,%s",turn_title((SNode::T_Turn)sym.maker),snode_title((SNode::S_Type)sym.point)); printf(",%s]",buffer); 
         } else {
            printf("Maker["); maker_body.print(stdout, T_PrintMode::pmMakerCompact); printf(",%s]",buffer);
         }
      }
   } else {
      if (print_maker) printf("unknown_maker");
      ret = -1; 
   }
   if ((ret > -2) && print_maker) {
      printf(", ret=%d", ret);
      int nodes_after=0, lexemes_after=0, types_after=0, turn_after=CountSNodes(); 
      Counts(nodes_after, lexemes_after, types_after); 
      int execs_after  = (int)semantic->ExecStack.size();
      int blocks_after = (int)semantic->BlockTable.size();
      int idents_after = (int)semantic->IdentTable.size();
      printf(" n=[%d,%d],l=[%d,%d],t=[%d,%d],e=[%d,%d],b=[%d,%d],i=[%d,%d],s=[%d,%d]", 
               nodes_before, nodes_after, lexemes_before, lexemes_after, types_before , types_after , 
               execs_before, execs_after, blocks_before , blocks_after , idents_before, idents_after, turn_before, turn_after);
      printf("\n");
   }
   if (ret == -2) ret = 0;
   return (ret >= 0);
}

bool MC_Syntax::MakerSyntaxNode(const GSymbol& sym, T_Lexeme_SNode* data_stack[], int maker_index)
{
   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0), print_stack = (option & T_OptionMode::omPrintStack) != 0; 
   GSymbol maker(sym);
   int index = (maker_index >= 0) ? GMakerTable::maker_table.maker_node : maker.maker;
   if (index >= 0) {
      const GMaker& maker_body = *(*makers)[index];
      ret = -2;
      if (((make_mode == mmNode) || (make_mode == mmMade)) && (sym.IsMakerYACC() || sym.IsMakerNode())) {
         if (!maker_body.make_yacc || !maker_body.make_yacc(sym,this, data_stack)) {
            ret = -1;
         } else {
            ret = 1; 
         }
      }
   } else {
      ret = -1; 
   }
   if ((ret > -2) && (print_rule || print_maker)) {
      print_symbol(maker,0x00); printf(", ret=%d", ret);
      printf("\n");
   }
   return (ret >= 0);
}

// ------------------------- C_Syntax -------------------------
bool C_Syntax::GenCastable(T_BaseType from, T_BaseType to, int& made)
{
   return semantic->GenCastable(from, to, made);
}
void C_Syntax::AddCode(TNode* code, int counter) { semantic->AddCode(code, counter); }
void C_Syntax::InsCode(TNode* code, int counter) { semantic->AddCode(code, counter); }
int  C_Syntax::made() { return (int)semantic->Code().size(); }
TNode* C_Syntax::GetCommand(int counter) { return semantic->GetCommand(counter); }

bool C_Syntax::UnaryOper(const T_Lexeme &lexeme)
{
   MakeValue();
   TExprStackItem operand = TipTop();
   const TOperProfile* profile = semantic->Oper(lexeme, operand.type);
   if (profile) {
      TExprStackItem result(profile->result, lexeme);
      GenCastable(operand.type, (*profile)[0]);
      semantic->GenCommand(T_Command::command_Oper, profile->oper, 0, result.type);
      Push(result);
      return true;
   } else {
      Push(btUnknown);
      return error_code(erUnknownOper);
   }
}

bool C_Syntax::BinaryOper(const T_Lexeme &lexeme)
{
   MakeValue();
   TExprStackItem right = TipTop();
   MakeValue();
   TExprStackItem left = TipTop();

   const TOperProfile* profile = semantic->Oper(lexeme, left.type, right.type);
   if (profile) {
      TExprStackItem result(profile->result, lexeme);
      GenCastable(right.type, (*profile)[1], right.made);
      GenCastable(left.type, (*profile)[0], left.made);
      //printf("\nleft = (%s->%s), right = (%s->%s)", TBaseType::Title(left.type), TBaseType::Title((*profile)[0]), TBaseType::Title(right.type), TBaseType::Title((*profile)[1])); 
      semantic->GenCommand(T_Command::command_Oper, profile->oper, 0, result.type);
      Push(result);
      return true;
   } else {
      Push(btUnknown);
      return error_code(erUnknownOper);
   }
}

bool C_Syntax::BinaryLogic(const T_Lexeme &lexeme)
{
   bool oper_or = lexeme.Match(T_Symbol::lxOrOr);
   if (!MakeLogic()) return false;
   TExprStackItem right = TipTop();
   if (!MakeLogic()) return false;
   TExprStackItem left = TipTop();
   if (oper_or) {
      semantic->Reference(left.true_label, right.true_label);
      InsCode(left.false_label, left.made);
   } else {
      semantic->Reference(left.false_label, right.false_label);
      InsCode(left.true_label, left.made);
   }
   Push(right);
   return true;
}

bool C_Syntax::MakeLogic()
{
   TExprStackItem& operand = Top();
   if (operand.type != btLogical) {
      if (!GenCastable(operand.type, T_BaseType::btCInt, operand.made)) {
         return error_code(erUnknownCast);
      }
      operand.true_label = new TNodeLabel(semantic); operand.false_label = new TNodeLabel(semantic);
      TNodeGoTo* go_true = new TNodeGoTo(T_GoTo::tgIf, operand.true_label);
      TNodeGoTo* go_false = new TNodeGoTo(T_GoTo::tgGoTo, operand.false_label);
      AddCode(go_true, operand.made); operand.made++;
      AddCode(go_false, operand.made); operand.made++;
      operand.type = btLogical;
   }
   return true;
}

void C_Syntax::MakeValue()
{
   TExprStackItem& operand = Top();
   if (operand.type == btLogical) {
      semantic->MakeValue(operand.true_label, operand.false_label, operand.made);
      operand.type = btCInt;
   }
}

void C_Syntax::GenReturn(bool value)
{
   TNodeDefFunc* func = dynamic_cast<TNodeDefFunc*>(semantic->BlockTable.Block(T_Block::tbFunc));
   T_BaseType base_type = func ? func->BaseType() : T_BaseType::btVoid;
   semantic->ExecStack.Return();
   T_BaseType return_type = T_BaseType::btVoid;
   if (value) {
      return_type = PopType();
      if (!semantic->GenCastable(return_type, base_type)) {
         error_code(erUnknownCast);
      }
   } else {
      if ((base_type != T_BaseType::btVoid) && (base_type != T_BaseType::btUnknown)) {
         error_code(erNoValue);
      }
   }
   semantic->GenCommand(T_Command::command_Return, 0, base_type);
}

bool C_Syntax::GenBreakContinue(T_Block rate, const T_Lexeme &lexeme)
{
   TNodeBreakContinue *statement = new TNodeBreakContinue(rate, lexeme);
   statement->FindLabel(*semantic);
   if (statement->del_count) semantic->GenPop(statement->del_count);
   semantic->AddCode(statement);
   return true;
}

void C_Syntax::GenGoTo(const T_Lexeme &lexeme)
{
   TNodeUserGoTo *statement = new TNodeUserGoTo(lexeme);
   semantic->MakeGoToLabel(statement);
   semantic->UserGoToTable.Add(statement);
   semantic->GenPop(-1);
   semantic->AddCode(statement);
   semantic->ExecStack.GoTo();
}

// --------------------------- MAKER_TREE_CODE_YACC ---------------------------
void MakeDefType(T_Lexeme& l, int def)
{
   def <<= 16; // GRAMMAR_NLL ||  GRAMMAR_NLR
   if (l.group == T_Lexeme::T_Group::grReserv) {
      l.value = def | l.type;
      l.group = T_Lexeme::T_Group::grSyntax; l.type = T_Lexeme::T_Syntax::sxDefType;
   }
   else if ((l.group == T_Lexeme::T_Group::grSyntax) && (l.type == T_Lexeme::T_Syntax::sxDefType)) {
      l.value |= def;
   }
}

#define MAKER_TREE(FUNC) \
bool make_tree_##FUNC(const GSymbol& item, M_Syntax* syntax);\
static GMaker maker_tree_##FUNC(make_tree_##FUNC,#FUNC, &GMakerTable::maker_table);\
bool make_tree_##FUNC(const GSymbol& item, M_Syntax* syntax)                   

#define MAKER_CODE(FUNC) \
bool make_code_##FUNC(const GSymbol& item, MC_Syntax* syntax, TSemantic* semantic);\
static GMaker maker_code_##FUNC(make_code_##FUNC,#FUNC, &GMakerTable::maker_table);\
bool make_code_##FUNC(const GSymbol& item, MC_Syntax* syntax, TSemantic* semantic)                   

#define MAKER_YACC(FUNC) \
bool make_yacc_##FUNC(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[]);\
static GMaker maker_yacc_##FUNC(make_yacc_##FUNC,#FUNC, &GMakerTable::maker_table);\
bool make_yacc_##FUNC(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[])                   

#define VARIABLES(NODE) if (NODE && (syntax->data->semantic->IsStack() || syntax->data->semantic->IsDirect())) NODE->Variables(*(syntax->data->semantic), 0x00);

#include "MakerYACC.cpp"
#include "MakerTree.cpp"
#include "MakerCode.cpp"

MAKER_TREE(MakerTurn)
{
   T_Lexeme lexeme;
   SNode::T_Turn command = (SNode::T_Turn)item.maker;
   int param = item. MakerParam();

   switch (command) {
   case SNode::ttNone :
      if (!syntax->SEmpty()) {
         SNode* node = syntax->SPop();
         syntax->Tree(node);
      }
      break;
   case SNode::ttPush : 
      if (!syntax->CountLexemes()) return false; lexeme = syntax->PopLexeme();
   case SNode::ttPut : {
      SNode* node = new SNodeList(lexeme,SNode::S_Type(item.point));
      node->option = param;
      syntax->SPush(node);
      } break;
   case SNode::ttAdd  : {
      if (syntax->SEmpty()) return false;
      if (!syntax->CountLexemes()) return false; lexeme = syntax->PopLexeme();
      SNode* node = new SNodeList(lexeme,SNode::S_Type(item.point));
      node->option = param;
      syntax->STop().Add(node);
      } break;
   case SNode::ttMake : {
      if (param < 0) {
         if (!syntax->CountLexemes()) return false; lexeme = syntax->PopLexeme();
      }
      SNodeList* master = new SNodeList(lexeme,SNode::S_Type(item.point));
      master->option = param;
      int count = abs(param);
      while (count--) {
         if (syntax->SEmpty()) return false;
         SNode* node = syntax->SPop();
         master->Insert(0,node);
      }
      syntax->SPush(master);
      } break;
   case SNode::ttDown : {
      if (syntax->SEmpty()) return false;
      SNode* node = syntax->SPop();
      if (syntax->SEmpty()) return false;
      syntax->STop().Add(node);
      } break;
   case SNode::ttUp : {
      if (syntax->SEmpty()) return false;
      SNode* node_1 = syntax->SPop();
      if (syntax->SEmpty()) return false;
      SNode* node_2 = syntax->SPop();
      node_1->Add(node_2);
      syntax->SPush(node_1);
      } break;
   case SNode::ttSwap : {
      if (syntax->SEmpty()) return false;
      SNode* node_1 = syntax->SPop();
      if (syntax->SEmpty()) return false;
      SNode* node_2 = syntax->SPop();
      syntax->SPush(node_1);
      syntax->SPush(node_2);
      } break;
   case SNode::ttCommand : {
      if (item.point == SNode::stLexeme) {
         if (!syntax->CountLexemes()) return false; 
         lexeme = syntax->PopLexeme();
      } else if (item.point == SNode::stParam) {
         if (syntax->SEmpty()) return false;
         syntax->STop().option = param;
      }
      } break;
   }
   return true;
}

MAKER_TREE(SimpleLexeme)
{
   return true;
}

MAKER_TREE(LexTypeName)
{
   int command = item.MakerParam();
   return syntax->Command(command);
}

MAKER_YACC(Expressions)
{
   return make_yacc_ExpressionS(item, syntax, data_stack);
}

static int i__node = GMakerTable::maker_table.maker_node = GMakerTable::maker_table.Find("MakerSNode");
static int i__turn = GMakerTable::maker_table.maker_turn = GMakerTable::maker_table.Find("MakerTurn");
#ifndef TRN_MAKER_H
#define TRN_MAKER_H

#include "Parse.h"
#include "RSyntax.h"
#include "CSyntax.h"
#include "SNodes.h"
 
class GSyntax;

// --------------------------- GMaker ---------------------------
class GMaker
{
public:
   GMaker(const char* t, GMakerTable* table);
   GMaker(bool (*f)(const GSymbol&, M_Syntax*), const char* t, GMakerTable* table);
   GMaker(bool (*f)(const GSymbol&, MC_Syntax*, TSemantic*), const char* t, GMakerTable* table);
   GMaker(bool (*y)(const GSymbol&, M_Syntax*, T_Lexeme_SNode*[]), const char* t, GMakerTable* table);
public:
   bool (*make_tree)(const GSymbol& item, M_Syntax* syntax);
   bool (*make_code)(const GSymbol& item, MC_Syntax* syntax, TSemantic* semantic);
   bool (*make_yacc)(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[]);
public:
   const char* title;
   void print(FILE* file, int print_mode = 0x00) const;
public:
   mutable int used;
};

class GMakerTable : public std::vector<GMaker*>
{
public:
   GMakerTable() :maker_node(-1), maker_turn(-1) {}
   ~GMakerTable();
public:
   void Add(GMaker& m);
   int  Find(const char* k) const;
   int  count() const { return (int)size(); }
   void print(const char* file_name = NULL, int print_mode = 0x00) const;
   void YACC(FILE* file, int print_mode = 0x00) const;
   void Clear();
protected:
   struct Key {
      Key(const char* k) :key(k) {}
      const char* key;
      bool operator == (const Key& k) const { return strcmp(key,k.key) == 0; }
      bool operator <  (const Key& k) const { return strcmp(key,k.key) <  0; }
   };
   class TMakerIndex : public std::map<const Key, int> {
   } indexs;
public:
   int maker_node, maker_turn;
public:
   static GMakerTable maker_table;
};

#define SYNTREE_SHIFT 6 
#define SYNTREE_MASK  0x3F 

void tree_syn(int s, int &s1, int &s2, int &s3, int &s4, int &s5); 

#endif

// --------------------- Codes ---------------------

MAKER_CODE(SaveLexeme)
{
   T_Lexeme::T_Group group = T_Lexeme::T_Group(item.MakerParam() >> 16);
   int type = item.MakerParam() & 0x0000FFFF;
   T_Lexeme lexeme(group,type);
   syntax->push_lexeme(lexeme);
   return true;
}

MAKER_CODE(Compaund)
{
   TNodeStatements *statements = new TNodeStatements();
   semantic->BlockBegin(statements);
   semantic->ExecStack.Push();
   return true;
}

MAKER_CODE(BegStmExpr)
{
   TNodeStatements *statements = new TNodeStatements();
   semantic->BlockBegin(statements);
   semantic->ExecStack.Push();
   return true;
}

MAKER_CODE(EndBlock)
{
   semantic->BlockEnd(NULL,true);
   if (semantic->ExecStack.size() > 1) {
      semantic->ExecStack.Down();
   } else {
      semantic->ExecStack.Pop();
   }
   return true;
}

MAKER_CODE(Part)
{
   T_Part param = (T_Part)item.MakerParam();
   TExprStackItem part(param);
   syntax->Push(part);
   return true;
}

MAKER_CODE(PopType)
{
   syntax->Pop();
   return true;
}

MAKER_CODE(Expressions)
{
   if (!syntax->LRMaker()) {
// stack: part, assign
      TExprStackItem assign = syntax->TipTop();
      assign.param = 1;
// stack: part
      TExprStackItem part = syntax->TipTop();
      assign.part = part.part;
      syntax->PushWithoutMade(assign);
   } else {
// stack: assign
      syntax->Top().param = 1;
   }
   return true;
}

MAKER_CODE(AddToExpr)
{
// stack: expr..., assign
   TExprStackItem assign = syntax->TipTop();
   assign.param = syntax->Top().param + 1;
   assign.part = syntax->Top().part;
   syntax->PushWithoutMade(assign);
   return true;
}

MAKER_CODE(ExpressionS)
{
   T_Part part;
   if (!syntax->LRMaker()) {
      part = syntax->Top().part;
   } else {
      part = (T_Part)item.MakerParam();
   }
   int count = syntax->Top().param;
   bool pop = false;
   if (!(part & T_Part::psValueList)) {
      TExprStackItem last_expr = syntax->Top();
      for (int i = count - 1; i >= 0; i-- ) {
   	   TExprStackItem& expr = syntax->Top(); 
         bool last = (i == (count - 1)), condition = last && (part & psIfGoTo), value = (part & psValueList) || last && (part & psValue);
         if (!last) { // !last
            if (expr.type == btLogical) {
               syntax->AddCode(expr.false_label,expr.made++); syntax->AddCode(expr.true_label,expr.made++);
            } else if (expr.value()) {
               semantic->GenPop(1,expr.made++);
            }
            syntax->Pop(); // expr
         } else if (part != psNone) { // last && !primary
            pop = !value && !condition;
            if ((part & psIfGoTo)) { 
               if (!syntax->MakeLogic()) return false;
            } else if (part & psValue) {
               syntax->MakeValue();
               if (!syntax->Top().value()) return false;
            } else {
               if (syntax->Top().value()) {
                  semantic->GenPop(1,syntax->Top().made++);
                  syntax->Top().type = btVoid;
               }
            }
            last_expr = syntax->TipTop();
         } else { // last && primary
            syntax->Pop(); // expr
         }
      }
      if (!pop) syntax->Push(last_expr);
   }
   return true;
}

MAKER_CODE(BegQuestion)
{
   T_Lexeme lexeme = syntax->PopLexeme();
// stack: logic
   if (!syntax->MakeLogic()) return false;
   TExprStackItem& logic = syntax->Top();
   syntax->AddCode(logic.true_label);
   return true;
}

MAKER_CODE(MidQuestion)
{
// stack: logic, left
   TExprStackItem  left  = syntax->TipTop(); 
// stack: logic
   TExprStackItem& logic = syntax->Top(); 
   TNodeLabel *label_end = new TNodeLabel(semantic);
   logic.true_label = label_end;
   TNodeGoTo* go_then = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
   syntax->AddCode(go_then);
   syntax->AddCode(logic.false_label);
   syntax->PushWithoutMade(left); // made == old, before (goto, label)
// stack: logic, left
   return true;
}

MAKER_CODE(Question)
{
// stack: logic, left, righ
   syntax->MakeValue();
   TExprStackItem right = syntax->TipTop(); 
// stack: logic, left
   syntax->MakeValue();
   TExprStackItem left  = syntax->TipTop(); 
// stack: logic
   TExprStackItem logic = syntax->TipTop(); 
// stack: 
   TNodeLabel *label_end = logic.true_label;
   T_BaseType result = CastableBetween(left.type,right.type);
	if (result == btUnknown) { return syntax->error(erUnknownCast); }
   syntax->GenCastable(right.type,result,right.made);
   syntax->GenCastable(left .type,result,left .made);
   syntax->AddCode(label_end);
   syntax->Push(result); // +made
// stack: result
   return true;
}

MAKER_CODE(Binary)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   if (lexeme.Match(T_Symbol::prOrOr) || lexeme.Match(T_Symbol::prAndAnd)) {
      if (!syntax->BinaryLogic(lexeme)) return false;
   } else {
      if (!syntax->BinaryOper(lexeme)) return false;
   }
   return true;
}

MAKER_CODE(Number)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   semantic->GenNumber(lexeme); 
   T_BaseType base_type = (lexeme.group == lexeme.grInteger) ? btCInt : ((lexeme.group == lexeme.grNumber) ? btCDouble : btUnknown);
   syntax->Push(TExprStackItem(base_type, lexeme));
   return true;
}

MAKER_CODE(Ident)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TNodeDefVar *def_var = semantic->FindIdent(lexeme); 
   if (!def_var) { return syntax->error(erUnknownIdent,lexeme); }
   if (def_var->uninitialized) { return syntax->error(erUninitialized,lexeme); }
   semantic->GenCommand(T_Command::command_PushVar,def_var->offset,def_var->alloc,def_var->BaseType()); 
   syntax->Push(def_var->BaseType());
   return true;
}

MAKER_CODE(BegIndex)
{
   if (syntax->LRMaker()) {
      syntax->Top().param = 1;
// stack: range_1
   } else {
      TExprStackItem pseudo_range; pseudo_range.param = -1;
      syntax->Push(pseudo_range);
// stack: pseudo_range_1
   }
   return true;
}

MAKER_CODE(Index)
{
   TExprStackItem range = syntax->TipTop();
   if (syntax->LRMaker()) {
      range.param = syntax->Top().param + 1; 
   } else {
      TExprStackItem prev_range = syntax->TipTop();
      if (prev_range.param > -1) {
         range.param = prev_range.param + 1;
         syntax->PushWithoutMade(prev_range);
      } else {
         range.param = 1;
      } 
   }
   syntax->PushWithoutMade(range);
   return true;
}

MAKER_CODE(EndIndex)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TNodeDefVar* def = semantic->FindIdent(lexeme);
   if (def) {
      TNodeDefArr *def_arr = dynamic_cast<TNodeDefArr*> (def);
      if (def_arr) {
         int count = syntax->Top().param;
         if (count == def_arr->ranges.size()) {
            for (int i = 0; i < count; i++) {
               TExprStackItem range = syntax->TipTop();  // cast -> const int
            }
            semantic->GenCommand(T_Command::command_PushArr,def_arr->offset,def_arr->alloc,def_arr->BaseType()); 
            syntax->Push(def_arr->BaseType());
         } else {
            return syntax->error(erInvalidType,lexeme);
         }
      } else {
         return syntax->error(erInvalidType,lexeme);
      }
   } else {
      return syntax->error(erUnknownIdent,lexeme);
   }
   return true;
}

MAKER_CODE(Params)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TFuncProfile profile; profile.ident = lexeme; // IdentFunc
   std::vector<TExprStackItem> items;
   int count = 0;
   if (item.MakerParam()) {  // (params)
      count = syntax->Top().param;
      for (int i = 0; i < count; i++) {
   	   TExprStackItem expr = syntax->TipTop();
         T_BaseType param_type = expr.type;
         profile.Add(param_type);
         items.push_back(expr); 
      }
   }
   TNodeDefFunc* func = semantic->FuncTable.Find(profile);
   if (func) {
      if (item.MakerParam()) {  // (params)
         for (int i = count - 1; i >= 0; i--) {
      	   TExprStackItem& expr = items[count - 1 - i];
            semantic->GenCastable(profile[i], (*func->profile)[i], expr.made);
         }
      }
      profile.result = func->profile->result;
		int number = func->number;
      semantic->GenCommand(T_Command::command_Call,number,0,profile.result); 
      syntax->Push(profile.result);
      return true;
   } else {
      return syntax->error(erUnknownFunc,lexeme);
   }
   return true;
}

MAKER_CODE(Unary)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   syntax->ChangeUnary(lexeme,true);
   TExprStackItem& operand = syntax->Top();
   if ((operand.type == btLogical) && lexeme.Match(T_Symbol::lxNot)) {
      TNodeLabel *label = operand.true_label; operand.true_label = operand.false_label; operand.false_label = label;
   } else {
      if (!syntax->UnaryOper(lexeme)) return false;
   }
   return true;
}

MAKER_CODE(IncDec)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   syntax->ChangeUnary(lexeme,false);
   if (!syntax->UnaryOper(lexeme)) return false;
   return true;
}

MAKER_CODE(Cast)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   syntax->MakeValue();
   const TNodeType *type = TBaseType::BaseType(lexeme,0); // !owner - clear
   if (!syntax->GenCastable(syntax->Top().type,type->BaseType())) return syntax->error(erUnknownCast);
   syntax->Top().type = type->BaseType();
   return true;
}

MAKER_CODE(NodeNull)
{
   syntax->Push(T_BaseType::btVoid);
   return true;
}

MAKER_CODE(Return)
{
   bool value = false;
   if (item.MakerParam() != 0x00) {
      value = true;
   }
   syntax->GenReturn(value);
   return true;
}

MAKER_CODE(Continue)
{
   return syntax->GenBreakContinue(T_Block::tbContinue,syntax->forward);
}

MAKER_CODE(Break)
{
   return syntax->GenBreakContinue(T_Block::tbBreak,syntax->forward);
}

MAKER_CODE(GoTo)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   syntax->GenGoTo(lexeme); // ident
   return true;
}

MAKER_CODE(Label)
{
   T_Lexeme lexeme = syntax->PopLexeme();
	TNodeUserLabel* label = new TNodeUserLabel(lexeme);
   semantic->MakeGoToLabel(label);
   semantic->UserLabelTable.Add(label);
   semantic->ExecStack.Label();
   syntax->AddCode(label);
   return true;
}

// block_labels -> (_one_, do); (_break_, end); (_continue_, while); 
MAKER_CODE(BegDo)
{
   TNodeDo *cycle = new TNodeDo();
   semantic->BlockBegin(cycle);
   TBlock& block_labels = *semantic->Block();

   TNodeLabel *label_do = new TNodeLabel(semantic), *label_while = new TNodeLabel(semantic), *label_end = new TNodeLabel(semantic);
   syntax->AddCode(label_do);
   semantic->ExecStack.Push();
   block_labels.break_label = label_end; block_labels.continue_label = label_while;
   block_labels.one_label = label_do;
   return true;
}

MAKER_CODE(MidDo)
{
   TBlock& block_labels = *semantic->Block();
   TNodeLabel *&label_while = block_labels.continue_label;
   semantic->ExecStack.Down();

   syntax->AddCode(label_while);
   return true;
}

MAKER_CODE(Do)
{
   TBlock& block_labels = *semantic->Block();
   TNodeLabel *&label_end = block_labels.break_label;
   TNodeLabel *&label_do = block_labels.one_label;
   TExprStackItem logic = syntax->TipTop();
   semantic->Reference(logic.true_label,label_do);
   semantic->Reference(logic.false_label,label_end);

   syntax->AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   return true;
}

// block_labels -> (_break_, end); (_continue_, while); 
MAKER_CODE(BegWhile)
{
   TNodeWhile *cycle = new TNodeWhile();
   semantic->BlockBegin(cycle);
   TNodeLabel *label_while = new TNodeLabel(semantic);
   syntax->AddCode(label_while);
   TBlock& block_labels = *semantic->Block();
   block_labels.continue_label = label_while;
   return true;
}

MAKER_CODE(MidWhile)
{
   TExprStackItem logic = syntax->TipTop(); 
   TNodeLabel *label_body = logic.true_label, *label_end = logic.false_label;
   TBlock& block_labels = *semantic->Block();

   semantic->ExecStack.Push();
   block_labels.break_label = label_end;
   syntax->AddCode(label_body);
   return true;
}

MAKER_CODE(While)
{
   TBlock& block_labels = *semantic->Block();
   TNodeLabel *&label_end   = block_labels.break_label;
   TNodeLabel *&label_while = block_labels.continue_label;
   semantic->ExecStack.Down();
   
   TNodeGoTo* go_cycle = new TNodeGoTo(T_GoTo::tgGoTo,label_while);
   syntax->AddCode(go_cycle);
   syntax->AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   return true;
}

// block_labels -> (_one_, end); (_two_, false); 
MAKER_CODE(BegIf)
{
   TNodeIf *statement = new TNodeIf();
   semantic->BlockBegin(statement);
   return true;
}

MAKER_CODE(Then)
{
// stack: logic(true_label,false_label)
   TExprStackItem logic = syntax->TipTop();

   TNodeIf* block = dynamic_cast<TNodeIf*>(semantic->BlockTable.Block());
   block->trunc = block->size;
   semantic->ExecStack.Push();
   syntax->AddCode(logic.true_label);
   block->two_label = logic.false_label;
// stack:
   return true;
}

MAKER_CODE(Else)
{
// stack:
   TNodeIf* block = dynamic_cast<TNodeIf*>(semantic->BlockTable.Block());
   semantic->BlockTrunc(block->trunc);

   block->then_exec = semantic->ExecStack.Pop();
   semantic->ExecStack.Push();

   TNodeLabel *label_end = new TNodeLabel(semantic);
   TNodeGoTo* go_then = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
   syntax->AddCode(go_then);
   syntax->AddCode(block->two_label);
   block->one_label = label_end;
   return true;
}

MAKER_CODE(If)
{
// stack:
   TNodeIf* block = dynamic_cast<TNodeIf*>(semantic->BlockTable.Block());
   TNodeLabel *label_end = NULL;
   int then_exec, else_exec;
   if (item.MakerParam() == 0x00) { // !else

      then_exec = semantic->ExecStack.Pop();
      else_exec = then_exec;
      label_end = new TNodeLabel(semantic);
      TNodeGoTo* go_then = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
      syntax->AddCode(go_then);
      syntax->AddCode(block->two_label);
   } else {
      label_end = block->one_label;
      then_exec = block->then_exec;
      else_exec = semantic->ExecStack.Pop();
   }
   semantic->ExecStack.Up(then_exec & else_exec);

   syntax->AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   return true;
}

// block_labels -> (_one_, body); (_two_, condition); (_break_, end); (_continue_);
MAKER_CODE(BegFor)
{
   TNodeFor *cycle = new TNodeFor();
   semantic->BlockBegin(cycle);
   return true;
}

MAKER_CODE(PrefFor)
{
   TNodeLabel *label_condition = new TNodeLabel(semantic);

   syntax->AddCode(label_condition);
   TBlock& block_labels = *semantic->Block();
   block_labels.two_label = label_condition;
   return true;
}

MAKER_CODE(ConditionFor)
{
// stack: condition
   TExprStackItem logic = syntax->TipTop();
   TBlock& block_labels = *semantic->Block();
   TNodeLabel *label_body, *label_end;
   if (logic.type == btLogical) { // yes condition
      label_body = logic.true_label; label_end = logic.false_label;
   } else {
      label_body = new TNodeLabel(semantic); label_end = new TNodeLabel(semantic);
   }
   block_labels.one_label = label_body;
   block_labels.break_label = label_end;
   TNodeLabel *label_continue = new TNodeLabel(semantic);
   block_labels.continue_label = label_continue;
   syntax->AddCode(label_continue);
// stack: 
   return true;
}

MAKER_CODE(PostFor)
{
// stack: 
   TBlock& block_labels = *semantic->Block();
   TNodeLabel *&label_condition = block_labels.two_label, *&label_body = block_labels.one_label;
   TNodeGoTo* go_cycle = new TNodeGoTo(T_GoTo::tgGoTo,label_condition); 
   syntax->AddCode(go_cycle);

   syntax->AddCode(label_body);
   semantic->ExecStack.Push();
   return true;
}

MAKER_CODE(For)
{
// stack:
   TBlock& block_labels = *semantic->Block();
   TNodeLabel *&label_continue  = block_labels.continue_label;
   TNodeLabel *&label_end       = block_labels.break_label;
   semantic->ExecStack.Down();
   TNodeGoTo* go_continue = new TNodeGoTo(T_GoTo::tgGoTo,label_continue);
   syntax->AddCode(go_continue);

   syntax->AddCode(label_end);
   semantic->BlockEnd(NULL,true);
   return true;
}

MAKER_CODE(DefType)
{
   int type = item.MakerParam();
   if (type & 0x08) syntax->PopLexeme(); // &
   T_Lexeme& l = syntax->TopLexeme();
   MakeDefType(l, type);
   return true;
}

MAKER_CODE(Define)
{
   T_Lexeme lexeme_type, lexeme_ident;
   if (!(syntax->syntax_lexeme & T_Grammar::slSyntax) && !item.MakerParam()) { // NR
      lexeme_ident = syntax->PopLexeme();
      lexeme_type  = syntax->PopLexeme();
      syntax->push_lexeme(lexeme_ident);
   } else {
      lexeme_type = syntax->PopLexeme();
   }
   TNodeType *type = syntax->BaseType(lexeme_type);
   TExprStackItem def(type);
   syntax->Push(def);
   return true;
}

MAKER_CODE(EndDefine)
{
   TExprStackItem define = syntax->TipTop();
   return true;
}

MAKER_CODE(DefArray)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   bool yes_ref = syntax->CountLexemes() && syntax->TopLexeme().Match(T_Symbol::lxAnd);
   if (yes_ref) 
      syntax->PopLexeme();
   TNodeType *type_arr = (TNodeType*)syntax->Top().node;
   if (yes_ref) {
      type_arr = TBaseType::Or(type_arr, T_BaseType::btReference);
   }
   TNodeDefArr *arr = new TNodeDefArr(type_arr,lexeme,NULL);
   semantic->AddDef(arr);
   return true;
}

MAKER_CODE(DRange)
{
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   TDefArrRangeItem range;
   TExprStackItem index = syntax->TipTop();
   if ((index.type == btCInt) && (index.lexeme.group == T_Lexeme::grInteger)) {
      range.range = syntax->Integer(index.lexeme);
   	if (range.range < 1) { syntax->error(erRanges); range.range = -2; }
   } else {
      range.range = -2;
      if (!semantic->GenCastable(index.type, btCInt)) {
         return syntax->error(erUnknownCast);
      }
   }
   range.made = syntax->made();
   arr->ranges.push_back(range);
   return true;
}

MAKER_CODE(DefArrD1AEmpty)
{
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   TDefArrRangeItem range;
   range.range = -1;
   syntax->AddCode(new TNodeCommand(T_Command::command_PushInt,range.range,0,btCInt));
   range.made = syntax->made();
   arr->ranges.push_back(range);
   return true;
}

MAKER_CODE(EndRanges)
{
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   arr->ranges.calc();
   int count = arr->ranges.count();
   semantic->GenCommand(T_Command::command_NewArr,count,arr->alloc,arr->BaseType()); 
   return true;
}

MAKER_CODE(BegAInit)
{
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   if (arr->ranges.variable_range()) { return syntax->error(erInvalidInit); }
   return true;
}

MAKER_CODE(AInitItem)
{
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   if (!arr->ranges.next()) return syntax->error(erInvalidInit);
   syntax->MakeValue();
   TExprStackItem operand = syntax->TipTop();
   if (!semantic->GenCastable(operand.type, TBaseType::Const(arr->BaseType()))) {
      return syntax->error(erUnknownCast);
   }
   semantic->GenCommand(T_Command::command_PushInt,arr->ranges.offset(),0,btCInt);
   semantic->GenCommand(T_Command::command_InitArr,arr->offset,arr->alloc,arr->BaseType()); 
   return true;
}

MAKER_CODE(BegInitial)
{
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   int &level = arr->ranges.level;
   if (item.MakerParam()) { // !empty
      if ((++level) > arr->ranges.count()) return syntax->error(erInvalidInit);
   } else {
      arr->ranges.jump(level);
   }
   return true;
}

MAKER_CODE(EndInitial)
{
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   int &level = arr->ranges.level;
   arr->ranges.jump(--level);
   return true;
}

MAKER_CODE(EndAInit)
{
   T_Lexeme lexeme_assign = syntax->PopLexeme();
   TNodeDefArr *arr = (TNodeDefArr*)semantic->IdentTable.back();
   if (arr->ranges.unknown_range()) {
      arr->ranges[0].range = arr->ranges[0].index;
      if (arr->ranges.count() == 1) arr->ranges[0].range++;
      TNodeCommand* command = (TNodeCommand*)semantic->GetCommand(arr->ranges[0].made - 1);
      command->param = arr->ranges[0].range;
   }
   return true;
}

MAKER_CODE(DefIdent)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   bool yes_ref = syntax->CountLexemes() && syntax->TopLexeme().Match(T_Symbol::lxAnd);
   if (yes_ref) syntax->PopLexeme();
   TNodeType *type_ident = (TNodeType*)syntax->Top().node;
   if (yes_ref) {
      type_ident = TBaseType::Or(type_ident, T_BaseType::btReference);
   }
   TNodeDefVar *var = new TNodeDefVar(type_ident,lexeme);
   semantic->AddDef(var);
   semantic->GenCommand(T_Command::command_NewVar,var->offset,var->alloc,var->BaseType()); 
   return true;
}

MAKER_CODE(BegDefVarAssign)
{
   TNodeDefVar *var = semantic->GetDef();
   if (!var) return false;
   semantic->GenCommand(T_Command::command_PushVar,var->offset,var->alloc,var->BaseType()); 
   var->uninitialized = true;
   syntax->Push(TBaseType::Tilda(var->BaseType(),T_BaseType::btConst));   // left
   return true;
}

MAKER_CODE(DefVarAssign)
{
// stack: var, assign
   TNodeDefVar *var = semantic->GetDef();
   T_Lexeme lexeme_assign = syntax->PopLexeme();
   if (!syntax->BinaryOper(lexeme_assign)) return false;
   semantic->GenPop(1);
   syntax->Pop();
   var->uninitialized = false;
   return true;
}

MAKER_CODE(PushDef)
{
   TNodeDefVar *var = semantic->GetDef();
   semantic->GenCommand(T_Command::command_PushVar,var->offset,var->alloc,var->BaseType()); 
   syntax->Push(var->BaseType());
   if (!syntax->MakeLogic()) return false;
   return true;
}

MAKER_CODE(DefParVar)
{
// lexemes: type, ident
   T_Lexeme lexeme = syntax->PopLexeme();
   T_Lexeme l = syntax->PopLexeme();
   TNodeType *type = syntax->BaseType(l);
   TNodeDefVar *param = new TNodeDefVar(type,lexeme);
   semantic->AddDef(param);
   TNodeDefFunc *function = dynamic_cast<TNodeDefFunc*>(semantic->BlockTable.Block(tbFunc));
   TFuncProfile &profile = *function->profile; 
   profile.Add(param->BaseType());
   return true;
}

MAKER_CODE(DefParArr)
{
// lexemes: type, ident
   T_Lexeme lexeme = syntax->PopLexeme();
   T_Lexeme l = syntax->PopLexeme();
   TNodeType *type = syntax->BaseType(l);
   TNodeDefArr *param = new TNodeDefArr(type,lexeme,NULL);
   semantic->AddDef(param);
   TNodeDefFunc *function = dynamic_cast<TNodeDefFunc*>(semantic->BlockTable.Block(tbFunc));
   TFuncProfile &profile = *function->profile; 
   profile.Add(param->BaseType());
   return true;
}

MAKER_CODE(BegParVarAssign)
{
   TNodeDefVar *var = semantic->GetDef();
   semantic->GenCommand(T_Command::command_PushVar,var->offset,var->alloc,var->BaseType()); 
   var->uninitialized = true;
   syntax->Push(TBaseType::Tilda(var->BaseType(),T_BaseType::btConst));
   return true;
}

MAKER_CODE(ParVarAssign)
{
   T_Lexeme lexeme_assign = syntax->PopLexeme();
   TNodeDefVar *var = semantic->GetDef();
   const T_Lexeme &lexeme = lexeme_assign;
   if (!syntax->BinaryOper(lexeme)) return false;
   semantic->GenPop(1);
   syntax->Pop();
   var->uninitialized = false;
   return true;
}

MAKER_CODE(FuncIdent)
{
// lexemes: type, ident
   T_Lexeme lexeme_ident = syntax->PopLexeme();
   T_Lexeme lexeme_type = syntax->PopLexeme();
   TNodeType *type = syntax->BaseType(lexeme_type);
   TNodeDefFunc *function = new TNodeDefFunc(type,lexeme_ident,NULL,NULL);
//   semantic->AddCode(function);
   TFuncProfile &profile = *(function->profile = new TFuncProfile());
   semantic->BlockBegin(function);
   profile.result = function->BaseType();
   profile.ident = lexeme_ident;
   return true;
}

MAKER_CODE(EndParams)
{
   TNodeDefFunc *function = dynamic_cast<TNodeDefFunc*>(semantic->BlockTable.Block());
   function->SetBody(new TNodeNull());
   semantic->AddFunc(function);
   semantic->ExecStack.Push();
   return true;
}

MAKER_CODE(BodyFunc)
{
   TNodeDefFunc *function = dynamic_cast<TNodeDefFunc*>(semantic->BlockTable.Block());
   if (item.MakerParam() < 0x02) {
      if (item.MakerParam() == 0x01) {
         function->SetBody(new TNodeNull());
      }
      semantic->AddFunc(function);
      semantic->ExecStack.Push();
   }
   int exec_mode = semantic->ExecStack.Pop();
   if (item.MakerParam() > 0x00) {
      if (!(exec_mode & T_ExecMode::meRestituer)) {
         if ((TBaseType::Tilda(function->BaseType(),T_BaseType::btStatic) != T_BaseType::btVoid) && (function->BaseType() != T_BaseType::btUnknown)) {
            return syntax->error_true(erNoReturn);
         }
      }
   
      semantic->UserGoToTable .Verify();
      semantic->UserLabelTable.Verify();
      semantic->UserGoToTable .clear();
      semantic->UserLabelTable.clear();
   
      semantic->GenCommand(T_Command::command_Exit,function->number,0,T_BaseType::btVoid);
   }
   semantic->BlockEnd(NULL);
   return true;
}
// --------------------- Tree ---------------------
MAKER_TREE(SaveLexeme)
{
   T_Lexeme::T_Group group = T_Lexeme::T_Group(item.MakerParam() >> 16);
   int type = item.MakerParam() & 0x0000FFFF;
   T_Lexeme lexeme(group,type);
   syntax->push_lexeme(lexeme);
   return true;
}

MAKER_TREE(Number)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TNodeNumber *number = new TNodeNumber(lexeme);
   syntax->PushNode(number);
   return true;
}

MAKER_TREE(Ident)
{
   T_Lexeme lexeme;   
   const T_Lexeme& top = syntax->TopLexeme();
   bool change = (!top.Match(T_Lexeme::grIdent));
   if (change) {
      lexeme = syntax->PopLexeme();
   }
   T_Lexeme lexeme_ident = syntax->PopLexeme();
   TNodeVar *var = new TNodeVar(lexeme_ident);
   syntax->PushNode(var);
   if (change)  syntax->push_lexeme(lexeme);
   VARIABLES(var);
   return true;
}

MAKER_TREE(Label)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   T_NodeList *compaund = new T_NodeList();
	TNodeUserLabel* label = new TNodeUserLabel(lexeme);
   TNode *node = syntax->PopNode();
   compaund->Add(label);
   compaund->Add(node);
   syntax->PushNode(compaund);
   return true;
}

MAKER_TREE(Params)
{
   T_Lexeme lexeme = syntax->PopLexeme(); // IdentFunc
   T_NodeList *list;
   if (item.MakerParam()) {
      list = (T_NodeList*)syntax->PopNode(); // (params)
   } else {
      list = new T_NodeList(lexeme); // ()
   }
   TNodeCall *call = new TNodeCall(lexeme,list);
   syntax->PushNode(call);
   VARIABLES(call);
   return true;
}

MAKER_TREE(BegIndex)
{
   T_Lexeme lexeme = syntax->PopLexeme(); // IdentArr
   T_NodeList *list = new T_NodeList(lexeme);
   TNodeIndex *index = new TNodeIndex(lexeme,list);
   if (syntax->LRMaker()) {
      TNode *expr = syntax->PopNode();
      list->Add(expr);
      }
   syntax->PushNode(index);
   return true;
}

MAKER_TREE(Index)
{
   TNode *expr = syntax->PopNode();
   TNodeIndex *index = (TNodeIndex*)syntax->TopNode();
   T_NodeList *list = index->Ranges();
   list->Add(expr);
   return true;
}

MAKER_TREE(EndIndex)
{
   if (syntax->data->semantic->IsDirect()) {
      TNodeIndex *index = (TNodeIndex*)syntax->TopNode();
      VARIABLES(index);
   }
   return true;
}

MAKER_TREE(Binary)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TNode *right = syntax->PopNode(), *left = syntax->PopNode();
   TNode *binary;
   if (lexeme.Match(T_Symbol::prOrOr) || lexeme.Match(T_Symbol::prAndAnd)) {
      binary = new TNodeLogical(lexeme, left, right);
   } else {
      binary = new TNodeBinary(lexeme, left, right);
   }
   syntax->PushNode(binary);
   VARIABLES(binary);
   return true;
}

MAKER_TREE(Unary)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   syntax->ChangeUnary(lexeme,true);
   TNode *expr = syntax->PopNode();
   TNodeUnary *unary = new TNodeUnary(lexeme, expr);
   syntax->PushNode(unary);
   VARIABLES(unary);
   return true;
}

MAKER_TREE(IncDec)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   syntax->ChangeUnary(lexeme,false);
   TNode *expr = syntax->PopNode();
   TNodeUnary *unary = new TNodeUnary(lexeme, expr);
   syntax->PushNode(unary);
   return true;
}

MAKER_TREE(Primary) // Tree only
{
   T_Lexeme lexeme;
   TNode *expr = syntax->PopNode();
   TNodePrimary *primary = new TNodePrimary(lexeme, expr);
   syntax->PushNode(primary);
   VARIABLES(primary);
   return true;
}

MAKER_TREE(Cast)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TNode *expr = syntax->PopNode();
   TNodeType *type = syntax->BaseType(lexeme);
   TNodeCast *cast = new TNodeCast(lexeme, type, expr);
   syntax->PushNode(cast);
   VARIABLES(cast);
   return true;
}

MAKER_TREE(Question)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TNode *right = syntax->PopNode(), *left = syntax->PopNode(), *expr = syntax->PopNode();
   TNodeTrio *question = new TNodeTrio(lexeme, expr, left, right);
   syntax->PushNode(question);
   VARIABLES(question);
   return true;
}

MAKER_TREE(Expressions)
{
// stack: assign
   T_Lexeme lexeme;
   TNodeExpressions *expression = new TNodeExpressions(lexeme);
   TNode *expr = syntax->PopNode(); // assign
   expression->Add(expr);
   syntax->PushNode(expression);
// stack: expression
   return true;
}

MAKER_TREE(ExpressionS)
{
// stack: expression
   TNodeExpressions *expression = (TNodeExpressions*)syntax->TopNode();
   expression->part = T_Part(item.MakerParam());
   return true;
}

MAKER_TREE(DefParVar)
{
   T_Lexeme ident_lexeme = syntax->PopLexeme();
   T_Lexeme type_lexeme = syntax->PopLexeme();
   TNodeType *type = syntax->BaseType(type_lexeme);
   TNodeDefVar *param = new TNodeDefVar(type,ident_lexeme);
   syntax->PushNode(param);
   return true;
}

MAKER_TREE(DefParArr)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   T_Lexeme l = syntax->PopLexeme();
   TNodeType *type = syntax->BaseType(l);
   T_NodeList *list_range = new T_NodeList();
   TNodeDefArr *param = new TNodeDefArr(type,lexeme,list_range);
   syntax->PushNode(param);
   return true;
}

MAKER_TREE(ParVarAssign)
{
   T_Lexeme lexeme_assign = syntax->PopLexeme();
   TNode *assign = syntax->PopNode();
   TNodeDefVar *param = (TNodeDefVar*)syntax->TopNode();
   param->SetAssign(assign);
   return true;
}

MAKER_TREE(EndParams)
{
   TNodeDefine *params = (TNodeDefine*)syntax->PopNode();
   TNodeDefFunc *func = (TNodeDefFunc*)syntax->TopNode();
   func->SetParams(params);
   return true;
}

MAKER_TREE(FuncIdent)
{
// lexemes: type, ident
   T_Lexeme lexeme_ident = syntax->PopLexeme();
   T_Lexeme lexeme_type = syntax->PopLexeme();
   TNodeType *type = syntax->BaseType(lexeme_type);
   TNodeDefFunc *func = new TNodeDefFunc(type,lexeme_ident,NULL,NULL);
   syntax->PushNode(func);
   return true;
}

MAKER_TREE(BodyFunc)
{
   if (item.MakerParam()) {
      TNode *body;
      if (item.MakerParam() == 0x02) {
         body = syntax->PopNode();
      } else {
         body = new TNodeStatements();
      }
      TNodeDefFunc *func = (TNodeDefFunc*)syntax->TopNode();
      func->SetBody(body);
   }
   return true;
}

MAKER_TREE(EndAInit)
{
   T_Lexeme lexeme_assign = syntax->PopLexeme();
   T_NodeList *list_init = (T_NodeList*)syntax->PopNode();
   TNodeDefArr *arr = (TNodeDefArr*)syntax->TopNode();
   arr->SetAssign(list_init);
   return true;
}

MAKER_TREE(DefArray)
{
   TNodeDefine *def = (TNodeDefine*)syntax->TopNode(); // top
   TNodeType *type_arr = def->Type();
   T_Lexeme lexeme = syntax->PopLexeme();
   T_NodeList *list_range = new T_NodeList();
   TNodeDefArr *arr = new TNodeDefArr(type_arr,lexeme,list_range);
   syntax->PushNode(arr);
   VARIABLES(arr);
   return true;
}

MAKER_TREE(DRange)
{
   TNode* expr = syntax->PopNode();
   TNodeDefArr *arr = (TNodeDefArr*)syntax->TopNode(); // top
   T_NodeList* range = arr->Range();
   range->Add(expr);
   return true;
}

MAKER_TREE(DefArrD1AEmpty)
{
   syntax->PushNode(new TNodeNull());
   return make_tree_DRange(item, syntax);
}

MAKER_TREE(DefIdent)
{
   TNodeDefine *def = (TNodeDefine*)syntax->TopNode(); // top
   TNodeType *type_ident = def->Type();
   T_Lexeme lexeme = syntax->PopLexeme();
   TNodeDefVar *var = new TNodeDefVar(type_ident,lexeme);
   syntax->PushNode(var);
   if (!lexeme.Match(T_Lexeme::grIdent)) {
      static int i_i = 0; i_i++;
   }
   return true;
}

MAKER_TREE(DefVarAssign)
{
   T_Lexeme lexeme_assign = syntax->PopLexeme();
   TNode* expr = syntax->PopNode();
   TNodeDefVar *var = (TNodeDefVar*)syntax->TopNode();
   var->SetAssign(lexeme_assign,expr);
   return true;
}

MAKER_TREE(PushDef) // Condition
{
// stack: define, def_var
   TNodeDefVar *def_var = (TNodeDefVar*)syntax->PopNode();
   T_NodeList *list = new T_NodeList();
   list->Add(def_var);
   T_Lexeme my_ident = def_var->Lexeme();
	TNodeVar *push_var = new TNodeVar(my_ident);
   list->Add(push_var);
   TNodeDefine *define = (TNodeDefine*)syntax->TopNode();
   define->Add(list);
// stack: define
   return true;
}

MAKER_TREE(RefDef)
{
   T_Lexeme lexeme_ref = syntax->PopLexeme();
   TNodeDefVar *var = (TNodeDefVar*)syntax->TopNode(); // var || arr
   TNodeType* type = var->Type();
   type = TBaseType::Or(type, T_BaseType::btReference);
   var->SetType(type);
   return true;
}

MAKER_TREE(DefType)
{
   int type = item.MakerParam();
   if (type & 0x08) syntax->PopLexeme(); // &
   T_Lexeme& l = syntax->TopLexeme();
   MakeDefType(l, type);
   return true;
}

MAKER_TREE(Define)
{
   if (item.MakerParam() == 0x02) { // DefParams
      TNodeDefine *define = new TNodeDefine();
      syntax->PushNode(define);
      return true;
   }
   T_Lexeme lexeme_type, lexeme_ident;
   bool close = !(syntax->syntax_lexeme & T_Grammar::slSyntax) && !item.MakerParam(); // NR
   if (close) {
      lexeme_ident = syntax->PopLexeme();
      lexeme_type  = syntax->PopLexeme();
      syntax->push_lexeme(lexeme_ident);
   } else {
      lexeme_type = syntax->PopLexeme();
   }
   TNodeType *type = syntax->BaseType(lexeme_type);
   TNodeDefine *define = new TNodeDefine(type);
   syntax->PushNode(define);
   return true;
}

MAKER_TREE(Do)
{
   TNodeDo *cycle = new TNodeDo(syntax->forward);
   TNode* condition = syntax->PopNode();
   cycle->SetCondition(condition);
   TNode* body = syntax->PopNode();
   cycle->SetBody(body);
   syntax->PushNode(cycle);
   VARIABLES(cycle);
   return true;
}

MAKER_TREE(While)
{
   TNodeWhile *cycle = new TNodeWhile(syntax->forward);
   TNode* body = syntax->PopNode();
   cycle->SetBody(body);
   TNode* condition = syntax->PopNode();
   cycle->SetCondition(condition);
   syntax->PushNode(cycle);
   VARIABLES(cycle);
   return true;
}

MAKER_TREE(For)
{
   TNodeFor *cycle = new TNodeFor(syntax->forward);
   TNode* body = syntax->PopNode(); // body
   cycle->SetBody(body);
   TNode* postfix  = syntax->PopNode();// postfix
   cycle->SetEnd(postfix);
   TNode* condition = syntax->PopNode(); // condition
   cycle->SetCondition(condition);
   TNode* prefix = syntax->PopNode(); // prefix
   cycle->SetBeg(prefix);
   syntax->PushNode(cycle);
   VARIABLES(cycle);
   return true;
}

MAKER_TREE(If)
{
   T_Lexeme lexeme;
   TNodeIf *statement = new TNodeIf(lexeme);
   if (item.MakerParam() != 0x00) {
      TNode* else_body = syntax->PopNode();
      statement->SetElse(else_body);
   } else {
      statement->SetElse(new TNodeNull()); 
   }
   TNode* then_body = syntax->PopNode();
   statement->SetThen(then_body);
   TNode* condition = syntax->PopNode();
   statement->SetCondition(condition);
   syntax->PushNode(statement);
   VARIABLES(statement);
   return true;
}

MAKER_TREE(GoTo)
{
   T_Lexeme lexeme = syntax->PopLexeme();
   TNodeUserGoTo *statement = new TNodeUserGoTo(lexeme);
   syntax->PushNode(statement);
   VARIABLES(statement);
   return true;
}

MAKER_TREE(Break)
{
   TNodeBreakContinue *statement = new TNodeBreakContinue(T_Block::tbBreak, syntax->forward);
   syntax->PushNode(statement);
   VARIABLES(statement);
   return true;
}

MAKER_TREE(Continue)
{
   TNodeBreakContinue *statement = new TNodeBreakContinue(T_Block::tbContinue, syntax->forward);
   syntax->PushNode(statement);
   VARIABLES(statement);
   return true;
}

MAKER_TREE(Return)
{
   TNodeReturn *statement = new TNodeReturn(syntax->forward);
   if (item.MakerParam() != 0x00) {
      TNode *expr = syntax->PopNode();
      statement->SetValue(expr);
   }
   syntax->PushNode(statement);
   VARIABLES(statement);
   return true;
}

MAKER_TREE(BegStmExpr)
{
   TNodeStatements *statements = new TNodeStatements();
   if (syntax->LRMaker() && (item.MakerParam() == 0x01)) {
      TNode *node = syntax->PopNode();
      statements->Add(node);
   }
   syntax->PushNode(statements);
   return true;
}

MAKER_TREE(Compaund)
{
   TNodeStatements *statement = new TNodeStatements();
   syntax->PushNode(statement);
   return true;
}

MAKER_TREE(NodeNull)
{
   TNodeNull *null = new TNodeNull();
   syntax->PushNode(null);
   return true;
}

MAKER_TREE(NodeList)
{
   T_NodeList *list = new T_NodeList();
   if (syntax->LRMaker() && (item.MakerParam() != 0x00)) {
      list->Add(syntax->PopNode());
   }
   syntax->PushNode(list);
   return true;
}

MAKER_TREE(AddToList)
{
   TNode *node = syntax->PopNode();
   T_NodeList *list = (T_NodeList*)syntax->TopNode(); // top
   if (!list) return false;
   list->Add(node);
   return true;
}

#undef S0
#undef S1
#undef S2
#undef S3
#undef S4

#define S0 (*data_stack[0])
#define S1 (*data_stack[1])
#define S2 (*data_stack[2])
#define S3 (*data_stack[3])
#define S4 (*data_stack[4])

MAKER_YACC(DefType)
{
   int param = item.MakerParam();
   T_Lexeme_SNode* x;
   switch (param) {
   case 0x01 : x = data_stack[1    ]; break;
   case 0x03 : x = data_stack[1 + 1]; break;
   case 0x05 : x = data_stack[1 + 1]; break;
   case 0x07 : x = data_stack[1 + 2]; break;
   case 0x09 : x = data_stack[1    ]; break;
   case 0x0B : x = data_stack[1 + 1]; break;
   case 0x20 : x = data_stack[1    ]; break;
   case 0x24 : x = data_stack[1 + 1]; break;
   default : 
      x = data_stack[1    ];
      break;
   }
   MakeDefType(x->lexeme, param);
   if (syntax->make_mode == M_Syntax::mmNode) {
      SNode* node = new SNode(x->lexeme,SNode::stType);
      node->option = param;
      S0.node = node;
   } else if (syntax->make_mode == M_Syntax::mmMade) {
      S0.tree = TBaseType::BaseType(x->lexeme, param);
   }
   S0.lexeme = x->lexeme;
   return true;
}

MAKER_YACC(ExpressionS)
{
   if (syntax->make_mode == M_Syntax::mmNode) {
      SNodeList* list = (SNodeList*)S1.node;
      list->option = item.MakerParam();
      S0.node = list;
   } else if (syntax->make_mode == M_Syntax::mmMade) {
      TNodeExpressions* expr = (TNodeExpressions*)S1.tree;
      expr->part = (T_Part)item.MakerParam();
      S0.tree = expr;
   }
return true;
}

MAKER_YACC(AddToList)
{
   if (syntax->make_mode == M_Syntax::mmNode) {
      SNodeList* list = NULL;
      if (item.MakerParam() == 0x05) { // LR
         list = (SNodeList*)S1.node;
         list->Add(S3.node);
         S0.node = list;
      } else if (item.MakerParam() == 0x03) { // LR
         list = (SNodeList*)S1.node;
         list->Add(S2.node);
         S0.node = list;
      } else if (item.MakerParam() == 0x02) { // LL
         list = (SNodeList*)S0.node;
         list->Add(S1.node);
      } else if (item.MakerParam() == 0x06) { // LL
         list = (SNodeList*)S0.node;
         list->Add(S1.node);
         S2.node = list;
      } else if (item.MakerParam() == 0x0A) { // LL
         list = (SNodeList*)S0.node;
         list->Add(S1.node);
         S3.node = list;
      }
   } else if (syntax->make_mode == M_Syntax::mmMade) {
      T_NodeList* list = NULL;
      if (item.MakerParam() == 0x05) { // LR
         list = (T_NodeList*)S1.tree;
         list->Add(S3.tree);
         S0.tree = list;
      } else if (item.MakerParam() == 0x03) { // LR
         list = (T_NodeList*)S1.tree;
         list->Add(S2.tree);
         S0.tree = list;
      } else if (item.MakerParam() == 0x02) { // LL
         list = (T_NodeList*)S0.tree;
         list->Add(S1.tree);
      } else if (item.MakerParam() == 0x06) { // LL
         list = (T_NodeList*)S0.tree;
         list->Add(S1.tree);
         S2.tree = list;
      } else if (item.MakerParam() == 0x0A) { // LL
         list = (T_NodeList*)S0.tree;
         list->Add(S1.tree);
         S3.tree = list;
      }
   }
   return true;
}

void tree_syn(int s, int &s1, int &s2, int &s3, int &s4, int &s5) 
{ 
   s1 = s & SYNTREE_MASK; s >>= SYNTREE_SHIFT;
   s2 = s & SYNTREE_MASK; s >>= SYNTREE_SHIFT;
   s3 = s & SYNTREE_MASK; s >>= SYNTREE_SHIFT;
   s4 = s & SYNTREE_MASK; s >>= SYNTREE_SHIFT;
   s5 = s & SYNTREE_MASK;
}

static T_Lexeme_SNode lexeme_node;
bool make_yacc_LL_SN(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[])
{
   bool print_maker = ((syntax->option & 0x0200) != 0);
   SNode::S_Type type = (SNode::S_Type)item.maker;
   int param = item. MakerParam();
   int s1, s2, s3, s4, s5;
   tree_syn(item.point, s1, s2, s3, s4, s5);
   T_Lexeme_SNode *y1 = &lexeme_node, *y2 = &lexeme_node, *y3 = &lexeme_node, *y4 = &lexeme_node, *y5 = &lexeme_node;
   if (s1) y1 = data_stack[s1];
   if (s2) y2 = data_stack[s2];
   if (s3) y3 = data_stack[s3];
   if (s4) y4 = data_stack[s4];
   if (s5) y5 = data_stack[s5];
   T_Lexeme_SNode *lexeme = &S1;

   SNode* ret = NULL;
   switch (type) {
   case SNode::stNone  :  {
      if (param == 0) { // Copy
         ret = y1->node;
         if (s2) { y2->node = ret; }
      } else if (param == 1) {
         ret = y1->node;
         syntax->Tree(ret);
      } else if (param == 2) { // lexeme
         y1->lexeme = lexeme->lexeme;
      }
      } break;
   case SNode::stLabel : {
      SNode* label = new SNode(lexeme->lexeme,type);
      SNodeList* list = new SNodeList(lexeme_node.lexeme,SNode::stList);
      list->Add(label);
      list->Add(S1.node);
      ret = list;
      } break;
   case SNode::stNull :
   case SNode::stGoTo :
   case SNode::stBreak :
   case SNode::stContinue :
   case SNode::stNumber  :  
   case SNode::stVar   : {
      ret = new SNode(lexeme->lexeme,type);
      } break;
   case SNode::stRefDef  : {
      y1->node->option = 0x08; // reference
      ret = y1->node;
      } break;
   case SNode::stCast  : {
      ret = new SNodeOne(lexeme->lexeme,type,y1->node);
      } break;
   case SNode::stReturn  :
   case SNode::stNodeOne : 
   case SNode::stPrimary  : 
   case SNode::stCall  : 
   case SNode::stIndex  : { 
      ret = new SNodeOne(lexeme->lexeme,type,y1->node);
      ret->option = param;
      } break;
   case SNode::stUnary  : {
      ret = new SNodeOne(lexeme->lexeme,type,y1->node);
      ret->option = param;
      if (param == 1) {
         S0.node = ret;
      }
      } break;
   case SNode::stDo :
   case SNode::stWhile :
   case SNode::stNodeTwo : {
      if (param == 0) {
         ret = new SNodeTwo(lexeme->lexeme,type,y1->node,y2->node);
         S0.node = ret;
      } else if (param == 1) {
      }
      } break; 
   case SNode::stLogical : 
   case SNode::stBinary  : {
      ret = new SNodeTwo(lexeme->lexeme,type,y1->node,y2->node);
      if (s3) { y3->node = ret; }
      S0.node = ret;
      } break;
   case SNode::stTrio  : { // Question
      if (param == 0) {
         ret = new SNodeThree(lexeme->lexeme,type,S0.node,S1.node,NULL);
         S0.node = ret;
      } else if (param == 1) {
         SNodeThree *question = (SNodeThree*)S0.node;
         question->SetRight(S1.node);
      }
      } break;
   case SNode::stFor  : {
      if (param == 0) { // prefix
         ret = new SNodeFour(lexeme_node.lexeme,type,S1.node,NULL,NULL,NULL);
      } else if (param == 1) { // condition
         SNodeFour* four = (SNodeFour*)S0.node;
         four->Add(S1.node);
      } else if (param == 2) { // postfix
         SNodeFour* four = (SNodeFour*)S0.node;
         four->Add(S1.node);
      } else if (param == 3) { // body
         SNodeFour* four = (SNodeFour*)S0.node;
         four->Add(S1.node);
      }
      } break;
   case SNode::stRanges : {
      SNodeList* list;
      if (param == 2) { // create
         list = new SNodeList(lexeme->lexeme,SNode::stList);
         list->Add(y1->node);
      } else if (param == 3) { // add
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      } else if (param == 4) { // insert
         list = (SNodeList*)y2->node;
         list->Insert(0, y3->node);
      } else if (param == 1) { // ins(Null)
         list = (SNodeList*)y2->node;
         list->Insert(0, new SNode(lexeme_node.lexeme,SNode::stNull));
      } else { // Null
         list = new SNodeList(lexeme->lexeme,SNode::stList);
         list->Add(new SNode(lexeme_node.lexeme,SNode::stNull));
      }
      ret = list;
      } break;
   case SNode::stDefArr  : // (Lexeme,Type,Range,Assign), (,l,m,r)
   case SNode::stDefVar  : {
      if (param == 2) {
         SNodeThree* def = (SNodeThree*)y2->node; def->SetRight(y1->node); // (,Node,Assign)
         ret = def;
      } else {
         ret = new SNodeThree(lexeme->lexeme,type,y1->node,y3->node,y2->node); // (Lexeme,Type,Range,Assign)
         S0.node = ret;
      }
      } break;
   case SNode::stDefFunc : {
      if (param == 0) { // Type
         SNode* type_node = new SNode(lexeme->lexeme,SNode::stType);
         SNodeThree* func = new SNodeThree(lexeme_node.lexeme,type,type_node,NULL,NULL);
         S0.node = func;
      } else if (param == 1) { // Ident
         SNodeThree* func = (SNodeThree*)S0.node;
         func->SetLexeme(lexeme->lexeme);
      } else if (param == 2) { // Params
         SNodeThree* func = (SNodeThree*)S0.node;
         func->SetRight(S1.node);
      } else if (param == 3) { // Body
         SNodeThree* func = (SNodeThree*)S0.node;
         func->SetMid(S1.node);
      }
      } break;
   case SNode::stDefine : {
      SNodeList* list = NULL;
      list = new SNodeList(lexeme->lexeme,type);
      if (param == 1) { // DefParams
         list->SetLexeme(T_Lexeme());
         list->Add(S1.node);
      }
      if (s1) { y1->node = list; }
      if (s2) { y2->node = list; }
      ret = list;
      } break;
   case SNode::stIf : {
      if (param == 0) { // condition
         ret = new SNodeThree(lexeme->lexeme,type,y1->node,NULL,NULL);
      } else if (param == 1) { // then
         SNodeThree* beg_if = (SNodeThree*)S0.node;
         beg_if->SetMid(y1->node);
         ret = beg_if;
      } else { // else
         SNodeThree* beg_if = (SNodeThree*)S0.node;
         beg_if->SetRight(y1->node);
         ret = beg_if;
      }
      } break;
   case SNode::stList  : 
   case SNode::stExpressions :  
   case SNode::stStatements  : {
      SNodeList* list;
      list = new SNodeList(lexeme->lexeme,type);
      if (param == 1) {
         list->Add(S1.node);
      }
      if (s1) { y1->node = list; }
      if (s2) { y2->node = list; }
      ret = list;
      } break;
   default : 
      ret = NULL;
      break;
   }
   if (ret && !S0.node) {
      S0.node = ret;
   }
   return true;
}

bool make_yacc_LL_MK(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[])
{
   SNode::S_Type type = (SNode::S_Type)item.maker;
   int param = item.MakerParam();
   int s1, s2, s3, s4, s5;
   tree_syn(item.point, s1, s2, s3, s4, s5);
   T_Lexeme_SNode *y1 = &lexeme_node, *y2 = &lexeme_node, *y3 = &lexeme_node, *y4 = &lexeme_node, *y5 = &lexeme_node;
   if (s1) y1 = data_stack[s1];
   if (s2) y2 = data_stack[s2];
   if (s3) y3 = data_stack[s3];
   if (s4) y4 = data_stack[s4];
   if (s5) y5 = data_stack[s5];
   T_Lexeme_SNode *lexeme = &S1;

   TNode* ret = NULL;
   switch (type) {
   case SNode::stNone: {
      if (param == 0) { // Copy
         ret = y1->tree;
         if (s2) { y2->tree = ret; }
      } else if (param == 1) {
         ret = y1->tree;
         syntax->program = ret;
      } else if (param == 2) { // lexeme
         y1->lexeme = lexeme->lexeme;
      }
      } break;
   case SNode::stNull: {
      ret = new TNodeNull();
      } break;
   case SNode::stNumber: {
      ret = new TNodeNumber(lexeme->lexeme);
      } break;
   case SNode::stVar: {
      ret = new TNodeVar(lexeme->lexeme);
      } break;
   case SNode::stGoTo: {
      ret = new TNodeUserGoTo(lexeme->lexeme);
      } break;
   case SNode::stBreak: {
      ret = new TNodeBreakContinue(T_Block::tbBreak, lexeme->lexeme);
      } break;
   case SNode::stContinue: {
      ret = new TNodeBreakContinue(T_Block::tbContinue, lexeme->lexeme);
      } break;
   case SNode::stLabel: {
      TNodeUserLabel* label = new TNodeUserLabel(lexeme->lexeme);
      T_NodeList* list = new T_NodeList(lexeme_node.lexeme);
      list->Add(label);
      list->Add(S1.tree);
      ret = list;
   } break;
   case SNode::stRefDef: {
      TNodeDefVar *var = (TNodeDefVar*)y1->tree; // var || arr
      TNodeType* type = var->Type();
      if (type) {
         type = TBaseType::Or(type, T_BaseType::btReference);
         var->SetType(type);
      }
      var->referenced = true;
      ret = var;
   } break;
   case SNode::stCast: {
      TNodeType *type = syntax->BaseType(lexeme->lexeme);
      TNodeCast *cast = new TNodeCast(lexeme->lexeme, type, y1->tree);
      ret = cast;
      } break;
   case SNode::stPrimary: {
      ret = new TNodePrimary(lexeme->lexeme, y1->tree);
      } break;
   case SNode::stCall: {
      TNodeCall* call = new TNodeCall(lexeme->lexeme);
      if (y1->tree) call->SetList((T_NodeList*)y1->tree); // params
      ret = call;
      } break;
   case SNode::stIndex: {
      TNodeIndex* index = new TNodeIndex(lexeme->lexeme);
      if (y1->tree) index->SetList((T_NodeList*)y1->tree); // ranges
      ret = index;
      } break;
   case SNode::stReturn: {
      TNodeReturn* retur = new TNodeReturn(lexeme->lexeme);
      if (y1->tree)  retur->SetValue(y1->tree);
      ret = retur;
      } break;
   case SNode::stUnary: {
      if (param) syntax->ChangeUnary(lexeme->lexeme, false);
      ret = new TNodeUnary(lexeme->lexeme, y1->tree);
      if (param) S0.tree = ret;
      } break;
   case SNode::stLogical:
   case SNode::stBinary: {
      if (lexeme->lexeme.Match(T_Symbol::prOrOr) || lexeme->lexeme.Match(T_Symbol::prAndAnd)) {
         ret = new TNodeLogical(lexeme->lexeme, y1->tree, y2->tree);
      } else {
         ret = new TNodeBinary(lexeme->lexeme, y1->tree, y2->tree);
      }
      if (s3) { y3->tree = ret; }
      S0.tree = ret;
      } break;
   case SNode::stWhile: {
      TNodeWhile* statement = new TNodeWhile(lexeme->lexeme);
      if (y1->tree) statement->SetCondition(y1->tree);
      if (y2->tree) statement->SetBody(y2->tree);
      ret = statement;
      S0.tree = ret;
      } break;
   case SNode::stDo: {
      TNodeDo* statement = new TNodeDo(lexeme->lexeme);
      if (y1->tree) statement->SetCondition(y1->tree);
      if (y2->tree) statement->SetBody(y2->tree);
      ret = statement;
      S0.tree = ret;
      } break;
   case SNode::stTrio: { // Question
      if (param == 0) {
         ret = new TNodeTrio(lexeme->lexeme, S0.tree, S1.tree, NULL);
         S0.tree = ret;
      } else if (param == 1) {
         TNodeTrio *question = (TNodeTrio*)S0.tree;
         question->SetRight(S1.tree);
      }
      } break;
   case SNode::stFor: {
      if (param == 0) { // prefix
         TNodeFor* statement = new TNodeFor(lexeme_node.lexeme);
         statement->SetBeg(S1.tree);
         ret = statement;
      } else if (param == 1) { // condition
         TNodeFor* statement = (TNodeFor*)S0.tree;
         statement->SetCondition(S1.tree);
      } else if (param == 2) { // postfix
         TNodeFor* statement = (TNodeFor*)S0.tree;
         statement->SetEnd(S1.tree);
      } else if (param == 3) { // body
         TNodeFor* statement = (TNodeFor*)S0.tree;
         statement->SetBody(S1.tree);
      }
      } break;
   case SNode::stIf: {
      if (param == 0) { // condition
         TNodeIf* statement = new TNodeIf(lexeme->lexeme);
         statement->SetCondition(y1->tree);
         ret = statement;
      } else if (param == 1) { // then
         TNodeIf* statement = (TNodeIf*)S0.tree;
         statement->SetThen(y1->tree);
      } else { // else
         TNodeIf* statement = (TNodeIf*)S0.tree;
         statement->SetElse(y1->tree);
      }
      } break;
   case SNode::stRanges: {
      T_NodeList* list;
      if (param == 2) { // create
         list = new T_NodeList(lexeme->lexeme);
         list->Add(y1->tree);
      } else if (param == 3) { // add
         list = (T_NodeList*)y2->tree;
         list->Add(y3->tree);
      } else if (param == 4) { // insert
         list = (T_NodeList*)y2->node;
         list->Insert(0, y3->tree);
      } else if (param == 1) { // ins(Null)
         list = (T_NodeList*)y2->tree;
         list->Insert(0, new TNodeNull());
      } else { // Null
         list = new T_NodeList(lexeme->lexeme);
         list->Add(new TNodeNull());
      }
      ret = list;
      } break;
   case SNode::stDefVar: {
      TNodeDefVar* def = new TNodeDefVar(lexeme->lexeme); // (Lexeme,Type,,Assign)
      if (y1->tree) def->SetType((TNodeType*)y1->tree);
      if (y2->tree) def->SetAssign(syntax->oper_assign, y2->tree);
      ret = def;
      S0.tree = ret;
      } break;
   case SNode::stDefArr: {
      if (param == 2) {
         TNodeDefArr* def = (TNodeDefArr*)y2->tree; // (,Node,Assign) 
         def->SetAssign(y1->tree);
         ret = def;
      } else {
         TNodeDefArr* def = new TNodeDefArr(lexeme->lexeme, (T_NodeList*)y3->tree); // (Lexeme,Type,Range,Assign)
         if (y1->tree) def->SetType((TNodeType*)y1->tree);
         if (y2->tree) def->SetAssign(y2->tree);
         ret = def;
         S0.tree = ret;
      }
      } break;
   case SNode::stDefFunc: {
      if (param == 0) { // Type
         TNodeType *type_node = syntax->BaseType(lexeme->lexeme);
         TNodeDefFunc* func = new TNodeDefFunc(type_node, lexeme_node.lexeme, NULL, NULL);
         S0.tree = func;
      } else if (param == 1) { // Ident
         TNodeDefFunc* func = (TNodeDefFunc*)S0.tree;
         func->SetLexeme(lexeme->lexeme);
      } else if (param == 2) { // Params
         TNodeDefFunc* func = (TNodeDefFunc*)S0.tree;
         func->SetParams((TNodeDefine*)S1.tree);
      } else if (param == 3) { // Body
         TNodeDefFunc* func = (TNodeDefFunc*)S0.tree;
         func->SetBody(S1.tree);
      }
      } break;
   case SNode::stDefine: {
      TNodeType *type_node = NULL;
      if (!param) { // DefParams
         type_node = syntax->BaseType(lexeme->lexeme);
      }
      TNodeDefine* define = new TNodeDefine(type_node);
      if (param == 1) { // DefParams
         if (s1) define->Add(y1->tree);
      }
      if (s1) { y1->tree = define; }
      if (s2) { y2->tree = define; }
      ret = define;
      } break;
   case SNode::stList: {
      T_NodeList* list;
      list = new T_NodeList(lexeme->lexeme);
      if (param == 1) {
         list->Add(S1.tree);
      }
      if (s1) { y1->tree = list; }
      if (s2) { y2->tree = list; }
      ret = list;
      } break;
   case SNode::stExpressions: {
      T_NodeList* list;
      list = new TNodeExpressions(lexeme->lexeme);
      if (param == 1) {
         list->Add(S1.tree);
      }
      if (s1) { y1->tree = list; }
      if (s2) { y2->tree = list; }
      ret = list;
      } break;
   case SNode::stStatements: {
      T_NodeList* list;
      list = new TNodeStatements();
      if (param == 1) {
         list->Add(S1.tree);
      }
      if (s1) { y1->tree = list; }
      if (s2) { y2->tree = list; }
      ret = list;
      } break;
   default:
      ret = NULL;
      break;
   }
   if (ret && !S0.tree) {
      S0.tree = ret;
   }
   return true;
}

bool make_yacc_LR_SN(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[])
{
   SNode::S_Type type = (SNode::S_Type)item.maker;
   int param = item. MakerParam();
   int s1, s2, s3, s4, s5;
   tree_syn(item.point, s1, s2, s3, s4, s5);
   T_Lexeme_SNode *y1 = &lexeme_node, *y2 = &lexeme_node, *y3 = &lexeme_node, *y4 = &lexeme_node, *y5 = &lexeme_node;
   if (s1) y1 = data_stack[s1];
   if (s2) y2 = data_stack[s2];
   if (s3) y3 = data_stack[s3];
   if (s4) y4 = data_stack[s4];
   if (s5) y5 = data_stack[s5];
   T_Lexeme_SNode *lexeme = y1;
   if (!lexeme) { lexeme = &lexeme_node; }

   SNode* ret = NULL;
   switch (type) {
   case SNode::stNone  :  {
      ret = y1->node;
      if (param) syntax->Tree(ret);
      } break;
   case SNode::stNull :
   case SNode::stGoTo :
   case SNode::stLabel :
   case SNode::stBreak :
   case SNode::stContinue :
   case SNode::stNumber  :  
   case SNode::stVar  :  {
      ret = new SNode(lexeme->lexeme,type);
      } break;
   case SNode::stRefDef  : {
      y2->node->option = 0x08; // reference
      ret = y2->node;
      } break;
   case SNode::stCast  : {
      ret = new SNodeOne(lexeme->lexeme,type,y2->node);
      } break;
   case SNode::stReturn  :
   case SNode::stNodeOne : 
   case SNode::stPrimary  : 
   case SNode::stCall  : 
   case SNode::stIndex  : 
   case SNode::stUnary  : {
      ret = new SNodeOne(lexeme->lexeme,type,y2->node);
      ret->option = param;
      } break;
   case SNode::stDo :
   case SNode::stWhile :
   case SNode::stNodeTwo :
   case SNode::stLogical : 
   case SNode::stBinary  : {
      ret = new SNodeTwo(lexeme->lexeme,type,y2->node,y3->node);
      ret->option = param;
      } break;
   case SNode::stTrio  : {
      ret = new SNodeThree(lexeme->lexeme,type,y2->node,y3->node,y4->node);
      } break;
   case SNode::stFor  : {
      ret = new SNodeFour(lexeme->lexeme,type,y2->node,y3->node,y4->node,y5->node);
      } break;
   case SNode::stRanges : {
      SNodeList* list;
      if (param == 2) { // create
         list = new SNodeList(lexeme->lexeme,SNode::stList);
         list->Add(y2->node);
      } else if (param == 3) { // add
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      } else if (param == 4) { // insert
         list = (SNodeList*)y2->node;
         list->Insert(0, y3->node);
      } else if (param == 1) { // ins(Null)
         list = (SNodeList*)y2->node;
         list->Insert(0, new SNode(lexeme_node.lexeme,SNode::stNull));
      } else { // Null
         list = new SNodeList(lexeme->lexeme,SNode::stList);
         list->Add(new SNode(lexeme_node.lexeme,SNode::stNull));
      }
      ret = list;
      } break;
   case SNode::stDefArr  : // (Lexeme,Type,Range,Assign), (,l,m,r)
   case SNode::stDefVar  : {
      if (param == 2) {
         SNodeThree* def = (SNodeThree*)y2->node; def->SetRight(y3->node); // (,Node,Assign)
         ret = def;
      } else {
         ret = new SNodeThree(lexeme->lexeme,type,y2->node,y4->node,y3->node); // (Lexeme,Type,Range,Assign)
      }
      } break;
   case SNode::stDefFunc : {
      if (param == 0) {
         SNodeThree* func = new SNodeThree(lexeme->lexeme, type, y2->node, NULL, NULL);
         SNodeTwo* par_body = (SNodeTwo*)y3->node;
         SNode* par = par_body->Left(); SNodeOne *body = (SNodeOne*)par_body->Right();
         if (body->option == 1) {
            func->SetMid(new SNodeList(lexeme_node.lexeme, SNode::stStatements));
         } else if (body->option == 2) {
            body->Child()->SetOwner(NULL);
            func->SetMid(body->Child());
         }
         par->SetOwner(NULL);
         func->SetRight(par);
//         par_body->clear();
         ret = func;
      }
      } break;
   case SNode::stDefine : { // ((,Type,First,Tail),1)    ((,Type,First),0)
      SNodeList* list = NULL;
      if (param == 1) {
         list = (SNodeList*)y4->node;
         if (list) {
            list->SetLexeme(y2->lexeme);
            list->type = type;
         }
      } 
      if (!list) {
         T_Lexeme *my_lexeme = y2 ? &y2->lexeme : &lexeme->lexeme;
         list = new SNodeList(*my_lexeme,type);
      }
      if (s3 && y3->node) { list->Insert(0,y3->node); }
      if (s2) list->option = y2->node->option;
//      y2->node->clear();
      ret = list;
      } break;
   case SNode::stIf : {
      if (param) {
         SNodeThree* beg_if = (SNodeThree*)y2->node;
         beg_if->SetRight(y3->node);
         ret = beg_if;
      } else {
         ret = new SNodeThree(lexeme->lexeme,type,y2->node,y3->node,y4->node);
      }
      } break;
   case SNode::stList  : 
   case SNode::stExpressions :  
   case SNode::stCompaund  : 
   case SNode::stStatements  : {
      SNodeList* list;
      if (param) {
         list = (SNodeList*)y3->node; // ((,node,list),1) - add
      } else {
         list = new SNodeList(lexeme->lexeme,type); // ((lexeme,node),0) - create + add
      }
      if (s2 && y2->node) { list->Add(y2->node); }
      ret = list;
      } break;
   default : 
      ret = NULL;
      break;
   }
   S0.node = ret;
   return true;
}

bool make_yacc_LR_MK(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[])
{
   SNode::S_Type type = (SNode::S_Type)item.maker;
   int param = item.MakerParam();
   int s1, s2, s3, s4, s5;
   tree_syn(item.point, s1, s2, s3, s4, s5);
   T_Lexeme_SNode *y1 = &lexeme_node, *y2 = &lexeme_node, *y3 = &lexeme_node, *y4 = &lexeme_node, *y5 = &lexeme_node;
   if (s1) y1 = data_stack[s1];
   if (s2) y2 = data_stack[s2];
   if (s3) y3 = data_stack[s3];
   if (s4) y4 = data_stack[s4];
   if (s5) y5 = data_stack[s5];
   T_Lexeme_SNode *lexeme = y1;
   if (!lexeme) { lexeme = &lexeme_node; }

   TNode* ret = NULL;
   switch (type) {
   case SNode::stNone: {
      ret = y1->tree;
      if (param) syntax->program = ret;
      } break;
   case SNode::stNull: {
      ret = new TNodeNull();
      } break;
   case SNode::stNumber: {
      ret = new TNodeNumber(lexeme->lexeme);
      } break;
   case SNode::stVar: {
      ret = new TNodeVar(lexeme->lexeme);
      VARIABLES(ret);
      } break;
   case SNode::stGoTo: {
      ret = new TNodeUserGoTo(lexeme->lexeme);
      } break;
   case SNode::stBreak: {
      ret = new TNodeBreakContinue(T_Block::tbBreak, lexeme->lexeme);
      } break;
   case SNode::stContinue: {
      ret = new TNodeBreakContinue(T_Block::tbContinue, lexeme->lexeme);
      } break;
   case SNode::stLabel: {
      ret = new TNodeUserLabel(lexeme->lexeme);
      } break;
   case SNode::stRefDef: {
      TNodeDefVar *var = (TNodeDefVar*)y2->tree; // var || arr
      TNodeType* type = var->Type();
      if (type) {
         type = TBaseType::Or(type, T_BaseType::btReference);
         var->SetType(type);
      }
      var->referenced = true;
      ret = var;
      } break;
   case SNode::stCast: {
      TNodeType *type = syntax->BaseType(lexeme->lexeme);
      TNodeCast *cast = new TNodeCast(lexeme->lexeme, type, y2->tree);
      ret = cast;
      VARIABLES(ret);
      } break;
   case SNode::stUnary: {
      if (param) syntax->ChangeUnary(lexeme->lexeme, false);
      ret = new TNodeUnary(lexeme->lexeme, y2->tree);
      VARIABLES(ret);
      } break;
   case SNode::stPrimary: {
      ret = new TNodePrimary(lexeme->lexeme, y2->tree);
      VARIABLES(ret);
      } break;
   case SNode::stCall: {
      TNodeCall* call = new TNodeCall(lexeme->lexeme);
      if (y2->tree) call->SetList((T_NodeList*)y2->tree); // params
      ret = call;
      S_Syntax *g_syntax = dynamic_cast<S_Syntax*> (syntax);
      g_syntax->print_stack();
      VARIABLES(ret);
      } break;
   case SNode::stIndex: {
      TNodeIndex* index = new TNodeIndex(lexeme->lexeme);
      if (y2->tree) index->SetList((T_NodeList*)y2->tree); // ranges
      ret = index;
      VARIABLES(ret);
      } break;
   case SNode::stReturn: {
      TNodeReturn* retur = new TNodeReturn(lexeme->lexeme);
      if (y2->tree)  retur->SetValue(y2->tree);
      ret = retur;
      } break;
   case SNode::stBinary: {
      if (lexeme->lexeme.Match(T_Symbol::prOrOr) || lexeme->lexeme.Match(T_Symbol::prAndAnd)) {
         ret = new TNodeLogical(lexeme->lexeme, y2->tree, y3->tree);
      } else {
         ret = new TNodeBinary(lexeme->lexeme, y2->tree, y3->tree);
      }
      VARIABLES(ret);
      } break;
   case SNode::stNodeOne: {
      TNode* body = y2->tree;
      if (param == 1) body = new TNodeNull(); // 0 - ; 1 - {} 2 - {...}
      ret = body; // Body
      } break;
   case SNode::stNodeTwo: {
      ret = new TNodeBinary(lexeme->lexeme, y2->tree, y3->tree); // Param_Body
      } break;
   case SNode::stLogical: {
      ret = new TNodeLogical(lexeme->lexeme, y2->tree, y3->tree);
      } break;
   case SNode::stWhile: {
      TNodeWhile* statement = new TNodeWhile(lexeme->lexeme);
      if (y2->tree) statement->SetCondition(y2->tree);
      if (y3->tree) statement->SetBody(y3->tree);
      ret = statement;
      } break;
   case SNode::stDo: {
      TNodeDo* statement = new TNodeDo(lexeme->lexeme);
      if (y2->tree) statement->SetCondition(y2->tree);
      if (y3->tree) statement->SetBody(y3->tree);
      ret = statement;
      } break;
   case SNode::stTrio: {
      ret = new TNodeTrio(lexeme->lexeme, y2->tree, y3->tree, y4->tree);
      VARIABLES(ret);
      } break;
   case SNode::stFor: {
      TNodeFor* statement = new TNodeFor(lexeme->lexeme);
      statement->SetBeg(y2->tree);
      statement->SetCondition(y3->tree);
      statement->SetEnd(y4->tree);
      statement->SetBody(y5->tree);
      ret = statement;
      } break;
   case SNode::stIf: {
      TNodeIf* statement;
      if (param) {
         statement = (TNodeIf*)y2->tree;
         statement->SetElse(y3->tree);
      } else {
         statement = new TNodeIf(lexeme->lexeme);
         statement->SetCondition(y2->tree);
         statement->SetThen(y3->tree);
         statement->SetElse(y4->tree);
      }
      ret = statement;
      } break;
   case SNode::stRanges: {
      T_NodeList* list;
      if (param == 2) { // create
         list = new T_NodeList(lexeme->lexeme);
         list->Add(y2->tree);
      } else if (param == 3) { // add
         list = (T_NodeList*)y2->tree;
         list->Add(y3->tree);
      } else if (param == 4) { // insert
         list = (T_NodeList*)y2->tree;
         list->Insert(0, y3->tree);
      } else if (param == 1) { // ins(Null)
         list = (T_NodeList*)y2->tree;
         list->Insert(0, new TNodeNull());
      } else { // Null
         list = new T_NodeList(lexeme->lexeme);
         list->Add(new TNodeNull());
      }
      ret = list;
      } break;
   case SNode::stDefVar: {
      TNodeDefVar* def;
      if (param == 2) {
         def = (TNodeDefVar*)y2->tree; 
         def->SetAssign(syntax->oper_assign, y3->tree, syntax->data->semantic); // (,Node,Assign)
      } else {
         def = new TNodeDefVar(lexeme->lexeme); // (Lexeme,Type,,Assign)
         if (y2->tree) def->SetType((TNodeType*)y2->tree);
         if (!y2->tree && syntax->data->semantic->IsStack()) {
            S_Syntax *g_syntax = dynamic_cast<S_Syntax*> (syntax);
            int index = g_syntax->filled() - 1;
            for (; index >= 0; index--) {
               TStackRuleItem& stack_item = g_syntax->stack_item(index);
               if (TNodeType* node_type = dynamic_cast<TNodeType*> (stack_item.lexeme_node.tree)) {
                  def->SetType(node_type); break;
               }
               if (TNodeDefVar* def_var = dynamic_cast<TNodeDefVar*> (stack_item.lexeme_node.tree)) {
                  def->SetType(def_var->Type()); break;
               }
            }
         }
         if (y3->tree) def->SetAssign(syntax->oper_assign, y3->tree, syntax->data->semantic);
      }
      ret = def;
      } break;
   case SNode::stDefArr: {
      TNodeDefArr* def;
      if (param == 2) {
         def = (TNodeDefArr*)y2->tree; 
         def->SetAssign(y3->tree); // (,Node,Assign)
      } else {
         def = new TNodeDefArr(lexeme->lexeme, (T_NodeList*)y4->tree); // (Lexeme,Range)
         if (y2->tree) def->SetType((TNodeType*)y2->tree);
         if (!y2->tree && syntax->data->semantic->IsStack()) {
            S_Syntax *g_syntax = dynamic_cast<S_Syntax*> (syntax);
            int index = g_syntax->filled() - 1;
            for (; index >= 0; index--) {
               TStackRuleItem& stack_item = g_syntax->stack_item(index);
               if (TNodeType* node_type = dynamic_cast<TNodeType*> (stack_item.lexeme_node.tree)) {
                  def->SetType(node_type); break;
               }
               if (TNodeDefVar* def_var = dynamic_cast<TNodeDefVar*> (stack_item.lexeme_node.tree)) {
                  def->SetType(def_var->Type()); break;
               }
            }
         }
         if (y3->tree) def->SetAssign(syntax->oper_assign, y3->tree);
      }
      ret = def;
      } break;
   case SNode::stDefFunc: {
      TNodeDefFunc* func = NULL;
      if (param == 1) {
      } else if (param == 2) {
      } else {
         func = new TNodeDefFunc(lexeme->lexeme);
         if (y2->tree)  func->SetType((TNodeType*)y2->tree);
         TNodeBinary* par_body = (TNodeBinary*)y3->tree;
         TNodeDefine* par = (TNodeDefine*)par_body->Left();
         TNode *body = par_body->Right();
         if (body) { body->SetOwner(NULL); func->SetMid(body); }
         par->SetOwner(NULL); func->SetRight(par);
         delete par_body;
         ret = func;
         VARIABLES(ret);
      }
      } break;
   case SNode::stExpressions: {
      TNodeExpressions* list;
      if (param) {
         list = (TNodeExpressions*)y3->tree; // ((,node,list),1) - add
      } else {
         list = new TNodeExpressions(); // ((lexeme,node),0) - create + add
      }
      if (s2 && y2->tree) { list->Add(y2->tree); }
      ret = list;
      } break;
   case SNode::stStatements: {
      TNodeStatements* list;
      if (param) {
         list = (TNodeStatements*)y3->tree; // ((,node,list),1) - add
      } else {
         list = new TNodeStatements(); // ((lexeme,node),0) - create + add
      }
      if (s2 && y2->tree) { list->Add(y2->tree); }
      ret = list;
      } break;
   case SNode::stList: {
      T_NodeList* list;
      if (param) {
         list = (T_NodeList*)y3->tree; // ((,node,list),1) - add
      } else {
         list = new T_NodeList(lexeme->lexeme); // ((lexeme,node),0) - create + add
      }
      if (s2 && y2->tree) { list->Add(y2->tree); }
      ret = list;
      } break;
   case SNode::stDefine: { // ((,Type,First,Tail),1)    ((,Type,First),0)
      TNodeDefine* define = NULL;
      if (param == 1) {
         define = (TNodeDefine*)y4->tree;
         if (define) {
            define->SetLexeme(y2->lexeme);
            define->SetType((TNodeType*)y2->tree);
         }
      }
      if (!define) {
         if (s2) {
            TNodeType *define_type = (TNodeType*)y2->tree;
            define = new TNodeDefine(define_type);
         } else {
            define = new TNodeDefine();
         }
      }
      if (s3 && y3->tree) { define->Insert(0, y3->tree); }
      ret = define;
      } break;
   default:
      ret = NULL;
      break;
   }
   S0.tree = ret;
   return true;
}

bool make_yacc_Grammar(const GSymbol& item, M_Syntax* syntax, T_Lexeme_SNode* data_stack[])
{
   SNode::S_Type type = (SNode::S_Type)item.maker;
   int param = item. MakerParam();
   int s1, s2, s3, s4, s5;
   tree_syn(item.point, s1, s2, s3, s4, s5);
   T_Lexeme_SNode *y1 = &lexeme_node, *y2 = &lexeme_node, *y3 = &lexeme_node, *y4 = &lexeme_node, *y5 = &lexeme_node;
   if (s1) y1 = data_stack[s1];
   if (s2) y2 = data_stack[s2];
   if (s3) y3 = data_stack[s3];
   if (s4) y4 = data_stack[s4];
   if (s5) y5 = data_stack[s5];
   T_Lexeme_SNode *lexeme = y1;
   if (!lexeme) { lexeme = &lexeme_node; }

   SNode* ret = NULL;
   switch (type) {
   case SNode::stEnums  : {
      SNodeList* list = NULL;
      if (param == 0) {
         list = new SNodeList(lexeme->lexeme,type);
      } else if (param == 1) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(new SNodeList(y2->lexeme,type));
      } else if (param == 2) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(y2->node);
      } else if (param == 3) {
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      } else if (param == 4) {
         list = (SNodeList*)y2->node;
         list->SetLexeme(lexeme->lexeme);
      } else if (param == 5) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(y2->node);
      } else if (param == 6) {
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      }  else if (param == 7) {
         list = (SNodeList*)y2->node;
      }

      ret = list;
      ret->option = param;
      } break;
   case SNode::stTokens : {
      SNodeList* list;
      if (param == 0) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(new SNodeList(y2->lexeme,type));
      } else if (param == 1) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(y2->node);
      } else if (param == 2) {
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      }

      ret = list;
      ret->option = param;
      } break;
   case SNode::stFormula  : {
      SNodeList* list;
      if (param == 0) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(y2->node);
      } else if (param == 1) {
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      } else if (param == 2) {
         if (y2->node) {
            SNodeList* formula = list = (SNodeList*)y2->node;
            formula->SetLexeme(lexeme->lexeme);
            bool yes_or = false;
            SNodeList* produce = (SNodeList*)formula->front();
            SNodeList::iterator p = produce->begin();
            while (p != produce->end()) {
               if ((*p)->Lexeme().Match(T_Symbol::prOr)) {
                  yes_or = true;
                  formula->Add(new SNodeList(lexeme->lexeme, SNode::stProduce));
                  delete (*p);
                  p = produce->erase(p);
               } else {
                  if (yes_or) {
                     SNode* node = (*p);
                     node->SetOwner(NULL);
                     ((SNodeList*)formula->back())->Add(node);
                     p = produce->erase(p);
                  } else {
                     p++;
                  }
               }
            }
         } else { // :;
            list = new SNodeList(lexeme->lexeme, type);
            list->Add(new SNodeList(lexeme->lexeme, SNode::stProduce));
         }
      } else if (param == 3) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(y2->node);
      } else if (param == 4) {
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      } else if (param == 5) {
         list = new SNodeList(lexeme->lexeme,type);
         if (y2->node) list->Add(y2->node);
         if (y3->node) list->Add(y3->node);
         list->Add(y4->node);
      } else if (param == 6) { // BNF
         list = new SNodeList(lexeme->lexeme, type);
      } else if (param == 7) { // BNF
         T_Lexeme head_lexeme(y2->node->Lexeme());
         if (!head_lexeme.Match(T_Lexeme::grIdent)) {
            syntax->forward = head_lexeme;
            return false;
         }
         list = new SNodeList(head_lexeme, type);
         list->Add(y2->node);
      }

      ret = list;
      ret->option = param;
      } break;
   case SNode::stProduce  : {
      SNodeList* list;
      if (param == 4) {
         list = new SNodeList(lexeme->lexeme,type);
         if (y2->node) list->Add(y2->node);
      } else if (param == 5) {
         list = (SNodeList*)y2->node;
         list->Add(y3->node);
      } else if (param == 6) { // BNF
         list = new SNodeList(lexeme->lexeme, type);
      } else if (param == 7) { // BNF
         list = (SNodeList*)y2->node;
         SNode* item;
         if (!y1->node) {
            item = new SNodeList(lexeme->lexeme, SNode::stItem); // <space>
         } else {
            item = y1->node;
         }
         list->Add(item);
      }

      ret = list;
      ret->option = param;
      } break;
   case SNode::stItem: {
      SNodeList* list;
      if (param == 0) {        // Item(Ident)
         list = new SNodeList(lexeme->lexeme,type);
      } else if (param == 1) { // Item(Integer)
         list = new SNodeList(lexeme->lexeme, type);
      } else if (param == 2) { // Item(<Group>)
         list = new SNodeList(lexeme->lexeme, type);
      } else if (param == 3) { // Item(<Group,Type>)
         list = new SNodeList(lexeme->lexeme, type);
         list->Add(new SNodeList(y2->lexeme, type));
      } else if (param == 4) { // Item(|)
         list = new SNodeList(lexeme->lexeme, type);
      }
      ret = list;
      ret->option = param;
      } break;
   case SNode::stMaker  : {
      SNodeList* list;
      if (param == 0 || param == 4 || param == 5) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(new SNodeList(y2->lexeme,type));
         if (y3->node) list->Add(y3->node);
      } else if (param == 1) {
         list = new SNodeList(lexeme->lexeme,type);
         list->Add(y2->node);
         if (y3->node) list->Add(y3->node);
      } else if (param == 2) {
         list = new SNodeList(lexeme->lexeme,type);
         if (y1->node) list->Add(y1->node);
         if (y2->node) list->Add(y2->node);
         if (y3->node) list->Add(y3->node);
         if (y4->node) list->Add(y4->node);
         if (y5->node) list->Add(y5->node);
      } else if (param == 3) {
         list = new SNodeList(lexeme->lexeme,type);
         if (y2->lexeme.group) list->Add(new SNodeList(y2->lexeme,type));
      }

      ret = list;
      ret->option = param;
      } break;
   default : 
      ret = NULL;
      break;
   }
   S0.node = ret;
   return true;
}

MAKER_YACC(MakerSNode)
{
   if (syntax->syntax_mode <= A_Syntax::smParseLL1) {
      if (syntax->make_mode == M_Syntax::mmNode) {
         return make_yacc_LL_SN(item, syntax, data_stack);
      } else if (syntax->make_mode == M_Syntax::mmMade) {
         return make_yacc_LL_MK(item, syntax, data_stack);
      }
   } else {
      if (item.maker >= SNode::stFormula) {
         return make_yacc_Grammar(item, syntax, data_stack);
      } else {
         if (syntax->make_mode == M_Syntax::mmNode) {
            return make_yacc_LR_SN(item, syntax, data_stack);
         } else if (syntax->make_mode == M_Syntax::mmMade) {
            return make_yacc_LR_MK(item, syntax, data_stack);
         }
      }
   }
   return true;
}


#undef S0
#undef S1
#undef S2
#undef S3
#undef S4

#include "stdafx.h"

#include "MSyntax.h"
#include "TSemantic.h"

// --------------------------- MSyntax ---------------------------
#define MAKE_(FUNC,P,M)   {static GSymbol maker(GSymbol::gsMaker,GMakerTable::maker_table.Find(#FUNC),P,0,M);\
                           if (!Maker(maker)) return false; }
#define MAKE(FUNC)         MAKE_(FUNC,0,GSymbol::Tree | GSymbol::Code)
#define MAKE_TREE(FUNC)    MAKE_(FUNC,0,GSymbol::Tree);
#define MAKE_CODE(FUNC)    MAKE_(FUNC,0,GSymbol::Code);
#define PARAM(FUNC,P)      MAKE_(FUNC,P,GSymbol::Tree | GSymbol::Code) 
#define PARAM_TREE(FUNC,P) MAKE_(FUNC,P,GSymbol::Tree) 
#define PARAM_CODE(FUNC,P) MAKE_(FUNC,P,GSymbol::Code) 
#define EXPRESSION(PART)   PARAM_CODE(Part,T_Part::ps##PART) if (!Expressions()) return false; PARAM_TREE(ExpressionS,T_Part::ps##PART)

bool MSyntax::Assign()
{
   if (!Question()) return false;
	if (Match(T_Symbol::prAssign)) {
	   if (!Assign()) return false;
      MAKE(Binary)
	}
   return true;
}

bool MSyntax::Question()
{
   if (!Binary(T_Symbol::prOrOr)) return false;
	if (Match(T_Symbol::prQuestion)) {
      MAKE_CODE(BegQuestion)
	   if (!Question()) return false;
      MAKE_CODE(MidQuestion)
		if (!MatchMust(T_Symbol::lxColon)) return false;
	   if (!Question()) return false;
      MAKE(Question)
	}
   return true;
}

bool MSyntax::Unary()
{
	if (Match(T_Symbol::prUnary) || Match(T_Symbol::prTerm) || Match(T_Symbol::prIncDec)) {
	   if (!Unary()) return false;
      MAKE(Unary)
      return true;
	}
   if (Match(T_Lexeme::sxCastUnary)) { // ([const] int) unary
	   if (!Unary()) return false;
      MAKE(Cast)
      return true;
	}
   if (!Primary()) return false;
	while (Match(T_Symbol::prIncDec)) {
      MAKE(IncDec)
   }
   return true;
}

bool MSyntax::Call()
{
	if (Match(T_Lexeme::sxEmptyBracket)) {
      MAKE(Params)
		return true;
	}
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxLeftBracket)) {
      EXPRESSION(ValueList)
      if (!Match(T_Lexeme::grSeparator, T_Symbol::lxRightBracket)) return false;
      PARAM(Params,0x01)
		return true;
	}
   return false;
}

bool MSyntax::Index()
{
   MAKE(BegIndex)
   while (Match(T_Lexeme::grSeparator, T_Symbol::lxLeftScrape)) {
      EXPRESSION(Value) 
      if (!Match(T_Lexeme::grSeparator, T_Symbol::lxRightScrape)) return false;
      MAKE(Index)
   }
   MAKE(EndIndex)
   return true;
}

bool MSyntax::Primary()
{
	if (Match(T_Lexeme::sxIdentFunc)) {
		return Call();
	}
	if (Match(T_Lexeme::sxIdentArr)) {
   	return Index();
	}
   if (Match(T_Lexeme::grIdent)) {
      MAKE(Ident)
		return true;
	}
   if (Match(T_Lexeme::grInteger)) {
      MAKE(Number) 
      return true;
   }
   if (Match(T_Lexeme::grNumber)) {
      MAKE(Number) 
      return true;
   }
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxLeftBracket)) {
      EXPRESSION(None)
      MAKE_TREE(Primary)
      return Match(T_Lexeme::grSeparator, T_Symbol::lxRightBracket);
      }
   if (Match(T_Lexeme::sxCast)) {
	   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
      EXPRESSION(None) 
      if (!MatchMust(T_Symbol::lxRightBracket)) return false;
      MAKE(Cast)
      return true;
   }
   return error(erPrimary);
}

bool MSyntax::Binary(T_Symbol::T_Priority priority)
{
   if ((priority + 1) < T_Symbol::prUnary) {
      if (!Binary(T_Symbol::T_Priority(priority + 1))) return false;
   } else {
      if (!Unary()) return false;
   }
   while (Match(priority)) {
      if ((priority + 1) < T_Symbol::prUnary) {
         if (!Binary(T_Symbol::T_Priority(priority + 1))) return false;
      } else {
         if (!Unary()) return false;
      }
      MAKE(Binary)
   }
   return true;
}

bool MSyntax::DefParArr()
{
   if (!Match(T_Lexeme::sxIdentArr)) return false;
   MAKE(DefParArr)
   if (!DefArrDA()) return false;
   if (Match(T_Lexeme::grOper, T_Symbol::lxAssign)) {
      MAKE_CODE(BegParVarAssign)
      if (!Assign()) return false;
      MAKE(ParVarAssign)
   }
   return true;
}

bool MSyntax::DefParVar()
{
   if (!Match(T_Lexeme::grIdent)) return false;
   MAKE(DefParVar) 
   if (Match(T_Lexeme::grOper, T_Symbol::lxAssign)) {
      MAKE_CODE(BegParVarAssign)
      if (!Assign()) return false;
      MAKE(ParVarAssign)
   }
   return true;
}

bool MSyntax::DefParItem()
{
   if (Match(T_Lexeme::sxDefArr)) {
      if (!DefParArr()) return false;
   } else if (Match(T_Lexeme::sxDefVar)) {
      if (!DefParVar()) return false;
   } else {
      return false;
   }
   MAKE_TREE(AddToList)
   return true;
}

bool MSyntax::DefParams()
{
   MAKE_TREE(NodeList)
   do {
      if (!DefParItem()) return false;
   } while (Match(T_Lexeme::grSeparator, T_Symbol::lxComma));
   MAKE_TREE(EndParams)
   return true;
}

bool MSyntax::DefFunc()
{
   if (!Match(T_Lexeme::sxIdentFunc)) return false;
   MAKE(FuncIdent)
   if (!Match(T_Lexeme::sxEmptyBracket) &&
       !(Match(T_Lexeme::grSeparator, T_Symbol::lxLeftBracket) && DefParams() && Match(T_Lexeme::grSeparator, T_Symbol::lxRightBracket))) {
      return false;
   }
   return BodyFunc();
}

bool MSyntax::BodyFunc()
{
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon)) {
      PARAM(BodyFunc,0x00)
   } else if (Match(T_Lexeme::sxEmptyCramp)) {
      PARAM(BodyFunc,0x01)
   } else if (Match(T_Lexeme::grSeparator, T_Symbol::lxLeftCramp)) {
      MAKE_CODE(EndParams)
      if (!StmExpr() || !Match(T_Lexeme::grSeparator, T_Symbol::lxRightCramp)) return false;
      PARAM(BodyFunc,0x02)
   } else {
      return false;
   }
   return true;
}

bool MSyntax::DefArrDA() 
{
   if (Match(T_Lexeme::sxEmptyScrape)) {
      MAKE(DefArrD1AEmpty)
   }
   while (Match(T_Lexeme::grSeparator, T_Symbol::lxLeftScrape)) {
      if (!Assign() || !Match(T_Lexeme::grSeparator, T_Symbol::lxRightScrape)) return false;
      MAKE(DRange)
   }
   MAKE_CODE(EndRanges) 
   return true;
}

bool MSyntax::AInitial()
{
   do {
      if (!AInitItem()) return false;
      MAKE_TREE(AddToList)
   } while(Match(T_Lexeme::grSeparator, T_Symbol::lxComma));
   return true;
}

bool MSyntax::AInitItem()
{
   int ret = Initializer();
   if (ret >= 0) return (ret > 0); 
   if (!Assign()) return false;
   MAKE_CODE(AInitItem)
   return true;
}

int  MSyntax::Initializer()
{
   if (Match(T_Lexeme::sxEmptyCramp)) {
      MAKE_CODE(BegInitial) MAKE_TREE(NodeList)
      return 1;
   }
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxLeftCramp)) {
      PARAM_CODE(BegInitial,0x01) MAKE_TREE(NodeList)
      if (!AInitial()) return 0; 
      if (!MatchMust(T_Symbol::lxRightCramp)) return 0;
      MAKE_CODE(EndInitial)
      return 1;
   }
   return -1;
}

bool MSyntax::DefArr()
{
   MAKE(DefArray) 
   if (!DefArrDA()) return false;
   if (Match(T_Lexeme::grOper, T_Symbol::lxAssign)) {
      MAKE_CODE(BegAInit)
      if (Initializer() <= 0) return false; 
      MAKE(EndAInit)
   }
   return true;
}

bool MSyntax::DefVar()
{
   MAKE(DefIdent)
   return DefVarInit();
}

bool MSyntax::DefVarInit()
{
   if (Match(T_Lexeme::grOper, T_Symbol::lxAssign)) {
      MAKE_CODE(BegDefVarAssign) 
      if (!Assign()) return false;
      MAKE(DefVarAssign)
   }
   return true;
}

bool MSyntax::DefItem()
{
   bool reference = Match(T_Lexeme::grOper, T_Symbol::lxAnd);
   if (Match(T_Lexeme::sxIdentArr)) {
      if (!DefArr()) return false;
   } else if (Match(T_Lexeme::grIdent)) {
      if (!DefVar()) return false;
   } else {
      return false;
   }
   if (reference) {
      MAKE_TREE(RefDef)
   }
   return true;
}

bool MSyntax::DefineSemi()
{
   MAKE(Define)
   do {
      if (!DefItem()) return false;
      MAKE_TREE(AddToList)
   } while (Match(T_Lexeme::grSeparator, T_Symbol::lxComma));
   MAKE_CODE(EndDefine) 
   return Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon);
}

bool MSyntax::ExprSemi()
{
   EXPRESSION(Expression)
   return Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon);
}

bool MSyntax::DefExpr()
{ 
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon)) {
      MAKE_TREE(NodeNull) 
      return true;
   }
   if (Match(T_Lexeme::sxDefType)) {
      return DefineSemi();
   }
   int ret = Statement();
   if (ret >= 0) return (ret == 1);
   return ExprSemi();
}

bool MSyntax::StmExpr()
{ 
   MAKE(BegStmExpr)
   do {
      if (!DefExpr()) return false;
      MAKE_TREE(AddToList)
   } while(!MatchSpot(T_Symbol::lxRightCramp)); 
   MAKE_CODE(EndBlock)
   return true;
}

bool MSyntax::DefFuncArrVar()
{
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon)) {
      MAKE_TREE(NodeNull)
      return true;
   }
   if (Match(T_Lexeme::sxDefFunc)) {
      return DefFunc();
   }
   if (Match(T_Lexeme::sxDefType)) {
      return DefineSemi();
   }
   return false;
}

bool MSyntax::Defines()
{
   MAKE(BegStmExpr)
   while (!Match(T_Lexeme::grEof)) {
      if (!DefFuncArrVar()) return false;
      MAKE_TREE(AddToList)
   }
   MAKE_CODE(EndBlock)
   return true;
}

bool MSyntax::Translate()
{
   makers = &GMakerTable::maker_table;
   bool ret = Defines();
   return ret;
}

int  MSyntax::Statement()
{
   if (Match(T_Lexeme::sxLabel) && Match(T_Lexeme::grSeparator, T_Symbol::lxColon)) {
      MAKE_CODE(Label) 
      if (!DefExpr()) return false;
      MAKE_TREE(Label)
      return true;
   } 
   if (Match(T_Lexeme::W_Type::rwFor))      return For();
   if (Match(T_Lexeme::W_Type::rwWhile))    return While();
   if (Match(T_Lexeme::W_Type::rwIf))       return If();
   if (Match(T_Lexeme::W_Type::rwDo))       return Do();
   if (Match(T_Lexeme::W_Type::rwContinue)) return Continue();
   if (Match(T_Lexeme::W_Type::rwBreak))    return Break();
   if (Match(T_Lexeme::W_Type::rwGoTo))     return GoTo();
   if (Match(T_Lexeme::W_Type::rwReturn))   return Return();
   if (Match(T_Lexeme::W_Type::rwSwitch))   return Switch();
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxLeftCramp)) return Compaund();

   return -1;
}

bool MSyntax::Expressions()
{
   if (!Assign()) return false;
   MAKE(Expressions)
   while (Match(T_Lexeme::grSeparator, T_Symbol::lxComma)) {
      if (!Assign()) return false;
      MAKE_TREE(AddToList) MAKE_CODE(AddToExpr)
   }
   MAKE_CODE(ExpressionS)
   return true;
}

bool MSyntax::Condition()
{
   if (Match(T_Lexeme::sxDefType)) {
      MAKE(Define)
      bool ref = Match(T_Lexeme::grOper, T_Symbol::lxAnd); 
      if (!Match(T_Lexeme::grIdent) || !DefVar()) return false;
      if (ref) {
         MAKE_TREE(RefDef)
      }
      MAKE(PushDef) 
      return true;
   } 
   EXPRESSION(Condition)
   return true;
}

bool MSyntax::Compaund()
{
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxRightCramp)) {
      MAKE(Compaund) 
      MAKE_CODE(EndBlock) 
      return true;
   }
   MAKE(Compaund) 
   if (!StmExpr()) return false; 
   MAKE_CODE(EndBlock) 
   MAKE_TREE(AddToList)
   return Match(T_Lexeme::grSeparator, T_Symbol::lxRightCramp);
}

bool MSyntax::For()
{
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   MAKE_CODE(BegFor)
// prefix
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon)) {
      MAKE_TREE(NodeNull)
   } else if (Match(T_Lexeme::sxDefType)) {
      if (!DefineSemi()) return false;
   } else {
      if (!ExprSemi()) return false;
   }
   MAKE_CODE(PrefFor)
// condition
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon)) {
      MAKE(NodeNull)
   } else {
      if (!Condition() || !MatchMust(T_Symbol::lxSemicolon)) return false;
   }
   MAKE_CODE(ConditionFor)
// postfix
   if (Match(T_Lexeme::grSeparator, T_Symbol::lxRightBracket)) {
      MAKE_TREE(NodeNull)
   } else {
      EXPRESSION(Expression)
      if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   }
   MAKE_CODE(PostFor)
// body
   if (!DefExpr()) return false;
   MAKE(For)
   return true;
}

bool MSyntax::While()
{
   MAKE_CODE(BegWhile) 
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Condition()) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   MAKE_CODE(MidWhile) 
   if (!DefExpr()) return false;
   MAKE(While) 
   return true;
}

bool MSyntax::If()
{
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   MAKE_CODE(BegIf)
   if (!Condition()) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   MAKE_CODE(Then)
   if (!DefExpr()) return false;
   if (Match(T_Lexeme::W_Type::rwElse)) {
      MAKE_CODE(Else) 
      if (!DefExpr()) return false;
      PARAM(If,0x01)
   } else {
      MAKE(If)
   }
   return true;
}

bool MSyntax::Do()
{
   MAKE_CODE(BegDo)
   if (!DefExpr()) return false;
   if (!Match(T_Lexeme::W_Type::rwWhile)) return false;
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   MAKE_CODE(MidDo) 
   if (!Condition()) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   MAKE(Do)
   return MatchMust(T_Symbol::lxSemicolon);
}

bool MSyntax::GoTo()
{
   if (!Match(T_Lexeme::grIdent)) return false;
   MAKE(GoTo)
   return MatchMust(T_Symbol::lxSemicolon);
}

bool MSyntax::Continue()
{
   MAKE(Continue)
   return MatchMust(T_Symbol::lxSemicolon);
}

bool MSyntax::Break()
{
   MAKE(Break)
   return MatchMust(T_Symbol::lxSemicolon);
}

bool MSyntax::Return()
{
	if (Match(T_Lexeme::grSeparator, T_Symbol::lxSemicolon)) {
      MAKE(Return)
      return true;
   }
   EXPRESSION(Value)
   PARAM(Return,0x01)
   return MatchMust(T_Symbol::lxSemicolon);
}

bool MSyntax::Switch()
{

   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Expressions()) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   if (!MatchMust(T_Symbol::lxLeftCramp)) return false;
   int case_count = 0, default_count = 0;
   do {
      while (Match(T_Lexeme::W_Type::rwCase) || Match(T_Lexeme::W_Type::rwDefault)) {
         if (forward.Match(T_Lexeme::W_Type::rwCase)) {
            case_count++; 
            if (!Question()) return error(erNoInteger);;
         } else {
            if (default_count++) return false;
         } 
         if (!MatchMust(T_Symbol::lxColon)) return false;
      }
      while (!MatchSpot(T_Lexeme::W_Type::rwCase) && !MatchSpot(T_Lexeme::W_Type::rwDefault) && !MatchSpot(T_Symbol::lxRightCramp)) {
//         if (!Statement(T_Part::psCase)) return false;
      }
   } while (!Match(T_Lexeme::grSeparator, T_Symbol::lxRightCramp));
   if (!case_count || (default_count > 1)) return false;
   return true;
}


#ifndef TRN_MSYNTAX_H
#define TRN_MSYNTAX_H

#include "Maker.h"
 
// --------------------------- MSyntax ---------------------------
class MSyntax : public MC_Syntax
{
public:
	MSyntax(T_Scan *s, TGrammar* g) :MC_Syntax(s), grammar(g) {}

	bool Assign();	
	bool Question();

	bool Unary();
   bool Index();
   bool Call();
	bool Primary();

	bool Binary(T_Symbol::T_Priority priority);

	bool error(T_Error code, int value = 0) { return error(code,lex,value); }
	bool error(T_Error code, const T_Lexeme &l, int value) {  return Error.error(code,l,value); }

	bool Expressions();
   bool Condition();
   int  Statement();

   bool DefParArr();
   bool DefParVar();
   bool DefParItem();
   bool DefParams();
   bool DefFunc();
   bool BodyFunc();

   bool DefArrDA();
   bool AInitial();
   bool AInitItem();
   int  Initializer();
   bool DefArr();
   bool DefVar();
   bool DefVarInit();
   bool DefItem();
   bool DefineSemi();
   bool ExprSemi();
   bool DefExpr();
   bool StmExpr();
   bool Defines();
   bool DefFuncArrVar();
   bool Compaund();

	bool For();
	bool If();
	bool While();
	bool Do();
	bool GoTo();
	bool Continue();
	bool Break();
	bool Return();
	bool Switch();

   virtual bool Translate();
public:
   TGrammar*  grammar;
};

#endif

// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "Parse.h"
#include <stack>

// --------------------------- T_Source ---------------------------
T_Source::T_Sym T_Source::Sym(int &sym)
{
	if (!text || (index >= length) || (!Char(index)))
	{
		if (index < length) length = index; 
		sym = 0;
		return slEof;
	}
	sym = Char(index);
	if (sym == '\n') return slEol;
	if ((sym == ' ') || (sym == '\t') || (sym == '\r')) return slSpace;
	if ((sym >= '0') && (sym <= '9'))  return slDigit;
	if ((sym >= 'a') && (sym <= 'z') || (sym >= 'A') && (sym <= 'Z') || (sym == '_')) return slAlpha;
	if ((sym == '.') || (sym == ',') || (sym == ';') || (sym == ':')) return slSeparator;
	if ((sym == '+') || (sym == '-') || (sym == '*') || (sym == '/')) return slOper;
   if ((sym == '\'') || (sym == '\"')) return slLimiter;
	return slUnknown;
}
 
T_Source::T_Sym T_Source::Read(int &sym)
{
	T_Sym ret = Sym(sym);
	index++;
	return ret;
}

// --------------------------- T_SourceFile ---------------------------
bool  T_SourceFile::Open(const char* name)
{
	if (name) text = name;
	FOPEN(file, text, "rb");
	return file != NULL;
}
int   T_SourceFile::Char(int pos) const  
{
	fseek(file, pos, SEEK_SET);
	int c = getc(file);
	if (c == EOF) c = 0x00;
	return c; 
}

// --------------------------- T_Lexeme ---------------------------
T_Scan* T_Lexeme::print_scan = NULL;
const T_WordTable* T_Lexeme::word_table = NULL;

bool T_Lexeme::Match(A_Symbol::T_Priority priority) const
{
   if ((group == T_Lexeme::grPriority) && ((A_Symbol::T_Priority)type == priority)) return true;
	if (!((group == grOper) || (group == grSeparator))) return false;
	const T_Symbol& symbol = symbol_table().Symbol(value);
	return symbol.priority == priority;
}

bool T_Lexeme::Match(T_Lexeme::W_Type keyword) const
{
	if (group != grReserv) return false;
   const T_Word& key = T_KeyWordTable::key_word_table.Word(value);
   if (key.type == keyword) return true;
   if (keyword == T_Lexeme::W_Type::rwDefine) {
		if ((key.type >= T_Lexeme::W_Type::rwShort) && (key.type <= T_Lexeme::W_Type::rwDouble)) return true;
   }
	return false;
}

bool T_Lexeme::Match(const T_Lexeme &l) const
{
   if (l.group == T_Lexeme::grPriority) {
   	return Match((A_Symbol::T_Priority)l.type);
   } else if (l.group == T_Lexeme::grReserv) {
   	return Match((T_Lexeme::W_Type)l.type);
   } else if ((l.group == T_Lexeme::grOper) || (l.group == T_Lexeme::grSeparator)) {
   	return Match((A_Symbol::T_Type)l.type);
   } else if (l.group == T_Lexeme::grSyntax) {
   	return Match(l.group,l.type);
   } else {
   	return Match(l.group);
   }
}

bool T_Lexeme::Match(A_Symbol::T_Type t) const
{ 
   T_Symbol::T_Type oper;
   if (group == T_Lexeme::grPriority) {
      const T_Symbol& symbol = symbol_table().Symbol(value);
      oper = T_Symbol::T_Type(symbol.type);
   } else if ((group == grOper) || (group == grSeparator) || (group == grPreproc)) {
      oper = T_Symbol::T_Type(type);
   } else {
      return false;
   }
   return (oper == t);
}

int T_Lexeme::print(T_Lexeme::T_Group group, int type, int mode, FILE *file)
{
   bool no_group_mode = (mode & T_PrintMode::pmNoGroupLexeme) != 0;
   if (mode) {
      int len = 0;
      const char* title = group_title(group);
      if (!no_group_mode || (group != grOper) && (group != grSeparator) && (group != grMeta)) {
	      fprintf(file, "%s", title);     len += (int)strlen(title);
      }
   	if ((group == grOper) || (group == grSeparator) || (group == grMeta)) {
         title = lexeme_type_title((T_Symbol::T_Type)type);
         if (no_group_mode) {
         	fprintf(file, "%s", title); len += (int)strlen(title);
         } else {
         	fprintf(file, ",%s", title); len += (int)strlen(title) + 1;
         }
   	} else if ((group == grIdent) && type) {
         fprintf(file, ",%d", type); len += 2;
   	} else if (group == grReserv) {
      	title = lexeme_word_title((T_Lexeme::W_Type)type);
      	fprintf(file, ",%s", title); len += (int)strlen(title) + 1;
   	} else if (group == grPriority) {
      	title = lexeme_priority_title((T_Symbol::T_Priority)type);
      	fprintf(file, ",%s", title); len += (int)strlen(title) + 1;
   	} else if (group == grSyntax) {
      	title = lexeme_syntax_title((T_Lexeme::T_Syntax)type);
      	fprintf(file, ",%s", title); len += (int)strlen(title) + 1;
      } else if (group == grGrammar) {
         fprintf(file, ",%03d", type); len += 4;
      } else {
      }
      return len;
   } else {
	   fprintf(file, "group=%-10s", group_title(group));
   	if ((group == grOper) || (group == grSeparator)) {
      	fprintf(file, ", type=%-12s", lexeme_type_title((T_Symbol::T_Type)type));
   	} else if (group == grReserv) {
      	fprintf(file, ", type=%-12s", lexeme_word_title((T_Lexeme::W_Type)type));
   	} else if (group == grPriority) {
      	fprintf(file, ", type=%-12s", lexeme_priority_title((T_Symbol::T_Priority)type));
   	} else if (group == grSyntax) {
      	fprintf(file, ", type=%-12s", lexeme_syntax_title((T_Lexeme::T_Syntax)type));
      } else {
      	fprintf(file, ", type=%02d          ", type);
      }
      return 6 + 10 + 7 + 12;
   }
}

void T_Lexeme::print(const T_Scan *scan, int mode, FILE *file) const
{
   bool eol = (mode & 0x01) != 0, no_pos = (mode & 0x02) != 0;
   print(group,type,0x00,file);
   if (!no_pos) fprintf(file, ", pos=%04d", pos);
   fprintf(file,", line=%03d, column=%03d, len=%02d", line, column, len);
   if (group == grInteger) {
      fprintf(file, ", value=%d", scan ? scan->Integer(*this) : value);
   } else if (group == grPriority) {
      fprintf(file, ", value=%d", value);
   } else if (group == grNumber) {
      if (scan) fprintf(file, ", number=%lf", scan->Number(*this)); else fprintf(file, ", value=%d", value);
   } else if ((group == grOper) || (group == grSeparator) || (group == grReserv) || (group == grSyntax)) {
      fprintf(file, ", value=%d", value);
   }
	if (len || (group == grReserv)) {
      const char* my_text = Text();
      if (!my_text && scan) my_text = scan->Text(*this);
		fprintf(file,", text=");
      if (my_text) {
			fprintf(file,"%s", my_text);
      } else if (scan && (group != grLine)) {
			for (int i = 0; i < len; i++) fprintf(file,"%c", scan->Char(pos + i));
		}
	}
	if (eol) fprintf(file,"\n");
}

void T_Lexeme::write(const T_Scan *scan, FILE *file) const
{
	fprintf(file,"%d %d %d %d %d %d %d ", group, type, pos, line, column, len, value);
   if ((group != grNone) && (group != grSpace) && (group != grLine) && (group != grEof)) { 
      const char* text = scan->Text(*this);
      if (text) {
         fprintf(file,"%s", text);
      } else {
			for (int i = 0; i < len; i++) fprintf(file,"%c", scan->Char(pos + i));
      }
   }
   fprintf(file,"\n");
}

const T_SymbolTable& symbol_table()
{ 
   //static const T_SymbolTable* table = NULL; if (!table) table = new T_SymbolTable(); return *table; 
   static T_SymbolTable table;
   return table;
}

TNameTable::~TNameTable()
{
}

void TNameTable::Clear()
{
   std::vector<const char*> ::iterator p = names.begin();
   while (p != names.end()) {
      if (*p) delete (*p);
      p = names.erase(p);
   }
}

void TNameTable::Zero()
{
   std::vector<const char*> ::iterator p = names.begin();
   while (p != names.end()) {
      (*p) = NULL;
      p = names.erase(p);
   }
}

int TNameTable::Find(const char* name) const
{
   TNameIndex::const_iterator ip = indexs.find(name); 
   if (ip != indexs.end()) {
      const std::pair<const Key, const int> item = (*ip);
      return item.second;
   } else {
      return -1;
   }
}

int TNameTable::Add(const char* name)
{
   TNameIndex::const_iterator ip = indexs.find(name); 
   if (ip != indexs.end()) {
      const std::pair<const Key, const int> item = (*ip);
      return item.second;
   } else {
      const std::pair<const Key, const int> item(name,index);
      indexs.insert(item); 
      names.push_back(name);
      return index++;
   }
}

int TNameTable::Add(const char* name, T_Lexeme &l)
{
   int len = (int)strlen(name);
   char* ident_body = (char*)malloc(len + 1);
   STRCPY(ident_body, len + 1, name);
   int old = Count();
   int add = Add(ident_body);
   l.text = Name(add);
   if (old == Count()) free(ident_body);
   return add;
}

int TNameTable::Add(T_Scan &scan, T_Lexeme &l)
{
   char* ident_body = (char*)malloc(l.len + 1);
   for (int len = 0; len < l.len; len++) {
   	int sym = scan.Char(l.pos + len);
      ident_body[len] = sym;
   }
   ident_body[l.len] = 0x00;
   int old = Count();
   int add = Add(ident_body);
   l.text = Name(add);
   if (old == Count()) free(ident_body);
   return add;
}

const char* TNameTable::Name(int index) const
{
   return names[index];
}

// --------------------------- T_Scan ---------------------------
T_Scan::T_Scan(T_Source *s) : source(s), line(0), beg_line(0), store_pos(0), old_line(0), mask(A_Symbol::mmTran), word_table(&T_KeyWordTable::key_word_table)
{ 
   symbol_table(); if (source) source->Reset(); 
   T_Lexeme::word_table = word_table;
}

T_Scan::~T_Scan() 
{ 
   names.Clear(); 
}

const char* T_Scan::Text(const T_Lexeme &l) const
{
   const char* text = l.Text();
   if (text) return text;
	if (l.group == T_Lexeme::grIdent) {
      text = names.Name(l.value);
   } else if ((l.group == T_Lexeme::grInteger) || (l.group == T_Lexeme::grNumber)) {
   } else if ((l.group == T_Lexeme::grOper) || (l.group == T_Lexeme::grSeparator) || (l.group == T_Lexeme::grPriority)) {
      text = symbol_table().Symbol(l.value).text;
   } else if (l.group == T_Lexeme::grReserv) {
      text = word_table->Word(l.value).text;
   }
   return text;
}

int T_Scan::Integer(const T_Lexeme &l) const
{
   return integers[l.value];
}

int T_Scan::Integer(int value) 
{ 
   int index = 0;
   for (int item : integers) {
      if (item == value) return index;
      index++;
   }
   integers.push_back(value); return (int)integers.size() - 1; 
}

double T_Scan::Number(const T_Lexeme &l) const
{
   return numbers[l.value];
}

int T_Scan::Number(const double& value)
{
   int index = 0;
   for (const double& item : numbers) {
      if (item == value) return index;
      index++;
   }
   numbers.push_back(value); return (int)numbers.size() - 1;
}

bool T_Scan::Compare(const T_Lexeme &l, const T_Lexeme &r) const 
{ 
   const char *text_l = Text(l), *text_r = Text(r);
   if ((text_l != NULL) && (text_r != NULL) ) {
      return !strcmp(text_l,text_r);
   }
   return !compare(l,r); 
}

int  T_Scan::compare(const T_Lexeme &l, const T_Lexeme &r) const
{
	int l_pos = l.pos, r_pos = r.pos;
	int len = MIN(l.len,r.len);
   while (len--) {
		int l_sym = Char(l_pos++), r_sym = Char(r_pos++), diff = l_sym - r_sym;
      if (diff) return diff;
   }
   return (l.len - r.len);
}

bool T_Scan::Compare(T_Lexeme &l, const char* title) const
{
   const char *text_l = Text(l);
   if (text_l != NULL) {
      return !strcmp(text_l, title);
   }
	int pos = l.pos;
	const char *p = title;
	int len = 0;
	while (p[0])
	{
		int sym = Char(pos + len);
		len++;
		if ((len > l.len) || (p[0] != sym)) { len = -1; break; }
		p++;
	}
	return (len == l.len);
}

T_Lexeme::T_Group T_Scan::Lex(T_Lexeme &l)
{
   store_pos = Pos(); old_line = line;
	int sym;
	l.set(T_Lexeme::grError,T_Lexeme::lxNone);
	l.pos = Pos();
	l.len = 0; l.text = NULL;
   l.value = 0;
   l.line = line;
   l.column = l.pos - beg_line;
	T_Source::T_Sym type = Read(sym);
	if (sym == '/') {
		int my_sym;
		T_Source::T_Sym my_type = Read(my_sym);
		if (my_sym == '/') {
			l.len = 2;
			my_type = Read(my_sym);
			while ((my_type != T_Source::slEof) && (my_type != T_Source::slEol)) 
			{
				l.len++;
				my_type = Read(my_sym);
			}
			Back();
			l.set(T_Lexeme::grSpace,T_Lexeme::lxComment);
			return l.group;
		} else {
			Back();
		}
	}
	if (type == T_Source::slEof) {
		l.group = T_Lexeme::grEof;
	} else if (type == T_Source::slEol) {
		l.group = T_Lexeme::grLine;
		l.len = 1;
      line++; beg_line = l.pos + 1;
	} else if (type == T_Source::slSpace) {
		do {
			l.len++;
			type = source->Read(sym);
		} while (type == T_Source::slSpace);
		l.set(T_Lexeme::grSpace,T_Lexeme::lxSpace);
		Back();
	} else if (type == T_Source::slDigit) {
      bool eight = (sym == '0');
		int value = 0, value_eight = 0, count = 0;
      double number = 0;
		do {
//			if (++count > 8) return l.group; // T_Lexeme::grError
			l.len++;
			value *= 10; value += (sym - '0');
         if (eight && (sym < '8')) {
			   value_eight *= 8; value_eight += (sym - '0');
         } else {
            eight = false;
         }
			type = Read(sym);
		} while (type == T_Source::slDigit);
		
		if ((type == T_Source::slSeparator) && (sym == '.') && !eight) {
			count = 0;
			l.len++;
			type = Read(sym);
			number = value;
			if (type == T_Source::slDigit) {
				int fraction = 0, digits = 1;
				do {
//					if (++count > 8) return l.group; // T_Lexeme::grError
					l.len++; digits *= 10;
					fraction *= 10; fraction += (sym - '0');
					type = Read(sym);
				} while (type == T_Source::slDigit);
				number += (((double)fraction) / digits);
			}
			l.group = T_Lexeme::grNumber;
         l.value = Number(number);
		} else {
			l.group = T_Lexeme::grInteger;
			value = eight ? value_eight : value;
         l.value = Integer(value);
      }
      names.Add(*this, l);
		Back();
	} else if (type == T_Source::slAlpha) {
		do {
//			if (++count > 8) return l.group; // T_Lexeme::grError
			l.len++;
			type = Read(sym);
		} while ((type == T_Source::slDigit) || (type == T_Source::slAlpha));
		Back();
		
		if (!word_table->Find(l,*this))  {
		   l.group = T_Lexeme::grIdent;
         l.value = names.Add(*this, l);
      }
	} else if ((type == T_Source::slLimiter) && (sym == '\'')) {
		l.len++;
		type = Read(sym);
      if (sym == '\'') {
		   l.len++; // error ''
	   } else  {
         if (sym == '\\') {
			   l.len++;
      		type = Read(sym);
            switch (sym) {
               case 't' : sym = 0x09; break;
               case 'n' : sym = 0x0A; break;
               case 'r' : sym = 0x0D; break;
               case 'v' : sym = 0x0B; break;
               case '0' : sym = 0x00; break;
            }
      	}
		   l.len++;
         l.value = Integer(sym);
         type = Read(sym);
         if (sym == '\'') {
			   l.len++; // 'X'
   			l.group = T_Lexeme::grInteger;
      	} else {
			   Back(); // error 'X
		   }
	   }
	} else {
		Back();
		if (symbol_table().Find(l,*this)) return l.group;
		l.len++;
		type = Read(sym);
	}
	return l.group;
}

// --------------------------- TScanArray ---------------------------

T_Lexeme::T_Group TScanArray::Lex(T_Lexeme &l)
{
   if (!make) { Make(); make = true; }
	if (index < (int)size()) {
		l = (*this)[index++]; 
	} else {
      l.group = T_Lexeme::grEof;
	}
   return l.group;
}

bool TScanArray::Make()
{
	T_Lexeme lex;
	T_Lexeme::T_Group group = LexMake(lex);
	while (group != T_Lexeme::grEof)
	{	
		if (!lex.Match(T_Lexeme::grSpace) && !lex.Match(T_Lexeme::grLine)) push_back(lex);
		group = LexMake(lex);
	}
	push_back(lex);
   return true;
}

T_Lexeme::T_Group TIfdefScan::LexMake(T_Lexeme &lex)
{
   T_Scan::Lex(lex);
   while ((lex.Match(T_Lexeme::grSpace)) || (lex.Match(T_Lexeme::grLine)))
   {
      T_Scan::Lex(lex);
   }
   return lex.group;
}

bool TIfdefScan::GetIdent(T_Lexeme &lex)
{
   if (LexMake(lex) == T_Lexeme::grIdent) return true;
   Error(lex, T_Error::erNoIdent);
   push_back(lex);
   return false;
}

void TIfdefScan::AddDef(const char* name)
{
   T_Lexeme l;
   names.Add(name, l);
}

void TIfdefScan::Error(T_Lexeme &lex, T_Error e)
{
   lex.set(T_Lexeme::grError, e); error_lex = lex;
}

bool TIfdefScan::Make()
{
   T_Lexeme lex;
   T_Lexeme::T_Group group = LexMake(lex);
   std::stack<int> stack;
   stack.push(1);
   while (group != T_Lexeme::grEof)
   {
      if (lex.Match(A_Symbol::lxDefine)) {
         if (!GetIdent(lex)) break;
         bool yes_def = definitions.find(CharsKey(lex.text)) != definitions.end();
         if (yes_def) {
            Error(lex, T_Error::erDuplicateIdent);
            push_back(lex);
            break;
         }
         definitions.insert(CharsKey(lex.text));
      } else if (lex.Match(A_Symbol::lxUndef)) {
         if (!GetIdent(lex)) break;
         std::set<CharsKey>::iterator def  = definitions.find(CharsKey(lex.text));
         if (def != definitions.end()) {
            definitions.erase(def);
         }
      } else if (lex.Match(A_Symbol::lxIfdef) || lex.Match(A_Symbol::lxIfndef)) {
         A_Symbol::T_Type if_type = (A_Symbol::T_Type)lex.type;
         if (!GetIdent(lex)) break;
         bool yes_ident = definitions.find(CharsKey(lex.text)) != definitions.end();
         int new_top = (stack.top() == 1) ? yes_ident ^ (if_type == A_Symbol::lxIfndef) : -1;
         stack.push(new_top);
      } else if (lex.Match(A_Symbol::lxElse)) {
         if (stack.size() <= 1) {
            Error(lex, T_Error::erSymbol);
            push_back(lex);
            break;
         }
         if (stack.top() >= 0) stack.top() = !stack.top();
      } else if (lex.Match(A_Symbol::lxEndif)) {
         if (stack.size() <= 1) {
            Error(lex, T_Error::erEnd);
            push_back(lex);
            break;
         }
         stack.pop();
      } else {
         if (stack.top() == 1) push_back(lex);
      }
      group = LexMake(lex);
   }
   if ((stack.size() != 1) && (lex.group != T_Lexeme::grError)) {
      Error(lex, T_Error::erNoEnd);
      push_back(lex);
   }
   lex.group = T_Lexeme::grEof;
   push_back(lex);
   return error_lex.Match(T_Lexeme::grNone);
}

// --------------------------- T_Parse ---------------------------
T_Lexeme T_Parse::empty_ident(T_Lexeme::grIdent,0);
T_Lexeme T_Parse::oper_assign(T_Lexeme::grOper,T_Symbol::lxAssign);

T_Lexeme::T_Group T_Parse::T_Scan__Lex(T_Lexeme &l)
{
	Scan().Lex(l);
	// 0x01 - other, 0x02 - space, 0x04 - line
	int print = T_OptionMode::omNone;
	if (l.Match(T_Lexeme::grLine)) print = (option & T_OptionMode::omPrintLine);
	else if (l.Match(T_Lexeme::grSpace)) print = (option & T_OptionMode::omPrintSpace);
	else print = (option & T_OptionMode::omPrintOther);
	if (print) l.print(&this->Scan());
	return l.group;
}

T_Lexeme::T_Group T_Parse::Lex(T_Lexeme &l)
{
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	l = lex; 
	return lex.group;
}

void T_Parse::SkipSpace()
{
	if (lex.Match(T_Lexeme::grNone)) T_Scan__Lex(lex);
	while ((lex.Match(T_Lexeme::grSpace)) || line_is_space && (lex.Match(T_Lexeme::grLine)))
	{
		T_Scan__Lex(lex);
	}
}

bool T_Parse::Next()
{
	SkipSpace();
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return (lex.group != T_Lexeme::grEof);
}

bool T_Parse::Match(T_Lexeme::T_Group group)
{
	SkipSpace();
	if (!lex.Match(group)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::Match(T_Lexeme::T_Group group, int type)
{
	SkipSpace();
	if (!lex.Match(group,type)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::Match(T_Lexeme &l, T_Lexeme::T_Group group)
{
	SkipSpace();
	l = lex; 
	if (!lex.Match(group)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::MatchSpot(T_Lexeme &l, T_Lexeme::T_Group group)
{
	SkipSpace();
	l = lex; 
	if (!lex.Match(group)) return false;
	return true;
}

bool T_Parse::Match(T_Lexeme &l, T_Lexeme::T_Group group, int type)
{
	SkipSpace();
	l = lex; 
	if (!lex.Match(group,type)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::Match(T_Symbol::T_Type type)
{
	SkipSpace();
	if (!lex.Match(type)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::MatchSpot(T_Symbol::T_Type type)
{
	SkipSpace();
	if (!lex.Match(type)) return false;
	return true;
}

bool T_Parse::Match(A_Symbol::T_Priority priority)
{
	SkipSpace();
	if (!lex.Match(priority)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::MatchSpot(A_Symbol::T_Priority priority)
{
	SkipSpace();
	if (!lex.Match(priority)) return false;
	return true;
}

bool T_Parse::Match(T_Lexeme &l, T_Symbol::T_Priority priority)
{
	SkipSpace();
	l = lex; 
	if (!lex.Match(priority)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::Match(T_Lexeme::W_Type keyword)
{
	SkipSpace();
	if (!lex.Match(keyword)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::Match(T_Lexeme &l, T_Lexeme::W_Type keyword)
{
	SkipSpace();
	l = lex; 
	if (!lex.Match(keyword)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

bool T_Parse::MatchSpot(T_Lexeme::W_Type keyword)
{
	SkipSpace();
	if (!lex.Match(keyword)) return false;
	return true;
}

bool T_Parse::Match(const T_Lexeme &l)
{
	SkipSpace();
	if (!lex.Match(l)) return false;
   forward = lex;
	if (!lex.Match(T_Lexeme::grEof)) T_Scan__Lex(lex);
	return true;
}

void T_Parse::Reset()                 
{ 
	Scan().Reset();
	lex.set(T_Lexeme::grNone,T_Lexeme::lxNone); 
   store_count = 0; restore_count = 0;
}

void T_Parse::Change(T_Lexeme &l,T_Symbol::T_Type t)
{
	symbol_table().Change(l,t);
}

void T_Parse::ChangeUnary(T_Lexeme &lexeme, bool only_term)
{
   T_Symbol::T_Type oper;
   if (lexeme.group == T_Lexeme::grPriority) {
      const T_Symbol& symbol = symbol_table().Symbol(lexeme.value);
      oper = T_Symbol::T_Type(symbol.type);
   } else {
      oper = T_Symbol::T_Type(lexeme.type);
   }
   if (oper == T_Symbol::lxAdd) {
      Change(lexeme,T_Symbol::lxUnaryAdd);
   } else if (oper == T_Symbol::lxSub) {
      Change(lexeme,T_Symbol::lxUnarySub);
   } 
   if (!only_term) {
      if (oper == T_Symbol::lxPlusPlus) {
         Change(lexeme,T_Symbol::lxPostInc);
      } else if (oper == T_Symbol::lxMinusMinus) {
         Change(lexeme,T_Symbol::lxPostDec);
      }
   }
}

// --------------------------- T_Symbol ---------------------------
bool T_Symbol::Compare(T_Lexeme &lex, T_Scan &scan) const
{
	int pos = scan.Pos(), len = 0;
	const char *p = text;
	while (p[0])
	{
		int sym;
		T_Source::T_Sym t = scan.Read(sym);
		len++;
		if ((t == T_Source::slEof) || (p[0] != sym)) 
		{
			while (len--) scan.Back();
			return false;
		}
		p++;
	}
	lex.pos = pos; lex.len = len;
	lex.set(group,type);
	return true;
}

// --------------------------- T_SymbolTable ---------------------------
#define ADD_SYMBOL(GROUP, TYPE, TEXT, MASK) Add(T_Symbol(T_Lexeme::gr##GROUP, T_Symbol::lx##TYPE, TEXT, A_Symbol::mm##MASK))
#define SYMBOL_ADD(GROUP, TYPE, TEXT, PRIOR, MASK) Add(T_Symbol(T_Lexeme::gr##GROUP, T_Symbol::lx##TYPE, TEXT, T_Symbol::pr##PRIOR, A_Symbol::mm##MASK))

T_SymbolTable::T_SymbolTable() :count(0), make(false), mask(A_Symbol::mmTran)
{
   if (make) return; make = true;
   
   ADD_SYMBOL(Separator, Ellipsis,   "...", C | A_Symbol::mmC_99 | A_Symbol::mmSQL);
	ADD_SYMBOL(Separator, Pointer ,    "->", C | A_Symbol::mmC_99);
/*
	ADD_SYMBOL(Separator, LeftCramp ,  "<%");
	ADD_SYMBOL(Separator, RightCramp , "%>");
	ADD_SYMBOL(Separator, LeftScrape , "<:");
	ADD_SYMBOL(Separator, RightScrape ,":>");
*/
   ADD_SYMBOL(Separator, BNFSet      ,"::="   , BNF | A_Symbol::mmSQL);

	ADD_SYMBOL(Separator, ModMod      ,"%%"    , Grammar);
	ADD_SYMBOL(Separator, ModBegin    ,"%{"    , Grammar);
	ADD_SYMBOL(Separator, ModEnd      ,"%}"    , Grammar);
   ADD_SYMBOL(Separator, ModToken    ,"%token", Grammar);
   ADD_SYMBOL(Separator, ModLeft     ,"%left" , Grammar);
   ADD_SYMBOL(Separator, ModRight    ,"%right", Grammar);

	SYMBOL_ADD(Oper, AddAssign,     "+=",Assign, );
	SYMBOL_ADD(Oper, SubAssign,     "-=",Assign, );
	SYMBOL_ADD(Oper, MultiAssign,   "*=",Assign, );
	SYMBOL_ADD(Oper, DivAssign,     "/=",Assign, );
	SYMBOL_ADD(Oper, ModAssign,     "%=",Assign, );
	SYMBOL_ADD(Oper, AndAssign,     "&=",Assign, );
	SYMBOL_ADD(Oper, OrAssign,      "|=",Assign, );
	SYMBOL_ADD(Oper, XOrAssign,     "^=",Assign, );
	SYMBOL_ADD(Oper, OrOr,          "||",OrOr  , );
	SYMBOL_ADD(Oper, Or,             "|",Or    , );
	SYMBOL_ADD(Oper, AndAnd,        "&&",AndAnd, );
	SYMBOL_ADD(Oper, And,            "&",And   , );
	SYMBOL_ADD(Oper, XOr,            "^",XOr   , );
	SYMBOL_ADD(Oper, Tilda,          "~",Unary , );
				   
	SYMBOL_ADD(Oper, Multi,          "*",Factor, ); 
	SYMBOL_ADD(Oper, Div,            "/",Factor, );
	SYMBOL_ADD(Oper, Mod,            "%",Factor, );
				   
	SYMBOL_ADD(Oper, PlusPlus,      "++",IncDec, );
	SYMBOL_ADD(Oper, Add,            "+",Term  , );
	SYMBOL_ADD(Oper, MinusMinus,    "--",IncDec, );
	SYMBOL_ADD(Oper, Sub,            "-",Term  , );
				   
	SYMBOL_ADD(Oper, Equ,           "==",Equ   , );
	SYMBOL_ADD(Oper, Assign,         "=",Assign, );
	SYMBOL_ADD(Oper, NotEqu,        "!=",Equ   , );
	SYMBOL_ADD(Oper, Not,            "!",Unary , );
				  
	SYMBOL_ADD(Oper, LShiftAssign, "<<=",Assign  , );
	SYMBOL_ADD(Oper, LShift,        "<<",Shift   , );
	SYMBOL_ADD(Oper, LE,            "<=",Compare , );
	SYMBOL_ADD(Oper, LT,             "<",Compare , );
	SYMBOL_ADD(Oper, RShiftAssign, ">>=",Assign  , );
	SYMBOL_ADD(Oper, RShift,        ">>",Shift   , );
	SYMBOL_ADD(Oper, GE,            ">=",Compare , );
	SYMBOL_ADD(Oper, GT,             ">",Compare , );
	SYMBOL_ADD(Oper, Question,       "?",Question, );

   SYMBOL_ADD(Oper, UnaryAdd,       "+",Unary   , );
   SYMBOL_ADD(Oper, UnarySub,       "-",Unary   , );
   SYMBOL_ADD(Oper, PostInc,       "++",IncDec  , );
   SYMBOL_ADD(Oper, PostDec,       "--",IncDec  , );
	
	ADD_SYMBOL(Separator, LeftCramp   ,"{", );
	ADD_SYMBOL(Separator, RightCramp  ,"}", );
	ADD_SYMBOL(Separator, LeftBracket ,"(", );
	ADD_SYMBOL(Separator, RightBracket,")", );
	ADD_SYMBOL(Separator, LeftScrape  ,"[", );
	ADD_SYMBOL(Separator, RightScrape ,"]", );
	ADD_SYMBOL(Separator, ColonColon ,"::", );
	ADD_SYMBOL(Separator, Slach      ,"\\", );
	ADD_SYMBOL(Separator, Point,       ".", );
	ADD_SYMBOL(Separator, Semicolon,   ";", );
	ADD_SYMBOL(Separator, Colon,       ":", );
	ADD_SYMBOL(Separator, Comma,       ",", );

   ADD_SYMBOL(Preproc,   Define, "#define", Ifdef);
   ADD_SYMBOL(Preproc,   Undef,  "#undef" , Ifdef);
   ADD_SYMBOL(Preproc,   Ifdef,  "#ifdef" , Ifdef);
   ADD_SYMBOL(Preproc,   Ifndef, "#ifndef", Ifdef);
   ADD_SYMBOL(Preproc,   Else,   "#else"  , Ifdef);
   ADD_SYMBOL(Preproc,   Endif,  "#endif" , Ifdef);

}

void T_SymbolTable::Add(const T_Symbol &sym)
{ 
   int index = table[count].index; table[count] = sym; table[count].index = index; 
   table[sym.type].index = count++;
}

const T_Symbol* T_SymbolTable::Symbol(const char* text) const
{
   size_t len = strlen(text) + 1;
	for (int i = 0; i < count; i++)
	{
		const T_Symbol& symbol = Symbol(i);
		if (!memcmp(text,symbol.text,len)) { return &symbol; }
	}
	return NULL;
}

bool T_SymbolTable::Find(T_Lexeme &lex, T_Scan &scan) const
{
	for (int i = 0; i < count; i++)
	{
		const T_Symbol& symbol = Symbol(i);
      if (!(symbol.mask & scan.mask) || (symbol.mask & (scan.mask << 16))) continue;
		if (symbol.Compare(lex, scan)) { lex.value = i; lex.text = symbol.text; return true; }
	}
	return false;
}

bool T_SymbolTable::Find(const char* text, T_Lexeme &lex) const
{
	for (int i = 0; i < count; i++)
	{
		const T_Symbol& symbol = Symbol(i);
      if (!(symbol.mask & mask) || (symbol.mask & (mask << 16))) continue;
		if (strcmp(symbol.text, text) == 0) {
         lex.group = symbol.group; lex.type = symbol.type; lex.value = i;
         return true; 
      }
	}
	return false;
}
bool T_SymbolTable::Find(char c, T_Lexeme &lex) const
{
   const char text[] = { c, 0x00 };
	return Find(text,lex);
}

void T_SymbolTable::Change(T_Lexeme &lex, T_Symbol::T_Type t) const
{
   const T_Symbol* symbol = &symbol_table().Symbol(t);
   size_t offset = symbol - symbol_table().table;
   int index = (int)offset;
   if (lex.group == T_Lexeme::grPriority) {
      lex.type = symbol->priority;
   } else {
      lex.type = t; 
   }
   lex.value = index; 
}

void T_SymbolTable::print() const
{
	int row = 0;
   for (const T_Symbol &sym : table) {
      printf("sym %2d: %d %2d %2d %2d %2d %d %s\n", row++, sym.group, sym.type, sym.priority, sym.index, sym.oper_index, sym.oper_count, sym.text);
   }
}

// --------------------------- T_Word ---------------------------
bool T_Word::Compare(const T_Lexeme &lex, T_Scan &scan) const
{
   const char *text_lex = lex.Text();
   if (text_lex != NULL) {
      return !strcmp(text_lex, text);
   }
   int pos = lex.pos, len = 0;
	const char *p = text;
	while (p[0])
	{
		int sym = scan.Char(pos + len);
		len++;
		if ((len > lex.len) || (p[0] != sym)) { len = -1; break; }
		p++;
	}
	return (len == lex.len);
}

// --------------------------- T_WordTable ---------------------------
bool T_WordTable::Find(T_Lexeme &lex, T_Scan &scan) const
{
	for (int i = 0; i < count; i++)
	{
		const T_Word& word = Word(i);
      if (!(word.mask & mask) || (word.mask & (mask << 16))) continue;
		if (word.Compare(lex, scan)) { lex.set(T_Lexeme::grReserv,word.type); lex.value = i; lex.text = word.text; return true; }
	}
	return false;
}

bool T_WordTable::Find(T_Lexeme &lex) const
{
   for (int i = 0; i < count; i++)
   {
      const T_Word& word = Word(i);
      if (!(word.mask & mask) || (word.mask & (mask << 16))) continue;
      if (!strcmp(word.text, lex.text)) { lex.set(T_Lexeme::grReserv, word.type); lex.value = i; lex.text = word.text; return true; }
   }
   return false;
}

const T_Word& T_WordTable::Word(T_Lexeme::W_Type w) const
{
   for (int i = 0; i < count; i++)
   {
      const T_Word& word = Word(i);
      if (word.type == w) return word;
   }
   return Word(0);

}

int  T_WordTable::Index(T_Lexeme::W_Type w) const
{
   for (int i = 0; i < count; i++)
   {
      const T_Word& word = Word(i);
      if (word.type == w) return i;
   }
   return -1;

}

#define ADD_WORD(TEXT, TYPE, MASK) Add(T_Word(T_Lexeme::W_Type::rw##TYPE, TEXT, ""#TYPE"", A_Symbol::mm##MASK))

T_KeyWordTable::T_KeyWordTable()
{	
	ADD_WORD("void"      ,Void         ,);
 	ADD_WORD("short"     ,Short        ,);
 	ADD_WORD("int"       ,Int          ,);
 	ADD_WORD("long"      ,Long         ,);
   ADD_WORD("float"     ,Float        ,);
	ADD_WORD("double"    ,Double       ,);
   ADD_WORD("for"       ,For          ,);
   ADD_WORD("while"     ,While        ,);
   ADD_WORD("if"        ,If           ,);
   ADD_WORD("else"      ,Else         ,);
   ADD_WORD("do"        ,Do           ,);
   ADD_WORD("goto"      ,GoTo         ,);
   ADD_WORD("continue"  ,Continue     ,);
   ADD_WORD("break"     ,Break        ,);
   ADD_WORD("return"    ,Return       ,);
   ADD_WORD("switch"    ,Switch       ,);
   ADD_WORD("case"      ,Case         ,);
   ADD_WORD("try"       ,Try          ,);
   ADD_WORD("throw"     ,Throw        ,);
   ADD_WORD("catch"     ,Catch        ,);
   ADD_WORD("enum"      ,Enum         ,);
   ADD_WORD("default"   ,Default      ,);
	ADD_WORD("const"     ,Const        ,);
	ADD_WORD("static"    ,Static       ,);

   ADD_WORD("auto"		,Auto		     ,C | A_Symbol::mmC_99);	
 	ADD_WORD("char"      ,Char         ,C | A_Symbol::mmC_99);
	ADD_WORD("extern"		,Extern	     ,C | A_Symbol::mmC_99);	   
	ADD_WORD("register"	,Register     ,C | A_Symbol::mmC_99);		
	ADD_WORD("signed"		,Signed	     ,C | A_Symbol::mmC_99);	   
	ADD_WORD("sizeof"	   ,Sizeof	     ,C | A_Symbol::mmC_99);  	
	ADD_WORD("struct"		,Struct	     ,C | A_Symbol::mmC_99);	   
	ADD_WORD("typedef"	,Typedef	     ,C | A_Symbol::mmC_99);	
	ADD_WORD("union"		,Union	     ,C | A_Symbol::mmC_99);		
	ADD_WORD("unsigned"	,Unsigned     ,C | A_Symbol::mmC_99);		
	ADD_WORD("volatile"	,Volatile     ,C | A_Symbol::mmC_99);		
#ifdef C99_GRAMMAR 
	ADD_WORD("_Bool"		,Bool		     ,C_99);	
	ADD_WORD("_Complex"	,Complex	     ,C_99);	
	ADD_WORD("_Imaginary",Imaginary    ,C_99);	
	ADD_WORD("inline"		,Inline	     ,C_99);	   
	ADD_WORD("restrict"	,Restrict     ,C_99);		
#endif
   ADD_WORD("ALL"       , ALL         ,Grammar);
   ADD_WORD("MAKE"      , MAKE        ,Grammar);
   ADD_WORD("NODE"      , NODE        ,Grammar);
   ADD_WORD("CODE"      , CODE        ,Grammar);
   ADD_WORD("TREE"      , TREE        ,Grammar);
   ADD_WORD("YACC"      , YACC        ,Grammar);
   ADD_WORD("TURN"      , TURN        ,Grammar);
   ADD_WORD("class"     , Class       ,Grammar);
}

const T_KeyWordTable T_KeyWordTable::key_word_table;

void T_Parse::Mask(A_Symbol::M_Mask mask) 
{ 
   scan->mask = mask; 
   scan->word_table->mask = mask;
   symbol_table().mask = mask;
}

static const char* group[] = { 
   "None", "Oper", "Separator", "Integer", "Number", "String", "Ident", "Reserv", "Space", "Line", "Error", "Priority", "Syntax", "Eof", "Preproc", "Meta", "Grammar"
}; 

static const char* lexeme_type[] = {
   "None","Add","Sub","Multi","Div","Mod",
	"AddAssign","SubAssign","MultiAssign","DivAssign","ModAssign","AndAssign","OrAssign","XOrAssign","Assign",
   "Or","And","OrOr","AndAnd","XOr","Tilda","Not","PlusPlus","MinusMinus",
	"Equ","NotEqu","LT","LE","GT","GE",
   "LShift","RShift","LShiftAssign","RShiftAssign",
   "LeftCramp","RightCramp","LeftBracket","RightBracket","LeftScrape","RightScrape",
   "Question","ColonColon","Slach","Point","Comma","Semicolon","Colon",
   "UnaryAdd", "UnarySub", "PostInc", "PostDec", "Pointer", "Ellipsis", 
   "ModMod", "ModBegin", "ModEnd", "ModToken", "ModLeft", "ModRight", "BNFSet",
   "Define", "Undef", "Ifdef", "Ifndef", "Else", "Endif"
};

static const char* lexeme_word[] = {
	"None","For","While","If","Else","Do","GoTo","Continue","Break","Return",
   "Switch","Case","Try","Throw","Catch","Enum","Default","Void","Short","Int","Long","Float","Double","Define","Const", "Static",
   "Auto","Char","Extern","Register","Signed","Sizeof","Struct","Typedef","Union","Unsigned","Volatile"
#ifdef C99_GRAMMAR 
   ,"Bool","Complex","Imaginary","Inline","Restrict"
#endif
   ,"All","Make","Node","Code","Tree","Yacc","Turn","Class"
};

static const char* lexeme_priority[] = {
   "None","Assign","Question","OrOr","AndAnd","Or","XOr","And","Equ","Compare","Shift", 
   "Term","Factor","Unary","IncDec"
};

static const char* lexeme_syntax[] = { 
   "None","IdentFunc","IdentArr","DefFunc","DefArr","DefVar","DefType","Label","Cast","CastUnary","EmptyCramp","EmptyBracket","EmptyScrape"
}; 

static const char* syntax_error[] = {
	"None", "Symbol", "End", "NoEnd", "Primary", "NoInteger", "NoIdent", "NoValue", "DefArr", "DefFunc", "Define", "DefVoid", "Statement", "Switch",
   "UnknownIdent", "DuplicateIdent", "Break", "Continue", "UnknownOper", "UnknownCast", "UnknownParam", "UnknownFunc", "DuplicateBody", "UnknownBody",
   "UnknownLabel", "DuplicateLabel", "ErrorLabel", "UnusedLabel", "InvalidType","NoReturn", "Ranges", "Uninitialized", "InvalidInit"
};

const char* group_title(T_Lexeme::T_Group g)              { return group[g]; }
const char* lexeme_word_title(T_Lexeme::W_Type w)
{ 
   const T_Word& word = T_Lexeme::word_table->Word(w);
   return word.title; 
}
const char* lexeme_type_title(A_Symbol::T_Type t)         { return lexeme_type[t]; }
const char* syntax_error_title(T_Error e)                 { return syntax_error[e & T_Error::er__Maska__]; }  
const char* lexeme_syntax_title(T_Lexeme::T_Syntax s)     { return lexeme_syntax[s]; }  
const char* lexeme_priority_title(A_Symbol::T_Priority p) { return lexeme_priority[p]; }  
T_Lexeme::T_Group title_group(const char* t) 
{
   int i = 0;
   for (const char* item : group) {
      if (strcmp(item, t) == 0) return (T_Lexeme::T_Group)i;
      i++;
   }
   return T_Lexeme::T_Group::grNone;
}
T_Lexeme::W_Type title_word(const char* t) 
{
   int i = 0;
   for (const char* item : lexeme_word) {
      if (strcmp(item, t) == 0) return (T_Lexeme::W_Type)i;
      i++;
   }
   return T_Lexeme::W_Type::rwNone;
}
A_Symbol::T_Type title_type(const char* t) 
{
   int i = 0;
   for (const char* item : lexeme_type) {
      if (strcmp(item, t) == 0) return (A_Symbol::T_Type)i;
      i++;
   }
   return A_Symbol::T_Type::lxNone;
}
T_Error title_error(const char* t) 
{
   int i = 0;
   for (const char* item : syntax_error) {
      if (strcmp(item, t) == 0) return (T_Error)i;
      i++;
   }
   return T_Error::erNone;
}
T_Lexeme::T_Syntax title_syntax(const char* t) 
{
   int i = 0;
   for (const char* item : lexeme_syntax) {
      if (strcmp(item, t) == 0) return (T_Lexeme::T_Syntax)i;
      i++;
   }
   return T_Lexeme::T_Syntax::sxNone;
}
A_Symbol::T_Priority title_priority(const char* t) 
{
   int i = 0;
   for (const char* item : lexeme_priority) {
      if (strcmp(item, t) == 0) return (A_Symbol::T_Priority)i;
      i++;
   }
   return A_Symbol::T_Priority::prNone;
}

int TTokenNames::Add(const char* group, const char* type, int token)
{
   int len_g = (int)strlen(group), len_t = (type != NULL) ? (int)strlen(type) : 0;
   int len = len_g + len_t + 1;
   char* ident_body = (char*)malloc(len + 1);
   STRCPY(ident_body, len_g + 1, group);
   if (type != NULL) {
      ident_body[len_g] = '_'; STRCPY(ident_body + len_g + 1, len_t + 1, type);
   }
   int old = Count();
   int add = TNameTable::Add(ident_body);
   if (old == Count()) free(ident_body); else tokens.push_back(token);
   tokens[add] = token;
   return add;

}

void T_Parse::MakeTokens(TTokenNames& tokens, int mode)
{
   bool bnf = (mode & T_PrintMode::pmBNF) != 0;
   tokens.Add(group_title(T_Lexeme::grIdent  ), NULL    , T_Lexeme::grIdent   << 8);
   tokens.Add(group_title(T_Lexeme::grInteger), NULL    , T_Lexeme::grInteger << 8);
   tokens.Add(group_title(T_Lexeme::grNumber ), NULL    , T_Lexeme::grNumber  << 8);
   tokens.Add(group_title(T_Lexeme::grIdent  ), "lexeme", T_Lexeme::grIdent   << 8);
   tokens.Add(group_title(T_Lexeme::grInteger), "lexeme", T_Lexeme::grInteger << 8);
   tokens.Add(group_title(T_Lexeme::grNumber ), "lexeme", T_Lexeme::grNumber  << 8);

   const char* title_group = group_title(T_Lexeme::grSyntax);
   for (int sx = T_Lexeme::sxIdentFunc; sx <= T_Lexeme::sxEmptyScrape; sx++ ) {
      tokens.Add(title_group, lexeme_syntax_title((T_Lexeme::T_Syntax)sx), (T_Lexeme::grSyntax << 8) | sx);
   }

   title_group = group_title(T_Lexeme::grPriority);
   for (int pr = T_Symbol::prAssign; pr <= T_Symbol::prIncDec; pr++) {
      tokens.Add(title_group, lexeme_priority_title((T_Symbol::T_Priority)pr), (T_Lexeme::grPriority << 8) | pr);
   }

   if (!bnf) {
      for (T_Symbol symbol : symbol_table().table) {
         if (!symbol.text) continue;
         tokens.Add(group_title(symbol.group), lexeme_type_title(symbol.type), (symbol.group << 8) | symbol.type);
      }
   }
}

char* get_file_name(const char*file, const char* ext)
{
   if (!file) return NULL;
   int len_file = (int)strlen(file), len_ext = (int)strlen(ext);
   char* file_ext = (char*)malloc(len_file + len_ext + 1 + 1);
   int pos_point = len_file - 1;
   for (; (pos_point >= 0) && (file[pos_point] != '.'); pos_point--);
   if (pos_point < 0) pos_point = len_file;
   for (int i = 0; i < pos_point; i++) file_ext[i] = file[i];
   file_ext[pos_point++] = '.';
   for (int i = 0; i < len_ext; i++) file_ext[pos_point++] = ext[i];
   file_ext[pos_point++] = 0x00;
   return file_ext;
}

int print_source(T_Source &source, const char* file_name)
{
   PRINT_FILE_OPEN_NO_RETURN(file, file_name, "wb");
   int count = 0;
   if (file == NULL) return count;
   int sym;
   T_Source::T_Sym type;
   while ((type = source.Read(sym)) != T_Source::slEof)
   {
      fprintf(file, "%c", sym); count++;
   }
   fprintf(file, "\n");
   if (file_name) {
      fclose(file);
   }
   return count;
}

int scan_source(T_Parse &scan)
{
   int count = 0;
   T_Lexeme lexeme;
   T_Lexeme::T_Group group = scan.Lex(lexeme);
   while (group != T_Lexeme::grEof) {
      count++;
      group = scan.Lex(lexeme);
   }
   return count;
}

#ifndef TRN_PARSE_H
#define TRN_PARSE_H
 
#if defined(_MSC_VER)
   #define SSCANF(B,F,V)    sscanf_s(B,F,V)
   #define FOPEN(F,N,M)     fopen_s(&F,N,M)
   #define STRCPY(D,L,S)    strcpy_s(D,L,S)
   #define SPRINTF(B,F,V)   sprintf_s(B,F,V)
   #define MIN(a,b)         (((a) < (b)) ? (a) : (b))
   #define FSCANF           fscanf_s
#elif defined(__GNUC__)
   #define SSCANF(B,F,V)    sscanf(B,F,V)
   #define FOPEN(F,N,M)     F = fopen(N,M)
   #define STRCPY(D,L,S)    strcpy(D,S)
   #define SPRINTF(B,F,V)   sprintf(B,F,V)
   #define MIN(a,b)         (((a) < (b)) ? (a) : (b))
   #define FSCANF           fscanf
#endif

#define PRINT_FILE_OPEN_NO_RETURN(F,N,M) \
   FILE* F; \
   if (N) { \
      FOPEN(F, N, M); \
   } else { \
      F = stdout; \
   }

#define PRINT_FILE_OPEN(F,N,M) \
   PRINT_FILE_OPEN_NO_RETURN(F,N,M) \
   if (!F) return;

// --------------------------- T_Source ---------------------------

struct T_Source
{
	enum T_Sym { slNone, slDigit, slAlpha, slOper, slSeparator, slLimiter, slSpace, slEol, slUnknown, slError, slEof };
	const char* text;
	int index, length;
	T_Source() : text(NULL), index(0), length(MAX_LENGTH) {}
	T_Source(const char* t) : text(t), index(0), length(MAX_LENGTH) {}
	T_Sym Sym(int &sym);
	T_Sym Read(int &sym);
	virtual int Char(int pos) const { return text[pos]; }
	int  Pos() const          { return index; }
	void Pos(int p)           { index = p; }
	void Back()               { if (index && text) index--; }
	void Reset()              { index = 0; }
	void Reset(const char* t) { text = t; length = MAX_LENGTH; index = 0; }

	static const int MAX_LENGTH = 10000000;
}; 

// --------------------------- A_Symbol ---------------------------
struct A_Symbol
{
	enum T_Type { 
               lxNone, lxAdd, lxSub, lxMulti, lxDiv, lxMod,
				   lxAddAssign, lxSubAssign, lxMultiAssign, lxDivAssign, lxModAssign, lxAndAssign, lxOrAssign, lxXOrAssign, lxAssign,
				   lxOr, lxAnd, lxOrOr, lxAndAnd, lxXOr, lxTilda, lxNot,
				   lxPlusPlus, lxMinusMinus,
				   lxEqu, lxNotEqu, lxLT, lxLE, lxGT, lxGE,
				   lxLShift, lxRShift, lxLShiftAssign, lxRShiftAssign,
				   lxLeftCramp, lxRightCramp, lxLeftBracket, lxRightBracket, lxLeftScrape, lxRightScrape, lxQuestion,
				   lxColonColon, lxSlach, lxPoint, lxComma, lxSemicolon, lxColon, lxUnaryAdd, lxUnarySub, lxPostInc, lxPostDec,
               lxPointer, lxEllipsis, 
               lxModMod, lxModBegin, lxModEnd, lxModToken, lxModLeft, lxModRight,
               lxBNFSet,
               lxDefine, lxUndef, lxIfdef, lxIfndef, lxElse, lxEndif,
               _lx_end_
				   };
   enum T_Priority {
               prNone, prAssign, prQuestion, prOrOr, prAndAnd, prOr, prXOr, prAnd, prEqu, prCompare, prShift, 
               prTerm, prFactor, prUnary, prIncDec
               };
   enum M_Mask {
               mmInclude = 0x0000FFFF, mmExclude = mmInclude << 16, mmAll  = mmInclude, mm = mmAll, 
               mmTran = 0x00000001, mmNoTran = mmTran << 16, mmGrammar = 0x00000002, mmNoGrammar = mmGrammar << 16,
               mmC    = 0x00000004, mmNoC    = mmC    << 16, mmC_99    = 0x00000008, mmNoC_99    = mmC_99    << 16,
               mmBNF  = 0x00000010, mmNoBNF  = mmBNF  << 16, mmIfdef   = 0x00000020, mmNoIfdef   = mmIfdef   << 16,
               mmSQL  = 0x00000040, mmNoSQL  = mmSQL  << 16
               };
}; 

// --------------------------- T_Lexeme ---------------------------

#define C99_GRAMMAR 

struct T_Scan;
struct T_WordTable;
struct T_Lexeme
{
	enum T_Group  { grNone, grOper, grSeparator, grInteger, grNumber, grString, grIdent, grReserv, grSpace, grLine, grError, grPriority, grSyntax, grEof, 
                   grPreproc, grMeta, grGrammar
                 };
	enum T_Type   { lxNone, lxSpace, lxComment, lxEol
				     };
	enum W_Type   { rwNone, rwFor, rwWhile, rwIf, rwElse, rwDo,
                   rwGoTo, rwContinue, rwBreak, rwReturn, rwSwitch, rwCase, rwTry, rwThrow, rwCatch, rwEnum, rwDefault, 
                   /* define types */
                   rwVoid, rwShort, rwInt, rwLong, rwFloat, rwDouble, 
                   /*    ordnung   */
                   rwDefine, rwConst, rwStatic,  
                   rwAuto, rwChar, rwExtern, rwRegister, rwSigned, rwSizeof, rwStruct, rwTypedef, rwUnion, rwUnsigned, rwVolatile
#ifdef C99_GRAMMAR 
                  ,rwBool, rwComplex, rwImaginary, rwInline, rwRestrict
#endif
                  ,rwALL, rwMAKE, rwNODE, rwCODE, rwTREE, rwYACC, rwTURN, rwClass
				     };
   enum T_Syntax { sxNone, sxIdentFunc, sxIdentArr, sxDefFunc, sxDefArr, sxDefVar, sxDefType, sxLabel, sxCast, sxCastUnary, sxEmptyCramp, sxEmptyBracket, sxEmptyScrape
				     };
	T_Group group;
	int     type;
	int     pos, len, line, column;
	int     value;
public:
   const char* text;
public:
	T_Lexeme() : group(grNone), type(lxNone), pos(0), len(0), line(0), column(0), value(0), text(NULL) {}
	T_Lexeme(T_Group g, int t) : group(g), type(t), pos(0), len(0), line(0), column(0), value(0), text(NULL) {}
   const char* Text() const                     { return text; }
	bool Match(T_Lexeme::T_Group g) const        { return (group == g); }
	bool Match(T_Lexeme::T_Group g, int t) const { return (group == g) && (type == t); }
	bool Match(A_Symbol::T_Type t) const;
	bool Match(A_Symbol::T_Priority priority) const;
	bool Match(T_Lexeme::W_Type keyword) const;
	bool Match(const T_Lexeme &l) const;
   bool IsSaved() const;
   bool Cast();
   void set(T_Lexeme::T_Group g, int t)         { group = g; type = t; }
public:
	void print(const T_Scan *scan = NULL, int mode = 0x01, FILE *file = stdout) const; // 0x01 - eol, 0x02 - !pos
	void write(const T_Scan *scan = NULL, FILE *file = stdout) const;
   static int print(T_Lexeme::T_Group g, int t, int mode = 0x00, FILE *file = stdout);
   static int YACC (FILE *file, T_Lexeme::T_Group g, int t, int mode = 0x00);
public:
   static T_Scan *print_scan;
   static const T_WordTable* word_table;
};

const char* group_title(T_Lexeme::T_Group g);
const char* lexeme_word_title(T_Lexeme::W_Type w);  
const char* lexeme_type_title(A_Symbol::T_Type t);
const char* lexeme_syntax_title(T_Lexeme::T_Syntax s);  
const char* lexeme_priority_title(A_Symbol::T_Priority p); 
T_Lexeme::T_Group title_group(const char* t);
A_Symbol::T_Type title_type(const char* t);
T_Lexeme::W_Type title_word(const char* t);
T_Lexeme::T_Syntax title_syntax(const char* t) ;
A_Symbol::T_Priority title_priority(const char* t);

// --------------------------- T_Symbol ---------------------------
struct T_Symbol : A_Symbol
{
	T_Lexeme::T_Group group;
	T_Type            type;
   T_Priority        priority;
	const char* text;
   int index;
   unsigned int mask;
	T_Symbol() : group(T_Lexeme::grNone), type(T_Symbol::lxNone), priority(prNone), text(NULL), index(-1), mask(A_Symbol::mmAll), oper_index(0), oper_count(0) {}
	T_Symbol(T_Lexeme::T_Group g, T_Symbol::T_Type t, const char* s, unsigned int m = A_Symbol::mmAll) : group(g), type(t), priority(prNone), text(s), index(-1), mask(m), oper_index(0), oper_count(0) {}
	T_Symbol(T_Lexeme::T_Group g, T_Symbol::T_Type t, const char* s, T_Priority p, unsigned int m = A_Symbol::mmAll) : group(g), type(t), priority(p), text(s), index(-1), mask(m), oper_index(0), oper_count(0) {}
	bool Compare(T_Lexeme &lex, T_Scan &scan) const;
public: // TSemantic
   void MakeOper(const int oper) const { if (!oper_count++) oper_index = oper; }
   mutable int oper_index, oper_count;
}; 

// --------------------------- T_SymbolTable ---------------------------

struct T_SymbolTable
{
	T_Symbol table[T_Symbol::_lx_end_];
	int count;
	T_SymbolTable();
	void Add(const T_Symbol &sym);
	bool inside(int sym) const                       { return (0 <= sym) && (sym < count); }
	const T_Symbol& Symbol(int index) const          { return table[index]; }
	const T_Symbol& Symbol(T_Symbol::T_Type t) const { return Symbol(Symbol((int)t).index); }
   const T_Symbol* Symbol(const char* text) const;
	const char* Text(T_Symbol::T_Type t) const       { return Symbol(t).text; }
	bool Find(T_Lexeme &lex, T_Scan &scan) const;
	bool Find(const char* text, T_Lexeme &lex) const;
	bool Find(char c, T_Lexeme &lex) const;
   void Change(T_Lexeme &lex,T_Symbol::T_Type t) const;
	void print() const;
public:
   mutable A_Symbol::M_Mask mask;
private:
   bool make;
}; 

const T_SymbolTable& symbol_table();

// --------------------------- T_Scan ---------------------------

struct T_ScanStore
{
   T_ScanStore() :store_pos(0), store_line(0), store_lexeme(0), store_node(0), store_tree(0), store_type(0) {}
public:
   int  store_pos, store_line; // scan
   int  store_lexeme, store_node, store_tree, store_type; // syntax
};

struct CharsKey {
   CharsKey(const char* k) :key(k) {}
   const char* key;
   bool operator == (const CharsKey& k) const { return strcmp(key, k.key) == 0; }
   bool operator <  (const CharsKey& k) const { return strcmp(key, k.key) <  0; }
};

class TNameTable {
public:
   TNameTable() :index(0) {}
   ~TNameTable();
public:
   int Add(const char* name);
   int Add(T_Scan &scan, T_Lexeme &l);
   int Add(const char* name, T_Lexeme &l);
   int Find(const char* name) const;
   int Index() { return index++; }
   int Count() const { return (int)indexs.size(); }
   const char* Name(int index) const;
public:
   void Clear();
   void Zero();
public:
   struct Key {
      Key(const char* k) :key(k) {}
      const char* key;
      bool operator == (const Key& k) const { return strcmp(key,k.key) == 0; }
      bool operator <  (const Key& k) const { return strcmp(key,k.key) <  0; }
   };
   class TNameIndex : public std::map<const Key, const int> {
   } indexs;
   std::vector<const char*> names;
protected:
   int index;
};

struct T_WordTable;
struct T_Scan
{
public:
   T_Scan(T_Source *s);
   ~T_Scan();
public:
   virtual T_Lexeme::T_Group Lex(T_Lexeme &l);
	virtual void Store(T_ScanStore& store)         { store.store_pos = store_pos; store.store_line = old_line; }
   virtual bool Restore(const T_ScanStore& store) { if (source->Pos() == store.store_pos) return false; source->Pos(store.store_pos); line = store.store_line; return true; }
	T_Source::T_Sym Read(int &sym) { return source->Read(sym); }
	int  Char(int pos) const       { return source->Char(pos); }
	int  Pos()  const              { return source->Pos(); }
	void Back() const              { source->Back(); }
	void Reset()                   { source->Reset(); line = 0; beg_line = 0; store_pos = 0; old_line = 0; }
	int  compare(const T_Lexeme &l, const T_Lexeme &r) const;
	bool Compare(T_Lexeme &l, const char* title) const;
	bool Compare(const T_Lexeme &l, const T_Lexeme &r) const;
   const char* Text(const T_Lexeme &l) const;
   int  Integer(const T_Lexeme &l) const;
   double Number(const T_Lexeme &l) const;
   int  Integer(int value);
   int  Number(const double& value);
public:
   int  line, beg_line;
   int  store_pos, old_line;
   A_Symbol::M_Mask mask;
public:
   TNameTable names;
   T_Source *source;
   const T_WordTable* word_table;
public:
   std::vector<int> integers;
   std::vector<double> numbers;
};

// --------------------------- T_SourceFile ---------------------------

struct T_SourceFile : T_Source
{
	FILE *file;
	T_SourceFile() : T_Source(), file(NULL) {}
	T_SourceFile(const char* name) : T_Source(name), file(NULL) {}
	bool Open(const char* name = NULL);
	void Close() { if (file) fclose(file); file = NULL; }
	virtual int  Char(int pos) const;

}; 

// --------------------------- TScanArray ---------------------------

class TScanArray : public T_Scan, public  std::vector<T_Lexeme> 
{
public:
	TScanArray(T_Source *s) : T_Scan(s), index(0), make(false) {}
	virtual T_Lexeme::T_Group Lex(T_Lexeme &l);
   virtual T_Lexeme::T_Group LexMake(T_Lexeme &l) { return T_Scan::Lex(l); }
   virtual void Store(T_ScanStore& store)    { store.store_pos = index ? index - 1 : 0; }
   virtual bool Restore(const T_ScanStore& store)  { if (!index || index == store.store_pos + 1) return false; index = store.store_pos; return true; }
   virtual bool Make();
	void Reset()                   { index = 0; }
public:
	int index;
private:
   bool make;
}; 

enum T_Error {
   er__Warning__ = 0x01000000, er__Maska__ = 0x0000FFFF,
   erNone = 0x0000, erSymbol, erEnd, erNoEnd, erPrimary, erNoInteger, erNoIdent, erNoValue, erDefArr, erDefFunc, erDefine, erDefVoid, erStatement, erSwitch,
   erUnknownIdent, erDuplicateIdent, erBreak, erContinue, erUnknownOper, erUnknownCast, erUnknownParam, erUnknownFunc, erDuplicateBody, erUnknownBody,
   erUnknownLabel, erDuplicateLabel, erErrorLabel, er_UnusedLabel, erInvalidType, erNoReturn, erRanges, erUninitialized, erInvalidInit,
   erUnusedLabel = er_UnusedLabel | er__Warning__
};

#include <set>

// --------------------------- TIfdefScan ---------------------------
struct TIfdefScan : public TScanArray
{
public:
   TIfdefScan(T_Source *s) : TScanArray(s) {}
   virtual T_Lexeme::T_Group LexMake(T_Lexeme &l);
   virtual bool Make();
   bool GetIdent(T_Lexeme &l);
   void AddDef(const char* name);
   void Reset() { definitions.clear(); TScanArray::Reset(); }
   void Error(T_Lexeme &lex, T_Error e);
public:
   std::set<CharsKey> definitions;
   T_Lexeme error_lex;
};

// --------------------------- T_Parse ---------------------------
class TTokenNames;

struct T_Parse 
{
	int option; // print(0x01 - other, 0x02 - space, 0x04 - line, 0x08 - eof, 0x10 - lexeme, 0x20 - erase_code, 0x40 - print_code, 0x80 - print_operator, 
               //       0x0100 - print_rule, 0x0200 - print_maker )
	bool line_is_space;
	T_Parse(T_Scan *s) : scan(s), lex(), forward(), option(0), line_is_space(false), store_count(0), restore_count(0) {}
	T_Lexeme::T_Group Lex(T_Lexeme &l);
	T_Lexeme::T_Group T_Scan__Lex(T_Lexeme &l);
	const T_Lexeme& Cur() { SkipSpace(); return lex; }
	T_Scan& Scan() { return *scan; }
   void Scan(T_Scan *s) { scan = s; }
   void Mask(A_Symbol::M_Mask mask);
   A_Symbol::M_Mask Mask() const { return scan->mask; }
   bool Compare(const T_Lexeme &l, const T_Lexeme &r) const { return scan->Compare(l,r); }
	void SkipSpace();
	bool Match(T_Lexeme::T_Group group);
	bool Match(T_Lexeme::T_Group group, int type);
	bool Match(T_Lexeme &l, T_Lexeme::T_Group group);
	bool Match(T_Lexeme &l, T_Lexeme::T_Group group, int type);
	bool Match(T_Symbol::T_Type t);
	bool Match(T_Symbol::T_Priority priority);
	bool Match(T_Lexeme &l, T_Symbol::T_Priority priority);
	bool Match(T_Lexeme::W_Type keyword);
	bool Match(T_Lexeme &l, T_Lexeme::W_Type keyword);
	bool Match(const T_Lexeme &l);
	bool MatchSpot(T_Lexeme &l, T_Lexeme::T_Group group);
	bool MatchSpot(T_Lexeme::W_Type keyword);
	bool MatchSpot(T_Symbol::T_Type t);
	bool MatchSpot(T_Symbol::T_Priority priority);
	bool Next();
	void Reset();
   void Change(T_Lexeme &l,T_Symbol::T_Type t);
   void ChangeUnary(T_Lexeme &l, bool only_term);

public:
   virtual void Store(T_ScanStore& store)         { scan->Store(store); store_count++; }
   virtual bool Restore(const T_ScanStore& store) { if (!scan->Restore(store)) return false; lex.set(T_Lexeme::grNone,T_Lexeme::lxNone); SkipSpace(); restore_count++; return true; }

public:
   int  Integer(const T_Lexeme &l) const { return scan->Integer(l); }
   double Number(const T_Lexeme &l) const { return scan->Number(l); }
   const char* Text(const T_Lexeme &l) const { return scan->Text(l); }
   int Integer(int value) { return scan->Integer(value); }
   int Number(const double& value) { return scan->Number(value); }
public:
   void MakeTokens(TTokenNames& tokens, int mode = 0x00);
   void WordTable(const T_WordTable* word_table) { scan->word_table = word_table; }
public:
	T_Lexeme forward;
public:
   int store_count, restore_count;
public:
	static T_Lexeme empty_ident, oper_assign;
protected:
	T_Lexeme lex;
private:
	T_Scan *scan;
};

// --------------------------- T_Word ---------------------------
struct T_Word
{
public:
   T_Word() : type(0), text(NULL), mask(A_Symbol::mmAll), title(NULL) {}
	T_Word(int t, const char *w, const char *l, unsigned int m = A_Symbol::mmAll) : type(t), text(w), mask(m), title(l) {}
	bool Compare(const T_Lexeme &lex, T_Scan &scan) const;
public:
   int          type;
   const char*  text;
   unsigned int mask;
   const char*  title;
};

struct T_WordTable
{
	static const int TABLE_LENGTH = 300;
	T_Word table[TABLE_LENGTH];
	int count;
	T_WordTable() : count(0), mask(A_Symbol::mmTran) {}
	void Add(const T_Word &word)   { if (count < TABLE_LENGTH) table[count++] = word; }
	bool inside(int word) const    { return (0 <= word) && (word < count); }
	const T_Word& Word(int index) const { return table[index]; }
   const T_Word& Word(T_Lexeme::W_Type w) const;
   int  Index(T_Lexeme::W_Type w) const;
   bool Find(T_Lexeme &lex, T_Scan &scan) const;
   bool Find(T_Lexeme &lex) const;
   //	void print() const;
public:
   mutable A_Symbol::M_Mask mask;
}; 

// --------------------------- T_KeyWordTable ---------------------------
struct T_KeyWordTable : T_WordTable
{
	T_KeyWordTable();

	static const T_KeyWordTable key_word_table;

}; 

// --------------------------- TTokenNames ---------------------------
class TTokenNames : public TNameTable
{
public:
   TTokenNames() : TNameTable() {}
public:
   int Add(const char* group, const char* type, int token);
   int Token(int index) const { return tokens[index]; }
protected:
   std::vector<int> tokens;
};


// --------------------------- T_Xxxxxx ---------------------------

enum T_Part { 
   psNone = 0x00, psDefine = 0x01, psDefFunc = 0x02, psStatement = 0x04, psCompaund = 0x08, psExpression = 0x10, psNoSemicolon = 0x20, psOneDef = 0x40, 
   psIfGoTo    = 0x80, psValue = 0x0100, psValueList = 0x0200,
   psMain      = psDefine | psDefFunc,
   psBody      = psDefine | psStatement | psCompaund | psExpression,
   psLabel     = psDefine | psStatement | psCompaund | psExpression,
   psCase      =            psStatement | psCompaund | psExpression,
   psForBeg    = psDefine | psExpression,
   psForExpr   = psDefine | psExpression | psIfGoTo | psOneDef,
   psCondition = psDefine | psExpression | psIfGoTo | psOneDef | psNoSemicolon
};

enum T_PrintMode {
   pmNone        = 0x00000000, pmPrintItem     = 0x00000001, pmCompact     = 0x00000004, pmRuleUsed     = 0x00000004,
   pmLexemePart  = 0x00000001, pmPrintPrefix   = 0x00000001,
   pmMultiLine   = 0x00000100, pmOffset        = 0x00000200, pmSpaces      = 0x00000400,
   pmYACCStack   = 0x00000100, pmNoPrintNone   = 0x00000200, pmProduceHead = 0x00000200, pmSortMode     = 0x00000400, pmCompactGroup = 0x00000800,
   pmBasic       = 0x00000100, pmTableLLk      = 0x00002000, pmEofToEmpty  = 0x00004000, 
   pmSimplePara  = 0x00001000,
   pmGrammar     = 0x00010000, pmBNF           = 0x00020000,
   pmFormulaHead = 0x00010000, pmParamMacro    = 0x00020000, 
   pmYACCMode    = 0x01000000, pmNoGroupLexeme = 0x02000000, pmMacroMode   = 0x04000000, 
   pmSymbolOper  = pmCompact,
   pmMakerNone   = 0x00000000, pmMakerItem     = 0x00000001, pmMakerCompact= 0x00000004,
   pmWriteSimple = 0x00000001, pmWriteZero     = 0x00000002, pmWriteSymbol = 0x00000003, pmWriteProg    = 0x00000004,
   pmProgHeader  = 0x00000001, pmProgBody      = 0x00000002, pmProgCall    = 0x00000003, pmProgList     = 0x00000004
};

enum T_OptionMode {
    omNone          = 0x00000000,
    omPrintOther    = 0x00000001, omPrintSpace   = 0x00000002, omPrintLine   = 0x00000004, omPrintLexeme   = 0x00000008,
    omPrintTree     = 0x00000010, omEraseCode    = 0x00000020, omPrintCode   = 0x00000040, omPrintOperator = 0x00000080,
    omPrintRule     = 0x00000100, omPrintMaker   = 0x00000200, omPrintStack  = 0x00000400, omPrintCodes    = 0x00000800,
    omPrintSNode    = 0x00001000, omPrintSyntax  = 0x00002000, omPrintSource = 0x00004000, omPrintSemantic = 0x00008000,
    omSelectProduce = 0x00010000, omTrimUnit     = 0x00020000, omAutoTree    = 0x00040000, omTreeTraversal = 0x00080000,
    omQuadruple     = 0x00100000, omAtOnce       = 0x00200000
};

const char* syntax_error_title(T_Error e);  
T_Error title_error(const char* t);

char* get_file_name(const char*file, const char* ext);

int print_source(T_Source &source, const char* file_name = NULL);
int scan_source(T_Parse &scan);

#endif


#include "stdafx.h"

#include "PSyntax.h"
#include "TSemantic.h"

bool P_Syntax::Translate()
{
   makers = &GMakerTable::maker_table;
   bool ret = translate() != 0;

   return ret;
}
#ifndef TRN_PSYNTAX_H
#define TRN_PSYNTAX_H

#include "Maker.h"
 
// --------------------------- PSyntax ---------------------------
class P_Syntax : public MC_Syntax
{
public:
	P_Syntax(T_Scan *s, TGrammar* g) :MC_Syntax(s), grammar(g) {}

   virtual bool Translate();
   virtual int translate() { return 0; }

public:
   TGrammar*  grammar;
};

#endif

#include "stdafx.h"

#include "RSyntax.h"
#include "Maker.h"
#include "Grammar.h"

RSyntax::RSyntax(T_Scan *s, TGrammar* g) :S_Syntax(g), MC_Syntax(s), 
 rules_true(0), rules_false(0), produce_count(0), failure_count(0), luck_count(0)
{
   unit.grammar = g;
}

bool RSyntax::MatchLexeme(const GSymbol& sym, int mode)
{
   bool ret = true, no_save = (mode & 0x01) != 0;
   const T_Lexeme lexeme(T_Lexeme(T_Lexeme::T_Group((sym.type == GSymbol::gsEof) ? T_Lexeme::grEof: sym.group),sym.lexeme_type));
   T_Lexeme l;
   if (lexeme.group == T_Lexeme::T_Group::grSyntax) {
      ret = MatchSyntax(l,lexeme);
      if (ret && !no_save && sym.IsSaved()) push_lexeme(l);
   } else {
      ret = A_Syntax::Match(lexeme);
      if (ret && !no_save && sym.IsSaved()) push_lexeme(forward);
   }
   return ret;
}

int RSyntax::MatchSymbol(const GSymbol& sym, int mode)
{
   int ret = true;
   if (sym.IsEmpty()) {
      ret = true;
   } else if (sym.IsTerminal() || sym.IsEof()) {
      ret = MatchLexeme(sym, mode);
   } else if (sym.IsFormula()) {
      const GFormula* formula = (*grammar).formulas[sym.formula];
      ret = Parse(*formula);
   } else if (sym.IsMaker()) {
      if (sym.maker < 0) return false; 
      ret = -1;
      const GMaker& maker = *(*makers)[sym.maker];
      if ((make_mode == mmTree) && sym.IsMakerTree()) {
         if (!maker.make_tree || !maker.make_tree(sym,this)) {
            ret = 0; 
         } else {
            ret = 1;
         }
      }
      if ((make_mode == mmCode) && sym.IsMakerCode()) {
         if (!maker.make_code || !maker.make_code(sym,this,semantic)) {
            ret = 0; 
         } else {
            ret = 1;
         }
      }
   } else {
      ret = false;
   }
   return ret;
}

bool RSyntax::Translate()
{
   bool ret = false;
   if (syntax_mode == A_Syntax::smParseStackRule) {
      if ((make_mode == mmNode) || (make_mode == mmMade)) {
         ret = ParseStack_SN();
      } else {
         ret = ParseStack();
      }
   } else if (syntax_mode == A_Syntax::smParseStackFormula) {
      ret = Parse();
   } else if (syntax_mode == A_Syntax::smParseFormula) {
      const GFormula& formula = *grammar->root;
      ret = Parse(formula);
   }
   if (ret && !Match(T_Lexeme::grEof)) ret = false;
   printf("\nlevel=%d, step=%d, rules_true=%d, rules_false=%d, produce_count=%d, failure_count=%d, luck_count=%d\n", max_level, step, rules_true, rules_false, produce_count, failure_count, luck_count);

   return ret;
}

// produce ==>> stack
int  RSyntax::ProduceToStack()
{
   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, select_produce = (option & T_OptionMode::omSelectProduce) != 0;
   TStackRuleItem& item = top();
   GSymbol& sym = item.sym;
   T_Lexeme current_lexeme, current_cast;
   bool yes_cast = false;
   if (select_produce) {
      Lexeme(current_lexeme); current_cast = current_lexeme;
      yes_cast = current_cast.Cast();
      Restore(item.store);
   }
   while (sym.produce < item.step) { // !end
      const GProduce& produce = grammar->Produce(sym);
      if (produce.empty()) break;
      const GSymbol& front = produce.front();
      if (select_produce) {
         if (front.IsEmpty() || front.IsMaker()) break;
         if (grammar->FIRSTsP.Have(produce.head, current_lexeme) || yes_cast && grammar->FIRSTsP.Have(produce.head, current_cast)) {
            //|| grammar->FIRSTsP.HaveEmpty(produce.head)) {
            break;
         }
      } else {
         if (!front.IsTerminal()) break;
         bool beg = MatchLexeme(front, 0x01); // !save
         Restore(item.store);
         if (beg) break;
      }
      sym.produce++;
   }
   if (sym.produce >= item.step) { // last
      leave(); 
      ret = -1; 
      return ret;
   }
   const GProduce& produce = grammar->Produce(sym);
   GProduce::const_reverse_iterator p = produce.rbegin();
   if (print_rule) {
      print_offset(level, 0x03); printf(" <<");
   }
   while (p != produce.rend()) {
      if ((*p).IsMaker()) {
         bool not_ours = !(*p).IsMakerTree() && !(*p).IsMakerCode() && !(*p).IsMakerTurn();
         if (not_ours) { p++; continue; }
      }
      if (print_rule) {
         printf(" "); print_symbol((*p),0x04);
      }
      entry((*p++));
   }
   if (print_rule) {
      printf("\n");
   }
   produce_count++;
   return ret;
}

bool RSyntax::ParseStack()
{
   const GFormula& formula = *grammar->root;
   TStackRuleItem root_item(formula.head);
   entry(root_item);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0;
   while (!rule_stack.empty()) {
      TStackRuleItem& item = top();
      GSymbol& sym = item.sym;
      if (ret == -1) { // failure
         failure_count++;
         if (print_rule) {
            print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00);
            printf(", ret=%2d", ret);
         }
         if (sym.IsProduce() && (++sym.produce < item.step)) {
            Restore(item.store);
            if (print_rule) {
               printf(" restore=%03d step=%d\n", item.store.store_pos, item.step);
            }
            // -> (produce ==>> stack)
            ret = ProduceToStack();
         } else { // last
            leave(); 
         }
      } else { // ret == 0, 1
         if (sym.IsFormula()) {
            const GFormula& formula = grammar->Formula(sym);
            const GProduce& produce = grammar->Produce(sym);
            Store(item.store);
            if (print_rule) {
               print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00);
               printf("store=%03d step=%d", item.store.store_pos,item.step);
               printf(", ret=%2d", ret);
            }
            if ((sym.mode & GSymbol::Master) && (filled() > 1)) {
               const TStackRuleItem& master_item = stack_item(filled() - 2);
               if (master_item.sym.IsProduce() && (master_item.sym.formula == sym.formula)) {
                  if (print_rule) {
                     printf(" #Master# ");
                  }
                  leave();
                  Store(top().store);
               }
            }
            if (print_rule) {
               printf("\n");
            }
            top().sym = produce.head; top().step = formula.count();
            // -> (produce ==>> stack)
            ret = ProduceToStack();
         } else if (sym.IsProduce()) { // luck
            if (print_rule) {
               print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00);
            }
            ret = 1; 
            leave(); 
            luck_count++;
         } else {
            bool print_maker = ((option & T_OptionMode::omPrintMaker) != 0) && sym.IsMaker();
            int nodes_before=0, lexemes_before=0; 
            if (print_maker) {
               Counts(nodes_before, lexemes_before);
            }
            int match = MatchSymbol(sym);
            if (match) { 
               ret = 1; 
            } else {
               ret = -1; 
            }
            if ((print_rule || print_maker) && (match >= 0)) {
               print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00); printf(", ret=%2d", ret);
               if (print_maker) {
                  int nodes_after=0, lexemes_after=0; Counts(nodes_after, lexemes_after);
         	      printf(" [%d,%d] -> [%d,%d]", nodes_before, lexemes_before, nodes_after, lexemes_after);
               }
               printf("\n");
            }
            leave(); 
         }
      }
   }
   return (ret != -1);
}

bool RSyntax::ParseStack_SN()
{
   const GFormula& formula = *grammar->root;
   TStackRuleItem root_item(formula.head);
   entry(root_item);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = ((option & T_OptionMode::omPrintMaker) != 0);
   const int S_count = 15;
   T_Lexeme_SNode* data_stack[S_count] = {};
   while (!rule_stack.empty()) {
      TStackRuleItem& item = top();
      GSymbol& sym = item.sym;
      if (ret == -1) { // failure
         failure_count++;
         if (print_rule) {
            print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00);
            printf(", ret=%2d", ret);
         }
         if (sym.IsProduce()) {
            const GFormula& formula = grammar->Formula(sym);
            sym.produce++;
            if (sym.produce >= formula.count()) { // last
               leave(); 
               continue;
            }
            Restore(item.store);
            if (print_rule) {
               printf("restore=%03d step=%d", item.store.store_pos, item.step);
            }
            // -> (produce ==>> stack)
         } else {
            leave(); 
            continue;
         }
      } else { // ret == 0, 1
         if (sym.IsFormula()) {
            const GFormula& formula = grammar->Formula(sym);
            const GProduce& produce = grammar->Produce(sym);
            Store(item.store);
            if (print_rule) {
               print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00);
               printf("store=%03d step=%d", item.store.store_pos,item.step);
               printf(", ret=%2d", ret);
            }
            if ((sym.mode & GSymbol::Master) && (filled() > 1)) {
               const TStackRuleItem& master_item = stack_item(filled() - 2);
               if (master_item.sym.IsProduce() && (master_item.sym.formula == sym.formula)) {
                  if (print_rule) {
                     printf(" #Master# ");
                  }
                  leave();
                  Store(top().store);
               }
            }
            top().sym = produce.head;
            // -> (produce ==>> stack)
         } else if (sym.IsProduce()) { // luck
            luck_count++;
            if (print_rule) {
               print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00);
               printf(" %03d", filled() - 1);
               const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 1).lexeme_node;
               if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
               if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
               printf(" ");
            }
            if (filled() > 1) {
               TStackRuleItem& next_item = stack_item(filled() - 2);
               if (next_item.sym.IsMaker() || next_item.sym.IsProduce()) {
                  if (item.lexeme_node.node) { next_item.lexeme_node.node = item.lexeme_node.node; }
                  if (item.lexeme_node.tree) { next_item.lexeme_node.tree = item.lexeme_node.tree; }
                  if (next_item.lexeme_node.lexeme.Match(T_Lexeme::grNone)) next_item.lexeme_node.lexeme = item.lexeme_node.lexeme;
                  if (print_rule) {
                     printf(" %03d", filled() - 2);
                     const T_Lexeme_SNode& lexeme_node = stack_item(filled() - 2).lexeme_node;
                     if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
                     if (lexeme_node.tree) printf("<%s>", lexeme_node.tree->title());
                     printf("; ");
                  }
               }
            }
            ret = 1; 
            leave(); 
            continue;
         } else if (sym.IsTerminal()) {
            bool match, save = false;
            const T_Lexeme lexeme(T_Lexeme(T_Lexeme::T_Group(sym.group),sym.lexeme_type));
            T_Lexeme l;
            if (lexeme.group == T_Lexeme::T_Group::grSyntax) {
               match = MatchSyntax(l,lexeme);
               if (match && (sym.IsSaved())) save = true;
            } else {
               match = A_Syntax::Match(lexeme);
               if (match && (sym.IsSaved())) { l = forward; save = true; }
            }
            ret = match ? 1 : -1; 
            if (print_rule) {
               print_offset(level, 0x03); printf(" >> "); print_symbol(sym,0x00); printf(", ret=%2d", ret);
            }
            if (save) {
               int maker = item.step - 1;
               while ((maker >= 0) && !stack_item(filled() - item.step + maker).sym.IsMaker()) {
                  maker--;
               }
               stack_item(filled() - item.step + maker).lexeme_node.lexeme = l;
            }
            leave(); 
            continue;
         } else if (sym.IsEmpty()) {
            leave(); 
            continue;
         } else if (sym.IsMaker()) {
            int nodes_before=0, lexemes_before=0; 
            if (print_maker) {
               Counts(nodes_before, lexemes_before);
            }
            int stack_top = filled() - 1;
            for (int i = 0; i <= item.step; i++) {
               if (i >= S_count - 1) {
                  ret = -1; 
                  break;
               }
               data_stack[i + 1] = &S_Syntax::rule_stack[stack_top - i].lexeme_node;
               if (print_maker) { 
                  printf(" %03d", (stack_top - i));
                  const T_Lexeme_SNode& lexeme_node = *data_stack[i + 1];
                  if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type)); 
                  printf(" ");
               }
            }
            data_stack[0] = &S_Syntax::rule_stack[stack_top - item.step].lexeme_node;
            if (print_maker) printf(" %03d --->>> ",(stack_top - item.step));
            const GSymbol& maker = sym;
            int match = -1;
            int save_print = (option & (0x0100 | 0x0200)); option &= ~(0x0100 | 0x0200);
            if (maker.IsMakerYACC()) {
               match = 0;
               if (!MakerSyntaxNode(maker,data_stack)) {
                  ret = -1; 
               }
            } else if (maker.IsMakerNode()) {
               match = 0;
               if (!MakerSyntaxNode(maker,data_stack,GMakerTable::maker_table.maker_node)) {
                  ret = -1; 
               }
            }
            option |= save_print;
            if ((print_rule || print_maker) && (match >= 0)) {
               if (print_maker) {
                  for (int i = 0; i <= item.step; i++) {
                     if (i >= S_count - 1) {
                        ret = -1;
                        break;
                     }
                     printf(" %03d", (stack_top - i));
                     const T_Lexeme_SNode& lexeme_node = *data_stack[i + 1];
                     if (lexeme_node.node) printf("<%s>", snode_title(lexeme_node.node->type));
                     printf(" ");
                  }
               }
               print_offset(level, 0x03); print_symbol(sym,0x00); printf(", ret=%2d", ret);
               if (print_maker) {
                  int nodes_after=0, lexemes_after=0; Counts(nodes_after, lexemes_after);
         	      printf(" [%d,%d] -> [%d,%d]", nodes_before, lexemes_before, nodes_after, lexemes_after);
               }
               printf("\n");
            }
            leave(); 
            continue;
         }
      }
      // produce ==>> stack
      produce_count++;
      const GProduce& produce = grammar->Produce(top().sym);
      GProduce::const_reverse_iterator p = produce.rbegin();
      if (print_rule) {
         print_offset(level, 0x03); printf(" <<");
      }
      int len = 0;
      while (p != produce.rend()) {
         if ((*p).IsMaker() && !(*p).IsMakerYACC() && !(*p).IsMakerNode()) {
            p++; continue;
         }
         if (print_rule) {
            printf(" "); print_symbol((*p),0x04);
         }
         entry((*p++));
         top().step = ++len;
      }
      if (print_rule) {
         printf("\n");
      }
      ret = 0;
   }
   return (ret != -1);
}

bool RSyntax::Parse()
{
   const GFormula& formula = *grammar->root;
   TStackRuleItem root_item(formula.head);
   entry(root_item);

   int ret = 0;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0, print_maker = (option & T_OptionMode::omPrintMaker) != 0;
   while (!rule_stack.empty()) {
      TStackRuleItem& item = top();
      const GSymbol& sym = item.sym;
      if (print_rule && (ret == 0) && (sym.IsFormula() || sym.IsProduce())) {
//         print_offset(level, 0x03); print_symbol(sym,0x00);
      }
      if (sym.IsFormula()) {
         const GFormula& formula = *grammar->formulas[sym.formula]; 
         if (ret == 0) { // begin
            Store(item.store);
            if (print_rule) {
               print_offset(level, 0x03); print_symbol(sym,0x00); printf("store=%03d \n", item.store.store_pos);
            }
         } else if (ret ==  1) { // after true down
         } else if (ret == -1) { // after false down
            Restore(item.store);
            if (print_rule) {
               print_offset(level, 0x03); print_symbol(sym,0x00); printf("restore=%03d \n", item.store.store_pos);
            }
         }
         if ((ret == 1) || (item.step == formula.count())) { // after true down, end
            if (ret == 0) { // items_count == 0
               ret = -1;
            } else if (ret == 1) {
            }
            if (print_rule) {
               print_offset(level, 0x03); printf("->"); print_symbol(sym,0x00); printf(", ret=%2d", ret);
            }
            if (ret == 1) rules_true++; else rules_false++;
            leave(); 
         } else { // after false down, begin
            TStackRuleItem sub_item(formula[item.step++].head); // produce
            entry(sub_item);
            ret = 0;
         }
      } else if (sym.IsProduce()) {
         const GFormula& formula = *grammar->formulas[sym.formula]; 
         const GProduce& produce = formula[sym.produce];
         if (ret == 0) { // begin rule
         } else if (ret == 1) { // after true down
         }
         if ((ret == -1) || (item.step == produce.count())) { // after false down, end
            if (ret == -1) { // after false down
            } else { // end
               ret = 1;
            }
            if (ret == 1) rules_true++; else rules_false++;
            if (print_rule) {
               print_offset(level, 0x03); printf("->"); print_symbol(sym,0x00); printf(", ret=%2d", ret);
            }
            leave(); 
         } else { // after true down, begin
            TStackRuleItem sub_item(produce[item.step++]);
            if ((sub_item.sym.mode & GSymbol::Master) && (item.step == produce.count())) {
               if (print_rule || print_maker) {
                  printf(" !Master! ");
               }
               leave(); // produce
               TStackRuleItem& master = top(); // formula
               master = sub_item;
            } else {
               entry(sub_item);
            }
            ret = 0;
         }
      } else { // sym
         int nodes_before=0, lexemes_before=0; 
         if (print_maker && sym.IsMaker()) {
            Counts(nodes_before, lexemes_before);
         }
         int match = MatchSymbol(sym);
         if (match) { 
            ret = 1; 
         } else {
            ret = -1; 
         }
         if ((print_rule || (print_maker && sym.IsMaker())) && (match >= 0)) {
            print_offset(level, 0x03); print_symbol(sym,0x00); printf(", ret=%2d", ret);
            if (print_maker && sym.IsMaker()) {
               int nodes_after=0, lexemes_after=0; Counts(nodes_after, lexemes_after);
      	      printf(" [%d,%d] -> [%d,%d]", nodes_before, lexemes_before, nodes_after, lexemes_after);
            }
            printf("\n");
         }
         leave(); 
      }
   }
   return (ret != -1);
}

bool RSyntax::Parse(const GProduce& produce)
{
   bool ret = true;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0; 
   if (print_rule) {
      print_offset(level, 0x03); print_symbol(produce.head,0x00);
   }
   for (const GSymbol& sym : produce) {
      bool print_maker = ((option & T_OptionMode::omPrintMaker) != 0) && sym.IsMaker();
      int nodes_before=0, lexemes_before=0; 
      if (print_maker) {
         Counts(nodes_before, lexemes_before);
      }
      int match = MatchSymbol(sym);
      if (match) { 
         ret = true; 
      } else {
         ret = false; 
      }
      if ((print_rule || print_maker) && (match >= 0)) {
         print_offset(level, 0x03); print_symbol(sym,0x00); printf(", ret=%d", ret);
         if (print_maker) {
            int nodes_after=0, lexemes_after=0; Counts(nodes_after, lexemes_after);
      	   printf(" [%d,%d] -> [%d,%d]", nodes_before, lexemes_before, nodes_after, lexemes_after);
         }
      }
      if (!ret) break;
   }
   if (print_rule) {
      print_offset(level, 0x03);  printf("->");print_symbol(produce.head,0x00); printf(", ret=%d ", ret);
   }
   if (ret) rules_true++; else rules_false++;
   return ret;
}

bool RSyntax::Parse(const GFormula& formula)
{
   bool ret = false;
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0;
   if (print_rule) {
      print_offset(level, 0x03); print_symbol(formula.head,0x00);
   }
   level++;
   T_ScanStore store; Store(store);
   for (const GProduce& produce : formula) {
      ret = Parse(produce); 
      if (ret) break; 
      Restore(store);
   }
   level--;
   if (print_rule) {
      print_offset(level, 0x03); printf("->"); print_symbol(formula.head,0x00); printf(", ret=%d ", ret);
   }
   if (ret) luck_count++; else failure_count++;
   return ret;
}

void RSyntax::clear(TNode* node)
{
   if (node) { node->clear(); delete node; } 
}
#ifndef TRN_RSYNTAX_H
#define TRN_RSYNTAX_H

#include "Parse.h"
#include "ASyntax.h"
#include "TNodes.h"
#include "SNodes.h"
#include "Rules.h"
#include "Tables.h"
#include "CSyntax.h"

class GMaker;
class GMakerTable;
class M_Syntax;
class MC_Syntax;
class GSyntax;
struct T_Lexeme_SNode;

class TLexemeSet : public std::map<const GSymbol, int>
{
public:
   TLexemeSet(const TGrammar* g) :grammar(g) {}
   bool Add(const GSymbol&);
   int  GetAdded(const GSymbol&) const;
   void print_(FILE* file, int print_mode = 0x00) const;
   void print(const char* file_name, int print_mode = 0x00) const;
   void YACC(FILE* file, int print_mode = 0x00) const;
   int  count() const { return (int)size(); }
public:
   T_SyntaxLexeme grammar_type() const;
public:
   const TGrammar* grammar;
};

class SNode;
struct T_Lexeme_SNode
{
   T_Lexeme_SNode() :node(NULL), tree(NULL), unit(NULL) {}
   T_Lexeme lexeme; SNode* node; TNode* tree; T_SyntaxNode* unit;
};

struct TStackRuleItem
{
public:
   TStackRuleItem(const GSymbol& s) :sym(s), store(), step(0) {}
public:
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE *file = stdout) const;
public:
   int   step;
   T_ScanStore  store;
   GSymbol sym;
public:
   T_Lexeme_SNode lexeme_node;
};

class TStackRule : public std::vector<TStackRuleItem>
{
public:
   TStackRule() {}
public:
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE *file = stdout) const;
};

class S_Syntax 
{
public:
   S_Syntax(TGrammar*  g) :grammar(g), level(0), max_level(0), step(0) {}
public:
   void entry(const TStackRuleItem& item) { rule_stack.push_back(item); level++; step++; if (max_level < level) max_level = level; }
   void entry(const GSymbol& symbol) { TStackRuleItem item(symbol); entry(item); }
   void leave() { level--; rule_stack.pop_back(); }
   TStackRuleItem& top() { return rule_stack.back(); }
   TStackRuleItem& stack_item(int index) { return rule_stack[index]; }
   bool empty() const    { return rule_stack.empty(); }
   int  filled() const   { return (int)rule_stack.size(); }
public:
   virtual void print_symbol(const GSymbol& symbol, int print_mode = 0x01) const { symbol.print(grammar,print_mode); }
   void print_stack() const { rule_stack.print(grammar); }
protected:
  TStackRule rule_stack;
public:
   int level, max_level, step;
   TGrammar*  grammar;
};

class M_Syntax : public A_Syntax 
{
public:
	M_Syntax(T_Scan *s);
   ~M_Syntax();
public:
   virtual void Store(T_ScanStore& store);
   virtual bool Restore(const T_ScanStore& store);
   virtual void print_store(FILE* file) const; 
   virtual bool Command(int command) { return false; }
   void Counts(int &tns, int &tls) const { tns = CountNodes(); tls = CountLexemes(); }
   void Trunc(int tns, int tls)          { TruncNodes(tns); TruncLexemes(tls); }
   virtual void PushLexeme(const T_Lexeme& lexeme);
   virtual void push_lexeme(const T_Lexeme& lexeme);
   void PushNode(TNode* node)   { nodes.push(node); }
   TNode* TopNode()             { if (nodes.empty()) return NULL; return nodes.top(); }
   TNode* PopNode()             { if (nodes.empty()) return NULL; TNode* node = nodes.top(); nodes.pop(); return node; }
   int  CountNodes() const      { return (int)nodes.size(); }
   void TruncNodes(int trunc)   { while (trunc < CountNodes()) { nodes.top()->clear(); nodes.pop();  trunc_node++; } }
   int  CountSNodes() const     { return (int)snodes.size(); }
   void TruncSNodes(int trunc)  { while (trunc < CountSNodes()) { snodes.top()->clear(); snodes.pop();  trunc_snode++; } }
   int  CountLexemes() const    { return (int)lexemes.size(); }
   void TruncLexemes(int trunc) { while (trunc < CountLexemes()) { lexemes.pop(); trunc_lexeme++; } }
   T_Lexeme& TopLexeme()        { return lexemes.top(); }
   T_Lexeme PopLexeme();
public:
   SNode& STop()         { return *snodes.top(); }
   SNode* SPop()         { SNode* ret = snodes.top(); snodes.pop(); return ret; }
   void SPush(SNode* n)  { snodes.push(n); }
   void SAdd(SNode* n)   { STop().Add(n); }
   bool SEmpty() const   { return !snodes.size(); }
public:
   virtual void Tree(SNode* node) { tree = node; }
   virtual SNode* Tree()          { return tree; }
protected:
   int trunc_node, trunc_lexeme, trunc_snode;
protected:
   std::stack<T_Lexeme> lexemes;
   std::stack<TNode*>  nodes;
   std::stack<SNode*> snodes;
public:
   virtual void ClearProgram();
   virtual TNode* Program();
public:
   TNode* program;
public:
   SNode* tree;
public:
   virtual TSyntaxTree* Auto() { return &unit; }
   virtual void Auto(T_SyntaxNode* node) { unit = node; }
public:
   TSyntaxTree unit;
public:
   const GMakerTable* makers;
};

// --------------------------- MC_Syntax ---------------------------
class MC_Syntax : public M_Syntax, public C_Syntax
{
public:
	MC_Syntax(T_Scan *s) :M_Syntax(s) {}

   bool Match(T_Lexeme::T_Syntax);
	bool Match(T_Lexeme::T_Group g);
	bool Match(T_Lexeme::T_Group g, T_Symbol::T_Type t);
	bool Match(A_Symbol::T_Priority priority);
	bool Match(T_Lexeme::W_Type keyword);

   bool Maker(const GSymbol& sym);
   bool MakerSyntaxNode(const GSymbol& sym, T_Lexeme_SNode* data_stack[], int maker_index = -1);
   virtual void Counts(int &tns, int &tls) const { tns = CountNodes(); tls = CountLexemes(); }
   virtual void Counts(int &tns, int &tls, int &tts) const { tns = CountNodes(); tls = CountLexemes(); tts = CountTypes(); }
   virtual void Store(T_ScanStore& store);
   virtual bool Restore(const T_ScanStore& store);
   virtual void print_store(FILE* file) const; 
   virtual void print_symbol(const GSymbol& symbol, int print_mode = 0x01) {}
};

class RSyntax : public MC_Syntax, public S_Syntax
{
public:
	RSyntax(T_Scan *s, TGrammar* g);
   virtual bool Parse();
   virtual bool ParseStack();
   virtual bool ParseStack_SN();
   virtual bool Parse(const GFormula& formula);
   virtual bool Parse(const GProduce& produce);
           int  MatchSymbol(const GSymbol& sym, int mode = 0x00); // 0x01 -!save
           bool MatchLexeme(const GSymbol& sym, int mode = 0x00); // 0x01 -!save
   virtual void print_symbol(const GSymbol& symbol, int print_mode = 0x01) { S_Syntax::print_symbol(symbol, print_mode); }
protected:
           int  ProduceToStack();
public:
   virtual bool Translate();
   virtual void clear(TNode* node);
public:
   virtual TNode* Program() { return M_Syntax::Program(); }
public:
   void set_syntax_mode(T_SyntaxMode m) { syntax_mode = m; }
   int rules_true, rules_false, produce_count, failure_count, luck_count;
};

#endif#if !defined(DEFINE_RULE_MACRO_H)
#define DEFINE_RULE_MACRO_H

#define FORMULA(TYPE)  { GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula,names.Add(#TYPE))); formula->title = #TYPE; formulas.Add(formula);
#define PRODUCE        { GProduce produce(GSymbol(GSymbol::gsProduce,formula->head.formula,formula->count())); formula->Add(produce); GProduce* rule = &formula->back();
#define END } 
#define TITLE(T)       rule->title = #T;

#define LEX(G)       { GSymbol item(GSymbol::gsTerminal,T_Lexeme::T_Group::gr##G,0); rule->Add(item); }
#define SYM(S)       { GSymbol item(GSymbol::gsTerminal,T_Lexeme::T_Group::grSeparator,A_Symbol::T_Type::lx##S); rule->Add(item); }
#define OPER(O)      { GSymbol item(GSymbol::gsTerminal,T_Lexeme::T_Group::grOper,A_Symbol::T_Type::lx##O); rule->Add(item); }
#define WORD(W)      { GSymbol item(GSymbol::gsTerminal,T_Lexeme::T_Group::grReserv,T_Lexeme::W_Type::rw##W); rule->Add(item); }
#define GROUP(G)     { GSymbol item(GSymbol::gsTerminal,T_Lexeme::T_Group::grSyntax,T_Lexeme::T_Syntax::sx##G); rule->Add(item); }
#define PRIOR(P)     { GSymbol item(GSymbol::gsTerminal,T_Lexeme::T_Group::grPriority,A_Symbol::T_Priority::pr##P); rule->Add(item); }
#define ERRORRULE(E) rule->error = T_Error::er##E;

#define MAKE(FUNC)      MODE(MAKE_(FUNC),GSymbol::Tree | GSymbol::Code)
#define MAKE_TREE(FUNC) MODE(MAKE_(FUNC),GSymbol::Tree)
#define MAKE_CODE(FUNC) MODE(MAKE_(FUNC),GSymbol::Code)
#define MAKE_YACC(FUNC) MODE(MAKE_(FUNC),GSymbol::Yacc)
#define MAKE_ALL(FUNC)  MODE(MAKE_(FUNC),GSymbol::Yacc | GSymbol::Code | GSymbol::Tree)

#define WARNING         rule->head.mode |= GSymbol::Warning;

#undef MAKE_
#if !defined(NO_GEN_MAKE)
   #define MAKE_(FUNC)  { GSymbol item(GSymbol::gsMaker,GMakerTable::maker_table.Find(#FUNC)); rule->Add(item); }
   #define PARAM(I,P)   I rule->OrParam(P);
   #define MODE(I,M)    I rule->OrMode(M);
   #define L            syn_tree
   #define MAKE_NODE(M,S,P) { GSymbol item(GSymbol::gsMaker,SNode::st##M,P,S,GSymbol::SNode); rule->Add(item); }
   #define MAKE_TURN(M,S,P) { GSymbol item(GSymbol::gsMaker,SNode::tt##M,P,SNode::st##S,GSymbol::Turn); rule->Add(item); }
#else
   #define PARAM(I,P)      
   #define MODE(I,M) 
   #define MAKE_(FUNC)      
   #define MAKE_NODE(M,S,P) 
   #define MAKE_TURN(M,S,P) 
#endif

#endif

#undef PRIOR
#define PRIOR(P)     { GSymbol item(GSymbol::gsTerminal,T_Lexeme::T_Group::grPriority,A_Symbol::T_Priority::pr##P); rule->Add(item); }

#undef MUST
#if   defined(DEFINE_GRAMMAR_LL) || defined(DEFINE_GRAMMAR_NL) || defined(DEFINE_GRAMMAR_ETF_LL)
#define MUST(I)      I rule->OrMode(GSymbol::T_Mode::Must);
#elif   defined(DEFINE_GRAMMAR_LR) || defined(DEFINE_GRAMMAR_ETF_LR) || defined(DEFINE_GRAMMAR_EEE_LR) || defined(DEFINE_GRAMMAR_NR)
#define MUST(I)      I
#endif

#undef FORMULA_PRIOR
#if   defined(DEFINE_GRAMMAR_LL) || defined(DEFINE_GRAMMAR_NL)

#define FORMULA_PRIOR(T,P)  \
   FORMULA(T) \
      PRODUCE RULE(P) MAKE_NODE(Copy,L(1,2),0) RULE(T##_) END \
   END \
   FORMULA(T##_) \
      PRODUCE PRIOR(T) RULE(P) MAKE(Binary) MAKE_NODE(Binary,L(3,1,2),0) MASTER END \
      EMPTY \
   END 

#elif   defined(DEFINE_GRAMMAR_LR) || defined(DEFINE_GRAMMAR_NR)

#define FORMULA_PRIOR(T,P)  \
   FORMULA(T) \
      PRODUCE MASTER PRIOR(T) RULE(P) MAKE(Binary) MAKE_TURN(Make,Binary,-2) MAKE_NODE(Binary,L(2,1,3),0) END \
      PRODUCE RULE(P) END \
   END

#define FORMULA_ASSOCIAT(T)  \
   PRODUCE MASTER PRIOR(T) MASTER MAKE(Binary) MAKE_TURN(Make,Binary,-2) MAKE_NODE(Binary,L(2,1,3),0) END

#endif

#undef MASTER
#undef EMPTY
#define MASTER       { GSymbol item(formula->head); item.mode |= GSymbol::Master; rule->Add(item); } 
#define RULE(T)      { GSymbol item(GSymbol::gsFormula,names.Add(#T)); rule->Add(item); }
#define EMPTY        PRODUCE END

#include "stdafx.h"

#include "Rules.h"
#include "RSyntax.h"
#include "Maker.h"
#include "Grammar.h"

const GSymbol GSymbol::none; const GSymbol GSymbol::empty(GSymbol::gsEmpty); const GSymbol GSymbol::eof(GSymbol::gsEof);
const GSymbol GSymbol::sharp(GSymbol::gsTerminal, T_Lexeme::grSpace);
const GSymbolSet GSymbolSet::none;

GSymbol::GSymbol(const T_Lexeme &lexeme)
{
   *this = lexeme;
}

GSymbol& GSymbol::operator = (const T_Lexeme &lexeme)
{
   if (lexeme.group == T_Lexeme::grEof) {
      type = gsEof; group = T_Lexeme::grNone; lexeme_type = 0; mode = 0; value = 0;
   } else {
      type = gsTerminal; group = lexeme.group; lexeme_type = lexeme.type; mode = 0; value = lexeme.value;
   }
   return *this;
}

bool GSymbol::operator == (const GSymbol& t2) const
{ 
   return ((type == t2.type) && (formula == t2.formula) && (produce == t2.produce) && 
           ((point == t2.point) || !IsPara() && !IsPoint() && !IsMaker()) && 
           ((mode  == t2.mode ) || !IsMaker())
          ); 
}

bool GSymbol::operator <  (const GSymbol& t2) const
{ 

   if (IsPara() && t2.IsPara() || IsMaker() && t2.IsMaker()) {
      return ((point > t2.point) ||
              (point == t2.point) && ((type <  t2.type) || 
                                      (type == t2.type) && ((formula <  t2.formula) || 
                                                            (formula == t2.formula) && ((produce <  t2.produce) ||
                                                                                        (produce == t2.produce) && (mode < t2.mode) && IsMaker()
                                                                                       )
                                                           ) 
                                     ) 
             ); 
   }

   return ((type <  t2.type) || 
           (type == t2.type) && ((formula <  t2.formula) || 
                                 (formula == t2.formula) && ((produce <  t2.produce) ||
                                                             (produce == t2.produce) && IsPoint() && (point <  t2.point)
                                                            )
                                ) 
          ); 
}

bool GSymbol::IsSaved() const
{
   if (!IsTerminal()) return false;
   if ((group == T_Lexeme::grOper) || (group == T_Lexeme::grInteger) || (group == T_Lexeme::grNumber) || (group == T_Lexeme::grIdent) || (group == T_Lexeme::grPriority)) return true;
   if ((group == T_Lexeme::grReserv) && (lexeme_type >= T_Lexeme::rwVoid) && (lexeme_type <= T_Lexeme::rwDefine)) return true; 
   if ((group == T_Lexeme::grSyntax) && (lexeme_type != T_Lexeme::sxEmptyBracket) && (lexeme_type != T_Lexeme::sxEmptyCramp) && (lexeme_type != T_Lexeme::sxEmptyScrape)) return true; 
   return false;
}

bool GSymbol::Cast()
{
   if (IsTerminal()) {
      if (group == T_Lexeme::grOper) {
         const T_Symbol& symbol = symbol_table().Symbol(value);
         if (symbol.priority) {
            group = T_Lexeme::grPriority; lexeme_type = symbol.priority;
            return true;
         }
      } else if (group == T_Lexeme::grPriority) {
         const T_Symbol& symbol = symbol_table().Symbol(value);
         group = T_Lexeme::grOper; lexeme_type = symbol.type;
         return true;
      } else if (group == T_Lexeme::grSyntax) {
         if ((lexeme_type == T_Lexeme::sxDefVar) || (lexeme_type == T_Lexeme::sxDefArr)) {
            lexeme_type = T_Lexeme::sxDefType;
            return true;
         } else if (lexeme_type == T_Lexeme::sxDefType) {
            group = T_Lexeme::grReserv; lexeme_type = T_Lexeme::W_Type::rwDefine;
            return true;
         }
      }
   }
   return false;
}

bool T_Lexeme::IsSaved() const
{
   return GSymbol(*this).IsSaved();
}

bool T_Lexeme::Cast()
{
   if (group == T_Lexeme::grOper) {
      const T_Symbol& symbol = symbol_table().Symbol(value);
      if (symbol.priority) {
         group = T_Lexeme::grPriority; type = symbol.priority;
         return true;
      }
   } else if (group == T_Lexeme::grPriority) {
      const T_Symbol& symbol = symbol_table().Symbol(value);
      group = T_Lexeme::grOper; type = symbol.type;
      return true;
   } else if (group == T_Lexeme::grSyntax) {
      if ((type == T_Lexeme::sxDefVar) || (type == T_Lexeme::sxDefArr)) {
         type = T_Lexeme::sxDefType;
         return true;
      } else if (type == T_Lexeme::sxDefType) {
         group = T_Lexeme::grReserv; type = T_Lexeme::W_Type::rwDefine;
         return true;
      }
   }
   return false;
}

const char* snode_title(int t);
void tree_syn(int s, int &s1, int &s2, int &s3, int &s4, int &s5); 

int  GSymbol::print_maker(int print_mode, FILE *file) const
{
   bool yacc_mode = (print_mode & T_PrintMode::pmYACCMode) != 0, macro_mode = (print_mode & T_PrintMode::pmMacroMode) != 0;
   bool syntax_tree = (print_mode & T_PrintMode::pmYACCStack) != 0;
   int my_mode = mode & (GSymbol::Tree | GSymbol::Code | GSymbol::Yacc | GSymbol::SNode | GSymbol::Turn);
   const char *yacc_sufix = "";
   if (syntax_tree) {
      if (yacc_mode) {
         yacc_sufix = ",$$,$1";
         my_mode &= (GSymbol::Yacc | GSymbol::SNode);
      }
   } else {
      if (yacc_mode) {
         my_mode &= (GSymbol::Tree | GSymbol::Code | GSymbol::Turn);
      }
   }
   static char buffer[20] = {};
   int len = 0;
   const char* title, *func_title, *command_title, *mode_title = "";
   if (my_mode & GSymbol::SNode) {
      func_title = snode_title(maker);
      title = "NODE";
      int s1, s2, s3, s4, s5;
      tree_syn(point, s1, s2, s3, s4, s5);
      int count_s = 0;
      if (s5) count_s = 5; else if (s4) count_s = 4; else if (s3) count_s = 3; else if (s2) count_s = 2; else count_s = 1;
      if (macro_mode) {
	      fprintf(file, "MAKE_%s(%s,L(", title, func_title); len += (int)strlen(title) + 9 + (int)strlen(func_title);
      } else {
	      fprintf(file, "{ %s(%s,L(", title, func_title); len += (int)strlen(title) + 6 + (int)strlen(func_title);
      }
      SPRINTF(buffer,"%d",s1); fprintf(file, "%s", buffer); len += (int)strlen(buffer);
      if (count_s > 1) { SPRINTF(buffer,",%d",s2); fprintf(file, "%s", buffer); len += (int)strlen(buffer); }
      if (count_s > 2) { SPRINTF(buffer,",%d",s3); fprintf(file, "%s", buffer); len += (int)strlen(buffer); }
      if (count_s > 3) { SPRINTF(buffer,",%d",s4); fprintf(file, "%s", buffer); len += (int)strlen(buffer); }
      if (count_s > 4) { SPRINTF(buffer,",%d",s5); fprintf(file, "%s", buffer); len += (int)strlen(buffer); }
      if (macro_mode) {
         SPRINTF(buffer,",%d",param);
         fprintf(file, ")%s)", buffer); len += 2 + (int)strlen(buffer);
      } else {
         if (param || yacc_mode) SPRINTF(buffer,",%d",param); else buffer[0] = 0;
         fprintf(file, ")%s%s); }", buffer, yacc_sufix); len += 5 + (int)strlen(buffer) + (int)strlen(yacc_sufix);
      }
   } else if (my_mode & GSymbol::Turn) {
      title = "TURN";
      command_title = turn_title(SNode::T_Turn(maker));
      func_title = snode_title(point);
      if (macro_mode) {
         SPRINTF(buffer,",%d",param);
   	   fprintf(file, "MAKE_%s(%s,%s%s)", title, command_title, func_title, buffer); len += (int)strlen(title) + 8 + (int)strlen(command_title) + (int)strlen(func_title) + (int)strlen(buffer);
      } else {
         if (param || yacc_mode) SPRINTF(buffer,",%d",param); else buffer[0] = 0;
   	   fprintf(file, "{ %s(%s,%s%s); }", title, command_title, func_title, buffer); len += (int)strlen(title) + 8 + (int)strlen(command_title) + (int)strlen(func_title) + (int)strlen(buffer);
      }
   } else if (my_mode) {
      func_title = maker_title(maker);
      switch (my_mode) {
      case (GSymbol::Tree | GSymbol::Code | GSymbol::Yacc) : mode_title = macro_mode ? "MAKE_ALL"  : "ALL" ; break;
      case (                                GSymbol::Yacc) : mode_title = macro_mode ? "MAKE_YACC" : "YACC"; break;
      case (GSymbol::Tree | GSymbol::Code                ) : mode_title = macro_mode ? "MAKE"      : "MAKE"; break;
      case (GSymbol::Tree                                ) : mode_title = macro_mode ? "MAKE_TREE" : "TREE"; break;
      case (                GSymbol::Code                ) : mode_title = macro_mode ? "MAKE_CODE" : "CODE"; break;
      }
      if (macro_mode) {
         fprintf(file, "%s(%s)", mode_title, func_title); len += 2 + (int)strlen(func_title) + (int)strlen(mode_title);
      } else {
         if (param || yacc_mode) SPRINTF(buffer,",%d",param); else buffer[0] = 0;
         fprintf(file, "{ %s(%s%s%s); }", mode_title, func_title, buffer, yacc_sufix); len += 7 + (int)strlen(func_title) + (int)strlen(buffer) + (int)strlen(mode_title) + (int)strlen(yacc_sufix);
      }
   }
   return len;
}

int GSymbol::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   if (!file) file = stdout;
   int len = 0;
   if (type == gsTerminal) {
      bool yes_print = false;
      if (print_mode & T_PrintMode::pmBNF) {
         if ((group == T_Lexeme::grOper) || (group == T_Lexeme::grSeparator)) {
            const T_Symbol& symbol = symbol_table().Symbol((T_Symbol::T_Type)lexeme_type);
            if ((lexeme_type == T_Symbol::lxOr) || (lexeme_type == T_Symbol::lxLeftCramp) || (lexeme_type == T_Symbol::lxRightCramp)) {
               fprintf(file, "\'%c\'", symbol.text[0]);
               len += (int)strlen(symbol.text) + 2;
               yes_print = true;
            } else {
               fprintf(file, "%s", symbol.text);
               len += (int)strlen(symbol.text);
            }
         } else if (group == T_Lexeme::grReserv) {
            const char* title = T_Lexeme::word_table->Word((T_Lexeme::W_Type)lexeme_type).text;
            fprintf(file, "%s", title);
            len += (int)strlen(title);
         } else if ((group == T_Lexeme::grIdent) && T_Lexeme::print_scan) {
            T_Lexeme lexeme(group, type); lexeme.value = value;
            const char* title = T_Lexeme::print_scan->Text(lexeme);
            fprintf(file, "%s", title);
            len += (int)strlen(title);
         } else if ((group == T_Lexeme::grIdent) || (group == T_Lexeme::grInteger) || (group == T_Lexeme::grNumber)) {
            const char* title = group_title(group);
            fprintf(file, "%s_lexeme", title);
            len += (int)strlen(title) + 7;
         } else if (group == T_Lexeme::grSyntax) {
            const char* title_group = group_title(group); len += (int)strlen(title_group);
            const char* title_type  = lexeme_syntax_title((T_Lexeme::T_Syntax)lexeme_type); len += (int)strlen(title_type) + 1;
            fprintf(file, "%s_%s", title_group, title_type);
         } else if (group == T_Lexeme::grPriority) {
            const char* title_group = group_title(group); len += (int)strlen(title_group);
            const char* title_type  = lexeme_priority_title((T_Symbol::T_Priority)lexeme_type); len += (int)strlen(title_type) + 1;
            fprintf(file, "%s_%s", title_group, title_type);
         }
         yes_print = true;
      } else if (print_mode & T_PrintMode::pmSymbolOper) {
         if ((group == T_Lexeme::grOper) || (group == T_Lexeme::grSeparator)) {
            const T_Symbol& symbol = symbol_table().Symbol((T_Symbol::T_Type)lexeme_type);
            if (!symbol.text[1]) { // len == 1
               fprintf(file, "\'%c\'",symbol.text[0]); 
               len += 3;
               yes_print = true;
            } else {
               fprintf(file, "\'%s\'", symbol.text);
               len += (int)strlen(symbol.text) + 2;
               yes_print = true;
            }
         }
      }
      if (!yes_print) {
         fprintf(file, "<"); 
         len += 2 + T_Lexeme::print(T_Lexeme::T_Group(group), lexeme_type, T_PrintMode::pmPrintItem | print_mode,file);
         fprintf(file, ">"); 
      }
   } else if (type == gsFormula) {
      const GFormula& f = *(const GFormula*)grammar->formulas[formula];
      len += f.write_title(file);
   } else if (type == gsProduce) {
      const GFormula& f = *(const GFormula*)grammar->formulas[formula]; 
      const GProduce& p = f[produce];
      const char* title = f.title;
      if (title) {
         fprintf(file, "[%3d] %s", produce, title); len += 6 + (int)strlen(title); 
      } else {
         fprintf(file, "[%3d] _f_%05d_", produce, formula); len += 15;
      }
   } else if ((type == gsPara) || (type == gsPoint)) {
      const GFormula& f = *(const GFormula*)grammar->formulas[formula]; 
      const GProduce& p = f[produce];
      const char* title = f.title;
      if (title) {
         fprintf(file, "(%d)[%3d] %s"  , point, produce, title); len += 9 + (int)strlen(title); 
      } else {
         fprintf(file, "(%d)[%3d] _f_%05d_", point, produce, formula); len += 18;
      }
   } else if (type == gsMaker) {
      len += print_maker(print_mode, file);
   } else if (type == gsSituation) {
      const char* title = symbol_title(type);
	   fprintf(file, "%s: %05d", title, situation); len += (int)strlen(title) + 7;
   } else if (type == gsPoint) {
      const char* title = symbol_title(type);
	   fprintf(file, "(%s,%d,%d,%d)", title,formula,produce,point); len += (int)strlen(title);
   } else if (type == gsVector) {
      union { const TGrammar* c_grammar; TGrammar* n_grammar; } my_grammar; my_grammar.c_grammar = grammar;
      const GSymbolVector& vector = my_grammar.n_grammar->Vector(*this);
      if (vector.count() == 1) return vector.front().print(grammar, print_mode, file);
      fprintf(file, " { ");
      vector.print(grammar, print_mode, file);
      fprintf(file, " } ");
      len = SYMBOL_PRINT_TITLE_LEN;
   } else if (type == gsTable) {
      if (!(print_mode & T_PrintMode::pmTableLLk)) {
         const char* title = symbol_title(type);
         fprintf(file, "%s: %05d", title, situation); len += (int)strlen(title) + 7;
      } else {
         return grammar->GetLLkA(*this).print(grammar, print_mode, file);
      }
   } else if (type == gsEof) {
      const char* title = symbol_title((print_mode & T_PrintMode::pmEofToEmpty) ? gsEmpty : type);
      fprintf(file, "%s", title); len += (int)strlen(title);
   } else {
      const char* title = symbol_title(type);
	   fprintf(file, "%s", title); len += (int)strlen(title);
   }
   if (!(print_mode & T_PrintMode::pmCompact)) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
   return len;
}

void GSymbol::write(FILE *file, const TGrammar* grammar, int print_mode) const
{
   if (print_mode == T_PrintMode::pmWriteSymbol) {
      fprintf(file, "GSymbol(GSymbol::gs%s,%d,%d,%d,%d)",symbol_title(type),formula,produce,point,mode);
   } else if (print_mode == T_PrintMode::pmWriteZero) {
      fprintf(file, "%02d %04d %04d %04d %04d",type,formula,produce,point,mode);
   } else if (print_mode == T_PrintMode::pmWriteProg) {
      fprintf(file, "%d,%d,%d,%d,%d",type,formula,produce,point,mode);
   } else {
      fprintf(file, "%d %d %d %d %d",type,formula,produce,point,mode);
   }
}

bool GSymbol::read (FILE *file, const TGrammar* grammar, int print_mode)
{
   FSCANF(file, "%d %d %d %d %d",&type,&formula,&produce,&point,&mode);
   return true;
}

GSymbolVector::GSymbolVector(const GSymbolVector& v, int mask)
{
   for (const GSymbol& sym : v) {
      int m = 0x01 << (sym.type - 1);
      if (m  & mask) {
         Add(sym);
      }
   }
}

GSymbolVector& GSymbolVector::operator << (const GSymbolVector& v) 
{ 
   for (const GSymbol& s : v) {
      push_back(s); 
   }
   return *this; 
}

int  GSymbolVector::Find(const GSymbol& sym, int beg) const
{
   for (int i = beg; i < count(); i++) {
      if (sym == (*this)[i]) return i;
   }
   return -1;
}

void GSymbolVector::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   if (!file) { file = stdout; }
   for (const GSymbol &item : *this) {
      item.print(grammar, print_mode, file);
      if (print_mode & T_PrintMode::pmCompact) fprintf(file, "  ");
   }
}

void GSymbolVector::write(FILE *file, const TGrammar* grammar, int print_mode) const
{
   if (!file) { file = stdout; }
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
   } else if (print_mode == T_PrintMode::pmWriteZero) {
      fprintf(file, "%05d\n",count());
   } else if (print_mode == T_PrintMode::pmWriteSimple) {
      fprintf(file, "%d",count());
   }
   int row = 0;
   for (const GSymbol &item : *this) {
      if ((print_mode == T_PrintMode::pmWriteSimple) || (print_mode == T_PrintMode::pmWriteZero)) fprintf(file, " ");
      if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "{");
      item.write(file, grammar, print_mode);
      if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "}");
      if (++row < count()) { if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, ","); }
   }
   if (print_mode == T_PrintMode::pmWriteSimple) fprintf(file, "\n");
}

bool GSymbolVector::Have(const GSymbol& sym) const
{
   for (const GSymbol& item : *this) 
   {
      if (item == sym) return true;
   }
   return false;
}

GSymbol GVectors::Add(const GSymbolVector& key)
{ 
//   if (key.empty()) return GSymbol::none;
//   if (key.IsEmpty()) return GSymbol::empty;
//   if (key.count() == 1) return key.front();
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(&key));
   if (ip != map.end()) {
      std::pair<const Key, const GSymbol&> item = (*ip);
      return item.second;
   }
   GSymbol sym(GSymbol::gsVector, count());
   GSymbolVector* body = new GSymbolVector(key);
   vector.push_back(body);
   std::pair<const Key, const GSymbol&> item(body, sym);
   map.insert(item);
   return sym;
}

const GSymbol& GVectors::Find(const GSymbolVector& key) const
{
   std::map<const Key, const GSymbol>::const_iterator ip = map.find(Key(&key));
   if (ip != map.end()) {
      std::pair<const Key, const GSymbol&> item = (*ip);
      return item.second;
   }
   return GSymbol::none;
}

void GVectors::clear()
{
   map.clear();
   std::vector<const GSymbolVector*>::iterator ip = vector.begin();
   while (ip != vector.end())
   {
      delete *ip; 
      ip = vector.erase(ip);
   }
}

bool GVectors::read(FILE* file, int print_mode)
{
   int my_count;
   FSCANF(file, "%d", &my_count);
   for (int i = 0; i < my_count; i++) {
      GSymbolVector body; int sym_count;
      FSCANF(file, "%d", &sym_count);
      for (int i = 0; i < sym_count; i++) {
         GSymbol sym;
         sym.read(file, NULL, print_mode);
         body << sym;
      }
      Add(body);
   }
   return true;
}

void GVectors::write(FILE* file, int print_mode) const
{
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "\nvoid make_vectors(TGrammar& grammar)\n{\n");
   } else {
      fprintf(file, "%d\n", count());
   }
   for (const GSymbolVector* body : vector)
   {
      if (print_mode == T_PrintMode::pmWriteProg) {
         fprintf(file, "{ static const int I[][5] = {");
      }
      body->write(file, NULL, print_mode);
      if (print_mode == T_PrintMode::pmWriteProg) {
         fprintf(file, "}; ");
         fprintf(file, "grammar.AddVector(");
         fprintf(file, "%d, I);", body->count());
         fprintf(file, " }");
         fprintf(file, "\n");
      }
   }
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "}\n");
   }
}

int GSymbolSet::operator += (const GSymbol& s)
{
   int ret = Add(s);
   return ret;
}

GSymbolSet& GSymbolSet::operator << (const GSymbol& s)
{
   Add(s);
   return *this;
}

int GSymbolSet::operator += (const GSymbolSet& m)
{
   int ret = 0;
   for (const GSymbol& item : m) {
      if (Add(item)) ret++;
   }
   return ret;
}

GSymbolSet GSymbolSet::operator * (const GSymbolSet& join) const
{
   GSymbolSet ret;
   for (const GSymbol& sym : join) {
      if (Have(sym)) ret += sym;
   }
   return ret;
}

GSymbolSet GSymbolSet::operator - (const GSymbolSet& join) const
{
   GSymbolSet ret;
   for (const GSymbol& sym : (*this)) {
      if (!join.Have(sym)) ret += sym;
   }
   return ret;
}

bool GSymbolSet::Have(const GSymbol& sym) const
{ 
   const_iterator ip = find(sym); 
   return (ip != end());
}

bool GSymbolSet::Add(const GSymbol& sym)
{ 
   const_iterator ip = find(sym); 
   if (ip != end()) return false;
   insert(sym);
   return true; 
}

bool GSymbolSet::Del(const GSymbol& sym)
{
   const_iterator ip = find(sym);
   if (ip == end()) return false;
   erase(ip);
   return true;
}

void GSymbolSet::Plus(const GSymbolSet& left, const GSymbolSet& right)
{
   GSymbolSet& result = *this;
   if (left.empty())  { result = right; return; }
   if (right.empty()) { result = left;  return; }
   for (const GSymbol& v1 : left) {
      if (v1.IsEmpty()) {
         result += right;
      } else {
         result += v1;
      }
   }
}

void GSymbolSet::print(const TGrammar* grammar, int print_mode, FILE *file) const
{
   if (!file) { file = stdout; }
   int i = 0;
   for (const GSymbol& item : *this) {
      if (!(i++ % 10) && (i > 1) && (print_mode & T_PrintMode::pmMultiLine) || (print_mode & T_PrintMode::pmPrintItem)) {
         fprintf(file, "\n");
         if (print_mode & T_PrintMode::pmSpaces) fprintf(file, "   ");
         int len = 0;
         if (print_mode & T_PrintMode::pmOffset) while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
      }
      item.print(grammar, print_mode, file);
      if (print_mode & T_PrintMode::pmCompactGroup) fprintf(file, "   ");
   }
}

void TTwoSym::print(const TGrammar* grammar, int print_mode, FILE* file) const
{
   fprintf(file, "{");
   if (!one.IsNone() || !(print_mode & T_PrintMode::pmNoPrintNone)) {
      one.print(grammar, print_mode, file);
   } else {
      int len = SYMBOL_PRINT_TITLE_LEN;
      fprintf(file, "%*c", len, ' ');
   }
   fprintf(file, ","); two.print(grammar, print_mode, file); fprintf(file, "}");
}

bool TwoSymGSymbolSetMap::Add(const TTwoSym& key, const GSymbol& sym)
{
   iterator ip = find(key);
   if (ip == end()) {
      std::pair<const TTwoSym&, GSymbolSet> item(key, GSymbolSet());
      insert(item);
      ip = find(key);
   }
   return (*ip).second.Add(sym);
}

const GSymbolSet& TwoSymGSymbolSetMap::Get(const TTwoSym& key) const
{
   const_iterator ip = find(key);
   return (ip == end()) ? GSymbolSet::none : (*ip).second;

}

bool TRuleNames::verify(const GFormulaTable& formulas) const
{
	printf("\n--- RuleNames --- <%d> ---\n", (int)indexs.size());
   bool ret = true;
   for (const std::pair<const Key, const int> item : indexs) {
      int type = item.second;
   }
   return ret;
}

bool GProduce::IsEmpty() const
{
   for (const GSymbol &sym : *this) {
      if (!sym.IsEmpty() && !sym.IsMaker()) return false;
   }
   return true;
}

bool GProduce::IsChain() const
{
   return (count() == 1) && maker.IsNone() && front().IsFormula();
}

bool GProduce::HaveMaster() const
{
   bool ret = false;
   for (const GSymbol &sym : *this) {
      if (sym.mode & GSymbol::Master) { ret = true; break; }
   }
   return ret;
}

void GProduce::Tail(int point, GSymbolVector& tail) const
{
   for (int i = point; i < count(); i++) {
      tail << (*this)[i];
   }
}

void GProduce::TailWithoutMaker(int point, GSymbolVector& tail) const
{
   for (int i = point; i < count(); i++) {
      const GSymbol& sym_tail = (*this)[i];
      if (sym_tail.IsMaker()) continue;
      tail << sym_tail;
   }
}

int  GProduce::Count() const
{
   int ret = 0;
   for (const GSymbol &sym : *this) {
      if (sym.IsTerminal() || sym.IsFormula()) ret++;
   }
   return ret;
}

int  GProduce::Real(int mode) const
{
   int ret = 0;
   for (const GSymbol &sym : *this) {
      if ((sym.IsTerminal() && (sym.IsSaved() || (mode & 0x01) && (sym == GSymbol::sharp))) || sym.IsFormula()) ret++;
   }
   return ret;
}

int  GProduce::Master() const
{
   int master = 0, index = 0;
   for (const GSymbol &sym : *this) {
      index++;
      if (sym.IsMaster()) {
         if (master) return 0;
         master = index;
      }
   }
   return master;
}

void GProduce::Add(const GSymbol& s)
{ 
#ifndef PRODUCE_ITEM_EMPTY
   if (s.IsEmpty()) return;
#endif
   push_back(s); 
}

void GProduce::Shift(GSymbol& para) const
{
   para.point++;
/*
   for (para.point++; para.point < count(); para.point++) {
      if (!(*this)[para.point].IsMaker()) return;
   }
*/
}

void GProduce::write(FILE *file, const TGrammar* grammar, int print_mode) const
{
   if (print_mode == T_PrintMode::pmWriteSymbol) {
      fprintf(file, "grammar.AddProduce(");
   } else if (print_mode != T_PrintMode::pmWriteProg) {
      fprintf(file, "%d ",count());
   }
   if ((print_mode != T_PrintMode::pmWriteProg) && ((print_mode != T_PrintMode::pmWriteSymbol) || maker.IsMaker())) {
      maker.write(file, grammar, print_mode); 
   }
   if (print_mode == T_PrintMode::pmWriteSymbol) {
      fprintf(file, ");\n");
   } else if (print_mode != T_PrintMode::pmWriteProg) {
      fprintf(file, " ");
   }
   if (print_mode == T_PrintMode::pmWriteProg) {
      fprintf(file, "{ static const int I[][5] = {");
   }
   int row = 0;
   for (const GSymbol& item : *this) {
      if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, "grammar.AddItem(");
      if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "{");
      item.write(file, grammar,print_mode); 
      if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "}");
      if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, ");");
      if (++row < count()) { if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, ","); else fprintf(file, " "); }
   }
   if (print_mode == T_PrintMode::pmWriteProg) {
      if (empty()) { fprintf(file, "{"); GSymbol::empty.write(file, grammar,print_mode); fprintf(file, "}"); }
      fprintf(file, "}; ");
      fprintf(file, "grammar.AddProduce(");
      if (maker.IsMaker()) {
         maker.write(file, grammar, 0x03); 
         fprintf(file, ", ");
      }
      fprintf(file, "%d, I);",count());
      fprintf(file, " }");
   }
   fprintf(file, "\n");
}

bool GProduce::read (FILE *file, const TGrammar* grammar, int print_mode)
{
   int my_count;
   FSCANF(file,"%d",&my_count);
   maker.read(file, grammar,print_mode);
   for (int i = 0; i < my_count; i++) {
      GSymbol sym;
      sym.read(file, grammar,print_mode);
      Add(sym);
   }
   return true;
}

void GProduce::print(const TGrammar* grammar, int print_mode, FILE* file, int point) const
{
   int len = 0;
   if (print_mode & T_PrintMode::pmProduceHead) {
      len += head.print(grammar, print_mode, file);
      len = 0;
      if (print_mode & T_PrintMode::pmCompact) { fprintf(file, "   "); len += 3; }
      if (maker.IsMaker()) {
         len += maker.print(grammar, print_mode, file) - 1;
      }
      if (len && !(print_mode & T_PrintMode::pmCompact)) while (len++ < MAKER_PRINT_TITLE_LEN) fprintf(file, " "); else fprintf(file, "   ");
   }
   if (!(print_mode & T_PrintMode::pmGrammar)) fprintf(file, "-> ");
   bool compact = (print_mode & T_PrintMode::pmCompactGroup) != 0;
   int  i = 0;
   for (const GSymbol& item : *this) {
      if (i == point) fprintf(file, " . ");
      int len = item.print(grammar, print_mode, file);
      if (!(print_mode & T_PrintMode::pmCompact) && (len > SYMBOL_PRINT_TITLE_LEN + 1)) {
         len -= SYMBOL_PRINT_TITLE_LEN + 1;
         while (len++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " ");
         if (compact) fprintf(file, "   ");
      }
      i++;
      if ((i != point) && (i < count()) && compact) fprintf(file, "   ");
   }
   if (i == point) fprintf(file, " . ");
}

bool GFormula::HaveEmpty() const
{
   bool ret = !size();
   for (const GProduce& produce : (*this)) {
      if (produce.IsEmpty()) return true;
   }
   return ret;
}

bool GFormula::HaveChain() const
{
   for (const GProduce& produce : (*this)) {
      if (produce.IsChain()) return true;
   }
   return false;
}

bool GFormula::IsRecursive() const
{
   for (const GProduce& produce : (*this)) {
      if (produce.HaveMaster()) return true;
   }
   return false;
}

void GFormula::print(const TGrammar* grammar, int print_mode, FILE* file) const
{
   int len_formula = 0;
   fprintf(file, "\n");
   if (print_mode & T_PrintMode::pmGrammar) {
      len_formula = head.print(grammar,print_mode,file);
      if (print_mode & T_PrintMode::pmCompact) len_formula = 10;
      int len = (print_mode & T_PrintMode::pmCompact) ? len_formula : SYMBOL_PRINT_TITLE_LEN;
      fprintf(file, "\n%*c",len,' ');
      fprintf(file, (print_mode & T_PrintMode::pmBNF) ? "::= " : ":   ");
   } else {
//      fprintf(file, "Formula:"); 
      len_formula = head.print(grammar,print_mode | T_PrintMode::pmCompact,file);
      fprintf(file, ":"); 
      len_formula += (print_mode & T_PrintMode::pmProduceHead) ? 1 : -2;
      if (!(print_mode & T_PrintMode::pmCompact)) while (len_formula++ < SYMBOL_PRINT_TITLE_LEN) fprintf(file, " "); else  fprintf(file, "   ");
      fprintf(file, "used=%d, %05d", used, head.formula);
   }
   for (const GProduce& produce : (*this)) {
      if (!(print_mode & T_PrintMode::pmGrammar)) fprintf(file, "\n");
      produce.print(grammar,print_mode,file);
      if (print_mode & T_PrintMode::pmGrammar) {
         int len = (print_mode & T_PrintMode::pmCompact) ? len_formula : SYMBOL_PRINT_TITLE_LEN;
         fprintf(file, "\n%*c",len,' ');
         if (produce.head.produce + 1 == count()) {
            if (!(print_mode & T_PrintMode::pmBNF)) fprintf(file, ";");
         } else {
            fprintf(file, "|   ");
         }
      }
   }
}

void GFormula::write(FILE *file, const TGrammar* grammar, int print_mode) const
{
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "grammar.AddFormula(\"");
   } else {
      fprintf(file, "%d ",count());
   }
   if (title) {
      fprintf(file, "%s",title);
   } else {
      fprintf(file, "_f_%05d_",head.formula);
   }
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "\");\n");
   } else {
      fprintf(file, "\n");
   }
   for (const GProduce& produce : (*this)) {
      produce.write(file, grammar, print_mode);
   }
}

bool GFormula::read (FILE *file, const TGrammar* grammar, int print_mode)
{
   int my_count;
   char buffer[50];
   FSCANF(file,"%d ",&my_count);
   FSCANF(file,"%50s",buffer,50);
//   fscanf_s(file,"%d %50s",&my_count,&buffer);
   size_t len = strlen(buffer); 
   char* my_title = (char*)malloc(len + 1);
   STRCPY(my_title,len + 1,buffer); 
   title = my_title;
   for (int i = 0; i < my_count; i++) {
      const GProduce produce_(GSymbol(GSymbol::gsProduce,head.formula,i));
      Add(produce_);
      GProduce& produce = back();
      produce.read(file,grammar,print_mode);
   }
   return true;
}

int  GFormula::write_title(FILE *file, const TGrammar* grammar, int print_mode) const
{
   int len = 0;
   const char *my_prefix = (print_mode & T_PrintMode::pmPrintPrefix) ? grammar->prefix : "";
   if (title) {
      fprintf(file, "%s%s", my_prefix, title); len += (int)strlen(my_prefix) + (int)strlen(title);
   } else {
      fprintf(file, "%s_f_%05d_", my_prefix, head.formula); len += 4 + 5;
   }
   return len;
}

GFormulaTable::GFormulaTable(const GFormulaTable& join)
  :root(NULL), readed(false) 
{
   for (const GFormula* item : join) {
      push_back(new GFormula(*item));
   }
}

GFormulaTable::~GFormulaTable()
{
   for (const GFormula* item : (*this)) {
      if (readed) { delete item->title; }
//      delete item;
   }
}

void GFormulaTable::Copy(const GFormulaTable& join)
{
   for (const GFormula* item : join) {
      push_back(new GFormula(*item));
   }
}

void GFormulaTable::print(const TGrammar* grammar, int print_mode, FILE* file) const
{
   if (print_mode == 0x00) return; 
   for (const GFormula *item : *this) {
      FORMULA_DELETED_CONTINUE(item);
      item->print(grammar,print_mode,file);
   }
   fprintf(file, "\n");
}

const char* symbol_title(GSymbol::T_Type type)
{
   static const char* title[] = {
      "None", "Formula", "Produce", "Terminal", "Vector", "Empty", "Eof", "Maker", "Rule", "Point", "Para", "Situation", "Table"
   };
   if ((type < 0) || (type >= sizeof(title))) return "### error ###";
   return title[type];
}

bool GFormulaTable::Add(GFormula* f, int &index)
{
   for (int i = 0; i < (int)(*this).size(); i++) {
      const GFormula *formula = (*this)[i];
      if (formula->title && !strcmp(formula->title, f->title)) {
         index = i;
         return false;
      }
   }
   push_back(f);
   index = count() - 1;
   return true;
}

GFormula* GFormulaTable::Find(const char* title)
{
   for (int i = 0; i < (int)(*this).size(); i++) {
      GFormula *formula = (*this)[i];
      if (formula->title && !strcmp(formula->title, title)) {
         return formula;
      }
   }
   return NULL;
}

bool GFormulaTable::make(TRuleNames& names)
{
   bool ret = names.verify(*this);
   printf("\n");
   std::vector<int> N2F;

   N2F.resize(names.Count(),-1);
   for (int f = 0; f < count(); f++) {
      const GFormula *formula = (*this)[f];
      N2F[formula->head.formula] = f;
   }

   TNameTable errors;
   for (GFormula *formula : *this) {
      formula->head.formula = N2F[formula->head.formula];
      for (GProduce& produce: *formula) {
         produce.head.formula = formula->head.formula;
         for (GSymbol& sym : produce) {
            if (sym.IsFormula()) {
               int order_formula = sym.formula;
               sym.formula = N2F[sym.formula];
               if (sym.formula < 0) {
                  errors.Add(names.Name(order_formula));
                  ret = false;
               }
            }
         }
      }
   }

   if (errors.Count()) {
      fprintf(stdout, "\nno rules:\n");
      for (int i = 0; i < errors.Count(); i++) {
         fprintf(stdout, "%s\n", errors.Name(i));
      }
   }
   root = front();

   return ret;
}

bool GFormulaTable::make(TRuleNames& names,TLexemeSet& lexemes)
{
   bool ret = make(names);

   root = front();
   Used(lexemes);
   return ret;
}

void GFormulaTable::Used(TLexemeSet& lexemes)
{
   used.clear();
   used.resize(count(),0);
   for (const GFormula* formula : *this) {
      formula->used = 0;
   }
   root = front();
   Used(*root);

   int new_formula = 0;
   for (int& cur_formula : used) {
      cur_formula = cur_formula ? new_formula++ : -1;
   }
   lexemes.clear();
   for (GFormula* formula : *this) {
      int new_formula = used[formula->head.formula];
      formula->head.formula = new_formula;
      if (new_formula < 0) continue;
      for (GProduce& produce : *formula) {
         produce.head.formula = new_formula;
         for (GSymbol& sym : produce) {
            if (sym.IsFormula()) {
               sym.formula = used[sym.formula];
            } else if (sym.IsTerminal()) {
               lexemes.Add(sym);
            }
         }
      }
   }
   iterator ip = begin();
   while(ip != end()) {
      GFormula* formula = *ip;
      if (formula->head.formula < 0) {
         ip = erase(ip);
         delete formula;
      } else {
         ip++;
      }
   }
}

void GFormulaTable::Used(const GFormula& formula)
{
   used[formula.head.formula]++;
   if (formula.used++) return;
   for (const GProduce& produce : formula) {
      for (const GSymbol& sym : produce) {
         if (sym.IsFormula()) {
            const GFormula& used = *(*this)[sym.formula];
            Used(used);
         }
      }
   }
}

void TGrammar::Used()
{
   formulas.Used(lexemes);
}

void GFormulaTable::write(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   write(file, print_mode);
   if (title) {
      fclose(file);
   }
}

void GFormulaTable::write(FILE* file, int print_mode) const
{
   if (print_mode == T_PrintMode::pmWriteSimple) {
      fprintf(file, "%d\n",count());
   } else if (print_mode == T_PrintMode::pmWriteZero) {
      fprintf(file, "%05d\n",count());
   } else if (print_mode == T_PrintMode::pmWriteSymbol) {
   }
   for (const GFormula *formula : *this) {
      formula->write(file, NULL, print_mode);
   }
   if (print_mode == T_PrintMode::pmWriteSymbol) {
   }
}

bool GFormulaTable::read(const char* title, int print_mode)
{
   FILE *file = NULL;
   if (!title) title = "formula_table.txt";
	FOPEN(file, title, "r");
   if (!file) return false;
   read (file, print_mode);
   fclose(file);
   return true;
}

bool GFormulaTable::read(FILE* file, int print_mode)
{
   clear();
   readed = true;
   int my_count, index;
   FSCANF(file,"%d",&my_count);
   for (int i = 0; i < my_count; i++) {
      GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula,i));
      formula->read(file,NULL,print_mode);
      if (!Add(formula, index)) return false;
   }
   if (count()) root = front();
   return true;
}

void TGrammar::write(FILE* file, int print_mode) const
{
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "\nvoid make_formulas(TGrammar& grammar)\n{\n");
      fprintf(file, "grammar.type = T_Grammar(%d); grammar.look_ahead = %d;\n", type, look_ahead);
   } else {
      fprintf(file, "%d %d\n", type, look_ahead);
   }
   formulas.write(file,print_mode);
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "}\n");
   }
   Vectors().write(file, print_mode);
}

bool TGrammar::read(FILE* file, int print_mode)
{
   int _type; FSCANF(file, "%d %d", &_type, &look_ahead); type = (T_Grammar)_type;
   if (!formulas.read(file, T_PrintMode::pmWriteSimple)) return false;
   return Vectors().read(file, T_PrintMode::pmWriteSimple);
}

void TGrammar::write(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   write(file,print_mode);
   if (title) {
      fclose(file);
   }
}

void TGrammar::print_(FILE* file, int print_mode) const
{
   int produce_count = 0, used_count = 0;
   for (const GFormula *item : formulas) {
      FORMULA_DELETED_CONTINUE(item);
      produce_count += item->count();
      if (item->used) used_count++;
   }
   if (!(print_mode & T_PrintMode::pmGrammar)) fprintf(file, "\n--- %sGrammar --- <%d> --- <%d> --- <%d> --- <%d> ---\n", prefix, count(), produce_count, used_count, Vectors().count());
   formulas.print(this, print_mode, file);
}

void TGrammar::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   print_(file, print_mode);
   if (title) {
      fclose(file);
   }
}

void TGrammar::grammar_type()
{
   int type_type = type, type_lexeme = lexemes.grammar_type();
   int type_maker = T_Grammar::mtNone, type_grammar = T_Grammar::gtNone;
   for (const GFormula* formula : formulas) {
      for (const GProduce& produce : *formula) {
         if (produce.count()) {
            if (produce[0].mode & GSymbol::Master) { type_grammar |= T_Grammar::gtLR; type_type &= ~T_Grammar::gtLL; }
         }
         for (const GSymbol& sym : produce) {
            if (sym.IsMaker()) {
               if (sym.IsMakerTree()) type_maker |= T_Grammar::mtTree;
               if (sym.IsMakerCode()) type_maker |= T_Grammar::mtCode;
               if (sym.IsMakerYACC()) type_maker |= T_Grammar::mtYacc;
               if (sym.IsMakerNode()) type_maker |= T_Grammar::mtSNode;
               if (sym.IsMakerTurn()) type_maker |= T_Grammar::mtTurn;
            }
         }
         const GSymbol& sym = produce.maker;
         if (sym.IsMaker()) {
            if (sym.IsMakerTree()) type_maker |= T_Grammar::mtTree;
            if (sym.IsMakerCode()) type_maker |= T_Grammar::mtCode;
            if (sym.IsMakerYACC()) type_maker |= T_Grammar::mtYacc;
            if (sym.IsMakerNode()) type_maker |= T_Grammar::mtSNode;
            if (sym.IsMakerTurn()) type_maker |= T_Grammar::mtTurn;
         }
      }
   }
   type_type |= type_lexeme | type_maker | type_grammar;
   type = (T_Grammar)type_type;
}

GFormula*  TGrammar::AddFormula(const char* title)
{
   GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula,formulas.count()));
   formula->title = title;
   int index;
   if (!formulas.Add(formula, index)) {
      delete formula;
      formula = formulas[index];
   }
   return formula;
}

void TGrammar::AddProduce()
{
   GFormula* formula = formulas.back();
   GProduce produce(GSymbol(GSymbol::gsProduce,formula->head.formula,formula->count()));
   formula->Add(produce);
}

void TGrammar::AddProduce(const GSymbol &sym)
{
   AddProduce();
   GFormula* formula = formulas.back();
   GProduce& produce = formula->back();
   produce.maker = sym;
}

void TGrammar::AddProduce(int count, const int I[][5])
{
   AddProduce(); AddItems(count, I);
}

void TGrammar::AddProduce(const GSymbol &sym, int count, const int I[][5])
{
   AddProduce(sym); AddItems(count, I);
}

void TGrammar::AddItem(const GSymbol &sym)
{
   GFormula* formula = formulas.back();
   GProduce& produce = formula->back();
   produce.Add(sym);
}

void TGrammar::AddItems(int count, const int I[][5])
{
   GFormula* formula = formulas.back();
   GProduce& produce = formula->back();
   for (int i = 0; i < count; i++) {
      const GSymbol sym((GSymbol::T_Type)I[i][0],I[i][1],I[i][2],I[i][3],I[i][4]);
      produce.Add(sym);
   }
}

void TGrammar::AddVector(int count, const int I[][5])
{
   GSymbolVector vector;
   for (int i = 0; i < count; i++) {
      const GSymbol sym((GSymbol::T_Type)I[i][0], I[i][1], I[i][2], I[i][3], I[i][4]);
      vector << sym;
   }
   AddVector(vector);
}

TData::TData(TGrammar* g, A_Syntax* syn, TSemantic* sem)
   :names(NULL), grammar(g), formulas(g ? &g->formulas : NULL), root(NULL), 
    lexemes(NULL), makers(NULL), LLTable(g ? &g->Mtable : NULL), LRTable(g ? &g->LRtable : NULL),
    syntax(syn), semantic(sem), option(0), print_mode(0), file(NULL) 
{ 
   if (syn) syn->data = this; 
}

bool TLexemeSet::Add(const GSymbol& sym)
{
   GSymbol key(sym);
   key.value = 0; key.mode = 0;
   const_iterator ip = find(key); 
   if (ip != end()) {
      return false;
   }
   std::pair<const GSymbol, int> item(key,count());
   insert(item); 
   return true; 
}

int  TLexemeSet::GetAdded(const GSymbol& lex) const
{
   int ret = -1;
   GSymbol key(lex);
   key.value = 0; key.mode = 0;
   const_iterator ip = find(key); 
   if (ip != end()) {
      const std::pair<const GSymbol,int> old = (*ip);
      ret = old.second;
   }
   return ret;
}

T_SyntaxLexeme TLexemeSet::grammar_type() const
{
   int type = T_SyntaxLexeme::slNone | T_SyntaxLexeme::slNoDefType | T_SyntaxLexeme::slNoDefArrVar, type_oper = T_SyntaxLexeme::slNone;
   for (const std::pair<const GSymbol&, int> item : *this) {
      const GSymbol& sym = item.first;
      if (sym.group == T_Lexeme::grPriority) {
         type |= T_SyntaxLexeme::slPrior;
         if (sym.lexeme_type == T_Symbol::prAssign) type_oper |= T_SyntaxLexeme::slPriorAssign;
      }
      if (sym.group == T_Lexeme::grSyntax) {
         if ((sym.lexeme_type == T_Lexeme::sxDefArr) || (sym.lexeme_type == T_Lexeme::sxDefVar)) {
            type &= ~T_SyntaxLexeme::slNoDefArrVar; type |= T_SyntaxLexeme::slSyntax;
         } else if (sym.lexeme_type == T_Lexeme::sxDefType) {
            type &= ~T_SyntaxLexeme::slNoDefType;
         } else {
            type |= T_SyntaxLexeme::slSyntax;
         }
      }
   }
   if (type & T_SyntaxLexeme::slPrior) type |= type_oper;
   return (T_SyntaxLexeme)type;
}

void TLexemeSet::print_(FILE* file, int print_mode) const
{
   fprintf(file, "\n--- Lexemes --- <%d> ---\n", (int)size());
   if (print_mode == T_PrintMode::pmNone) return;
   int old_group = -1;
   for (const std::pair<const GSymbol&, int> item : *this) {
      if (print_mode & T_PrintMode::pmLexemePart) {
         if (old_group != item.first.group) {
            old_group = item.first.group;
            fprintf(file, "\n");
         }
      }
      item.first.print(grammar, print_mode, file);
   }
   fprintf(file, "\n");
}

void TLexemeSet::print(const char* file_name, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   print_(file, print_mode);
   if (file_name) {
      fclose(file);
   }
}

const char* snode_title(int t);
#define SYNTREE_SHIFT 6 
int syn_tree(int s1) { return s1; }
int syn_tree(int s1, int s2) { return s1 | (s2 << SYNTREE_SHIFT); }
int syn_tree(int s1, int s2, int s3) { return s1 | (s2 << SYNTREE_SHIFT) | (s3 << 2 * SYNTREE_SHIFT); }
int syn_tree(int s1, int s2, int s3, int s4) { return s1 | (s2 << SYNTREE_SHIFT) | (s3 << 2 * SYNTREE_SHIFT) | (s4 << 3 * SYNTREE_SHIFT); }
int syn_tree(int s1, int s2, int s3, int s4, int s5) { return s1 | (s2 << SYNTREE_SHIFT) | (s3 << 2 * SYNTREE_SHIFT) | (s4 << 3 * SYNTREE_SHIFT) | (s5 << 4 * SYNTREE_SHIFT); }

/**/
const GSymbol& TGrammar::GetLLkA(const GSymbol& tab) const
{
   return GSymbol::none;
}
/**/

/*
http://rain.ifmo.ru/cat/view.php/vis/graph-general/topological-sort-2007/algorithm
  
 

 (Topological sort)       ,       .       :       ,              .,      ,     .            (DFS).   ,    ,    .        .       .

.      3 .   .  ,     .       ,     .
  

  true,     ,   false.

Color  ,     (0  , 1  , 2  ).
N   .
Edges     .
Numbers  ,      .
Stack  ,       .
Cycle    true,     .
*/

int TIndexes::Add(int i)
{
   iterator ip = find(i);
   if (ip != end()) return (*ip).second;
   std::pair<int, int> item(i,(int)index.size());
   insert(item);
   index.push_back(i);
   return (int)index.size() - 1;
}

int  TIndexes::Get(int i) const
{
   const_iterator ip = find(i);
   return (*ip).second;
}

int  TIndexes::Teg(int i) const
{
   return index[i];
}

bool TopologicalSort::dfs(int v)
{
   //   ,    .   .
   if (Color[v] == 1) return true;
   //   ,    .
   if (Color[v] == 2) return false;
   //     .
   Color[v] = 1;
   //      .
   for (int i = 0; i < (int)Edges[v].size(); i++) {
      if (dfs(Edges[v][i])) return true;
   }
   //    .
   Stack.push(v);
   //     .
   Color[v] = 2;
   return false;
}

bool TopologicalSort::sort()
{
   bool Cycle;
   //       .  ,   .
   for (int i = 0; i < N; i++) {
      Cycle = dfs(i);
      if (Cycle) return false;
   }
   //      .
   for (int i = 0; i < N; i++) {
      Numbers[Stack.top()] = i;
      Stack.pop();
   }
   Indexes.resize(N);
   for (int i = 0; i < N; i++) {
      Indexes[Numbers[i]] = i;
   }
   return true;
}
#ifndef TRN_RULES_H
#define TRN_RULES_H

#include <stack>
#include <set>
#include <vector>
#include <map>
#include "Parse.h"

#define PRODUCE_ITEM_EMPTY

class TGrammar;
class GFormula;
class Produce;
struct GSymbol 
{
public:
   enum T_Type { gsNone, gsFormula, gsProduce, gsTerminal, gsVector, gsEmpty, gsEof, gsMaker, gsRule, gsPoint, gsPara, gsSituation, gsTable };
   enum T_Mask { msNone = 0x00, msFormula = 0x01, msProduce = 0x02, msTerminal = 0x04, msEmpty = 0x08, msEof = 0x10, msMaker = 0x20, msRule = 0x40, msPoint = 0x80, 
                 msPara = 0x0100, msSituation = 0x0200 };
   enum T_Mode { None = 0x00, Must = 0x01, Turn = 0x04, Tree = 0x08, Code = 0x10, Master = 0x20, Yacc = 0x0100, SNode = 0x0200, Warning = 0x0400, 
                 Used = 0x0800, Deleted = 0x1000 };
public:
   GSymbol(T_Type t = gsNone, int g = 0, int s = 0, int p = 0, int m = 0) :type(t), _formula(g), _produce(s), point(p), mode(m) {}
   GSymbol(const T_Lexeme &l);
   bool IsNone     () const { return type == gsNone     ; }
   bool IsEmpty    () const { return type == gsEmpty    ; }
   bool IsTerminal () const { return type == gsTerminal ; }
   bool IsEof      () const { return type == gsEof      ; }
   bool IsFormula  () const { return type == gsFormula  ; }
   bool IsMaster   () const { return (type == gsFormula) && (mode & Master); }
   bool IsProduce  () const { return type == gsProduce  ; }
   bool IsStart    () const { return (type == gsProduce) && !formula  && !produce || (type == gsFormula) && !formula; }
   bool IsMaker    () const { return type == gsMaker    ; }
   bool IsMakerTree() const { return (type == gsMaker) && (mode & Tree); }
   bool IsMakerCode() const { return (type == gsMaker) && (mode & Code); }
   bool IsMakerYACC() const { return (type == gsMaker) && (mode & Yacc); }
   bool IsMakerNode() const { return (type == gsMaker) && (mode & SNode); }
   bool IsMakerTurn() const { return (type == gsMaker) && (mode & Turn); }
   bool IsPoint    () const { return type == gsPoint    ; }
   bool IsPara     () const { return type == gsPara     ; }
   bool IsBasic    () const { return (type == gsPara) && (point || !formula  && !produce); }
   bool IsSituation() const { return type == gsSituation; }
   bool IsVector   () const { return type == gsVector   ; }
   bool IsTable    () const { return type == gsTable    ; }
   bool IsUsed     () const { return (mode & Used) != 0 ; }
   bool IsDeleted  () const { return (mode & Deleted) != 0; }
   int  MakerParam () const { return param;               }
   bool IsSaved    () const;
   bool Cast();
public:
   bool operator == (const GSymbol& t2) const;
   bool operator <  (const GSymbol& t2) const;
   GSymbol& operator = (const T_Lexeme &l);
public:
   int  print_maker(int print_mode, FILE *file) const;
   int  print(const TGrammar* grammar, int print_mode = 0x00, FILE *file = NULL) const;
   int  YACC (FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   int  MACRO(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   int  PROG (FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   void write(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   bool read (FILE *file, const TGrammar* grammar, int print_mode = 0x00);
public:
   T_Type type;
   int    mode;
   union {
      struct { int situation   ;                      }; // Situation
      struct { int formula     , produce;             }; // Formula, Produce
      struct { T_Lexeme::T_Group group; int lexeme_type, value; }; // Lexeme, Terminal
      struct { int maker       , param       , func;  }; // Maker
      struct { int _formula    , _produce    , point; }; // Para
      struct { int vector      ;                      }; // Vector
      struct { int table       ;                      }; // Table
   };
public:
   static const GSymbol none, empty, eof, sharp;
};

class TTwoSym {
public:
   TTwoSym() :one(), two() {}
   TTwoSym(GSymbol o, GSymbol t) :one(o), two(t) {}
   bool operator == (const TTwoSym& p) const { return ((*this).one == p.one) && ((*this).two == p.two); }
   bool operator <  (const TTwoSym& p) const { return ((*this).one <  p.one) || ((*this).one == p.one) && ((*this).two < p.two); }
public:
   void print(const TGrammar* grammar, int print_mode, FILE* file) const;
public:
   GSymbol one, two;
};

class TTwoSymVector : public std::vector<TTwoSym> {
public:
   void Add(const TTwoSym& item) { push_back(item); }
};

template <class T_Item> class T_SetQueue : public std::set<T_Item> {
public:
   bool Push(const T_Item& item) { if (std::set<T_Item>::find(item) != std::set<T_Item>::end()) return false; std::set<T_Item>::insert(item); return true; }
   bool Pop(T_Item& item) { if (std::set<T_Item>::empty()) return false; item = *std::set<T_Item>::begin(); std::set<T_Item>::erase(std::set<T_Item>::begin()); return true; }
};

class TTwoSymQueue : public T_SetQueue<TTwoSym> {
};

#define MAKER_CRAMP

#ifdef MAKER_CRAMP
   #define SYMBOL_PRINT_TITLE_LEN  25
   #define MAKER_PRINT_TITLE_LEN   25
#else
   #define SYMBOL_PRINT_TITLE_LEN  30
   #define MAKER_PRINT_TITLE_LEN   40
#endif
#define PRODUCE_PRINT_TITLE_LEN    20

class GSymbolVector : public std::vector<GSymbol>
{
public:
   GSymbolVector() {}
   GSymbolVector(const GSymbolVector& v, int mask);
   GSymbolVector& operator << (const GSymbol& s) { push_back(s); return *this; }
   GSymbolVector& operator << (const GSymbolVector& v);
public:
   void Add(const GSymbol& sym) { push_back(sym); }
   int  Find(const GSymbol& sym, int beg = 0) const;
   bool Have(const GSymbol& sym) const;
   bool HaveEmpty() const { return Have(GSymbol::empty); };
   bool IsEmpty() const { return (count() == 1) && HaveEmpty(); };
public:
   int  count() const { return (int)size(); }
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE *file = NULL) const;
   void write(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
};

class GSymbolSet : public std::set<GSymbol>
{
public:
   GSymbolSet() {}
   GSymbolSet(const GSymbol& s) { (*this) << s; }
public:
   GSymbolSet& operator << (const GSymbol& s);
   GSymbolSet& operator << (const GSymbolSet& s) { *this += s; return *this; }
   bool operator == (const GSymbol& s) const { return ((int)size() == 1) && (find(s) != end()); }
   int  operator += (const GSymbol& s);
   int  operator += (const GSymbolSet& m);
   GSymbolSet operator * (const GSymbolSet& join) const;
   GSymbolSet operator - (const GSymbolSet& join) const;
   bool Add(const GSymbol& sym);
   bool Del(const GSymbol& sym);
   bool Have(const GSymbol& sym) const;
   bool HaveEmpty() const { return Have(GSymbol::empty); };
   bool IsEmpty() const { return (count() == 1) && HaveEmpty(); };
   void Plus(const GSymbolSet& left, const GSymbolSet& right);
public:
   int  count() const { return (int)size(); }
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE *file = NULL) const;
public:
   static const GSymbolSet none;
};

class GSymbolQueue : public T_SetQueue<GSymbol> {
};

class TwoSymGSymbolSetMap : public std::map<const TTwoSym, GSymbolSet>
{
public:
   bool Add(const TTwoSym& key, const GSymbol& sym);
   const GSymbolSet& Get(const TTwoSym& key) const;
   bool Have(const TTwoSym& key) const { return (find(key) != end()); }
};

class TData; class TRuleNames;

class GProduce : public GSymbolVector
{
public:
   GProduce() :head(GSymbol::gsProduce), maker() {}
   GProduce(const GSymbol& s) :head(s), maker() {}
   int  count() const { return (int)size(); } 
   int  Count() const;
   int  Real(int mode = 0x00) const; // 0x01 - space
   int  Master() const;
   void Add(const GSymbol& s);
   void Shift(GSymbol& para) const;
   bool IsEmpty() const;
   bool IsChain() const;
   bool HaveMaster() const;
   void OrMode(int mode)   { if (empty()) return; back().mode  |= mode;  }
   void OrParam(int param) { if (empty()) return; back().param |= param; }
   void Tail(int point, GSymbolVector& tail) const;
   void Tail(const GSymbol& point, GSymbolVector& tail) const { Tail(point.point + 1, tail); }
   void TailWithoutMaker(int point, GSymbolVector& tail) const;
   void TailWithoutMaker(const GSymbol& point, GSymbolVector& tail) const { TailWithoutMaker(point.point + 1, tail); }
   void SymAndTail(const GSymbol& point, GSymbolVector& tail) const { Tail(point.point, tail); }
public:
   bool IsUsed() const { return head.IsUsed(); }
   void SetUsed() { head.mode |= GSymbol::Used; }
   void ClearUsed() { head.mode &= ~GSymbol::Used; }
   bool IsDeleted() const { return head.IsDeleted(); }
   void SetDeleted() { head.mode |= GSymbol::Deleted; }
public:
   GSymbol head, maker;
public:
   void PROG (FILE *file, const TGrammar* grammar, int print_mode = 0x00) const; // FORMULA_TITLE_PREFIX - prefix
   void write(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   bool read (FILE *file, const TGrammar* grammar, int print_mode = 0x00);
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE* file = stdout, int point = -1) const;
};

class TLexemeSet;
class GFormulaTable : public std::vector<GFormula*>
{
public:
   GFormulaTable() :root(NULL), readed(false) {}
   GFormulaTable(const GFormulaTable& join); 
   ~GFormulaTable();
   void Copy(const GFormulaTable& join);
   bool Add(GFormula* f, int &index);
   bool Add(GFormula* f) { int index; return Add(f, index); }
   GFormula* Find(const char* title);
   bool make(TRuleNames& names);
   int  count() const { return (int)size(); } 
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE* file = stdout) const;
   void write(const char* title, int print_mode = 0x00) const;
   bool read (const char* title, int print_mode = 0x00);
   void write(FILE* file, int print_mode = 0x00) const;
   bool read (FILE* file, int print_mode = 0x00);
public:
   void Used(TLexemeSet& lexemes);
   void Used(const GFormula&);
   bool make(TRuleNames& names,TLexemeSet& lexemes);
public:
   GFormula* root;
   std::vector<int> used;
   bool readed;
};

class GFormula : public std::vector<GProduce>
{
public:
   GFormula() :head(GSymbol::gsFormula), title(NULL), used(0) {}
   GFormula(const GSymbol sym) :head(sym), title(NULL), used(0) {}
   void Add(const GProduce& p) { push_back(p); }
   int  count() const { return (int)size(); } 
   bool IsRecursive() const;
   bool IsEmpty() const { return (!size() || (count() == 1) && front().IsEmpty()); }
   bool IsChain() const { return (count() == 1) && front().IsChain(); }
   bool HaveEmpty() const;
   bool HaveChain() const;
   bool IsUsed() const { return head.IsUsed(); }
   void SetUsed() { head.mode |= GSymbol::Used; }
   void ClearUsed() { head.mode &= ~GSymbol::Used; }
   bool IsDeleted() const { return head.IsDeleted(); }
   void SetDeleted() { head.mode |= GSymbol::Deleted; }
public:
   GSymbol head;
public:
   mutable int used;
public:
   void PROG (FILE *file, const TGrammar* grammar, int print_mode = 0x00) const; // FORMULA_TITLE_PREFIX - prefix
   void write(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   bool read (FILE *file, const TGrammar* grammar, int print_mode = 0x00);
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE* file = stdout) const;
public:
   int  write_title(FILE *file, const TGrammar* grammar = NULL, int print_mode = 0x00) const;
   const char* title;
};

class TRuleNames : public TNameTable {
public:
   bool verify(const GFormulaTable& formulas) const;
};

class GMakerTable; class A_Syntax; class TSemantic; class TRuleNames; class TLexemeSet; 
class MTableKey; class MTableMap; class LRTableMap; struct TAction;
class TData {
public:
   TData() :names(NULL), grammar(NULL), formulas(NULL), lexemes(NULL), makers(NULL), LLTable(NULL), LRTable(NULL),
            syntax(NULL), semantic(NULL), root(NULL), option(0), print_mode(0), file(NULL), tokens(NULL) {}
   TData(TGrammar* g, A_Syntax* syn, TSemantic* sem);
public:
   const GFormula& Formula(const GSymbol &sym) const;
   const GProduce& Produce(const GSymbol &sym) const;
   const GSymbol&  Cell(const MTableKey& key) const;
   const TAction&  Action(const MTableKey& key) const;
   const GFormula* Root() const;
public:
   const char*    file;
   TTokenNames*   tokens;
   TRuleNames*    names;
   GFormulaTable* formulas;
   GFormula*      root;
   TGrammar*      grammar;
   GMakerTable*   makers;
   A_Syntax*      syntax;
   TSemantic*     semantic;
   TLexemeSet*    lexemes;
   MTableMap*     LLTable;
   LRTableMap*    LRTable;
public:
   int            option, print_mode;
};

class TIndexes : public std::map<int, int> {
public:
   TIndexes() {}
   int  Add(int i);
   int  Get(int i) const;
   int  Teg(int i) const;
   void Clear() { clear(); index.clear(); }
private:
   std::vector<int> index;
};

class TopologicalSort {
public:
   TopologicalSort(int n) :N(n) { Color.resize(n, 0); Numbers.resize(n); Edges.resize(n); }
   bool sort();
   void add(int i, int j) { Edges[i].push_back(j); }
private:
   bool dfs(int v);
public:
   std::vector<int> Color;
   std::stack<int>  Stack;
   std::vector<int> Numbers, Indexes;
   int N;
   std::vector< std::vector<int> > Edges;
};

int syn_tree(int s1);
int syn_tree(int s1, int s2);
int syn_tree(int s1, int s2, int s3);
int syn_tree(int s1, int s2, int s3, int s4);
int syn_tree(int s1, int s2, int s3, int s4, int s5);

const char* symbol_title(GSymbol::T_Type type);

#endif
// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "TNodes.h"
#include "SNodes.h"
#include "ASyntax.h"

bool SNode::ClearNode(SNode* N)
{
   if (N && (!N->Owner() || (N->Owner() == this))) {
      if (SNodeList *list = dynamic_cast<SNodeList*>(N)) {
         SNodeList::iterator p = list->begin();
         while (p != list->end()) {
            list->ClearNode(*p);
            p = list->erase(p);
         }
      }
      N->clear(); delete N;
      return true; 
   }
   return false;
}

void SNode::clear()   {}

void SNodeList::clear()
{
	iterator p = begin();
   while (p != end()) { 
      ClearNode(*p);
      p = erase(p);
   }
}

void SNode::print(const char *file_name, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   print(0, file, print_mode);
   if (file_name) {
      fclose(file);
   }
}

void SNode::print(int level, FILE *file, int print_mode) const
{
   const char *t = title();
   print_offset(level, true, file); fprintf(file, "%-15s, type=%s, option=%08X ",t,snode_title(type),option);
   if (level >= 0) {
      if (lexeme.group != lexeme.grNone) {
         fprintf(file, "  "); lexeme.print(T_Lexeme::print_scan,false,file);
      }
   } else {
   	fprintf(file, " pos=%04d, line=%03d, column=%03d, len=%02d", lexeme.pos, lexeme.line, lexeme.column, lexeme.len);
		fprintf(file, ", text=");
   	for (int i = 0; i < lexeme.len; i++) fprintf(file, "%c", T_Lexeme::print_scan->Char(lexeme.pos + i));
   }
}

void SNodeList::print(int level, FILE *file, int print_mode) const
{
   SNode::print(level, file, print_mode);
	const_iterator p = begin();
   while (p != end()) { 
      (*p)->print(level + 1, file, print_mode);
      p++;
   }
}

TNode* SNode::Create(A_Syntax* syntax)
{ 
   TNode* ret = NULL;
   switch (type) {
   case stNull : {
      ret = new TNodeNull();
      } break;
   case stNumber : {
      ret = new TNodeNumber(lexeme);
      } break;
   case stVar : {
      ret = new TNodeVar(lexeme);
      } break;
   case stGoTo  : {
       ret = new TNodeUserGoTo(lexeme); 
      } break;
   case stBreak  : {
      ret = new TNodeBreakContinue(T_Block::tbBreak,lexeme);
      } break;
   case stContinue  : { 
      ret = new TNodeBreakContinue(T_Block::tbContinue,lexeme);
      } break;
   case stLabel : { 
      ret = new TNodeUserLabel(lexeme);
      } break;
   case stType : {
      ret = TBaseType::BaseType(lexeme,option);
      } break;
   default : 
      break;
   }

   return ret;
}

TNode* SNodeOne::Create(A_Syntax* syntax)
{ 
   TNode* ret = NULL;
   switch (type) {
   case stUnary : {
      if (option) syntax->ChangeUnary(lexeme,false);
      ret = new TNodeUnary(lexeme, child->Create(syntax));
      } break;
   case stPrimary : {
      ret = new TNodePrimary(lexeme, child->Create(syntax));
      } break;
   case stCast  : {
      TNodeType *type = syntax->BaseType(lexeme);
      TNodeCast *cast = new TNodeCast(lexeme, type, child->Create(syntax));
      ret = cast;
      } break;
   case stCall  : {
      TNodeCall* call = new TNodeCall(lexeme);
      if (child) call->SetList((T_NodeList*)child->Create(syntax)); // params
      ret = call;
      } break;
   case stIndex  : {
      TNodeIndex* index = new TNodeIndex(lexeme);
      if (child) index->SetList((T_NodeList*)child->Create(syntax)); // ranges
      ret = index;
      } break;
   case stReturn : {
      TNodeReturn* retur = new TNodeReturn(lexeme);
      if (child)  retur->SetValue(child->Create(syntax));
      ret = retur;
      } break;
   case stSwitchCase : { 
      } break;
   default : 
      break;
   }

   return ret;
}

TNode* SNodeTwo::Create(A_Syntax* syntax)
{ 
   TNode* ret = NULL;
   switch (type) {
   case stBinary  : {
      if (lexeme.Match(T_Symbol::prOrOr) || lexeme.Match(T_Symbol::prAndAnd)) {
         ret = new TNodeLogical(lexeme,left->Create(syntax),right->Create(syntax));
      } else {
         ret = new TNodeBinary(lexeme,left->Create(syntax),right->Create(syntax));
      }
      } break;
   case stLogical  : {
      ret = new TNodeLogical(lexeme,left->Create(syntax),right->Create(syntax));
      } break;
   case stWhile  : {
      TNodeWhile* statement = new TNodeWhile(lexeme);
      if (left)  statement->SetCondition(left->Create(syntax));
      if (right) statement->SetBody(right->Create(syntax));
      ret = statement;
      } break;
   case stDo  : {
      TNodeDo* statement = new TNodeDo(lexeme);
      if (left)  statement->SetCondition(left->Create(syntax));
      if (right) statement->SetBody(right->Create(syntax));
      ret = statement;
      } break;
   case stSwitchItem : 
      break;
   case stSwitch : 
      break;
   default : break;
   }

   return ret;
}

TNode* SNodeThree::Create(A_Syntax* syntax)
{ 
   TNode* ret = NULL;
   switch (type) {
   case stTrio  : {
       ret = new TNodeTrio(lexeme,left->Create(syntax),mid->Create(syntax),right->Create(syntax)); 
      } break;
   case stDefVar  : {
      TNodeDefVar* def = new TNodeDefVar(lexeme);
      if (left)  def->SetType((TNodeType*)left->Create(syntax));
      if (right) def->SetAssign(syntax->oper_assign,right->Create(syntax));
      ret = def;
      } break;
   case stDefArr  : {
      TNodeDefArr* def = new TNodeDefArr(lexeme,(T_NodeList*)mid->Create(syntax));
      if (left)  def->SetType((TNodeType*)left->Create(syntax));
      if (right) def->SetAssign(right->Create(syntax));
      ret = def;
      } break;
   case stDefFunc : { 
      TNodeDefFunc* def = new TNodeDefFunc(lexeme);
      if (left)  def->SetType((TNodeType*)left->Create(syntax));
      if (right) def->SetParams((TNodeDefine*)right->Create(syntax));
      if (mid)   def->SetBody(mid->Create(syntax));
      ret = def;
      } break;
   case stIf : {
      TNodeIf* statement = new TNodeIf(lexeme);
      if (left)  statement->SetCondition(left->Create(syntax));
      if (mid)   statement->SetThen(mid->Create(syntax));
      if (right) statement->SetElse(right->Create(syntax));
      ret = statement;
      } break;
      default : { 
      } break;
   }

   return ret;
}

TNode* SNodeFour::Create(A_Syntax* syntax)
{ 
   TNodeFor* ret = NULL;
   switch (type) {
   case stFor : {
      ret = new TNodeFor(lexeme);
      if (left)  ret->SetBeg(left->Create(syntax));
      if (mid)   ret->SetCondition(mid->Create(syntax));
      if (right) ret->SetEnd(right->Create(syntax));
      if (four)  ret->SetBody(four->Create(syntax));
      } break;
   default : 
      break;
   }

   return ret;
}

TNode* SNodeList::Create(A_Syntax* syntax)
{ 
   T_NodeList* ret = NULL;
   switch (type) {
   case stExpressions :  {
      TNodeExpressions* expr = new TNodeExpressions();
      expr->part = (T_Part)option; 
      ret = expr;
      for (SNode *snode : *this) {
         if (TNode* node = snode->Create(syntax)) ret->Add(node);
      } 
      } break;
   case stStatements  :  {
      ret = new TNodeStatements(); 
      for (SNode *snode : *this) {
         if (TNode* node = snode->Create(syntax)) ret->Add(node);
      } 
      } break;
   case stList  :  {
      ret = new T_NodeList(); 
      for (SNode *snode : *this) {
         if (TNode* node = snode->Create(syntax)) ret->Add(node);
      } 
      } break;
   case stDefine : {
      TNodeType *define_type = NULL;
      TNodeDefine* define = NULL;
      if (!lexeme.Match(T_Lexeme::grNone)) {
         define_type = syntax->BaseType(lexeme, option);
         define = new TNodeDefine(define_type);
      } else {
         define = new TNodeDefine();
      }
      for (SNode *snode : *this) {
         TNode* node = snode->Create(syntax);
         if (!node) continue;
         define->Add(node);
         if (!define_type) continue;
         if (snode->option & 0x08) { // reference
            define_type = TBaseType::Or(define_type, T_BaseType::btReference);
         }
         if (TNodeDefVar* var = dynamic_cast<TNodeDefVar*>(node)) {
            var->SetType(define_type);
         }
      } 
      ret = define;
      } break;
   default : 
      return ret;
   }

   return ret;
}

#define CHILD(R) SNode *child = (Count() > R) ? (*this)[R] : NULL;
#define LEFT(R)  SNode *left  = (Count() > R) ? (*this)[R] : NULL;
#define MID(R)   SNode *mid   = (Count() > R) ? (*this)[R] : NULL;
#define RIGHT(R) SNode *right = (Count() > R) ? (*this)[R] : NULL;
#define FOUR(R)  SNode *four  = (Count() > R) ? (*this)[R] : NULL;

TNode* SNodeList::Make(A_Syntax* syntax)
{
   TNode* ret = NULL;
   switch (type) {
   case stNull : {
      ret = new TNodeNull();
      } break;
   case stNumber : {
      ret = new TNodeNumber(lexeme);
      } break;
   case stVar : {
      ret = new TNodeVar(lexeme);
      } break;
   case stGoTo  : {
       ret = new TNodeUserGoTo(lexeme); 
      } break;
   case stBreak  : {
      ret = new TNodeBreakContinue(T_Block::tbBreak,lexeme);
      } break;
   case stContinue  : { 
      ret = new TNodeBreakContinue(T_Block::tbContinue,lexeme);
      } break;
   case stLabel : { 
      ret = new TNodeUserLabel(lexeme);
      } break;
   case stType : {
      ret = TBaseType::BaseType(lexeme,option);
      } break;
   case stUnary : {
      CHILD(0)
      if (option) syntax->ChangeUnary(lexeme,false);
      ret = new TNodeUnary(lexeme, child->Make(syntax));
      } break;
   case stIncDec : {
      CHILD(0)
      syntax->ChangeUnary(lexeme,false);
      ret = new TNodeUnary(lexeme, child->Make(syntax));
      } break;
   case stPrimary : {
      CHILD(0)
      ret = new TNodePrimary(lexeme, child->Make(syntax));
      } break;
   case stCast  : {
      CHILD(0)
      TNodeType *type = syntax->BaseType(lexeme);
      TNodeCast *cast = new TNodeCast(lexeme, type, child->Make(syntax));
      ret = cast;
      } break;
   case stCall  : {
      CHILD(0)
      TNodeCall* call = new TNodeCall(lexeme);
      if (child) call->SetList((T_NodeList*)child->Make(syntax)); // params
      ret = call;
      } break;
   case stIndex  : {
      CHILD(0)
      TNodeIndex* index = new TNodeIndex(lexeme);
      if (child) index->SetList((T_NodeList*)child->Make(syntax)); // ranges
      ret = index;
      } break;
   case stReturn : {
      CHILD(0)
      TNodeReturn* retur = new TNodeReturn(lexeme);
      if (child)  retur->SetValue(child->Make(syntax));
      ret = retur;
      } break;
   case stBinary  : {
      LEFT(0) RIGHT(1)
      if (lexeme.Match(T_Symbol::prOrOr) || lexeme.Match(T_Symbol::prAndAnd)) {
         ret = new TNodeLogical(lexeme,left->Make(syntax),right->Make(syntax));
      } else {
         ret = new TNodeBinary(lexeme,left->Make(syntax),right->Make(syntax));
      }
      } break;
   case stLogical  : {
      LEFT(0) RIGHT(1)
      ret = new TNodeLogical(lexeme,left->Make(syntax),right->Make(syntax));
      } break;
   case stWhile  : {
      LEFT(0) RIGHT(1)
      TNodeWhile* statement = new TNodeWhile(lexeme);
      if (left)  statement->SetCondition(left->Make(syntax));
      if (right) statement->SetBody(right->Make(syntax));
      ret = statement;
      } break;
   case stDo  : {
      LEFT(0) RIGHT(1)
      TNodeDo* statement = new TNodeDo(lexeme);
      if (left)  statement->SetCondition(left->Make(syntax));
      if (right) statement->SetBody(right->Make(syntax));
      ret = statement;
      } break;
   case stSwitchItem : 
      break;
   case stSwitch : 
      break;
   case stTrio  : {
      LEFT(0) MID(1) RIGHT(2)
      ret = new TNodeTrio(lexeme,left->Make(syntax),mid->Make(syntax),right->Make(syntax)); 
      } break;
   case stDefVar  : {
      LEFT(0) RIGHT(1)
      TNodeDefVar* def = new TNodeDefVar(lexeme);
      if (left) {
         TNode* node = left->Make(syntax);
         TNodeType *param_type = dynamic_cast<TNodeType*>(node);
         if (param_type) {
            def->SetType(param_type);
            if (right) def->SetAssign(right->Make(syntax));
         } else {
            def->SetAssign(syntax->oper_assign,node);
         }
      }
      ret = def;
      } break;
   case stDefArr  : {
      LEFT(0) MID(2) RIGHT(1)
      if (!left) break;
      TNode *node = left->Make(syntax), *assign = NULL;
      TNodeType *param_type = dynamic_cast<TNodeType*>(node);
      T_NodeList* ranges = NULL;
      if (!param_type) {
         ranges = (T_NodeList*)node;
         if (right) assign = right->Make(syntax); 
      } else {
         ranges = (T_NodeList*)right->Make(syntax);
         if (mid) assign = mid->Make(syntax); 
      }
      TNodeDefArr* def = new TNodeDefArr(lexeme,ranges);
      if (param_type) def->SetType(param_type);
      if (assign) def->SetAssign(assign);
      ret = def;
      } break;
   case stDefFunc : { 
      LEFT(0) MID(2) RIGHT(1)
      TNodeDefFunc* def = new TNodeDefFunc(lexeme);
      if (left)  def->SetType((TNodeType*)left->Make(syntax));
      if (right) def->SetParams((TNodeDefine*)right->Make(syntax));
      if (mid && (mid->type != stNull))   def->SetBody(mid->Make(syntax));
      ret = def;
      } break;
   case stIf : {
      LEFT(0) MID(1) RIGHT(2)
      TNodeIf* statement = new TNodeIf(lexeme);
      if (left)  statement->SetCondition(left->Make(syntax));
      if (mid)   statement->SetThen(mid->Make(syntax));
      if (right) statement->SetElse(right->Make(syntax));
      ret = statement;
      } break;
   case stFor : {
      LEFT(0) MID(1) RIGHT(2) FOUR(3)
      TNodeFor* statement = new TNodeFor(lexeme);
      if (left )  statement->SetBeg(left->Make(syntax));
      if (mid  )  statement->SetCondition(mid->Make(syntax));
      if (right)  statement->SetEnd(right->Make(syntax));
      if (four )  statement->SetBody(four->Make(syntax));
      ret = statement;
      } break;
   case stExpressions :  {
      TNodeExpressions* expr = new TNodeExpressions();
      expr->part = (T_Part)option; 
      for (SNode *snode : *this) {
         if (TNode* node = snode->Make(syntax)) expr->Add(node);
      } 
      ret = expr;
      } break;
   case stStatements  :  {
      T_NodeList* list = new TNodeStatements(); 
      for (SNode *snode : *this) {
         if (TNode* node = snode->Make(syntax)) list->Add(node);
      } 
      ret = list;
      } break;
   case stRanges : 
   case stList  :  {
      T_NodeList* list = new T_NodeList(); 
      for (SNode *snode : *this) {
         if (TNode* node = snode->Make(syntax)) list->Add(node);
      } 
      ret = list;
      } break;
   case stDefine : {
      TNodeType *define_type = NULL;
      TNodeDefine* define =  NULL;
      for (SNode *snode : *this) {
         if (!define) {
            if (snode->type == stType) {
               define_type = syntax->BaseType(snode->Lexeme(), option);
            }
            define =  new TNodeDefine(define_type);
            if (define_type) continue;
         }
         TNode* node = snode->Make(syntax);
         if (!node) continue;
         TNodeDefVar* var = dynamic_cast<TNodeDefVar*>(node);
         if (var && define_type) {
            TNodeType *var_type = define_type;
            if (snode->option & 0x08) { // reference
               var_type = TBaseType::Or(var_type, T_BaseType::btReference);
            }
            var->SetType(var_type);
         }
         define->Add(node);
      } 
      ret = define;
      } break;
   default : 
      return ret;
   }
 
//   if (ret) ret->TNode::print(0x00);

   return ret;
}

static const char* title_snode[] = {
   "None", "Node", "Unary", "Binary", "Logical", "Trio", "Number", "Primary", "Type", "Cast", "IncDec",
   "Expressions", "Compaund", "Statements", "DefVar", "DefArr", "DefFunc", "Define", "Var",
   "Call", "Index", "For", "While", "Do", "Label", "GoTo", "Break", "Continue", "Return", "If", 
   "SwitchCase", "SwitchItem", "Switch", "List", "Ranges", "Null", "NodeOne", "NodeTwo", "RefDef",
   "Lexeme", "Param", "Formula", "Produce", "Maker", "Tokens", "Enums", "Item"
   }; 
static const char* title_turn[] = { "None", "Push", "Put", "Add", "Make", "Down", "Up", "Swap", "Command" };
const char* snode_title(SNode::S_Type t) { return title_snode[t]; }
const char* snode_title(int t) { return snode_title((SNode::S_Type)t); }
const char*  turn_title(SNode::T_Turn t) { return title_turn[t]; }
SNode::S_Type title_snode_maker(const char* t) 
{
   int i = 0;
   for (const char* item : title_snode) {
      if (strcmp(item, t) == 0) return (SNode::S_Type)i;
      i++;
   }
   return SNode::S_Type::stNone;
}
SNode::T_Turn title_tnode_maker(const char* t) 
{
   int i = 0;
   for (const char* item : title_turn) {
      if (strcmp(item, t) == 0) return (SNode::T_Turn)i;
      i++;
   }
   return SNode::T_Turn::ttNone;
}

#include "Grammar.h"
// ------------------------- T_SyntaxNode ----------------------
void T_SyntaxNode::clear() {}

void TLexemeNode::clear() {}

void TProduceNode::clear()
{
   iterator p = begin();
   while (p != end()) {
      (*p)->clear();
      delete (*p);
      p = erase(p);
   }
   std::vector<T_SyntaxNode*> ::clear();
}

void TSyntaxTree::clear()
{
   if (root) {
      root->clear();
      delete root;
      root = NULL;
   }
}

T_SyntaxNode* TProduceNode::trim()
{
   if (empty()) return NULL;
   iterator p = begin();
   while (p != end()) {
      T_SyntaxNode* node = (*p)->trim();
      if (node) {
         node->child = (*p)->child;
         delete (*p);
         (*p) = node;
      }
      p++;
   }
   if ((children == 1) && (size() == 1)) return front();
   
   if ((master == 1) && (size() == 2) && (front()->symbol == symbol)) {
      TProduceNode* list = (TProduceNode*)front();
      list->Add(back(), (int)list->size() + 1);
      back() = NULL; front() = NULL;
      return list;
   }
   
   return NULL;
}

void TSyntaxTree::trim()
{
   if (root) root->trim();
}

void TProduceNode::Add(T_SyntaxNode* node, int index)
{ 
   node->child = index;
   push_back(node);
}

void TProduceNode::Insert(T_SyntaxNode* node, int index)
{
   node->child = index;
   insert(begin(), node);
}

const char* T_SyntaxNode::title() const
{
   return symbol_title(symbol.type);
}

const char* TLexemeNode::title() const
{
   return T_SyntaxNode::title();
}

const char* TProduceNode::title() const
{
   return T_SyntaxNode::title();
}

T_SyntaxNode* TSyntaxTree::New(const GSymbol& type)
{
   T_SyntaxNode* ret = NULL;
   if (type.IsProduce()) {
      const GProduce produce = grammar->Produce(type);
      TProduceNode* node = new TProduceNode(type); 
      node->children = produce.Real(0x01); node->master = produce.Master(); // BNF(space == SYMBOL)
      ret = node;
   } else if (type.IsTerminal()) {
      if (type.IsSaved()) ret = new TLexemeNode(type);
   }
   return ret;
}

T_SyntaxNode* TSyntaxTree::New(const T_Lexeme& lexeme)
{
   T_SyntaxNode* ret = NULL;
   ret = new TLexemeNode(lexeme);
   return ret;
}

void TSyntaxTree::print(const char *file_name, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   if (root) root->print(grammar, 0, file, print_mode);
   if (file_name) {
      fclose(file);
   }
}

void T_SyntaxNode::print(const TGrammar* grammar, int level, FILE *file, int print_mode) const
{
   print_offset(level, true, file); fprintf(file,"(%d)",child);
}

void TLexemeNode::print(const TGrammar* grammar, int level, FILE *file, int print_mode) const
{
   T_SyntaxNode::print(grammar, level, file, print_mode);
   lexeme.print(NULL, print_mode, file);
}

void TProduceNode::print(const TGrammar* grammar, int level, FILE *file, int print_mode) const
{
   T_SyntaxNode::print(grammar, level, file, print_mode);
   symbol.print(grammar, print_mode, file); fprintf(file, "(%d,%d)", children, master);
   for (const T_SyntaxNode* node : (*this)) {
      node->print(grammar, level + 1, file, print_mode);
   }
}
#ifndef TRN_S_NODES_H
#define TRN_S_NODES_H

#include "Parse.h"

#define CLEAR_NODE(N) if (this->ClearNode(N)) { N = NULL; }
#define PRINT_NODE(N) if (N) { N->print(level + 1, file, print_mode); }
 
// --------------------------- SNode ---------------------------
class TNode;
class A_Syntax;
struct T_Lexeme_SNode;

class SNode {
public:
   enum S_Type { stNone, stNode, stUnary, stBinary, stLogical, stTrio, stNumber, stPrimary, stType, stCast, stIncDec,
                 stExpressions, stCompaund, stStatements, stDefVar, stDefArr, stDefFunc, stDefine, stVar,
                 stCall, stIndex, stFor, stWhile, stDo, stLabel, stGoTo, stBreak, stContinue, stReturn, stIf, 
                 stSwitchCase, stSwitchItem, stSwitch, stList, stRanges, stNull, stNodeOne, stNodeTwo, stRefDef, stLexeme, stParam,
                 stFormula, stProduce, stMaker, stTokens, stEnums, stItem,
                 st = stNone, st0 = stNone, stAddToList = stNone, stCopy = stNone
               }; 
   enum T_Turn { ttNone, ttPush, ttPut, ttAdd, ttMake, ttDown, ttUp, ttSwap, ttCommand };
   S_Type type;
   int    option;
public:
   SNode(S_Type s = stNone) :owner(NULL), lexeme(), type(s), option(0) {}
   SNode(const T_Lexeme& l, S_Type s = stNone) :owner(NULL), lexeme(l), type(s), option(0) {}
   virtual ~SNode() {}
   virtual TNode* Create(A_Syntax* syntax);
   virtual TNode* Make(A_Syntax* syntax) { return NULL; }
public:
   virtual void Add(SNode *r)          {} 
   virtual SNode *Get(int i)           { return NULL; }
   virtual int  Count() const          { return 0; }
public:
   bool ClearNode(SNode* N);
   virtual void clear();
public:
   const T_Lexeme& Lexeme() const { return lexeme; }
   void SetLexeme(const T_Lexeme& l) { lexeme = l; }
protected:
   T_Lexeme lexeme;
public:
   SNode *Owner()           { return owner; }
   void SetOwner(SNode *o)  { if (!owner || !o) owner = o; } 
protected:
   SNode *owner;
public:
   virtual const char* title() const   { return "SNode"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
           void print(const char *file, int print_mode) const;
   static void YACC(FILE *file, int print_mode);
};

class SNodeOne : public SNode {
public:
   SNodeOne(S_Type s = stNone) :SNode(s), child(NULL) {}
   SNodeOne(const T_Lexeme& l, S_Type s, SNode *c = NULL) :SNode(l,s) { SetChild(c); }
   virtual ~SNodeOne() {}
   virtual TNode* Create(A_Syntax* syntax);
public:
   virtual void Add(SNode *r)          { SetChild(r); } 
   virtual SNode *Get(int i)           { return child; }
   virtual int  Count() const          { return (child != NULL); }
public:
   SNode *Child()           { return child; }
   void SetChild(SNode *c)  { child = c; if (child) child->SetOwner(this); } 
   void MoveChild(SNode* c) { child = c; if (child) { child->SetOwner(NULL); child->SetOwner(this); } } 
protected:
   SNode *child;
public:
   virtual void clear()     { CLEAR_NODE(child) SNode::clear(); }
   virtual const char* title() const   { return "SNodeOne"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { SNode::print(level, file, print_mode); PRINT_NODE(child) }
};

class SNodeTwo : public SNode {
public:
   SNodeTwo(S_Type s = stNone) :SNode(s), left(NULL), right(NULL) {}
   SNodeTwo(const T_Lexeme& h, S_Type s, SNode *l, SNode *r) :SNode(h,s) { SetBoth(l,r); }
   virtual ~SNodeTwo() {}
   virtual TNode* Create(A_Syntax* syntax);
public:
   virtual void Add(SNode *r)          { if (left == NULL) SetLeft(r); else SetRight(r); } 
   virtual SNode *Get(int i)           { return (i == 0) ? left : right; }
   virtual int  Count() const          { return (left != NULL) + (right != NULL); }
public:
   SNode *Left()                    { return left; }
   void SetLeft(SNode *l)           { left = l; if (left) left->SetOwner(this); } 
   void MoveLeft(SNode *l)          { left = l; if (left) { left->SetOwner(NULL); left->SetOwner(this); } }
   SNode *Right()                   { return right; }
   void SetRight(SNode *r)          { right = r; if (right) right->SetOwner(this); } 
   void MoveRight(SNode *r)         { right = r; if (right) { right->SetOwner(NULL); right->SetOwner(this); }  }
   void SetBoth(SNode *l, SNode *r) { SetLeft(l); SetRight(r); } 
protected:
   SNode *left; SNode *right;
public:
   virtual void clear()                { CLEAR_NODE(left) CLEAR_NODE(right) SNode::clear(); }
   virtual const char* title() const   { return "SNodeTwo"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { SNode::print(level, file, print_mode); PRINT_NODE(left) PRINT_NODE(right) }
};

class SNodeThree : public SNodeTwo {
public:
   SNodeThree(S_Type s = stNone) :SNodeTwo(s), mid(NULL) {}
   SNodeThree(const T_Lexeme& h, S_Type s, SNode *l, SNode *m, SNode *r) :SNodeTwo(h,s,l,r), mid(m) { if (mid) mid->SetOwner(this); }
   virtual ~SNodeThree() {}
   virtual TNode* Create(A_Syntax* syntax);
public:
   virtual void Add(SNode *r)          { if (left == NULL) SetLeft(r); else { if (mid == NULL) SetMid(r); else SetRight(r); } } 
   virtual SNode *Get(int i)           { return (i == 0) ? left : ((i == 1) ? mid : right); }
   virtual int  Count() const          { return SNodeTwo::Count() + (mid != NULL); }
public:
   SNode *Mid()                     { return mid; }
   void SetMid(SNode *m)            { mid = m; if (mid) mid->SetOwner(this); } 
   void SetThree(SNode *l, SNode *m, SNode *r) { SetBoth(l,r); SetMid(m); } 
protected:
   SNode *mid;
public:
   virtual void clear()                { CLEAR_NODE(mid) SNodeTwo::clear(); }
   virtual const char* title() const   { return "SNodeThree"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { SNode::print(level, file, print_mode); PRINT_NODE(left) PRINT_NODE(mid) PRINT_NODE(right) }
};

class SNodeFour : public SNodeThree {
public:
   SNodeFour(S_Type s = stNone) :SNodeThree(s), four(NULL) {}
   SNodeFour(const T_Lexeme& h, S_Type s, SNode *l, SNode *m, SNode *r, SNode *f) :SNodeThree(h,s,l,m,r), four(f) { if (four) four->SetOwner(this); }
   virtual ~SNodeFour() {}
   virtual TNode* Create(A_Syntax* syntax);
public:
   virtual void Add(SNode *r)          { if (left == NULL) SetLeft(r); else { if (mid == NULL) SetMid(r); else { if (right == NULL) SetRight(r); else SetFour(r); } } } 
   virtual SNode *Get(int i)           { return (i == 0) ? left : ((i == 1) ? mid : ((i == 2) ? right : four)); }
   virtual int  Count() const          { return SNodeThree::Count() + (four != NULL); }
public:
   SNode *Four()                     { return four; }
   void SetFour(SNode *f)            { four = f; if (four) four->SetOwner(this); } 
   void SetAll(SNode *l, SNode *m, SNode *r, SNode *f) { SetThree(l,m,r); SetFour(f); } 
protected:
   SNode *four;
public:
   virtual void clear()                { CLEAR_NODE(four) SNodeThree::clear(); }
   virtual const char* title() const   { return "SNodeFour"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { SNode::print(level, file, print_mode); PRINT_NODE(left)  PRINT_NODE(mid) PRINT_NODE(right) PRINT_NODE(four) }
};

class SNodeList : public SNode, public std::vector<SNode*> {
public:
   SNodeList(S_Type s = stNone) :SNode(s) {}
   SNodeList(const T_Lexeme& h, S_Type s) :SNode(h,s) {}
   virtual ~SNodeList() {}
   virtual TNode* Create(A_Syntax* syntax);
   virtual TNode* Make(A_Syntax* syntax);
public:
   SNode *Last()                       { if (empty()) return NULL; return back(); }
   void Insert(int i,SNode *r)         { r->SetOwner(this); insert(begin() + i, r); } 
public:
   virtual void Add(SNode *r)          { r->SetOwner(this); push_back(r); } 
   virtual SNode *Get(int i)           { return (*this)[i]; }
   virtual int  Count() const          { return (int)size(); }
public:
   virtual void clear();
   virtual const char* title() const   { return "SNodeList"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
};

#include "Rules.h"
// ------------------------- T_SyntaxNode ----------------------
class T_SyntaxNode {
public:
   T_SyntaxNode() {}
   T_SyntaxNode(const GSymbol& sym) :symbol(sym), child(0) {}
   virtual ~T_SyntaxNode() {}
   virtual void Add(T_SyntaxNode* node, int index) {}
   virtual void Insert(T_SyntaxNode* node, int index) {}
   virtual T_SyntaxNode* Get(int index) const { return NULL; }
public:
   virtual T_SyntaxNode* trim() { return NULL; }
   virtual void clear();
   virtual void print(const TGrammar* grammar, int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const;
public:
   GSymbol symbol;
   int child;
};

class TLexemeNode : public T_SyntaxNode {
public:
   TLexemeNode() {}
   TLexemeNode(const GSymbol& sym) :T_SyntaxNode(sym) {}
   TLexemeNode(const T_Lexeme& lex) :T_SyntaxNode(lex), lexeme(lex) {}
   virtual ~TLexemeNode() {}
public:
   virtual void clear();
   virtual void print(const TGrammar* grammar, int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const;
public:
   T_Lexeme lexeme;
};

class TProduceNode : public T_SyntaxNode, public std::vector<T_SyntaxNode*> {
public:
   TProduceNode() {}
   TProduceNode(const GSymbol& sym) :T_SyntaxNode(sym), children(0), master(0) {}
   virtual ~TProduceNode() {}
   virtual void Add(T_SyntaxNode* node, int index);
   virtual void Insert(T_SyntaxNode* node, int index);
   virtual T_SyntaxNode* Get(int index) const { return (*this)[index]; }
public:
   virtual T_SyntaxNode* trim();
   virtual void clear();
   virtual void print(const TGrammar* grammar, int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const;
public:
   int children, master;
};

class TSyntaxTree {
public:
   TSyntaxTree() :root(NULL), grammar(NULL) {}
   T_SyntaxNode* tree() { return root; }
   T_SyntaxNode* New(const GSymbol& type);
   T_SyntaxNode* New(const T_Lexeme& lexeme);
   void operator = (T_SyntaxNode* join) { root = join; }
public:
   void trim();
   virtual void clear();
   void print(const char *file_name, int print_mode) const;
public:
   T_SyntaxNode* root;
   TGrammar* grammar;
};

const char* snode_title(SNode::S_Type t);
const char*  turn_title(SNode::T_Turn t);
SNode::S_Type title_snode_maker(const char* t);
SNode::T_Turn title_tnode_maker(const char* t);
#endif

// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "Syntax.h"

// --------------------------- T_Syntax ---------------------------

bool T_Syntax::Assign()
{
   if (!Question()) return false;
	if (Match(T_Symbol::prAssign)) {
	   return Assign();
	}
   return true;
}

bool T_Syntax::Question()
{
#ifndef EXPRESION_BINARY
   if (!OrOr()) return false;
#else
   if (!Binary(T_Symbol::prOrOr)) return false;
#endif
	if (Match(T_Symbol::prQuestion)) {
	   if (!Question()) return false;
		if (!MatchMust(T_Symbol::lxColon)) return false;
	   return Question();
	}
   return true;
}

#ifndef EXPRESION_BINARY
bool T_Syntax::OrOr()
{
   if (!AndAnd()) return false;
   while (Match(T_Symbol::prOrOr)) {
      if (!AndAnd()) return false;
      }
   return true;
}

bool T_Syntax::AndAnd()
{
   if (!Or()) return false;
   while (Match(T_Symbol::prAndAnd)) {
      if (!Or()) return false;
      }
   return true;
}

bool T_Syntax::Or()
{
   if (!XOr()) return false;
   while (Match(T_Symbol::prOr)) {
      if (!XOr()) return false;
      }
   return true;
}

bool T_Syntax::XOr()
{
   if (!And()) return false;
   while (Match(T_Symbol::prXOr)) {
      if (!And()) return false;
      }
   return true;
}

bool T_Syntax::And()
{
   if (!Equ()) return false;
   while (Match(T_Symbol::prAnd)) {
      if (!Equ()) return false;
      }
   return true;
}

bool T_Syntax::Equ()
{
   if (!Compare()) return false;
   while (Match(T_Symbol::prEqu)) {
      if (!Compare()) return false;
      }
   return true;
}

bool T_Syntax::Compare()
{
   if (!Shift()) return false;
   while (Match(T_Symbol::prCompare)) {
      if (!Shift()) return false;
      }
   return true;
}

bool T_Syntax::Shift()
{
   if (!Term()) return false;
   while (Match(T_Symbol::prShift)) {
      if (!Term()) return false;
      }
   return true;
}

bool T_Syntax::Term()
{
   if (!Factor()) return false;
   while (Match(T_Symbol::prTerm)) {
      if (!Factor()) return false;
      }
   return true;
}

bool T_Syntax::Factor()
{
   if (!Unary()) return false;
   while (Match(T_Symbol::prFactor)) {
      if (!Unary()) return false;
      }
   return true;
}
#endif

bool T_Syntax::Unary()
{
	if (Match(T_Symbol::prUnary) || Match(T_Symbol::prTerm) || Match(T_Symbol::prIncDec)) {
	   return Unary();
	}
   T_ScanStore store; Store(store);
   if (Match(T_Symbol::lxLeftBracket)) { // ([const] int) unary
   	bool constant = Match(T_Lexeme::W_Type::rwConst);
      if (Match(T_Lexeme::W_Type::rwDefine) && Match(T_Symbol::lxRightBracket)) {
   	   return Unary();
      } else {
         if (constant) return error(erUnknownCast);
      } 
	}
   Restore(store);
   if (!Primary()) return false;
	while (Match(T_Symbol::prIncDec)) {}
   return true;
}

bool T_Syntax::Primary()
{
   if (Match(T_Lexeme::grIdent)) {
		if (Match(T_Symbol::lxLeftBracket)) {
			if (!Match(T_Symbol::lxRightBracket)) {
			   do {
					if (!Expressions()) return false;
				} while (Match(T_Symbol::lxComma));
			   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
			}
			return true;
		}
		while (Match(T_Symbol::lxLeftScrape)) {
			if (!Expressions()) return false;
		   if (!MatchMust(T_Symbol::lxRightScrape)) return false;
		}
		return true;
	}
   if (Match(T_Lexeme::grInteger)) return true;
   if (Match(T_Lexeme::grNumber)) return true;
   if (Match(T_Symbol::lxLeftBracket)) {
      return Expressions() && Match(T_Symbol::lxRightBracket);
      }
   if (Match(T_Lexeme::W_Type::rwDefine)) {
	   return MatchMust(T_Symbol::lxLeftBracket) && Expressions() && MatchMust(T_Symbol::lxRightBracket);
   }
   return error(erPrimary);
}

bool T_Syntax::Binary(T_Symbol::T_Priority priority)
{
   if ((priority + 1) < T_Symbol::prUnary) {
      if (!Binary(T_Symbol::T_Priority(priority + 1))) return false;
   } else {
      if (!Unary()) return false;
   }
   while (Match(priority)) {
      if ((priority + 1) < T_Symbol::prUnary) {
         if (!Binary(T_Symbol::T_Priority(priority + 1))) return false;
      } else {
         if (!Unary()) return false;
      }
   }
   return true;
}

bool T_Syntax::Statements(T_Part part)
{
   while (!Match(T_Lexeme::grEof)) {
      if (!Statement(part)) return false;
   }
   return true;
}

bool T_Syntax::Translate()
{
   return Statements(T_Part::psMain);
}

bool T_Syntax::Statement(T_Part part)
{

	if (Match(T_Symbol::lxSemicolon)) return !(part & T_Part::psNoSemicolon);

   if (part & T_Part::psDefine) {
      T_Lexeme l;
      int def = SCDefine(l,0x26); // -1 - error, 0, 0x01 - define, 0x02 - const, 0x04 - static, 0x20 - void
		if (def < 0) return false;
		if (def) {
         forward = l;
		   return Define(part);
		}
	}
   if (part & T_Part::psStatement) {
      T_ScanStore store; Store(store);
      if (Match(T_Lexeme::grIdent) && Match(T_Symbol::lxColon)) {
         return Statement(T_Part::psLabel);
      } 
      Restore(store);
      if (Match(T_Lexeme::W_Type::rwFor))      return For();
      if (Match(T_Lexeme::W_Type::rwWhile))    return While();
      if (Match(T_Lexeme::W_Type::rwIf))       return If();
      if (Match(T_Lexeme::W_Type::rwDo))       return Do();
      if (Match(T_Lexeme::W_Type::rwContinue)) return Continue();
      if (Match(T_Lexeme::W_Type::rwBreak))    return Break();
      if (Match(T_Lexeme::W_Type::rwGoTo))     return GoTo();
      if (Match(T_Lexeme::W_Type::rwReturn))   return Return();
      if (Match(T_Lexeme::W_Type::rwSwitch))   return Switch();
	}
   if (part & T_Part::psCompaund) {
      if (Match(T_Symbol::lxLeftCramp)) return Compaund();
	}

   if (part & T_Part::psExpression) {
      return Expressions() && ((part & T_Part::psNoSemicolon) || Match(T_Symbol::lxSemicolon));
	}

   return false;
}

bool T_Syntax::Expressions()
{
   do {
      if (!Assign()) return false;
   } while (Match(T_Symbol::lxComma));
   return true;
}

bool T_Syntax::Compaund()
{
   while (!Match(T_Symbol::lxRightCramp)) {
      if (!Statement(T_Part::psBody)) return false;
   }
   return true;
}

bool T_Syntax::DefineParam()
{
   T_Lexeme l;
   int def = SCDefine(l, 0x0A); // -1 - error, 0, 0x01 - define, 0x02 - const, 0x04 - static, 0x08 - &
	if (def < 0) return false;
   if (!def) return error(erDefine);
   if (Match(T_Lexeme::grIdent)) {}
   int scrape = 0;
	while (Match(T_Symbol::lxLeftScrape)) {
	   if (!scrape++ && Match(T_Symbol::lxRightScrape)) continue;
		if (!Assign()) return false;
	   if (!MatchMust(T_Symbol::lxRightScrape)) return false;
	}
   if (Match(T_Symbol::lxAssign)) {
      return Assign();
   }
   return true;
}

bool T_Syntax::DefineParams()
{
   do {
      if (!DefineParam()) return false;
   } while (Match(T_Symbol::lxComma));
   return true;
}

bool T_Syntax::InitializerItem()
{
   if (MatchSpot(T_Symbol::lxLeftCramp)) return Initializer();
   return Assign();
}

bool T_Syntax::Initializer()
{
   if (!MatchMust(T_Symbol::lxLeftCramp)) return false;
   if (Match(T_Symbol::lxRightCramp)) return true;
   do {
      if (!InitializerItem()) return false;
   } while (Match(T_Symbol::lxComma));
   if (!MatchMust(T_Symbol::lxRightCramp)) return false;
   return true;
}

int T_Syntax::DefineItem(const T_Lexeme &lexeme, T_Part part)
{
	bool reference = (Match(T_Symbol::lxAnd));
   if (!Match(T_Lexeme::grIdent)) return error(erNoIdent);
   if (Match(T_Symbol::lxLeftBracket)) {
      if (!(part & psDefFunc)) return error(erDefFunc);
		if (!Match(T_Symbol::lxRightBracket)) {
         if (!DefineParams()) return false;
		   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
         }
      return -1;
   }
   if (lexeme.Match(T_Lexeme::W_Type::rwVoid)) return false;
   if (Match(T_Symbol::lxAssign)) {
      return Assign();
   }
   int scrape = 0;
	while (Match(T_Symbol::lxLeftScrape)) {
	   if (!scrape++ && Match(T_Symbol::lxRightScrape)) continue;
		if (!Assign()) return false;
	   if (!MatchMust(T_Symbol::lxRightScrape)) return false;
	}
   if (scrape && Match(T_Symbol::lxAssign)) {
      return Initializer();
   }
   return true;
}

bool T_Syntax::Define(T_Part part)
{
   T_Lexeme lexeme = forward;
   int count = 0, def;
   do {
      def = DefineItem(lexeme, part);
      if (!def) return false;
      count++;
   } while (Match(T_Symbol::lxComma));
   if ((count == 1) && (def == -1)) {
      if (Match(T_Symbol::lxLeftCramp)) {
         if (!Compaund()) return false;
         def = -2;
      }
   }
   return (part & T_Part::psNoSemicolon) || Match(T_Symbol::lxSemicolon) || (def == -2);
}

bool T_Syntax::For()
{
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psForBeg)) return false;
   if (!Statement(T_Part::psForExpr)) return false;
   if (!Match(T_Symbol::lxRightBracket)) {
      if (!Expressions()) return false;
      if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   }
   if (!Statement(T_Part::psBody)) return false;
   return true;
}

bool T_Syntax::While()
{
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psCondition)) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   if (!Statement(T_Part::psBody)) return false;
   return true;
}

bool T_Syntax::If()
{
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psCondition)) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   if (!Statement(T_Part::psBody)) return false;
   if (Match(T_Lexeme::W_Type::rwElse)) {
      if (!Statement(T_Part::psBody)) return false;
   }
   return true;
}

bool T_Syntax::Do()
{
   if (!Statement(T_Part::psBody)) return false;
   if (!Match(T_Lexeme::W_Type::rwWhile)) return false;
   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Statement(T_Part::psCondition)) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   return MatchMust(T_Symbol::lxSemicolon);
}

bool T_Syntax::GoTo()
{
   return Match(T_Lexeme::grIdent) && MatchMust(T_Symbol::lxSemicolon);
}

bool T_Syntax::Continue()
{
   return MatchMust(T_Symbol::lxSemicolon);
}

bool T_Syntax::Break()
{
   return MatchMust(T_Symbol::lxSemicolon);
}

bool T_Syntax::Return()
{
	if (Match(T_Symbol::lxSemicolon)) return true;
   if (!Expressions()) return false;
   return MatchMust(T_Symbol::lxSemicolon);
}

bool T_Syntax::Switch()
{
	const int i = 0;
	switch (i) {
	case (i + 5) :;
	}


   if (!MatchMust(T_Symbol::lxLeftBracket)) return false;
   if (!Expressions()) return false;
   if (!MatchMust(T_Symbol::lxRightBracket)) return false;
   if (!MatchMust(T_Symbol::lxLeftCramp)) return false;
   int case_count = 0, default_count = 0;
   do {
      while (Match(T_Lexeme::W_Type::rwCase) || Match(T_Lexeme::W_Type::rwDefault)) {
         if (forward.Match(T_Lexeme::W_Type::rwCase)) {
            case_count++; 
            if (!Question()) return error(erNoInteger);;
         } else {
            if (default_count++) return false;
         } 
         if (!MatchMust(T_Symbol::lxColon)) return false;
      }
      while (!MatchSpot(T_Lexeme::W_Type::rwCase) && !MatchSpot(T_Lexeme::W_Type::rwDefault) && !MatchSpot(T_Symbol::lxRightCramp)) {
         if (!Statement(T_Part::psCase)) return false;
      }
   } while (!Match(T_Symbol::lxRightCramp));
   if (!case_count || (default_count > 1)) return false;
   return true;
}
#ifndef TRN_SYNTAX_H
#define TRN_SYNTAX_H

#include "Parse.h"
#include "ASyntax.h"
 
// --------------------------- T_Syntax ---------------------------

#define EXPRESION_BINARY
class T_Syntax : public A_Syntax
{
public:
	T_Syntax(T_Scan *s) : A_Syntax(s) {}

	bool Assign();	
	bool Question();
#ifndef EXPRESION_BINARY
   bool OrOr();
	bool AndAnd();
	bool Or();
	bool XOr();
	bool And();
	bool Equ();
	bool Compare();
	bool Shift();
	bool Term();
	bool Factor();
#endif
   bool Unary();
	bool Primary();

	bool Binary(T_Symbol::T_Priority priority);

	bool error(T_Error code, int value = 0) { return error(code,lex,value); }
	bool error(T_Error code, const T_Lexeme &l, int value) {  return Error.error(code,l,value); }

	bool Expressions();
   bool Statement(T_Part part);
   bool Statements(T_Part part);
   bool Compaund();

	bool Define(T_Part part);
	int  DefineItem(const T_Lexeme &l, T_Part part);
   bool DefineParam();
   bool DefineParams();
   bool Initializer();
   bool InitializerItem();
	bool For();
	bool If();
	bool While();
	bool Do();
	bool GoTo();
	bool Continue();
	bool Break();
	bool Return();
	bool Switch();

   virtual bool Translate();

protected:
};

#endif

// TableBuilder.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Parse.h"
#include "GSyntax.h"
#include "FSyntax.h"
#include "InHelp.h"

#include "Maker.h"
#include "GrammarStock.h"
#include "Grammar.h"

char* get_file_name(const char*file, const char* ext);

// --------------------------- GSyntax ---------------------------
#include "GSyntax.h"

extern bool grammar_reception(TGrammar& table, int type, int option, const char *file, const char *table_file, const T_WordTable* word_table = &T_KeyWordTable::key_word_table);

void test(int type, int option, const char *file, const char *table_file)
{
   M_Syntax::M_Mode make_mode = M_Syntax::M_Mode((type & 0x0F0) >> 4);
   A_Syntax::T_SyntaxMode syntax_mode = A_Syntax::T_SyntaxMode(type & 0x00F);
   int look_ahead = (type & 0x000F0000) >> 16;

   if ((syntax_mode == A_Syntax::T_SyntaxMode::smParseYACC) || (look_ahead > 1)) {
      option |= TGrammar::POption::opNoPriorAssign;
   }

   TGrammar table;
   TNameTable names; table.names = &names;
   if (!grammar_reception(table, type, option, file, table_file)) return;

   T_Lexeme::word_table = &T_KeyWordTable::key_word_table;

   table.Make(type, syntax_mode, make_mode, file);

}

int main(int argc, const char* argv[])
{
   TInHelp in_help(TInHelp::Table);
//   in_help.file = "xAxa.tab"; // "FSyntax.tab";
//   in_help.file = "LR_LRk.tab";
//   in_help.file = "..\\Table\\NR_SN_YACC.y"; 

//   in_help.table = "..\\Grammar\\ETF_LR.y";  
//   in_help.file  = "ETF_LR_.tab";
//   in_help.type  = 0x000D08;

   in_help.table = "..\\Grammar\\ETF_LR_TC.bnf";
   in_help.file = "ETF_LR_TC.tab";
   in_help.type = 0x000B8;

   in_help.option = 0x100911FF;

//   in_help.option |= TGrammar::opCompression;   // 0x00200000
//   in_help.option |= TGrammar::opNoPriorAssign; // 0x00800000

//   in_help.type = 0x00021E;
//   in_help.type = 0x000407;

//   TableBuilder 02071A 0x108915FF ETF\ETF_LR_TC_LALR2.tab
//   TableBuilder 010E15 0x000911ff DefExpr\DefExpr_LLk.tab DefExpr_LL.y
//   TableBuilder 020E18 0x003931FF BNF.tab ..\Grammar\bnf.y

//   in_help.option |= TGrammar::opTable;       // 0x00002000
//   in_help.type = 0x020E18;
//   in_help.table = "bnf.y";  
//   in_help.file = "BNF.tab";

//   TableBuilder.exe E36 0x00002001 Table\FSyntax.tab Grammar\FSyntax.y
//   in_help.type = 0x000E36;
//   in_help.option = 0x00002001;
//   in_help.table = "FSyntax.y";  
//   in_help.file = "FSyntax.tab";

//   TableBuilder.exe 010015 004931FF LXk\LL_TC_LL1.tab
//   in_help.type = 0x020015;
//   in_help.option = 0x006931FF;
//   in_help.file = "LL_TC_LL2.tab";

//   in_help.type = 0x00031E;
//   in_help.option = 0x00000000;
//   in_help.option |= TGrammar::opGrammar; // | TGrammar::opBNF;
//   in_help.file = "NR_YACC_TC.y";

//   in_help.table = "NR_BNF_TC.bnf";
//   in_help.file = "NR_BNF_TC.tab";
//   in_help.type = 0x000B08;

   in_help.table = "NR_YACC_TC.yacc";
   in_help.file = "NR_YACC_TC.tab";
   in_help.type = 0x000D08;

//   TableBuilder.exe 0x020D38 0x001931FF ..\Table\BSyntax.tab ..\Grammar\BSyntax.y
//   in_help.table = "..\\Grammar\\BSyntax.y";
//   in_help.file = "BSyntax.tab";
//   in_help.type = 0x020D38;
//   in_help.option = 0x001931FF;

//   in_help.type = 0x010405;
//   in_help.option = 0x004931FF;
//   in_help.file = "ETF_LLk_.tab";

//   TableBuilder 010219 00091800 ..\Table\LR_TC_LRk_Core.tab
   in_help.file = "LR_TC_LR1_Core.tab";
   in_help.type = 0x000219;
   in_help.option = 0x00091901;

   in_help.table = "Green_E_5_26.bnf";
   in_help.file = "Green_E_5.26_C.tab";
   in_help.type = 0x020B08;
   in_help.option = 0x000B1901;

   in_help.table = "ETF_LL_TC.grammar";
   in_help.file = "ETF_LL_TC_D.tab";
   in_help.type = 0x000D08;
   in_help.option = 0x000B1901;
   
//   ..\Release\TableBuilder.exe 0x040E08 0x000B1801 Core\Green_L_8_7_LRk.tab   ..\Grammar\Green_L_8_7.grammar
//   in_help.table = "Green_L_8_7.grammar";
//   in_help.file = "Green_L_8.7.tab";
//   in_help.type = 0x040E08;
//   in_help.option = 0x000B1801;

//   ..\Release\TableBuilder.exe 0x040D08 0x000B1801 Core\Green_L_8_7_LRk.tab   ..\Grammar\Green_L_8_7.grammar
//   in_help.type = 0x040D08;

//   TableBuilder 218 00391000 ..\Table\LR_TC_LR1.tab 
   in_help.file = "..\\Table\\LR_TC_LR1.tab";
   in_help.type = 0x000218;
   in_help.option = 0x00031100;

//   TableBuilder 010608 104931FF ETF\ETF_LR_LRk.tab
   in_help.file = "ETF_LR_LRk.tab";
   in_help.type = 0x010608;
   in_help.option = 0x104931FF;
//   TableBuilder 015 003931FF ..\Table\LL_TC_LL1.tab 
   in_help.file = "LL_TC_LL1.tab";
   in_help.type = 0x000015;
   in_help.option = 0x00001141;
//   TableBuilder 035 003911FF ..\Table\LL_SN_LL1.tab
   in_help.file = "LL_SN_LL1.tab";
   in_help.type = 0x000016;
   in_help.option = 0x003911FF;
//   TableBuilder 035 003911FF ..\Table\LL_SN_LL1.tab
   in_help.table = "sql.y";
   in_help.file = "sql.tab";
   in_help.type = 0x010D06;
   in_help.option = 0x00193101;
// * * * * * * *
   in_help.file = "ETF_LR_LRkCore.tab";
   in_help.type = 0x010509;
   in_help.option = 0x104931FF;

//   TableBuilder 020E18 000910ff ETF_LR_LR2.tab ..\Grammar\ETF_LR.grammar
   in_help.table = "..\\Grammar\\ETF_GG.grammar";
//   in_help.table = "..\\Grammar\\SaSb.y";
   //   in_help.table = "..\\Grammar\\SaSb.y";
   in_help.file = "ETF_GG.tab";
   in_help.type = 0x010E18;
   in_help.option = 0x000918ff;
   in_help.option |= TGrammar::opFiUnattainable; 
//   in_help.option |= TGrammar::opSplitting;
   in_help.option |= TGrammar::opChainRule;
   in_help.option = 0x011979FF;

//   TableBuilder.exe 010E18 0x0009B9FF ETF_TC_Fi.tab ..\Grammar\ETF_LR_TC.grammar
   in_help.option = 0x0009F9FF;
   in_help.table = "..\\Grammar\\ETF_LR_TC.grammar";
//   in_help.file = "SLR_TC_Fi_.tab";
   in_help.file = "ETF_TC_Fi_.tab";
   in_help.type = 0x010E18;
//   in_help.option |= TGrammar::opSplittingAddition;
//   in_help.option |= TGrammar::opChainRule;

//   if (!in_help.input(argc,argv)) return 0;
   test(in_help.type, in_help.option, in_help.file, in_help.table);

	return 0;
}

void make_actions(TGrammar& grammar)
{
static const int A[][16] = {
{11,0,0,0,0,1,1,0,0,0,4,11,1,0,0,0},
{11,0,0,0,0,1,2,0,0,0,4,11,2,0,0,0},
{11,0,0,0,0,1,3,0,0,0,4,11,3,0,0,0},
{11,0,0,0,0,3,2,54,0,0,1,11,4,0,0,0},
{11,0,0,0,0,3,2,56,0,0,2,2,3,1,5,0},
{11,0,0,0,0,3,6,0,0,0,2,2,3,1,5,0},
{11,1,0,0,0,6,0,0,0,0,3,2,0,0,0,0},
{11,2,0,0,0,6,0,0,0,0,2,2,1,0,1,0},
{11,3,0,0,0,1,8,0,0,0,4,11,5,0,0,0},
{11,3,0,0,0,1,9,0,0,0,4,11,6,0,0,0},
{11,3,0,0,0,1,10,0,0,0,4,11,7,0,0,0},
{11,3,0,0,0,3,2,56,0,0,1,11,8,0,0,0},
{11,3,0,0,0,3,6,0,0,0,2,2,8,1,16,0},
{11,4,0,0,0,1,4,0,0,0,4,11,9,0,0,0},
{11,4,0,0,0,1,5,0,0,0,4,11,10,0,0,0},
{11,4,0,0,0,3,7,15,0,0,1,11,11,0,0,0},
{11,5,0,0,0,1,11,0,0,0,4,11,12,0,0,0},
{11,5,0,0,0,1,12,0,0,0,4,11,13,0,0,0},
{11,5,0,0,0,3,6,0,0,0,1,11,14,0,0,0},
{11,6,0,0,0,1,10,0,0,0,4,11,15,0,0,0},
{11,6,0,0,0,3,2,53,0,0,1,11,16,0,0,0},
{11,6,0,0,0,3,2,56,0,0,1,11,8,0,0,0},
{11,7,0,0,0,3,2,53,0,0,2,2,9,1,18,0},
{11,7,0,0,0,3,2,56,0,0,2,2,9,1,18,0},
{11,8,0,0,0,3,6,0,0,0,1,11,17,0,0,0},
{11,9,0,0,0,1,5,0,0,0,4,11,18,0,0,0},
{11,9,0,0,0,3,2,55,0,0,1,11,19,0,0,0},
{11,9,0,0,0,3,7,15,0,0,1,11,11,0,0,0},
{11,10,0,0,0,3,2,55,0,0,2,2,4,1,7,0},
{11,10,0,0,0,3,7,15,0,0,2,2,4,1,7,0},
{11,11,0,0,0,3,2,34,0,0,1,11,20,0,0,0},
{11,11,0,0,0,3,6,0,0,0,1,11,21,0,0,0},
{11,11,0,0,0,3,7,49,0,0,1,11,22,0,0,0},
{11,12,0,0,0,1,12,0,0,0,4,11,23,0,0,0},
{11,12,0,0,0,3,2,53,0,0,1,11,24,0,0,0},
{11,12,0,0,0,3,6,0,0,0,1,11,14,0,0,0},
{11,12,0,0,0,6,0,0,0,0,2,2,2,1,3,0},
{11,13,0,0,0,3,2,53,0,0,2,2,11,1,21,0},
{11,13,0,0,0,3,6,0,0,0,2,2,11,1,21,0},
{11,13,0,0,0,6,0,0,0,0,2,2,11,1,21,0},
{11,14,0,0,0,3,2,46,0,0,1,11,25,0,0,0},
{11,15,0,0,0,3,2,53,0,0,2,2,9,0,17,0},
{11,15,0,0,0,3,2,56,0,0,2,2,9,0,17,0},
{11,16,0,0,0,3,6,0,0,0,2,2,8,0,15,0},
{11,17,0,0,0,3,3,0,0,0,1,11,26,0,0,0},
{11,18,0,0,0,3,2,55,0,0,2,2,4,0,6,0},
{11,18,0,0,0,3,7,15,0,0,2,2,4,0,6,0},
{11,19,0,0,0,3,2,56,0,0,2,2,3,0,4,0},
{11,19,0,0,0,3,6,0,0,0,2,2,3,0,4,0},
{11,20,0,0,0,1,6,0,0,0,4,11,27,0,0,0},
{11,20,0,0,0,1,7,0,0,0,4,11,28,0,0,0},
{11,20,0,0,0,3,6,0,0,0,1,11,29,0,0,0},
{11,21,0,0,0,3,2,34,0,0,1,11,30,0,0,0},
{11,22,0,0,0,3,6,0,0,0,1,11,31,0,0,0},
{11,23,0,0,0,3,2,53,0,0,2,2,11,0,20,0},
{11,23,0,0,0,3,6,0,0,0,2,2,11,0,20,0},
{11,23,0,0,0,6,0,0,0,0,2,2,11,0,20,0},
{11,24,0,0,0,6,0,0,0,0,2,2,2,0,2,0},
{11,25,0,0,0,1,13,0,0,0,4,11,32,0,0,0},
{11,25,0,0,0,1,14,0,0,0,4,11,33,0,0,0},
{11,25,0,0,0,1,15,0,0,0,4,11,34,0,0,0},
{11,25,0,0,0,1,17,0,0,0,4,11,35,0,0,0},
{11,25,0,0,0,1,19,0,0,0,4,11,36,0,0,0},
{11,25,0,0,0,1,22,0,0,0,4,11,37,0,0,0},
{11,25,0,0,0,3,1,15,0,0,1,11,38,0,0,0},
{11,25,0,0,0,3,1,26,0,0,1,11,39,0,0,0},
{11,25,0,0,0,3,2,34,0,0,1,11,40,0,0,0},
{11,25,0,0,0,3,2,45,0,0,2,2,13,1,24,0},
{11,25,0,0,0,3,3,0,0,0,1,11,41,0,0,0},
{11,25,0,0,0,3,6,0,0,0,1,11,42,0,0,0},
{11,26,0,0,0,3,2,53,0,0,2,2,10,0,19,0},
{11,26,0,0,0,3,2,56,0,0,2,2,10,0,19,0},
{11,27,0,0,0,3,2,35,0,0,1,11,43,0,0,0},
{11,27,0,0,0,3,2,44,0,0,1,11,44,0,0,0},
{11,28,0,0,0,3,2,35,0,0,2,2,6,1,12,0},
{11,28,0,0,0,3,2,44,0,0,2,2,6,1,12,0},
{11,29,0,0,0,3,1,14,0,0,1,11,45,0,0,0},
{11,29,0,0,0,3,2,35,0,0,2,2,7,1,14,0},
{11,29,0,0,0,3,2,44,0,0,2,2,7,1,14,0},
{11,30,0,0,0,1,6,0,0,0,4,11,46,0,0,0},
{11,30,0,0,0,1,7,0,0,0,4,11,28,0,0,0},
{11,30,0,0,0,3,6,0,0,0,1,11,29,0,0,0},
{11,31,0,0,0,3,2,34,0,0,1,11,47,0,0,0},
{11,32,0,0,0,3,2,45,0,0,1,11,48,0,0,0},
{11,33,0,0,0,1,15,0,0,0,4,11,49,0,0,0},
{11,33,0,0,0,1,17,0,0,0,4,11,35,0,0,0},
{11,33,0,0,0,1,19,0,0,0,4,11,36,0,0,0},
{11,33,0,0,0,1,22,0,0,0,4,11,37,0,0,0},
{11,33,0,0,0,3,1,15,0,0,1,11,38,0,0,0},
{11,33,0,0,0,3,1,26,0,0,1,11,39,0,0,0},
{11,33,0,0,0,3,2,34,0,0,1,11,40,0,0,0},
{11,33,0,0,0,3,2,45,0,0,2,2,13,0,23,0},
{11,33,0,0,0,3,3,0,0,0,1,11,41,0,0,0},
{11,33,0,0,0,3,6,0,0,0,1,11,42,0,0,0},
{11,34,0,0,0,3,1,15,0,0,2,2,14,1,26,0},
{11,34,0,0,0,3,1,26,0,0,2,2,14,1,26,0},
{11,34,0,0,0,3,2,34,0,0,2,2,14,1,26,0},
{11,34,0,0,0,3,2,45,0,0,2,2,14,1,26,0},
{11,34,0,0,0,3,3,0,0,0,2,2,14,1,26,0},
{11,34,0,0,0,3,6,0,0,0,2,2,14,1,26,0},
{11,35,0,0,0,3,1,15,0,0,2,2,15,0,27,0},
{11,35,0,0,0,3,1,26,0,0,2,2,15,0,27,0},
{11,35,0,0,0,3,2,34,0,0,2,2,15,0,27,0},
{11,35,0,0,0,3,2,45,0,0,2,2,15,0,27,0},
{11,35,0,0,0,3,3,0,0,0,2,2,15,0,27,0},
{11,35,0,0,0,3,6,0,0,0,2,2,15,0,27,0},
{11,36,0,0,0,3,1,15,0,0,2,2,15,1,28,0},
{11,36,0,0,0,3,1,26,0,0,2,2,15,1,28,0},
{11,36,0,0,0,3,2,34,0,0,2,2,15,1,28,0},
{11,36,0,0,0,3,2,45,0,0,2,2,15,1,28,0},
{11,36,0,0,0,3,3,0,0,0,2,2,15,1,28,0},
{11,36,0,0,0,3,6,0,0,0,2,2,15,1,28,0},
{11,37,0,0,0,3,1,15,0,0,2,2,15,2,29,0},
{11,37,0,0,0,3,1,26,0,0,2,2,15,2,29,0},
{11,37,0,0,0,3,2,34,0,0,2,2,15,2,29,0},
{11,37,0,0,0,3,2,45,0,0,2,2,15,2,29,0},
{11,37,0,0,0,3,3,0,0,0,2,2,15,2,29,0},
{11,37,0,0,0,3,6,0,0,0,2,2,15,2,29,0},
{11,38,0,0,0,3,1,15,0,0,2,2,15,7,34,0},
{11,38,0,0,0,3,1,26,0,0,2,2,15,7,34,0},
{11,38,0,0,0,3,2,34,0,0,2,2,15,7,34,0},
{11,38,0,0,0,3,2,45,0,0,2,2,15,7,34,0},
{11,38,0,0,0,3,3,0,0,0,2,2,15,7,34,0},
{11,38,0,0,0,3,6,0,0,0,2,2,15,7,34,0},
{11,39,0,0,0,1,16,0,0,0,4,11,50,0,0,0},
{11,39,0,0,0,3,3,0,0,0,1,11,51,0,0,0},
{11,39,0,0,0,3,6,0,0,0,1,11,52,0,0,0},
{11,40,0,0,0,1,18,0,0,0,4,11,53,0,0,0},
{11,40,0,0,0,3,7,42,0,0,1,11,54,0,0,0},
{11,40,0,0,0,3,7,43,0,0,1,11,55,0,0,0},
{11,40,0,0,0,3,7,44,0,0,1,11,56,0,0,0},
{11,40,0,0,0,3,7,45,0,0,1,11,57,0,0,0},
{11,40,0,0,0,3,7,46,0,0,1,11,58,0,0,0},
{11,40,0,0,0,3,7,47,0,0,1,11,59,0,0,0},
{11,40,0,0,0,3,7,48,0,0,1,11,60,0,0,0},
{11,41,0,0,0,3,1,15,0,0,2,2,15,4,31,0},
{11,41,0,0,0,3,1,26,0,0,2,2,15,4,31,0},
{11,41,0,0,0,3,2,34,0,0,2,2,15,4,31,0},
{11,41,0,0,0,3,2,45,0,0,2,2,15,4,31,0},
{11,41,0,0,0,3,3,0,0,0,2,2,15,4,31,0},
{11,41,0,0,0,3,6,0,0,0,2,2,15,4,31,0},
{11,42,0,0,0,3,1,15,0,0,2,2,15,3,30,0},
{11,42,0,0,0,3,1,26,0,0,2,2,15,3,30,0},
{11,42,0,0,0,3,2,34,0,0,2,2,15,3,30,0},
{11,42,0,0,0,3,2,45,0,0,2,2,15,3,30,0},
{11,42,0,0,0,3,3,0,0,0,2,2,15,3,30,0},
{11,42,0,0,0,3,6,0,0,0,2,2,15,3,30,0},
{11,43,0,0,0,3,2,45,0,0,1,11,61,0,0,0},
{11,44,0,0,0,1,7,0,0,0,4,11,62,0,0,0},
{11,44,0,0,0,3,6,0,0,0,1,11,29,0,0,0},
{11,45,0,0,0,3,3,0,0,0,1,11,63,0,0,0},
{11,46,0,0,0,3,2,35,0,0,1,11,64,0,0,0},
{11,46,0,0,0,3,2,44,0,0,1,11,44,0,0,0},
{11,47,0,0,0,1,6,0,0,0,4,11,65,0,0,0},
{11,47,0,0,0,1,7,0,0,0,4,11,28,0,0,0},
{11,47,0,0,0,3,6,0,0,0,1,11,29,0,0,0},
{11,48,0,0,0,3,2,53,0,0,2,2,12,0,22,0},
{11,48,0,0,0,3,6,0,0,0,2,2,12,0,22,0},
{11,48,0,0,0,6,0,0,0,0,2,2,12,0,22,0},
{11,49,0,0,0,3,1,15,0,0,2,2,14,0,25,0},
{11,49,0,0,0,3,1,26,0,0,2,2,14,0,25,0},
{11,49,0,0,0,3,2,34,0,0,2,2,14,0,25,0},
{11,49,0,0,0,3,2,45,0,0,2,2,14,0,25,0},
{11,49,0,0,0,3,3,0,0,0,2,2,14,0,25,0},
{11,49,0,0,0,3,6,0,0,0,2,2,14,0,25,0},
{11,50,0,0,0,3,1,28,0,0,1,11,66,0,0,0},
{11,50,0,0,0,3,2,44,0,0,1,11,67,0,0,0},
{11,51,0,0,0,3,1,28,0,0,2,2,16,1,36,0},
{11,51,0,0,0,3,2,44,0,0,2,2,16,1,36,0},
{11,52,0,0,0,3,1,28,0,0,2,2,16,0,35,0},
{11,52,0,0,0,3,2,44,0,0,2,2,16,0,35,0},
{11,53,0,0,0,3,2,36,0,0,1,11,68,0,0,0},
{11,54,0,0,0,3,2,36,0,0,2,2,18,0,39,0},
{11,55,0,0,0,3,2,36,0,0,2,2,18,1,40,0},
{11,56,0,0,0,3,2,36,0,0,1,11,69,0,0,0},
{11,57,0,0,0,3,2,36,0,0,2,2,18,2,41,0},
{11,58,0,0,0,3,2,36,0,0,2,2,18,3,42,0},
{11,59,0,0,0,3,2,36,0,0,2,2,18,4,43,0},
{11,60,0,0,0,3,2,36,0,0,1,11,70,0,0,0},
{11,61,0,0,0,3,2,55,0,0,2,2,5,0,8,0},
{11,61,0,0,0,3,7,15,0,0,2,2,5,0,8,0},
{11,62,0,0,0,3,2,35,0,0,2,2,6,0,11,0},
{11,62,0,0,0,3,2,44,0,0,2,2,6,0,11,0},
{11,63,0,0,0,3,2,35,0,0,2,2,7,0,13,0},
{11,63,0,0,0,3,2,44,0,0,2,2,7,0,13,0},
{11,64,0,0,0,3,2,45,0,0,1,11,71,0,0,0},
{11,65,0,0,0,3,2,35,0,0,1,11,72,0,0,0},
{11,65,0,0,0,3,2,44,0,0,1,11,44,0,0,0},
{11,66,0,0,0,3,1,15,0,0,2,2,15,5,32,0},
{11,66,0,0,0,3,1,26,0,0,2,2,15,5,32,0},
{11,66,0,0,0,3,2,34,0,0,2,2,15,5,32,0},
{11,66,0,0,0,3,2,45,0,0,2,2,15,5,32,0},
{11,66,0,0,0,3,3,0,0,0,2,2,15,5,32,0},
{11,66,0,0,0,3,6,0,0,0,2,2,15,5,32,0},
{11,67,0,0,0,1,16,0,0,0,4,11,73,0,0,0},
{11,67,0,0,0,3,3,0,0,0,1,11,74,0,0,0},
{11,67,0,0,0,3,6,0,0,0,1,11,75,0,0,0},
{11,68,0,0,0,3,6,0,0,0,1,11,76,0,0,0},
{11,69,0,0,0,3,6,0,0,0,1,11,77,0,0,0},
{11,70,0,0,0,3,6,0,0,0,1,11,78,0,0,0},
{11,71,0,0,0,3,2,55,0,0,2,2,5,1,9,0},
{11,71,0,0,0,3,7,15,0,0,2,2,5,1,9,0},
{11,72,0,0,0,3,2,45,0,0,1,11,79,0,0,0},
{11,73,0,0,0,3,1,28,0,0,1,11,80,0,0,0},
{11,74,0,0,0,3,1,28,0,0,2,2,16,1,36,0},
{11,75,0,0,0,3,1,28,0,0,2,2,16,0,35,0},
{11,76,0,0,0,3,2,37,0,0,1,11,81,0,0,0},
{11,76,0,0,0,3,2,44,0,0,1,11,82,0,0,0},
{11,77,0,0,0,3,2,44,0,0,1,11,83,0,0,0},
{11,78,0,0,0,3,2,44,0,0,1,11,84,0,0,0},
{11,79,0,0,0,3,2,55,0,0,2,2,5,2,10,0},
{11,79,0,0,0,3,7,15,0,0,2,2,5,2,10,0},
{11,80,0,0,0,3,1,15,0,0,2,2,15,6,33,0},
{11,80,0,0,0,3,1,26,0,0,2,2,15,6,33,0},
{11,80,0,0,0,3,2,34,0,0,2,2,15,6,33,0},
{11,80,0,0,0,3,2,45,0,0,2,2,15,6,33,0},
{11,80,0,0,0,3,3,0,0,0,2,2,15,6,33,0},
{11,80,0,0,0,3,6,0,0,0,2,2,15,6,33,0},
{11,81,0,0,0,3,2,45,0,0,1,11,85,0,0,0},
{11,82,0,0,0,1,21,0,0,0,4,11,86,0,0,0},
{11,82,0,0,0,3,1,2,0,0,1,11,87,0,0,0},
{11,82,0,0,0,3,3,0,0,0,1,11,88,0,0,0},
{11,82,0,0,0,3,6,0,0,0,1,11,89,0,0,0},
{11,83,0,0,0,1,20,0,0,0,4,11,90,0,0,0},
{11,83,0,0,0,3,2,36,0,0,1,11,91,0,0,0},
{11,84,0,0,0,3,6,0,0,0,1,11,92,0,0,0},
{11,85,0,0,0,3,2,35,0,0,1,11,93,0,0,0},
{11,86,0,0,0,3,2,37,0,0,1,11,94,0,0,0},
{11,87,0,0,0,3,3,0,0,0,1,11,95,0,0,0},
{11,88,0,0,0,3,2,37,0,0,2,2,21,0,51,0},
{11,89,0,0,0,3,2,37,0,0,2,2,21,1,52,0},
{11,89,0,0,0,3,2,41,0,0,1,11,96,0,0,0},
{11,90,0,0,0,3,2,37,0,0,1,11,97,0,0,0},
{11,90,0,0,0,3,2,44,0,0,1,11,98,0,0,0},
{11,91,0,0,0,1,21,0,0,0,4,11,99,0,0,0},
{11,91,0,0,0,3,1,2,0,0,1,11,100,0,0,0},
{11,91,0,0,0,3,3,0,0,0,1,11,101,0,0,0},
{11,91,0,0,0,3,6,0,0,0,1,11,102,0,0,0},
{11,92,0,0,0,3,2,37,0,0,1,11,103,0,0,0},
{11,92,0,0,0,3,2,44,0,0,1,11,104,0,0,0},
{11,93,0,0,0,3,1,15,0,0,2,2,17,1,38,0},
{11,93,0,0,0,3,1,26,0,0,2,2,17,1,38,0},
{11,93,0,0,0,3,2,34,0,0,2,2,17,1,38,0},
{11,93,0,0,0,3,2,45,0,0,2,2,17,1,38,0},
{11,93,0,0,0,3,3,0,0,0,2,2,17,1,38,0},
{11,93,0,0,0,3,6,0,0,0,2,2,17,1,38,0},
{11,94,0,0,0,3,2,45,0,0,1,11,105,0,0,0},
{11,95,0,0,0,3,2,37,0,0,2,2,21,3,54,0},
{11,96,0,0,0,3,6,0,0,0,1,11,106,0,0,0},
{11,97,0,0,0,3,2,45,0,0,1,11,107,0,0,0},
{11,98,0,0,0,1,21,0,0,0,4,11,108,0,0,0},
{11,98,0,0,0,3,1,2,0,0,1,11,87,0,0,0},
{11,98,0,0,0,3,3,0,0,0,1,11,88,0,0,0},
{11,98,0,0,0,3,6,0,0,0,1,11,89,0,0,0},
{11,99,0,0,0,3,2,37,0,0,1,11,109,0,0,0},
{11,99,0,0,0,3,2,44,0,0,1,11,110,0,0,0},
{11,100,0,0,0,3,3,0,0,0,1,11,111,0,0,0},
{11,101,0,0,0,3,2,37,0,0,2,2,21,0,51,0},
{11,101,0,0,0,3,2,44,0,0,2,2,21,0,51,0},
{11,102,0,0,0,3,2,37,0,0,2,2,21,1,52,0},
{11,102,0,0,0,3,2,41,0,0,1,11,112,0,0,0},
{11,102,0,0,0,3,2,44,0,0,2,2,21,1,52,0},
{11,103,0,0,0,3,2,45,0,0,1,11,113,0,0,0},
{11,104,0,0,0,1,21,0,0,0,4,11,114,0,0,0},
{11,104,0,0,0,3,1,2,0,0,1,11,87,0,0,0},
{11,104,0,0,0,3,3,0,0,0,1,11,88,0,0,0},
{11,104,0,0,0,3,6,0,0,0,1,11,89,0,0,0},
{11,105,0,0,0,3,2,35,0,0,1,11,115,0,0,0},
{11,106,0,0,0,3,2,37,0,0,2,2,21,2,53,0},
{11,107,0,0,0,3,2,35,0,0,1,11,116,0,0,0},
{11,108,0,0,0,3,2,37,0,0,1,11,117,0,0,0},
{11,109,0,0,0,3,2,37,0,0,2,2,20,0,46,0},
{11,109,0,0,0,3,2,44,0,0,2,2,20,0,46,0},
{11,110,0,0,0,1,21,0,0,0,4,11,118,0,0,0},
{11,110,0,0,0,3,1,2,0,0,1,11,100,0,0,0},
{11,110,0,0,0,3,3,0,0,0,1,11,101,0,0,0},
{11,110,0,0,0,3,6,0,0,0,1,11,102,0,0,0},
{11,111,0,0,0,3,2,37,0,0,2,2,21,3,54,0},
{11,111,0,0,0,3,2,44,0,0,2,2,21,3,54,0},
{11,112,0,0,0,3,6,0,0,0,1,11,119,0,0,0},
{11,113,0,0,0,3,2,35,0,0,1,11,120,0,0,0},
{11,114,0,0,0,3,2,37,0,0,1,11,121,0,0,0},
{11,115,0,0,0,3,1,15,0,0,2,2,17,0,37,0},
{11,115,0,0,0,3,1,26,0,0,2,2,17,0,37,0},
{11,115,0,0,0,3,2,34,0,0,2,2,17,0,37,0},
{11,115,0,0,0,3,2,45,0,0,2,2,17,0,37,0},
{11,115,0,0,0,3,3,0,0,0,2,2,17,0,37,0},
{11,115,0,0,0,3,6,0,0,0,2,2,17,0,37,0},
{11,116,0,0,0,3,1,15,0,0,2,2,19,1,45,0},
{11,116,0,0,0,3,1,26,0,0,2,2,19,1,45,0},
{11,116,0,0,0,3,2,34,0,0,2,2,19,1,45,0},
{11,116,0,0,0,3,2,45,0,0,2,2,19,1,45,0},
{11,116,0,0,0,3,3,0,0,0,2,2,19,1,45,0},
{11,116,0,0,0,3,6,0,0,0,2,2,19,1,45,0},
{11,117,0,0,0,3,2,45,0,0,1,11,122,0,0,0},
{11,118,0,0,0,3,2,37,0,0,1,11,123,0,0,0},
{11,118,0,0,0,3,2,44,0,0,1,11,124,0,0,0},
{11,119,0,0,0,3,2,37,0,0,2,2,21,2,53,0},
{11,119,0,0,0,3,2,44,0,0,2,2,21,2,53,0},
{11,120,0,0,0,3,1,15,0,0,2,2,22,1,56,0},
{11,120,0,0,0,3,1,26,0,0,2,2,22,1,56,0},
{11,120,0,0,0,3,2,34,0,0,2,2,22,1,56,0},
{11,120,0,0,0,3,2,45,0,0,2,2,22,1,56,0},
{11,120,0,0,0,3,3,0,0,0,2,2,22,1,56,0},
{11,120,0,0,0,3,6,0,0,0,2,2,22,1,56,0},
{11,121,0,0,0,3,2,45,0,0,1,11,125,0,0,0},
{11,122,0,0,0,3,2,35,0,0,1,11,126,0,0,0},
{11,123,0,0,0,3,2,37,0,0,2,2,20,1,47,0},
{11,123,0,0,0,3,2,44,0,0,2,2,20,1,47,0},
{11,124,0,0,0,1,21,0,0,0,4,11,127,0,0,0},
{11,124,0,0,0,3,1,2,0,0,1,11,100,0,0,0},
{11,124,0,0,0,3,3,0,0,0,1,11,101,0,0,0},
{11,124,0,0,0,3,6,0,0,0,1,11,102,0,0,0},
{11,125,0,0,0,3,2,35,0,0,1,11,128,0,0,0},
{11,126,0,0,0,3,1,15,0,0,2,2,19,0,44,0},
{11,126,0,0,0,3,1,26,0,0,2,2,19,0,44,0},
{11,126,0,0,0,3,2,34,0,0,2,2,19,0,44,0},
{11,126,0,0,0,3,2,45,0,0,2,2,19,0,44,0},
{11,126,0,0,0,3,3,0,0,0,2,2,19,0,44,0},
{11,126,0,0,0,3,6,0,0,0,2,2,19,0,44,0},
{11,127,0,0,0,3,2,37,0,0,1,11,129,0,0,0},
{11,127,0,0,0,3,2,44,0,0,1,11,130,0,0,0},
{11,128,0,0,0,3,1,15,0,0,2,2,22,0,55,0},
{11,128,0,0,0,3,1,26,0,0,2,2,22,0,55,0},
{11,128,0,0,0,3,2,34,0,0,2,2,22,0,55,0},
{11,128,0,0,0,3,2,45,0,0,2,2,22,0,55,0},
{11,128,0,0,0,3,3,0,0,0,2,2,22,0,55,0},
{11,128,0,0,0,3,6,0,0,0,2,2,22,0,55,0},
{11,129,0,0,0,3,2,37,0,0,2,2,20,2,48,0},
{11,129,0,0,0,3,2,44,0,0,2,2,20,2,48,0},
{11,130,0,0,0,1,21,0,0,0,4,11,131,0,0,0},
{11,130,0,0,0,3,1,2,0,0,1,11,100,0,0,0},
{11,130,0,0,0,3,3,0,0,0,1,11,101,0,0,0},
{11,130,0,0,0,3,6,0,0,0,1,11,102,0,0,0},
{11,131,0,0,0,3,2,37,0,0,1,11,132,0,0,0},
{11,131,0,0,0,3,2,44,0,0,1,11,133,0,0,0},
{11,132,0,0,0,3,2,37,0,0,2,2,20,3,49,0},
{11,132,0,0,0,3,2,44,0,0,2,2,20,3,49,0},
{11,133,0,0,0,1,21,0,0,0,4,11,134,0,0,0},
{11,133,0,0,0,3,1,2,0,0,1,11,87,0,0,0},
{11,133,0,0,0,3,3,0,0,0,1,11,88,0,0,0},
{11,133,0,0,0,3,6,0,0,0,1,11,89,0,0,0},
{11,134,0,0,0,3,2,37,0,0,1,11,135,0,0,0},
{11,135,0,0,0,3,2,37,0,0,2,2,20,4,50,0},
{11,135,0,0,0,3,2,44,0,0,2,2,20,4,50,0}
};
grammar.AddActions(345,A);
}

void make_formulas(TGrammar& grammar)
{
grammar.type = T_Grammar(336896); grammar.look_ahead = 0;
grammar.AddFormula("S_");
{ static const int I[][5] = {{1,1,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("S__");
{ static const int I[][5] = {{1,2,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,0,1,1,512), 1, I); }
grammar.AddFormula("Grammar");
{ static const int I[][5] = {{1,3,0,0,0},{1,8,0,0,0},{1,11,0,0,0},{3,2,53,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,5,794688,512), 4, I); }
{ static const int I[][5] = {{1,3,0,0,0},{1,8,0,0,0},{1,11,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,5,794688,512), 3, I); }
grammar.AddFormula("Enum_part");
{ static const int I[][5] = {{3,2,54,0,0},{1,4,0,0,0},{3,2,55,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,7,128,512), 3, I); }
{ static const int I[][5] = {{5,0,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("Enums");
{ static const int I[][5] = {{1,4,0,0,0},{1,5,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,6,8256,512), 2, I); }
{ static const int I[][5] = {{1,5,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,5,64,512), 1, I); }
grammar.AddFormula("Enum");
{ static const int I[][5] = {{3,7,15,0,0},{3,2,34,0,0},{1,6,0,0,0},{3,2,35,0,0},{3,2,45,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,4,192,512), 5, I); }
{ static const int I[][5] = {{3,7,15,0,0},{3,6,0,0,0},{3,2,34,0,0},{1,6,0,0,0},{3,2,35,0,0},{3,2,45,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,4,258,512), 6, I); }
{ static const int I[][5] = {{3,7,15,0,0},{3,7,49,0,0},{3,6,0,0,0},{3,2,34,0,0},{1,6,0,0,0},{3,2,35,0,0},{3,2,45,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,4,323,512), 7, I); }
grammar.AddFormula("enum_list");
{ static const int I[][5] = {{1,6,0,0,0},{3,2,44,0,0},{1,7,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,3,12352,512), 3, I); }
{ static const int I[][5] = {{1,7,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,2,64,512), 1, I); }
grammar.AddFormula("enum_item");
{ static const int I[][5] = {{3,6,0,0,0},{3,1,14,0,0},{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,1,193,512), 3, I); }
{ static const int I[][5] = {{3,6,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,45,0,1,512), 1, I); }
grammar.AddFormula("Token_part");
{ static const int I[][5] = {{1,9,0,0,0},{3,2,53,0,0}}; grammar.AddProduce(2, I); }
{ static const int I[][5] = {{5,0,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("Tokens");
{ static const int I[][5] = {{1,9,0,0,0},{1,10,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,44,2,8256,512), 2, I); }
{ static const int I[][5] = {{1,10,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,44,1,64,512), 1, I); }
grammar.AddFormula("Token");
{ static const int I[][5] = {{3,2,56,0,0},{3,6,0,0,0},{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,44,0,194,512), 3, I); }
grammar.AddFormula("Rules");
{ static const int I[][5] = {{1,11,0,0,0},{1,12,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,1,8256,512), 2, I); }
{ static const int I[][5] = {{1,12,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,0,64,512), 1, I); }
grammar.AddFormula("Formula");
{ static const int I[][5] = {{3,6,0,0,0},{3,2,46,0,0},{1,13,0,0,0},{3,2,45,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,2,193,512), 4, I); }
grammar.AddFormula("Produces");
{ static const int I[][5] = {{1,14,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,41,0,64,512), 1, I); }
{ static const int I[][5] = {{5,0,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("Produce");
{ static const int I[][5] = {{1,14,0,0,0},{1,15,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,42,5,8256,512), 2, I); }
{ static const int I[][5] = {{1,15,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,42,4,64,512), 1, I); }
grammar.AddFormula("produce_item");
{ static const int I[][5] = {{1,17,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{1,19,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{1,22,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,6,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,46,0,1,512), 1, I); }
{ static const int I[][5] = {{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,46,1,1,512), 1, I); }
{ static const int I[][5] = {{3,1,26,0,0},{1,16,0,0,0},{3,1,28,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,46,2,2,512), 3, I); }
{ static const int I[][5] = {{3,1,26,0,0},{1,16,0,0,0},{3,2,44,0,0},{1,16,0,0,0},{3,1,28,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,46,3,258,512), 5, I); }
{ static const int I[][5] = {{3,1,15,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,46,0,1,512), 1, I); }
grammar.AddFormula("lexeme_item");
{ static const int I[][5] = {{3,6,0,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,3,0,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("Maker_Make");
{ static const int I[][5] = {{3,2,34,0,0},{1,18,0,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,0,24834,512), 9, I); }
{ static const int I[][5] = {{3,2,34,0,0},{1,18,0,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,0,258,512), 7, I); }
grammar.AddFormula("Ident_Maker");
{ static const int I[][5] = {{3,7,42,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,43,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,45,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,46,0,0}}; grammar.AddProduce(1, I); }
{ static const int I[][5] = {{3,7,47,0,0}}; grammar.AddProduce(1, I); }
grammar.AddFormula("Maker_Node");
{ static const int I[][5] = {{3,2,34,0,0},{3,7,44,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,20,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,1,33156,512), 11, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,44,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,20,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,1,388,512), 9, I); }
grammar.AddFormula("node_body");
{ static const int I[][5] = {{3,2,36,0,0},{1,21,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,2,512), 3, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,258,512), 5, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,24834,512), 7, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,2121986,512), 9, I); }
{ static const int I[][5] = {{3,2,36,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,37,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,2,169894146,512), 11, I); }
grammar.AddFormula("int_body");
{ static const int I[][5] = {{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,3,1,512), 1, I); }
{ static const int I[][5] = {{3,6,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,3,1,512), 1, I); }
{ static const int I[][5] = {{3,6,0,0,0},{3,2,41,0,0},{3,6,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,3,193,512), 3, I); }
{ static const int I[][5] = {{3,1,2,0,0},{3,3,0,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,4,2,512), 2, I); }
grammar.AddFormula("Maker_Turn");
{ static const int I[][5] = {{3,2,34,0,0},{3,7,48,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{3,6,0,0,0},{3,2,44,0,0},{1,21,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,5,33156,512), 11, I); }
{ static const int I[][5] = {{3,2,34,0,0},{3,7,48,0,0},{3,2,36,0,0},{3,6,0,0,0},{3,2,44,0,0},{3,6,0,0,0},{3,2,37,0,0},{3,2,45,0,0},{3,2,35,0,0}}; grammar.AddProduce(GSymbol(GSymbol::gsMaker,43,5,388,512), 9, I); }
}

void make_vectors(TGrammar& grammar)
{
}

void make_grammar(TGrammar& grammar) { make_actions(grammar); make_formulas(grammar); make_vectors(grammar); }
#include "stdafx.h"

#include "Tables.h"
#include "RSyntax.h"
#include "Grammar.h"

const TAction TAction::none, TAction::error(TAction::taError), TAction::fi(TAction::taFi);

int  TLXkReference::Get(int i) const
{
   if ((*this)[i] == i) {
      return i;
   } else if ((*this)[i] == -1) {
      return -1;
   } else {
      return Get((*this)[i]);
   }
}

void TLXkReference::Set(int i, int j)
{
   int ref_i = Ref(i), ref_j = Ref(j);
   (*this)[ref_i] = ref_j;
}

int  TLXkReference::Ref(int i)
{
   if ((*this)[i] == i) {
      return i;
   } else {
      int ref = Ref((*this)[i]);
      (*this)[i] = ref;
      return ref;
   }
}

int  TLXkReference::Ref(int i, int j)
{
   int ref_i = Ref(i), ref_j = Ref(j);
   if (ref_i < ref_j) {
      (*this)[ref_j] = ref_i;
      return 1;
   } else {
      (*this)[ref_i] = ref_j;
      return -1;
   }
}

void TLXkReference::Delete(int i)
{
   if ((*this)[i] == i) {
      (*this)[i] = -1;
   }
}

void TLXkReference::Rename(TLXkReference& target) const
{
   int used = 0;
   target.resize(count());
   std::vector<int> use(count());
   for (int i = 0; i < count(); i++) {
      if ((*this)[i] == i) {
         use[i] = used++;
      }
   }
   for (int i = 0; i < count(); i++) {
      if ((*this)[i] == i) {
         target[i] = use[i];
      } else {
         int get = Get(i);
         target[i] = (get == -1) ? -1 : use[get];
      }
   }
}

int MTableKey::cast(const MTableKey& key)
{
   if (key.sym.IsTerminal()) {
      if (key.sym.group == T_Lexeme::grOper) {
         const T_Symbol& symbol = symbol_table().Symbol(key.sym.value);
         if (symbol.priority) {
            sym.group = T_Lexeme::grPriority; sym.lexeme_type = symbol.priority;
            return 1;
         }
      } else if (key.sym.group == T_Lexeme::grPriority) {
         const T_Symbol& symbol = symbol_table().Symbol(key.sym.value);
         sym.group = T_Lexeme::grOper; sym.lexeme_type = symbol.type;
         return 1;
      } else if (key.sym.group == T_Lexeme::grSyntax) {
         if ((key.sym.lexeme_type == T_Lexeme::sxDefVar) || (key.sym.lexeme_type == T_Lexeme::sxDefArr)) {
            sym.lexeme_type = T_Lexeme::sxDefType;
            return 1;
         }
      }
   } 
   return 0;
}

void MTableKey::write(FILE *file, const TGrammar* grammar, int print_mode) const
{
   if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, "MTableKey(");
   produce.write(file, grammar,print_mode); 
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) fprintf(file, ","); else fprintf(file, " ");
   sym.write(file, grammar,print_mode);
   if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, ")");
}

bool MTableKey::read (FILE *file, const TGrammar* grammar, int print_mode)
{
   produce.read(file, grammar,print_mode);
   sym.read(file, grammar,print_mode);
   return true;
}

void MTableKey::print(const TGrammar* grammar, int print_mode, FILE* file) const
{
   fprintf(file, "{"); 
   if (!produce.IsNone() || !(print_mode & T_PrintMode::pmNoPrintNone)) {
      produce.print(grammar, print_mode, file); 
   } else {
      int len = SYMBOL_PRINT_TITLE_LEN;
      fprintf(file, "%*c",len,' '); 
   }
   fprintf(file, ","); sym.print(grammar, print_mode, file); fprintf(file, "}");
}

bool MTableMap::Add(const MTableKey& key, const GSymbol& produce)
{
   std::pair<const MTableKey&,const GSymbol&> item(key,produce); 
   const_iterator ip = find(key); 
   if (ip != end()) {
      const std::pair<const MTableKey&,const GSymbol&> old = (*ip);
      if (item.second == old.second) {
         return false;
      }
      const GProduce& produce_body = grammar->Produce(produce);
      if (produce_body.head.mode & GSymbol::Warning) { warning++; return false; }
      const GProduce& old_body = grammar->Produce(old.second);
      if (old_body.head.mode & GSymbol::Warning) { warning++; return false; }
      printf("\nDuplicate:\n");
      int print_mode = 0x00;
      old .first.print(grammar, print_mode); printf(" -> "); old .second.print(grammar, print_mode); printf("\n");
      item.first.print(grammar, print_mode); printf(" -> "); item.second.print(grammar, print_mode); printf("\n");
      duplicate++;
      return false;
   }
   insert(item); 
   return true; 
}

const GSymbol& MTableMap::Find(const MTableKey& key) const
{
   const_iterator ip = find(key); 
   if (ip !=end()) {
      return (*ip).second;
   } else {
      return GSymbol::none;
   }
}

const GSymbol& MTableMap::Cell(const MTableKey& key) const
{
   MTableKey my_key(key); my_key.sym.value = 0; my_key.sym.mode = 0;
   const_iterator ip = find(my_key); 
   if (ip != end()) {
      return (*ip).second;
   } else {
      if (key.sym.IsVector()) {
         const GSymbolVector& vec = grammar->Vector(key.sym);
         my_key.sym = vec.front();
      }
      my_key.sym.value = key.sym.value;
      if (my_key.sym.Cast()) {
         my_key.sym.value = 0;
         if (key.sym.IsVector()) {
            GSymbolVector vec = grammar->Vector(key.sym);
            vec.front() = my_key.sym;
            my_key.sym = grammar->Vectors().Find(vec);
         }
         ip = find(my_key);
         if (ip != end()) {
            return (*ip).second;
         }
      }
   }
   return GSymbol::none;
}

bool TGrammar::read(const char* title, int &table_type, int print_mode)
{
   FILE *file = NULL;
   if (!title) title = "def_rule.tab";
	FOPEN(file, title, "r");
   if (!file) {
      printf("\nfile error : %s", title);
      return false;
   }
   FSCANF(file,"%d",&table_type);
   if (table_type & T_Grammar::gtLL) {
      Mtable.read(file, 0x00);
   }
   if (table_type & T_Grammar::gtLR) {
      LRtable.read(file, 0x00);
   }
   read(file, 0x01);
   if (count()) root = formulas.front();
   if ((table_type & (T_Grammar::gtLL | T_Grammar::gtLR)) && (look_ahead > 0)) {
      int ref_count;
      FSCANF(file, "%d", &ref_count);
      references.resize(ref_count);
      for (int i = 0; i < ref_count; i++) {
         FSCANF(file, "%d", &references[i]);
      }
   }
   fclose(file);
   return true;
}

bool TGrammar::read(const char* title, int print_mode)
{
   FILE *file = NULL;
   if (!title) title = "def_rule.tab";
	FOPEN(file, title, "r");
   if (!file) {
      printf("\nfile error : %s", title);
      return false;
   }
   read(file, T_PrintMode::pmWriteSimple);
   fclose(file);
   return true;
}

void TGrammar::AddAction(const MTableKey& key, const TAction& action)
{
   LRtable.Add(key,action);
}

void TGrammar::AddActions(int count, const int A[][16])
{
   for (int i = 0; i < count; i++) {
      MTableKey key(GSymbol((GSymbol::T_Type)A[i][0],A[i][1],A[i][2],A[i][3],A[i][4]), GSymbol((GSymbol::T_Type)A[i][5],A[i][6],A[i][7],A[i][8],A[i][9])); 
      TAction action((TAction::T_Type)A[i][10],GSymbol((GSymbol::T_Type)A[i][11],A[i][12],A[i][13],A[i][14],A[i][15]));
      AddAction(key,action);
   }
}

void TGrammar::AddCell(const MTableKey& key, const GSymbol& cell)
{
   Mtable.Add(key,cell);
}

void TGrammar::AddCells(int count, const int A[][15])
{
   for (int i = 0; i < count; i++) {
      MTableKey key(GSymbol((GSymbol::T_Type)A[i][0],A[i][1],A[i][2],A[i][3],A[i][4]), GSymbol((GSymbol::T_Type)A[i][5],A[i][6],A[i][7],A[i][8],A[i][9])); 
      GSymbol cell((GSymbol::T_Type)A[i][10],A[i][11],A[i][12],A[i][13],A[i][14]);
      AddCell(key,cell);
   }
}

class TKeyVector : public std::map<const GSymbol, GSymbolVector> {
public:
   bool Add(const GSymbol& key, const GSymbol& sym);
};

bool TKeyVector::Add(const GSymbol& key, const GSymbol& sym)
{
   iterator ip = find(key);
   if (ip != end()) {
      (*ip).second.push_back(sym);
      return false;
   } else {
      value_type item(key, GSymbolVector());
      item.second.push_back(sym);
      insert(item);
      return true;
   }
}

bool MTableMap::read(const char* title, int print_mode)
{
   FILE *file = NULL;
   if (!title) title = "def_rule_LL.tab";
	FOPEN(file, title, "r");
   if (!file) return false;
   read(file, print_mode);
   fclose(file);
   return true;
}

bool MTableMap::read (FILE* file, int print_mode)
{
   clear();
   int my_count;
   FSCANF(file,"%d",&my_count);
   for (int i = 0; i < my_count; i++) {
      MTableKey key;
      GSymbol action;
      key.read(file,grammar,print_mode);
      action.read(file,grammar,print_mode);
      Add(key,action);
   }
   return true;
}

void MTableMap::write(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   write(file, print_mode);
   if (title) {
      fclose(file);
   }
}

void MTableMap::write(FILE* file, int print_mode) const
{
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "\nvoid make_cells(TGrammar& grammar)\n{\n");
   } else if (print_mode == T_PrintMode::pmWriteZero) {
      fprintf(file, "%05d\n",count());
   } else {
      fprintf(file, "%d\n",count());
   }
   if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "static const int A[][15] = {\n");
   int row = 0;
   for (const std::pair<const MTableKey&,const GSymbol&> item : *this) {
      const MTableKey &key = item.first;
      if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, "grammar.AddCell(");
      if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "{");
      key.write(file, grammar,print_mode); 
      if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) fprintf(file, ","); else fprintf(file, " ");
      const GSymbol& action = item.second;
      action.write(file, grammar,print_mode);
      if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, ");");
      if (print_mode == T_PrintMode::pmWriteProg) { fprintf(file, "}"); if (++row != count()) fprintf(file, ","); else fprintf(file, "};"); }
      fprintf(file, "\n");
   }
   if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, "}\n");
   if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "grammar.AddCells(%d,A);}\n",count());
}

void MTableMap::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if (!title) {
      fprintf(file, "\n--- M table --- <%d> ---\n", (int)size());
   }
   if (print_mode == 0x00) return;
   print_(file, print_mode);
   if (title) {
      fclose(file);
   }
}

void MTableMap::print_(FILE* file, int print_mode) const
{
   int situation_old = -1;
   for (const std::pair<const MTableKey&,const GSymbol&> item : *this) {
      MTableKey key(item.first);
      if (key.produce.situation != situation_old) {
         situation_old = key.produce.situation;
      } else {
         key.produce.type = GSymbol::gsNone;
      }
      key.print(grammar, print_mode, file);
      const GSymbol& p = item.second;
      if (p.IsProduce()) {
         const GProduce& pr = grammar->Produce(p);
         //pr.head.print(grammar, print_mode,file); 
         pr.print(grammar, print_mode, file);
      } else {
         fprintf(file, " -> ");
         p.print(grammar, print_mode, file);
      }
      fprintf(file, "\n");
   }
}

bool LRTableMap::read(const char* title, int print_mode)
{
   FILE *file = NULL;
   if (!title) title = "def_rule_LR.txt";
	FOPEN(file, title, "r");
   if (!file) return false;
   read (file, print_mode);
   fclose(file);
   return true;
}

bool LRTableMap::read (FILE* file, int print_mode)
{
   clear();
   int my_count;
   FSCANF(file,"%d",&my_count);
   for (int i = 0; i < my_count; i++) {
      MTableKey key;
      TAction action;
      key.read(file,grammar,print_mode);
      action.read(file,grammar,print_mode);
      Add(key,action);
   }
   return true;
}

void LRTableMap::write(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   write(file, print_mode);
   if (title) {
      fclose(file);
   }
}

void LRTableMap::write(FILE* file, int print_mode) const
{
   if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) {
      fprintf(file, "\nvoid make_actions(TGrammar& grammar)\n{\n");
   } else if (print_mode == T_PrintMode::pmWriteZero) {
      fprintf(file, "%05d\n",count());
   } else {
      fprintf(file, "%d\n",count());
   }
   if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "static const int A[][16] = {\n");
   int row = 0;
   for (const std::pair<const MTableKey&,const TAction&> item : *this) {
      const MTableKey &key = item.first;
      const TAction& action = item.second;
      if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, "grammar.AddAction(");
      if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "{");
      key.write(file, grammar,print_mode); 
      if ((print_mode == T_PrintMode::pmWriteSymbol) || (print_mode == T_PrintMode::pmWriteProg)) fprintf(file, ","); else fprintf(file, " ");
      action.write(file, grammar,print_mode);
      if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, ");");
      if (print_mode == T_PrintMode::pmWriteProg) { fprintf(file, "}"); if (++row != count()) fprintf(file, ","); else fprintf(file, "\n};"); }
      fprintf(file, "\n");
   }
   if (print_mode == T_PrintMode::pmWriteSymbol) fprintf(file, "\n}\n");
   if (print_mode == T_PrintMode::pmWriteProg) fprintf(file, "grammar.AddActions(%d,A);\n}\n",count());
}

void LRTableMap::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if (!title) {
      fprintf(file, "\n--- LR table --- <%d> ---\n", count());
   }
   if (print_mode == 0x00) return;
   /*
   int old_situation = -1, max_situation = -1;
   for (const std::pair<const MTableKey&,const TAction&> item : *this) {
      int new_situation = item.first.produce.situation;
      if (new_situation > old_situation + 1) {
//         GSymbol skip_situation(GSymbol::gsSituation,old_situation + 1);
//         for (;skip_situation.situation < new_situation; skip_situation.situation++) {
//            printf("!"); skip_situation.print(grammar, print_mode); printf("\n");
//         }
      }
      old_situation = new_situation;
      const TAction& action = item.second;
      if ((action.IsShift() || action.IsGoto()) && (action.sym.situation > max_situation)) max_situation = action.sym.situation; 
   }
   if (max_situation > old_situation) {
      GSymbol skip_situation(GSymbol::gsSituation,old_situation + 1);
//      for (;skip_situation.situation <= max_situation; skip_situation.situation++) {
//         printf("!"); skip_situation.print(grammar, print_mode); printf("\n");
//      }
   }
   */
   GSymbol key_old; key_old.formula = -1;
   for (const std::pair<const MTableKey&,const TAction&> item : *this) {
      const TAction& action = item.second;
      MTableKey key(item.first);
      if (!(key.produce == key_old)) {
         key_old = key.produce;
      } else {
         key.produce.type = GSymbol::gsNone;
      }
      key.print(grammar, print_mode, file); fprintf(file, " -> "); action.print(grammar, print_mode, file); fprintf(file, "\n");
   }
   if (title) {
      fclose(file);
   }
}

bool LRTableMap::AssociationPriority(const MTableKey& key, const TAction& item, const TAction& old)
{
   GSymbol key_sym = key.sym;
   int look_ahead = grammar->look_ahead;
   if ((look_ahead > 0) && key_sym.IsVector()) {
      const GSymbolVector& vector = grammar->Vector(key_sym);
      key_sym = vector.front();
   }
   if (!key_sym.IsTerminal() || (key_sym.group != T_Lexeme::grPriority)) return false;
   if ((key_sym.lexeme_type != T_Symbol::prAssign) && ((key_sym.lexeme_type < T_Symbol::prOrOr) || (key_sym.lexeme_type > T_Symbol::prFactor))) return false;
   const TAction *shift = NULL, *reduce = NULL;
   if (item.IsShift())   shift = &item; if (old.IsShift())   shift = &old;
   if (item.IsReduce()) reduce = &item; if (old.IsReduce()) reduce = &old;
   if (!shift || !reduce) return false;
   const GProduce& produce = Produce(reduce->sym);
   if (produce.count() < 3) return false;
   const GSymbol& produce_sym = produce[1];
   if (!produce_sym.IsTerminal() || (produce_sym.group != T_Lexeme::grPriority)) return false;
   if ((produce_sym.lexeme_type != T_Symbol::prAssign) && ((produce_sym.lexeme_type < T_Symbol::prOrOr) || (produce_sym.lexeme_type > T_Symbol::prFactor))) return false;
   if (!(produce[0] == produce[2]) || !produce[0].IsFormula() || (produce.head.formula != produce[0].formula)) return false;
/*
   int print_mode = 0x00;
   printf("\n");
   const TAction&  old_action = old;
   key.print(grammar, print_mode); printf(" -> ");  old_action.print(grammar, print_mode); 
   if ( old_action.type == TAction::taReduce) {
      const GProduce& produce = Produce(old_action.sym);
      produce.print(grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact);
   }
   printf("\n");
   const TAction& item_action = item;
   key.print(grammar, print_mode); printf(" -> "); item_action.print(grammar, print_mode); 
   if (item_action.type == TAction::taReduce) {
      const GProduce& produce = Produce(item_action.sym);
      produce.print(grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact);
   }
   printf("\n");
*/
   bool change = false;
   if (key_sym.lexeme_type == produce_sym.lexeme_type) {
      if ((key_sym.lexeme_type == T_Symbol::prAssign)) {
         if (!old.IsShift()) change = true;
      } else {
         if (!old.IsReduce()) change = true;
      }
   } else if ((key_sym.lexeme_type > produce_sym.lexeme_type) && (produce_sym.lexeme_type != T_Symbol::prAssign)) {
      change = true;
   }
   if (change) {
      TAction& new_action = at(key);
      new_action = item;
   }

   return true;
}

bool LRTableMap::Add(const MTableKey& key, const TAction& action)
{
   std::pair<const MTableKey&,const TAction&> item(key,action); 
   const_iterator ip = find(key); 
   if (ip != end()) {
      const std::pair<const MTableKey&,const TAction&> old = (*ip);
      if (item.second == old.second) return true;
      if (AssociationPriority(key, item.second, old.second)) return true;
      const TAction& item_action = item.second;
      const TAction&  old_action = old.second;
      if (item_action.type == TAction::taReduce) {
         const GProduce& produce = Produce(item_action.sym);
         if (produce.head.mode & GSymbol::Warning) { warning++; return false; }
      }
/* */
      printf("\nDuplicate:\n");
      int print_mode = 0x00;
      old .first.print(grammar, print_mode); printf(" -> ");  old_action.print(grammar, print_mode); 
      if ( old_action.type == TAction::taReduce) {
         const GProduce& produce = Produce(old_action.sym);
         produce.print(grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact);
      }
      printf("\n");
      item.first.print(grammar, print_mode); printf(" -> "); item_action.print(grammar, print_mode); 
      if (item_action.type == TAction::taReduce) {
         const GProduce& produce = Produce(item_action.sym);
         produce.print(grammar, T_PrintMode::pmCompactGroup | T_PrintMode::pmCompact);
      }
      printf("\n");
/* */
      if (old.second.IsReduce() && item.second.IsShift()) {
         TAction& new_action = at(key);
         new_action = action;
         printf(":="); item.second.print(grammar, print_mode); printf("\n");
      }
      duplicate++;
      return false;
   }
   insert(item); 
   return true; 
}

const TAction& LRTableMap::Action(const MTableKey& key) const
{
   MTableKey my_key(key); my_key.sym.point = 0; my_key.sym.mode = 0;
   const_iterator ip = find(my_key); 
   if (ip != end()) {
      return (*ip).second;
   } else {
      if (!key.sym.IsVector() || (grammar->look_ahead < 2)) {
         if (key.sym.IsVector()) {
            const GSymbolVector& vec = grammar->Vector(key.sym);
            my_key.sym = vec.front();
         }
         my_key.sym.value = key.sym.value;
         if (my_key.sym.Cast()) {
            my_key.sym.value = 0;
            if (key.sym.IsVector()) {
               GSymbolVector vec = grammar->Vector(key.sym);
               vec.front() = my_key.sym;
               my_key.sym = grammar->Vectors().Find(vec);
            }
            ip = find(my_key);
            if (ip != end()) {
               return (*ip).second;
            }
         }
      }
      my_key.sym = GSymbol::none; // Compression
      ip = find(my_key);
      if (ip != end()) {
         return (*ip).second;
      }
   }
   return TAction::none;
}

int  LRTableMap::GOTO(const MTableMap& join)
{
   int ret = 0;
   for (const std::pair<const MTableKey&,const GSymbol&> item : join) {
      const MTableKey &key = item.first;
      if (!key.sym.IsFormula()) continue;
      TAction action(TAction::taGoto,item.second);
      Add(key,action);
      ret++;
      }
   return ret;
}

int  LRTableMap::Compression()
{
   int old_count = count(), del_count = 0, none_count = 0;
   const_iterator ip_situation = begin();
   while (ip_situation != end()) {
      const GSymbol situation = (*ip_situation).first.produce;
      TKeyVector reduces;
      while (ip_situation != end() && (situation == (*ip_situation).first.produce)) {
         const TAction& action = (*ip_situation).second;
         if (action.IsReduce()) {
            reduces.Add(action.sym, (*ip_situation).first.sym);
         }
         ip_situation++;
      }
      GSymbol key_max; int max = 1;
      for (const std::pair<const GSymbol&, GSymbolVector> item : reduces) {
         int vector_size = (int)item.second.size();
         if (vector_size > max) {
            key_max = item.first; max = vector_size;
         }
      }
      if (max >= 2) {
         MTableKey key_del(situation,GSymbol::none);
         std::pair<const MTableKey, TAction> compres(key_del,TAction(TAction::taReduce,key_max));
         insert(compres); none_count++;
         const GSymbolVector& symbols = reduces.at(key_max);
         for (const GSymbol& sym : symbols) {
            key_del.sym = sym;
            iterator ip_del = find(key_del);
            erase(ip_del); del_count--;
         }
      }
   }
   if (old_count) {
      printf("\nCompression: %d%%, %d -> %d, %d, +%d\n", ((old_count - count()) * 100)/ old_count, old_count, count(), del_count, none_count);
   }
   return true;
}

bool LRTableMap::verify(const MTableMap& go_to) const
{
   if (grammar->look_ahead > 1) return true;
   bool ret = true;
   int print_mode = 0x0001;
   int different = 0;
   FILE *file = stdout;
              const_iterator ip_table = begin();
   MTableMap::const_iterator  ip_goto = go_to.begin();
   while ((ip_table != end()) && (ip_goto != go_to.end())) {
            MTableKey  key_table = (*ip_table).first;
      const MTableKey& key_goto  = (*ip_goto ).first;
      const TAction& action = (*ip_table).second;
      const GSymbol& sym_goto = (*ip_goto).second;
      if (action.IsAccept() || action.IsReduce()) { ip_table++; continue; }
      if (grammar->look_ahead > 0) {
         if (key_table.sym.IsVector()) {
            const GSymbolVector& vector = grammar->Vector(key_table.sym);
            key_table.sym = vector.front();
         }
      }
      if ((key_table == key_goto) && (action.sym == sym_goto)) { ip_table++; ip_goto++; continue; }
      if (ret) {
         fprintf(file, "\nLRTable != GOTO\n");
         key_table.print(grammar, print_mode, file); fprintf(file, " -> "); action.print(grammar, print_mode, file); fprintf(file, "\n");
         key_goto.print(grammar, print_mode, file); fprintf(file, " -> "); sym_goto.print(grammar, print_mode, file); fprintf(file, "\n");
      }
      ret = false; different++;
      if (key_table.produce == key_goto.produce) { ip_table++; ip_goto++; continue; }
      while ((ip_table != end()) && ((*ip_table).first.produce < (*ip_goto).first.produce)) { ip_table++; different++; }
      if (ip_table == end()) break;
      while ((ip_goto != go_to.end()) && ((*ip_goto).first.produce < (*ip_table).first.produce)) { ip_goto++;  different++; }
      if (ip_goto == go_to.end()) break;
   }
   while (ip_table != end()) {
      const MTableKey& key_table = (*ip_table).first;
      const TAction&   action = (*ip_table).second;
      if (action.IsAccept() || action.IsReduce()) { ip_table++; continue; }
      ret = false; different++;
      ip_table++;

   }
   while (ip_goto != go_to.end()) {
      const MTableKey& key_goto = (*ip_goto).first;
      const GSymbol&   sym_goto = (*ip_goto).second;
      ret = false; different++;
      ip_goto++;
   }
   if (different) {
      fprintf(file, "\nDifferent : %d\n", different);
   }

   return ret;
}

const char* action_title(TAction::T_Type type)
{
   static const char* title[] = {
      "None", "Shift", "Reduce", "Accept", "Goto", "Error", "Fi", "Produce", "Pop"
   };
   return title[type];
}

int  TAction::print(const TGrammar* grammar, int print_mode, FILE* file) const
{
   int len = 0;
   const char* title = action_title(type);
	fprintf(file, "%-7s ", title); len += 1 + (int)strlen(title);
   if (type != taAccept) {
      len += sym.print(grammar, print_mode, file);
   }
   return len;
}

void TAction::write(FILE *file, const TGrammar* grammar, int print_mode) const
{
   const char* title[] = { "None", "Shift", "Reduce", "Accept", "Goto" };
   if (print_mode == T_PrintMode::pmWriteSymbol) {
      fprintf(file, "TAction(TAction::ta%s,",title[type]);
   } else if (print_mode == T_PrintMode::pmWriteZero) {
      fprintf(file,"%02d ",type);
   } else if (print_mode == T_PrintMode::pmWriteProg) {
      fprintf(file,"%d,",type);
   } else {
      fprintf(file,"%d ",type);
   }
   sym.write(file, grammar,print_mode);
   if (print_mode == T_PrintMode::pmWriteSymbol) {
      fprintf(file, ")");
   }
}

bool TAction::read (FILE *file, const TGrammar* grammar, int print_mode)
{
   FSCANF(file,"%d",&type);
   sym.read(file, grammar,print_mode);
   return true;
}

const GFormula& TData::Formula(const GSymbol &sym) const
{
   const GFormula& formula = *(*formulas)[sym.formula];
   return formula;
}
const GProduce& TData::Produce(const GSymbol &sym) const
{
   return grammar->Produce(sym);
}
const GSymbol&  TData::Cell(const MTableKey& key) const
{
   return LLTable->Cell(key);
}
const TAction&  TData::Action(const MTableKey& key) const
{
   return LRTable->Action(key);
}

const GFormula* TData::Root() const
{
   if (root) return root;
   if (formulas) {
      if (formulas->root) return formulas->root;
      return formulas->front();
   }
   if (grammar) {
   }
   return NULL;
}

const GProduce& LRTableMap::Produce(const GSymbol &sym) const
{
   return grammar->Produce(sym);
}

const TAction& LRFiTable::Action(const GSymbol& key) const
{
   const_iterator ip = find(key);
   if (ip != end()) {
      return (*ip).second;
   } else {
      return TAction::none;
   }
}

const TAction& LRFiTable::FiAction(const GSymbol& key) const
{
   const_iterator ip = find(key);
   if (ip != end()) {
      return (*ip).second;
   } else {
      if (errors.Have(key)) {
         return TAction::error;
      }
      return TAction::fi;
   }
}

// ------------------------------------- FiUnattainable --------------------------------------
// Green(v=2,(7.3.3,7.3.4))
int  LRFiTable::FiCompare(const LRFiTable& join, TLXkReference& references) const
{
   int ret = 0;
   for (const std::pair<const GSymbol&, const TAction&> item : *this) {
      const TAction& action = item.second; // !error && !fi
      const GSymbol& key = item.first;
      const TAction& join_action = join.FiAction(key);
      if (join_action.IsError()) { // action error
         ret = -1; break;
      } else if (join_action.IsFi()) { // action fi
      } else if (join_action.type == action.type) {
         if (join_action.sym == action.sym) { // action == action
         } else if (action.IsGoto() || action.IsShift()) {
            if (references.Ref(action.sym.situation) == references.Ref(join_action.sym.situation)) {
            } else { // goto != goto
               ret++;
            }
         } else { // action != action
            ret = -1; break;
         }
      } else { // action.type != join.type
         ret = -1; break;
      }
   }
   if (ret < 0) return ret;
   for (const GSymbol& err : errors) {
      const TAction& join_action = join.FiAction(err);
      if (join_action.IsError()) { // error == error
      } else if (join_action.IsFi()) { // error == fi
      } else {
         ret = -1; break;
      }
   }
   return ret;
}

void LRFiTable::FiMerge(const LRFiTable& join)
{
   for (const std::pair<const GSymbol&, const TAction&> item : join) {
      const TAction& join_action = item.second; // !error && !fi
      const GSymbol& key = item.first;
      const TAction& action = FiAction(key);
      if (action.IsFi()) { // fi <- action
         std::pair<const GSymbol, TAction> item_table(key, join_action);
         insert(item_table);
      }
   }
   errors << join.errors;
}

// Green(v=2,7.3.6)
bool LRFiTable::ChainCompare(const LRFiTable& T1, const GSymbol& p, TLXkReference& references) const
{
   for (const std::pair<const GSymbol&, const TAction&> item : *this) {
      const TAction& action = item.second;
      const GSymbol& key = item.first;
      const TAction& T1_action = T1.FiAction(key);
      if (action == T1_action) continue;
      if (T1_action.IsFi()) continue;
      if (T1_action.IsReduce() && (T1_action.sym == p)) continue;
      return false;
   }
   for (const GSymbol& err : errors) {
      const TAction& T1_action = T1.FiAction(err);
      if (T1_action.IsError()) continue; // error == error
      if (T1_action.IsFi()) continue; // error == fi
      return false;
   }
   return true;
}

void LRFiTable::ChainMerge(const LRFiTable& T1, const GSymbol& p)
{
   for (const std::pair<const GSymbol&, const TAction&> item : T1) {
      const TAction& T1_action = item.second; // !error && !fi
      if (T1_action.IsReduce() && (T1_action.sym == p)) continue;
      const GSymbol& key = item.first;
      const TAction& action = FiAction(key);
      if (action.IsFi()) { // fi <- action
         std::pair<const GSymbol, TAction> item_table(key, T1_action);
         insert(item_table);
      }
   }
   errors << T1.errors;
}

bool LRFiTable::Delete(const GSymbol& U)
{
   iterator ip = find(U);
   if (ip != end()) {
      erase(ip);
      return true;
   }
   if (errors.Have(U)) {
      errors.Del(U);
      return true;
   }
   return false;
}

int  LRFiTable::DelAction(const GSymbol& key, const TAction& action)
{
   int ret = 0;
   iterator ip = find(key);
   if (ip != end()) {
      const TAction& my_action = (*ip).second;
      if (my_action == action) {
         ip = erase(ip);
      }
   }
   return ret;
}

void LRFiTable::print(const TGrammar* grammar, FILE* file, int print_mode) const
{
   if (!file) {
      file = stdout;
   }
   for (const std::pair<const GSymbol&, const TAction&> item : *this) {
      const TAction& action = item.second;
      const GSymbol& key = item.first;
      key.print(grammar, print_mode, file); fprintf(file, " -> "); action.print(grammar, print_mode, file); fprintf(file, "\n");
   }
   fprintf(file, ">> "); errors.print(grammar, print_mode, file);
   fprintf(file, "\n");
}

bool LRFiColumn::Compare() const
{
   for (const LRFiTable* table : (*this)) {
      const TAction& action = table->FiAction(A);
      const TAction& join_action = table->FiAction(B);
      if (action == join_action) continue;
      if (action.IsFi() || join_action.IsFi()) continue;
      return false;
   }
   return true;
}

void LRFiColumn::Merge()
{
   for (LRFiTable* table : (*this)) {
      const TAction& action = table->FiAction(A);
      const TAction& join_action = table->FiAction(B);
      if (action.IsFi()) {
         std::pair<const GSymbol, TAction> item_table(A, join_action);
         table->insert(item_table);
      }
   }
}

bool LRFiTableMap::Make(const LRTableMap& general)
{
   GSymbol key_old; key_old.formula = -1;
   LRFiTable* table;
   for (const std::pair<const MTableKey&, const TAction&> general_item : general) {
      const MTableKey& key = general_item.first;
      if (!(key.produce == key_old)) {
         key_old = key.produce;
         std::pair<const GSymbol, LRFiTable> new_table(key.produce, LRFiTable(grammar));
         insert(new_table);
         iterator ip = find(key.produce);
         table = &(*ip).second;
      }
      std::pair<const GSymbol, TAction> item_table(key.sym, general_item.second);
      table->insert(item_table);
   }
   return true;
}

void LRFiTableMap::Copy(LRFiTableMap& target) const
{
   TLXkReference refer;
   references.Rename(refer);
   target.clear();
   for (const std::pair<const GSymbol&, const LRFiTable&> item_table : *this) {
      const LRFiTable& table = item_table.second;
      if (table.deleted) continue;
      GSymbol key_table = item_table.first;
      key_table.situation = refer.Item(key_table.situation);
      std::pair<const GSymbol, LRFiTable> new_table(key_table, LRFiTable(grammar));
      target.insert(new_table);
      LRFiTable& target_table = (*target.find(key_table)).second;
      for (const std::pair<const GSymbol&, const TAction&> item_action : table) {
         std::pair<GSymbol, TAction> new_action(item_action.first, item_action.second);
         TAction& action = new_action.second;
         if (action.IsGoto() || action.IsShift()) {
            action.sym.situation = refer.Item(action.sym.situation);
         }
         target_table.insert(new_action);
      }
      target_table.errors = table.errors;
   }
   target.references.Init(target.count());
}

int LRFiTableMap::Copy(LRTableMap& general, MTableMap& go_to) const
{
   TLXkReference refer;
   references.Rename(refer);

   general.clear(); go_to.clear();
   int table_count = 0;
   for (const std::pair<const GSymbol&, const LRFiTable&> item_table : *this) {
      const LRFiTable& table = item_table.second;
      if (table.deleted) continue;
      MTableKey key; key.produce = item_table.first;
      key.produce.situation = refer.Item(key.produce.situation);
      for (const std::pair<const GSymbol&, const TAction&> item_action : table) {
         TAction action = item_action.second;
         key.sym = item_action.first;
         if (action.IsGoto() || action.IsShift()) {
            action.sym.situation = refer.Item(action.sym.situation);
            go_to.Add(key, action.sym);
         }
         general.Add(key, action);
      }
      table_count++;
   }
   return table_count;
}

void LRFiTableMap::GoToRef()
{
   for (iterator ip_table = begin(); ip_table != end(); ip_table++) {
      LRFiTable& table = (*ip_table).second;
      if (table.deleted) continue;
      for (LRFiTable::iterator ip_action = table.begin(); ip_action != table.end(); ip_action++) {
         TAction& action = (*ip_action).second;
         if (action.IsGoto() || action.IsShift()) {
            action.sym.situation = references.Ref(action.sym.situation);
         }
      }
   }
}

void LRFiTableMap::Statistic(int& table_count, int& item_count) const
{
   table_count = 0; item_count = 0;
   for (const std::pair<const GSymbol&, const LRFiTable&> tab : *this) {
      const LRFiTable& table = tab.second;
      if (table.deleted) continue;
      table_count++; item_count += table.count();
   }
}

// Green(v=2,p=56,a=7.6)
bool LRFiTableMap::FiUnattainable(int k)
{
   for (iterator ip_table = begin(); ip_table != end(); ip_table++) {
      LRFiTable& table_shift = (*ip_table).second;
      if (table_shift.deleted) continue;
      for (LRFiTable::const_iterator ip_action = table_shift.begin(); ip_action != table_shift.end(); ip_action++) {
         const TAction& action = (*ip_action).second;
         if (!action.IsShift()) continue;
         iterator ip = find(action.sym);
         if (ip == end()) return false;
         LRFiTable& table = (*ip).second;
         const GSymbol& key = (*ip_action).first;
         GSymbolVector av = grammar->Vectors().Vector(key);
         av.erase(av.begin()); const GSymbolVector& v = av;
         if (!v.empty()) {
            GSymbol u = grammar->Vectors().Add(v);
            if (table.Action(u).IsNone()) {
               table.AddError(u);
            }
         } else {
            if (table.Action(GSymbol::empty).IsNone()) {
               table.AddError(GSymbol::empty);
            }
         }
         if (v.count() == (k - 1)) {
            GSymbolVector vbs;
            grammar->Vectors().Tails(av, vbs, grammar->lexemes);
            for (const GSymbol& vb : vbs) {
               if (table.Action(vb).IsNone()) {
                  table.AddError(vb);
               }
            }
         }
      }
   }
   return true;
}

// Green(v=2,p=60,a=7.7)
bool LRFiTableMap::JointSplitting()
{
   printf("\n--- FiUnattainable ---\n");

   if (references.count() != count()) references.Init(count());
   int step = 0;
   int cycle = 0, change = 0;
   do {
      cycle = 0; change = 0;  step++;
      for (GSymbol situation(GSymbol::gsSituation, 1); situation.situation < count() - 1; situation.situation++) {
         if (references.Deleted(situation.situation)) continue;
         iterator ip = find(situation);
         LRFiTable& table = (*ip).second;
         if ((step > 1) && (table.step < step - 1)) continue;
         for (GSymbol join(GSymbol::gsSituation, situation.situation + 1); join.situation < count(); join.situation++) {
            if (references.Deleted(join.situation)) continue;
            iterator ip_join = find(join);
            LRFiTable& table_join = (*ip_join).second;
            if ((step > 1) && (table_join.step < step - 1)) continue;
            int compare = table.FiCompare(table_join, references);
            if (compare < 0) continue;
            if (compare > 0) { // goto != goto
               table.step = step; table_join.step = step;
               cycle++;
               continue;
            }
            table.FiMerge(table_join);
            references.Set(join.situation, references.Ref(situation.situation));
            table_join.deleted = true;
            change++;
         }
      }
      printf("cycle=%d, change=%d\n", cycle, change);
   } while (cycle && change);

   GoToRef();
   return true;
}

// Green(v=2,7.3.6)
// Green(v=2,p=82,a=7.9)
bool LRFiTableMap::ChainRule()
{
   GSymbolSetMap B_p, p_T;
   TopologicalSort topological_sort(grammar->count());
   for (const GFormula* formula : grammar->formulas) {
      if (grammar->IsStart(formula->head)) continue;
      for (const GProduce& produce : *formula) {
         if (!produce.IsChain()) continue;
         const GSymbol& B = produce.front();
         topological_sort.add(formula->head.formula,B.formula);
         B_p.Add(B,produce.head);
         p_T.Get(produce.head);
      }
   }

   for (const std::pair<const GSymbol&, const LRFiTable&> tab : *this) {
      const LRFiTable& table = tab.second;
      if (table.deleted) continue;
      for (const std::pair<const GSymbol&, const TAction&> act : table) {
         const TAction& action = act.second;
         if (action.IsReduce() && p_T.Have(action.sym)) {
            p_T.Add(action.sym,tab.first);
         }
      }
   }

   int B_p_item = 0, p_T_item = 0, NEXT_item = 0, merge_count = 0;
   for (std::pair<const GSymbol&, const GSymbolSet&> item : B_p) {
      B_p_item += item.second.count();
   }
   for (std::pair<const GSymbol&, const GSymbolSet&> item : p_T) {
      p_T_item += item.second.count();
   }
   printf("\n--- ChainRule --- ");

   int ret = topological_sort.sort();

   if (references.count() != count()) references.Init(count());

   for (int i = 0; i < topological_sort.N; i++) {
      int index = topological_sort.Indexes[i];
      GSymbol B(GSymbol(GSymbol::gsFormula,index));
      if (B_p.Count(B)) {
         const GSymbolSet& p_s = B_p.Get(B);
         for (const GSymbol& p : p_s) {
            if (!p_T.Count(p)) continue;
            const GSymbolSet& T_s = p_T.Get(p);
            for (const GSymbol& T_1 : T_s) {
               TTwoSymVector NEXT;
               MakeNEXT(T_1,p,B,NEXT); 
               NEXT_item += (int)NEXT.size();
               if (ChainCompare(T_1,p,NEXT)) {
                  ChainMerge(T_1,p,B,NEXT);
                  merge_count++;
               }
            }
         }
      }
   }

   int column_del = 0, action_del = 0;
   TLXkReference chains;
   chains.Init(grammar->count());
   for (int i = topological_sort.N - 1; i >= 0; i--) {
      int index = topological_sort.Indexes[i];
      GSymbol B(GSymbol(GSymbol::gsFormula, index));
      if (B_p.Count(B)) {
         const GSymbolSet& p_s = B_p.Get(B);
         GSymbolSet As;
         int yes_del = 0;
         for (const GSymbol& p : p_s) {
            GSymbol A(GSymbol::gsFormula, p.formula);
            if (As.Add(A)) {
               LRFiColumn column_AB(A, B);
               MakeColumn(column_AB);
               if (column_AB.Compare()) {
                  column_AB.Merge();
                  yes_del++;
               }
            }
         }
         if ((yes_del == As.count()) && (As.count() == 1)) {
            action_del += DeleteColumn(B);
            const GSymbol A = *As.begin();
            chains.Set(B.formula,A.formula);
            column_del++;
         }
      }
   }
   // GSynax.ParseLRx!!!
   for (int i = 0; i < chains.count(); i++) chains.Ref(i);
   grammar->references = chains;

   int situation = 0, ref_del = 0;
   for (const std::pair<const GSymbol&, const LRFiTable&> tab : *this) {
      const LRFiTable& table = tab.second;
      if (table.deleted && !references.Deleted(situation)) {
         references.Delete(situation);
         ref_del++;
      }
      situation++;
   }

   printf("<%d> --- <%d> --- <%d> --- <%d> --- merge_count=%d, ref_del=%d, column_del=%d, action_del=%d\n", 
          B_p.count(), B_p_item, p_T_item, NEXT_item, merge_count, ref_del, column_del, action_del);

   return true;
}

void LRFiTableMap::MakeNEXT(const GSymbol& T_1, const GSymbol& p, const GSymbol& B, TTwoSymVector& NEXT) const
{
   GSymbol A(GSymbol::gsFormula, p.formula);
   for (const std::pair<const GSymbol&, const LRFiTable&> tab : *this) {
      const LRFiTable& table = tab.second;
      if (table.deleted) continue; 
      const TAction& action_B = table.FiAction(B);
      if (action_B.IsGoto() && (action_B.sym == T_1)) {
         const TAction& action_A = table.FiAction(A);
         if (action_A.IsGoto()) {
            TTwoSym item(tab.first, action_A.sym);
            NEXT.Add(item);
         }
      }
   }
}

void LRFiTableMap::MakeColumn(LRFiColumn& column)
{
   iterator tab = begin();
   while (tab != end()) {
      LRFiTable& table = (*tab).second;
      if (table.deleted) { tab++; continue; }
      const TAction& action_A = table.FiAction(column.A);
      const TAction& action_B = table.FiAction(column.B);
      if (!action_A.IsFi() || !action_B.IsFi()) {
         column.Add(&table);
      }
      tab++;
   }
}

int LRFiTableMap::DeleteColumn(const GSymbol& D)
{
   int del = 0;
   iterator tab = begin();
   while (tab != end()) {
      LRFiTable& table = (*tab).second;
      if (!table.deleted) {
         if (table.Delete(D)) del++;
      }
      tab++;
   }
   return del;
}

bool LRFiTableMap::ChainCompare(const GSymbol& T_1, const GSymbol& p, const TTwoSymVector& NEXT)
{
   GSymbol t_1(T_1); t_1.situation = references.Ref(t_1.situation);
   LRFiTableMap::const_iterator ip_T1 = find(t_1);
   const LRFiTable& T1 = (*ip_T1).second;
   for (const TTwoSym& GOTO_1_T_2 : NEXT) {
      const GSymbol& T_2 = GOTO_1_T_2.two;
      GSymbol t_2(T_2); t_2.situation = references.Ref(t_2.situation);
      LRFiTableMap::const_iterator ip_T2 = find(t_2);
      const LRFiTable& T2 = (*ip_T2).second;
      if (!T2.ChainCompare(T1,p,references)) return false;
   }
   return true;
}

void LRFiTableMap::ChainMerge(const GSymbol& T_1, const GSymbol& p, const GSymbol& B, const TTwoSymVector& NEXT)
{
   GSymbol t_1(T_1); t_1.situation = references.Ref(t_1.situation);
   LRFiTableMap::iterator ip_T1 = find(t_1);
   LRFiTable& T1 = (*ip_T1).second;
   for (const TTwoSym& GOTO_1_T_2 : NEXT) {
      const GSymbol& T_2 = GOTO_1_T_2.two;
      GSymbol t_2(T_2); t_2.situation = references.Ref(t_2.situation);
      LRFiTableMap::iterator ip_T2 = find(t_2);
      LRFiTable& T2 = (*ip_T2).second;
      T2.ChainMerge(T1,p);
   }
   GSymbol A(GSymbol::gsFormula, p.formula);
   for (const TTwoSym& GOTO_1_T_2 : NEXT) {
      const GSymbol& goto_1 = GOTO_1_T_2.one;
      LRFiTableMap::iterator ip_goto_1 = find(goto_1);
      LRFiTable& T_GOTO_1 = (*ip_goto_1).second;
      const TAction& action_A = T_GOTO_1.FiAction(A);
      LRFiTable::iterator ip = T_GOTO_1.find(B);
      TAction& action_B = (*ip).second;
      action_B.sym = action_A.sym;
   }
   T1.deleted = true;
}

int  LRFiTableMap::DelAction(const GSymbol& key, const TAction& action)
{
   int ret = 0;
   iterator ip = begin();
   while (ip != end()) {
      LRFiTable& table = (*ip).second;
      if (!table.deleted) {
         ret += table.DelAction(key, action);
      }
      ip++;
   }
   return ret;
}

void LRFiTableMap::print(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   if (!title) {
      fprintf(file, "\n--- LR Fi table --- <%d> ---\n", count());
   }
   if (print_mode == 0x00) return;
   int no_del = 0, action_count = 0;
   for (const std::pair<const GSymbol&, const LRFiTable&> item : *this) {
      const LRFiTable& table = item.second;
      if (table.deleted) continue;
      const GSymbol& key = item.first;
      key.print(grammar, print_mode, file); fprintf(file, "\n"); 
      table.print(grammar, file, print_mode);
      no_del++;
      action_count += table.count();
   }
   fprintf(file, "\nreferences:");
   for (int item : references) {
      fprintf(file, "%4d ", item);
   }
   fprintf(file, "\ntable=%d, action=%d, vector=%d\n", no_del, action_count, grammar->Vectors().count());
   if (title) {
      fclose(file);
   }
}

#ifndef TRN_TABLES_H
#define TRN_TABLES_H

#include "Rules.h"

class TLXkReference : public std::vector<int>
{
public:
   TLXkReference() {}
   TLXkReference(int s) { resize(s, 0); }
   void Init(int s) { if (s != count()) resize(s, 0); for (int i = 0; i < s; i++) (*this)[i] = i; }
   void Rename(TLXkReference& target) const;
   int  Ref(int i);
   int  Get(int i) const;
   void Set(int i, int j);
   int  Item(int i) const { return (*this)[i]; }
   int  Ref(int i, int j);
   bool Deleted(int i) const { return ((*this)[i] != i); };
   void Delete(int i);
public:
   int count() const { return (int)size(); }
};

class MTableKey
{
public:
   MTableKey() :produce(), sym() {}
   MTableKey(const GSymbol& p, const GSymbol& s) :produce(p), sym(s) {}
   bool operator <  (const MTableKey& k) const { return (produce <  k.produce) || (produce == k.produce) && (sym < k.sym); }
   bool operator == (const MTableKey& k) const { return (produce == k.produce) && (sym == k.sym); }
   int  cast(const MTableKey& key);
public:
   void write(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   bool read (FILE *file, const TGrammar* grammar, int print_mode = 0x00);
   void print(const TGrammar* grammar, int print_mode = 0x00, FILE* file = stdout) const;
public:
   GSymbol produce;
   GSymbol sym;
};

class MTableMap : public std::map<const MTableKey, const GSymbol>
{
public:
   MTableMap(const TGrammar* g = NULL) :grammar(g), duplicate(0), warning(0) {}
   bool Add(const MTableKey&, const GSymbol&);
   const GSymbol& Find(const MTableKey&) const;
   const GSymbol& Cell(const MTableKey& key) const;
public:
   void print_(FILE* file, int print_mode = 0x00) const;
   void print(const char* title = NULL, int print_mode = 0x00) const;
   void write(const char* title, int print_mode = 0x00) const;
   bool read (const char* title, int print_mode = 0x00);
   void write(FILE* file, int print_mode = 0x00) const;
   bool read (FILE* file, int print_mode = 0x00);
   int  count() const { return (int)size(); }
public:
   const TGrammar* grammar;
   int duplicate, warning;
};

struct TAction
{
   enum T_Type { taNone, taShift, taReduce, taAccept, taGoto, taError, taFi, taProduce, taPop };
public:
   TAction() :type(taNone) {}
   TAction(T_Type t) :type(t) {}
   TAction(T_Type t, const GSymbol& s) :type(t), sym(s) {}
   bool IsNone   () const { return (type == taNone   ); }
   bool IsShift  () const { return (type == taShift  ); }
   bool IsReduce () const { return (type == taReduce ); }
   bool IsAccept () const { return (type == taAccept ); }
   bool IsGoto   () const { return (type == taGoto   ); }
   bool IsError  () const { return (type == taError  ); }
   bool IsFi     () const { return (type == taFi     ); }
   bool IsProduce() const { return (type == taProduce); }
   bool IsPop    () const { return (type == taPop    ); }
   bool operator == (const TAction& a) const { return ((type == a.type) && (sym == a.sym)); }
public:
   int  print(const TGrammar* grammar, int print_mode = 0x00, FILE* file = stdout) const;
   void write(FILE *file, const TGrammar* grammar, int print_mode = 0x00) const;
   bool read (FILE *file, const TGrammar* grammar, int print_mode = 0x00);
public:
   T_Type  type;
   GSymbol sym;
public:
   static const TAction none, error, fi;
};

class LRTableMap : public std::map<const MTableKey, TAction>
{
public:
   LRTableMap(TGrammar* g = NULL) :grammar(g), duplicate(0), warning(0) {}
   bool Add(const MTableKey&, const TAction&);
   const TAction& Action(const MTableKey& key) const;
   bool AssociationPriority(const MTableKey& key, const TAction& item, const TAction& old);
   int  GOTO(const MTableMap& join);
   const GProduce& Produce(const GSymbol &sym) const;
   int  Compression();
   bool verify(const MTableMap& go_to) const;
public:
   int  count() const { return (int)size(); }
   void print(const char* title = NULL, int print_mode = 0x00) const;
   void write(const char* title, int print_mode = 0x00) const;
   bool read (const char* title, int print_mode = 0x00);
   void write(FILE* file, int print_mode = 0x00) const;
   bool read (FILE* file, int print_mode = 0x00);
public:
   TGrammar* grammar;
   int  duplicate, warning;
};

// ------------------------------------- FiUnattainable --------------------------------------
// Green(v=2,(7.3.3,7.3.4))
class LRFiTable : public std::map<const GSymbol, TAction>
{
public:
   LRFiTable(TGrammar* g) :grammar(g), deleted(false), step(0) {}
   const TAction& Action(const GSymbol& key) const;
   const TAction& FiAction(const GSymbol& key) const;
   bool AddError(const GSymbol& sym) { return errors.Add(sym); }
   int  FiCompare(const LRFiTable& join, TLXkReference& references) const;
   void FiMerge(const LRFiTable& join);
   bool ChainCompare(const LRFiTable& join, const GSymbol& p, TLXkReference& references) const;
   void ChainMerge(const LRFiTable& join, const GSymbol& p);
   int  DelAction(const GSymbol& key, const TAction& action);
   bool Delete(const GSymbol& U);
public:
   int  count() const { return (int)size(); }
   void print(const TGrammar* grammar, FILE* file = NULL, int print_mode = 0x00) const;
public:
   bool deleted;
   int  step;
   GSymbolSet  errors;
   TGrammar*   grammar;
};

class LRFiColumn : public std::vector<LRFiTable*>
{
public:
   LRFiColumn(const GSymbol& a, const GSymbol& b) :A(a), B(b) {}
   void Add(LRFiTable* item) { push_back(item); }
public:
   bool Compare() const;
   void Merge();
public:
   GSymbol A, B;
};

class TNextTab;
class LRFiTableMap : public std::map<const GSymbol, LRFiTable>
{
public:
   LRFiTableMap(TGrammar* g) :grammar(g) {}
   bool Make(const LRTableMap& general);
   bool FiUnattainable(int k);
   bool JointSplitting();
public:
   bool ChainRule();
   bool ChainCompare(const GSymbol& T_1, const GSymbol& p, const TTwoSymVector& NEXT);
   void ChainMerge(const GSymbol& T_1, const GSymbol& p, const GSymbol& B, const TTwoSymVector& NEXT);
   void MakeNEXT(const GSymbol& T_1, const GSymbol& p, const GSymbol& B, TTwoSymVector& NEXT) const;
   void MakeColumn(LRFiColumn& column);
   int  DeleteColumn(const GSymbol& D);
public:
   int  DelAction(const GSymbol& key, const TAction& action);
   int  Copy(LRTableMap& general, MTableMap& go_to) const;
   void Copy(LRFiTableMap& target) const;
   void GoToRef();
   void Statistic(int& table_count, int& item_count) const;
public:
   int  count() const { return (int)size(); }
   void print(const char* title = NULL, int print_mode = 0x00) const;
public:
   TGrammar* grammar;
   TLXkReference references;
};

#endif// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "TNodes.h"
#include "TSemantic.h"

void TNode::InsertAfter(TNode *b)
{
   if (after) {
      TNode* node = after;
      while (node->after) node = node->after;
      node->after = b;  b->SetBefore(node);
   } else {
      after = b; b->SetBefore(this);
   }
   b->SetOwner(this);
}
void TNode::InsertBefore(TNode *b)
{
   if (before) {
      TNode* node = before;
      while (node->before) node = node->before;
      node->before = b;  b->SetAfter(node);
   } else {
      before = b; b->SetAfter(this);
   }
   b->SetOwner(this);
}

void TNode::SetOwner(TNode *o) 
{ 
   if (!owner) {
      owner = o;
   }
}

bool TNode::ClearNode(TNode* N)
{
   if (N && (!N->Owner() || (N->Owner() == this))) {
      if (TNodeType *type = dynamic_cast<TNodeType*>(N)) {
         int i=12; i++;
      } else if (T_NodeList *list = dynamic_cast<T_NodeList*>(N)) {
         T_NodeList::iterator p = list->begin();
         while (p != list->end()) {
            list->ClearNode(*p);
            p = list->erase(p);
         }
      }
      N->clear(); GarbageCollectorAdd(N,0x01);
      return true; 
   }
   return false;
}

void TNode::clear()   {}

void T_NodeList::clear()
{
	iterator p = begin();
   while (p != end()) { 
      ClearNode(*p);
      p = erase(p);
   }
}

void TNodeDefFunc::clear() { if (profile) { delete profile; profile = NULL; } T_NodeThree<TNodeType, TNodeDefine, TNode>::clear(); }
void TNodeCall::clear()    { if (profile) { delete profile; profile = NULL; } T_NodeTwo<TNodeDefFunc, T_NodeList>::clear(); }

void print_offset(int level, int mode, FILE *file) // 0x01 - eol, 0x02 - !offset
{
   bool eol = (mode & 0x01) != 0x00, not_offset = (mode & 0x02) != 0x00;
   if (eol) fprintf(file, "\n");
   if (!not_offset) {
      if (level > 0) fprintf(file,"%*c",level * 2, ' ');
   } else {
      fprintf(file,"*%05d* ", level);
   }
}
 
void TNode::print(const char *file_name, int print_mode) const
{
   PRINT_FILE_OPEN(file, file_name, "w");
   print(0, file, print_mode);
   if (file_name) {
      fclose(file);
   }
}

void TNode::print(int level, FILE *file, int print_mode) const
{
   if (level >= 0) print_offset(level, true, file);
   fprintf(file, "%-15s", title());
   if (level >= 0) {
      fprintf(file, " type = %-10s, ",TBaseType::Title(BaseType()));
      if (lexeme.group != lexeme.grNone) {
         fprintf(file, "  "); lexeme.print(T_Lexeme::print_scan,0x02,file); // !pos
      }
   } else {
      fprintf(file, " line=%03d, column=%03d, len=%02d", lexeme.line, lexeme.column, lexeme.len);
      fprintf(file, ", text=");
      if (lexeme.Text()) {
         fprintf(file, "%s", lexeme.Text());
      } else {
         for (int i = 0; i < lexeme.len; i++) fprintf(file, "%c", T_Lexeme::print_scan->Char(lexeme.pos + i));
      }
   }
}

void TNode::write(FILE *file, int print_mode) const
{
   if (print_mode) {
      fprintf(file,"\n%s",title());
      lexeme.write(T_Lexeme::print_scan, file);
   } else {
      TNode::print(-1, file, 0);
   }
}

void T_NodeList::print(int level, FILE *file, int print_mode) const
{
   TNode::print(level, file, print_mode);
	const_iterator p = begin();
   while (p != end()) { 
      (*p)->print(level + 1, file, print_mode);
      p++;
   }
}

void T_NodeList::write(FILE *file, int print_mode) const
{
   TNode::write(file, print_mode);
   fprintf(file,"\n%d",(int)size());
	const_iterator p = begin();
   while (p != end()) { 
      (*p)->write(file, print_mode);
      p++;
   }
}

void TNodeVar::print(int level, FILE *file, int print_mode) const
{
   TNode::print(level, file, print_mode);
   if (child)  child->TNode::print(level + 1, file, print_mode); // type
}

void TNodeVar::write(FILE *file, int print_mode) const
{
   TNode::write(file, print_mode);
   if (child)  child->TNode::write(file, print_mode); // type
}

void TNodeCall::print(int level, FILE *file, int print_mode) const
{
   TNode::print(level, file, print_mode);
   if (left)  left->TNode::print(level + 1, file, print_mode); // type
   if (right) right->print(level + 1, file, print_mode); 
}

void TNodeCall::write( FILE *file, int print_mode) const
{
   TNode::write(file, print_mode);
   if (left)  left->TNode::write(file, print_mode); // type
   if (right) right->write(file, print_mode); 
}

void TNodeIndex::print(int level, FILE *file, int print_mode) const
{
   TNode::print(level, file, print_mode);
   if (left)  left->TNode::print(level + 1, file, print_mode); // type
   if (right) right->print(level + 1, file, print_mode); 
}

void TNodeIndex::write(FILE *file, int print_mode) const
{
   TNode::write(file, print_mode);
   if (left)  left->TNode::write(file, print_mode); // type
   if (right) right->write(file, print_mode); 
}

void TNodeDefVar::print(int level, FILE *file, int print_mode) const
{
   T_NodeThree::print(level, file, print_mode); fprintf(file, "\n");
   print_offset(level + 1, false, file); fprintf(file, "alloc=%s, offset=%02d",title_alloc(alloc), offset);
}

void TNodeLabel::print(int level, FILE *file, int print_mode) const
{
   TNode::print(level, file, print_mode);
   print_offset(level + 1, false, file); fprintf(file, "go_to=%02d",go_to);
   if (child) child-> print(level + 1, file, print_mode);
}

void TNodeUserLabel::print(int level, FILE *file, int print_mode) const
{
   TNodeLabel::print(level, file, print_mode);
   T_UserGoToLabel::print(file, print_mode);
}

void TNodeUserGoTo::print(int level, FILE *file, int print_mode) const
{
   TNodeGoTo::print(level, file, print_mode);
   T_UserGoToLabel::print(file, print_mode);
}

static const T_BaseType btarr[] =
{
   T_BaseType::btVoid   , T_BaseType::btShort   , T_BaseType::btInt   , T_BaseType::btLong   , T_BaseType::btFloat   , T_BaseType::btDouble   ,
   T_BaseType::btCVoid  , T_BaseType::btCShort  , T_BaseType::btCInt  , T_BaseType::btCLong  , T_BaseType::btCFloat  , T_BaseType::btCDouble  ,
   T_BaseType::btRVoid  , T_BaseType::btRShort  , T_BaseType::btRInt  , T_BaseType::btRLong  , T_BaseType::btRFloat  , T_BaseType::btRDouble  ,
   T_BaseType::btCRVoid , T_BaseType::btCRShort , T_BaseType::btCRInt , T_BaseType::btCRLong , T_BaseType::btCRFloat , T_BaseType::btCRDouble ,
   T_BaseType(T_BaseType::btVoid   | T_BaseType::btStatic), T_BaseType(T_BaseType::btShort   | T_BaseType::btStatic), T_BaseType(T_BaseType::btInt   | T_BaseType::btStatic), T_BaseType(T_BaseType::btLong   | T_BaseType::btStatic), T_BaseType(T_BaseType::btFloat   | T_BaseType::btStatic), T_BaseType(T_BaseType::btDouble   | T_BaseType::btStatic),
   T_BaseType(T_BaseType::btCVoid  | T_BaseType::btStatic), T_BaseType(T_BaseType::btCShort  | T_BaseType::btStatic), T_BaseType(T_BaseType::btCInt  | T_BaseType::btStatic), T_BaseType(T_BaseType::btCLong  | T_BaseType::btStatic), T_BaseType(T_BaseType::btCFloat  | T_BaseType::btStatic), T_BaseType(T_BaseType::btCDouble  | T_BaseType::btStatic),
   T_BaseType(T_BaseType::btRVoid  | T_BaseType::btStatic), T_BaseType(T_BaseType::btRShort  | T_BaseType::btStatic), T_BaseType(T_BaseType::btRInt  | T_BaseType::btStatic), T_BaseType(T_BaseType::btRLong  | T_BaseType::btStatic), T_BaseType(T_BaseType::btRFloat  | T_BaseType::btStatic), T_BaseType(T_BaseType::btRDouble  | T_BaseType::btStatic),
   T_BaseType(T_BaseType::btCRVoid | T_BaseType::btStatic), T_BaseType(T_BaseType::btCRShort | T_BaseType::btStatic), T_BaseType(T_BaseType::btCRInt | T_BaseType::btStatic), T_BaseType(T_BaseType::btCRLong | T_BaseType::btStatic), T_BaseType(T_BaseType::btCRFloat | T_BaseType::btStatic), T_BaseType(T_BaseType::btCRDouble | T_BaseType::btStatic)
};

static TNodeType*& arr_type(int i)
{
   static TNodeType* arr_type_[sizeof(btarr) / sizeof(int)];
   static bool make = false;
   if (!make) {
      const int count = sizeof(btarr) / sizeof(int);
      for (int i = 0; i < count; i++) {
         T_BaseType type = btarr[i];
         T_Lexeme lexeme; lexeme.group = lexeme.grReserv; lexeme.value = type & 0x00FF; 
         lexeme.text = T_KeyWordTable::key_word_table.Word(lexeme.value).text;
         lexeme.type = lexeme.value + lexeme.rwVoid;
         TNodeType* node = new TNodeType(lexeme); node->base_type = type;
         node->SetOwner(node);
         arr_type_[i] = node;
      }
      make = true;
   }
   if (make && (i == -1)) 
   {
      for (TNodeType* node : arr_type_) {
         delete node;
      }
      i = 0;
   }
   return arr_type_[i];
}

TBaseType::TBaseType()
{
}

void TBaseType::Clear()
{
   arr_type(-1);
}

TNodeType* TBaseType::BaseType(const T_Lexeme &l, int detail)
{
   T_Lexeme lexeme(l);
   int def = 0;
   if (l.group == T_Lexeme::grSyntax) {
      def = (l.value >> 16) & 0x0000FFFF;
      lexeme.group = T_Lexeme::grReserv; lexeme.type = l.value & 0x0000FFFF;
   } else {
      def = detail;
   }
   const int offset = T_BaseType::btDouble - T_BaseType::btVoid + 1;
   int type = lexeme.type - T_Lexeme::W_Type::rwVoid;
   if ((def & 0x02) != 0) type +=     offset; // const
   if ((def & 0x04) != 0) type += 4 * offset; // static
   if ((def & 0x08) != 0) type += 2 * offset; // reference
   return arr_type(type);
}

TNodeType* TBaseType::Or(const TNodeType* type, T_BaseType maska)
{
   T_BaseType new_type = Or(type->base_type,maska);
   int index = Index(new_type);
   return arr_type(index);
}

int TBaseType::Index(T_BaseType type)
{
   if (type == btUnknown) return -1;
   const int offset = T_BaseType::btDouble - T_BaseType::btVoid + 1;
   int index = type & 0x00FF;
   if (type & btConst) index += offset;
   if (type & btStatic) index += 4 * offset;
   if (type & btReference) index += 2 * offset;
   return index;
}

T_BaseType TBaseType::Const(T_BaseType type)
{
   return Or(type,T_BaseType::btConst);
}

T_BaseType TBaseType::Or(T_BaseType type, T_BaseType maska)
{
   if (type == btUnknown) return btUnknown;
   return T_BaseType(type | maska);
}

T_BaseType TBaseType::And(T_BaseType type, T_BaseType maska)
{
   if (type == btUnknown) return btUnknown;
   return T_BaseType(type & maska);
}

T_BaseType TBaseType::Tilda(T_BaseType type, T_BaseType maska)
{
   if (type == btUnknown) return btUnknown;
   return T_BaseType(type & ~maska);
}

const char* TBaseType::Title(T_BaseType type)
{
   static const char* title[] = {
   "Void"  ,"Short"  ,"Int"  ,"Long"  ,"Float"  ,"Double"  ,"CVoid"  ,"CShort"  ,"CInt"  ,"CLong"  ,"CFloat"  ,"CDouble"  ,
   "RVoid" ,"RShort" ,"RInt" ,"RLong" ,"RFloat" ,"RDouble" ,"CRVoid" ,"CRShort" ,"CRInt" ,"CRLong" ,"CRFloat" ,"CRDouble" ,
   "SVoid" ,"SShort" ,"SInt" ,"SLong" ,"SFloat" ,"SDouble" ,"SCVoid" ,"SCShort" ,"SCInt" ,"SCLong" ,"SCFloat" ,"SCDouble" ,
   "SRVoid","SRShort","SRInt","SRLong","SRFloat","SRDouble","SCRVoid","SCRShort","SCRInt","SCRLong","SCRFloat","SCRDouble"
   };
   if (type == btUnknown) return "Unknown";
   if (type == btLogical) return "Logical";
   return title[Index(type)];
}


static int statement_count = 0;
TNodeStatements::TNodeStatements() :T_NodeList(), TBlock(tbStatements), step(++statement_count) {}

static const char* alloc_title[] = { "None   ", "Global ", "Local  ", "Param  ", "Integer", "Number ", "Oper   ", "Label  ", "Command " };
const char* title_alloc(T_Alloc a) { return alloc_title[a]; }


#ifndef TRN_TREE_NODES_H
#define TRN_TREE_NODES_H

#include "Parse.h"
#include "define_enum.h"

// --------------------------- TNode ---------------------------
class TSyntax;
class TSemantic;
class TOperProfile;
class TFuncProfile;
class TNode;
class TNodeLabel;
class TNodeLogical;
class TNodeType;

enum T_Block { 
   tbNone = 0x00, tbBreak = 0x01, tbContinue = 0x02, tbParam = 0x04,
   tbBlock = 0x010000, tbFor = 0x020000 | tbBreak | tbContinue, tbWhile = 0x030000 | tbBreak | tbContinue, tbDo = 0x040000 | tbBreak | tbContinue, 
   tbIf = 0x050000, tbSwitch = 0x060000 | tbBreak, tbSwitchItem = 0x070000, tbFunc = 0x080000 | tbParam, 
   tbStatements = 0x090000
};

enum T_BaseType {
   btVoid   = 0x0000, btShort   = 0x0001, btInt   = 0x0002, btLong   = 0x0003, btFloat   = 0x0004, btDouble   = 0x0005,
   btCVoid  = 0x0100, btCShort  = 0x0101, btCInt  = 0x0102, btCLong  = 0x0103, btCFloat  = 0x0104, btCDouble  = 0x0105,
   btRVoid  = 0x0200, btRShort  = 0x0201, btRInt  = 0x0202, btRLong  = 0x0203, btRFloat  = 0x0204, btRDouble  = 0x0205,
   btCRVoid = 0x0300, btCRShort = 0x0301, btCRInt = 0x0302, btCRLong = 0x0303, btCRFloat = 0x0304, btCRDouble = 0x0305,
   btConst  = 0x0100, btReference = 0x0200, btStatic = 0x0400, btConstReference = btConst | btReference, btType  = 0x000F,
   btUnknown = 0x80000000, btLogical = 0x40000000
};

class TBaseType {
public:
   TBaseType();
   static TNodeType* BaseType(const T_Lexeme &l, int detail);
   static TNodeType* Or(const TNodeType* type, T_BaseType maska);
   static int Index(T_BaseType type);
   static const char* Title(T_BaseType type);
   static T_BaseType Const(T_BaseType type);
   static T_BaseType Or(T_BaseType type, T_BaseType maska);
   static T_BaseType And(T_BaseType type, T_BaseType maska);
   static T_BaseType Tilda(T_BaseType type, T_BaseType maska);
   static void Clear();
};

class TBlock {
public:
   TBlock() :type(tbNone)    , offset(0), size(0), number(0), continue_label(NULL), break_label(NULL), one_label(NULL), two_label(NULL) {}
   TBlock(T_Block t) :type(t), offset(0), size(0), number(0), continue_label(NULL), break_label(NULL), one_label(NULL), two_label(NULL) {}
public:
   virtual void BlockBegin(TSemantic& semantic);
   virtual void BlockEnd(TSemantic& semantic, bool del = false);
   bool LabelDelVar(TNodeLabel* &label, int &del, int rate) const;
   void BreakContinueLabel(TNodeLabel* label_break, TNodeLabel* label_continue);
public:
   T_Block type;
   int     offset, size, number;
   TNodeLabel *continue_label, *break_label;
   TNodeLabel *one_label, *two_label;
public:
   void print(FILE *file = stdout, int print_mode = 0) const;
};

class TFinder {
public:
   enum { mfNone = 0x0000, 
          mfDuplicateSearch = 0x0001, mfBreak = 0x0002, mfContinue = 0x0004,
          mfVar             = 0x0010, mfLabel = 0x0020, mfFunction = 0x0040, mfFunctionType = 0x0040,
          mfOffset          = 0x0100
        };
public:
   TFinder(TSemantic& s, int m) :mode(m), level(0), count(0), place(NULL), result(NULL), lexeme(NULL), semantic(&s), is_stack(false) {}
   TFinder(TNode* p, int m) :mode(m), level(0), count(0), place(p), result(NULL), lexeme(NULL), semantic(NULL), is_stack(false) {}
   TFinder(int m) :mode(m), level(0), count(0), place(NULL), result(NULL), lexeme(NULL), semantic(NULL), is_stack(false) {}
   bool Compare(const T_Lexeme& l);
   bool IsStack() const { return is_stack; }
   void Reset(int m);
public:
   bool   is_stack;
   int    mode, level, count;
   TNode* place;
   TNode* result;
   const T_Lexeme* lexeme;
   TSemantic* semantic;
};

enum T_Alloc {
   taNone, taGlobal, taLocal, taParam, taInteger, taNumber, taOper, taLabel, taCommand
};

class TQuadruple;
struct TAddress
{
public:
   TAddress(TQuadruple* q = NULL) :alloc(T_Alloc::taNone), number(0), quad(q) {}
   bool operator == (const TAddress& a) const { return (alloc == a.alloc) && (number == a.number); }
public:
   void write(FILE *file = stdout, int print_mode = 0) const;
public:
   T_Alloc alloc; int number; TQuadruple* quad;
};

const char* title_alloc(T_Alloc a);

void print_offset(int level, int mode = 0x01, FILE *file = stdout); // 0x01 - eol, 0x02 - !offset

//#define CLEAR_NODE(N) if (N && (!N->Owner() || (N->Owner() == (TNode*)this))) { N->clear(); delete N; N = NULL; }
#define CLEAR_NODE(N) if (this->ClearNode(N)) { N = NULL; }
#define PRINT_NODE(N) if (N) { N->print(level + 1, file, print_mode); }
#define WRITE_NODE(N) if (N) { N->write(file, print_mode); }

class TNode {
public:
   TNode() :owner(NULL), after(NULL), before(NULL), lexeme(), error_code(erNone) {}
   TNode(const T_Lexeme& l) :owner(NULL), after(NULL), before(NULL), lexeme(l), error_code(erNone) {}
   virtual ~TNode() {}
public:
   bool ClearNode(TNode* N);
   virtual bool null() const   { return false; }
   virtual bool IsNull() const { return null(); }
   virtual void clear();
   virtual void Variables(TSemantic &semantic, int mode) {}
   virtual void Codes(TSemantic &semantic, int mode) {}
   virtual void Verify(TSemantic &semantic, int mode) {}
   virtual T_BaseType BaseType() const { return btUnknown; } 
	virtual TNodeLogical* Logical() { return NULL; }
   virtual bool Search(TFinder& finder);
   virtual bool SearchInside(TFinder& finder);
public:
   virtual bool error()   { return (error_code != erNone); }
   void SetError(T_Error code) { if ((error_code == erNone) || (code == erNone)) error_code = code; }
   T_Error error_code;
public:
   const T_Lexeme& Lexeme() const { return lexeme; }
   void SetLexeme(const T_Lexeme& l) { lexeme = l; }
protected:
   T_Lexeme lexeme;
public:
   TNode *Owner()           { return owner; }
   void SetOwner(TNode *o);
   void SetOwner() { owner = NULL; }
   //   TNode *After()           { return after; }
   void SetAfter(TNode *a)  { after = a; } 
//   TNode *Before()          { return before; }
   void SetBefore(TNode *b) { before = b; } 
   void InsertAfter(TNode *b);
   void InsertBefore(TNode *b);
   void After(TSemantic &semantic, int mode);
   void Before(TSemantic &semantic, int &mode);
protected:
   TNode *owner, *after, *before;
public:
   virtual const char* title() const   { return "TNode"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
           void print(const char *file, int print_mode) const;
   virtual void write(FILE *file, int print_mode) const;
public:
   TAddress quad;
};

class TNodeNull : public TNode {
public:
   TNodeNull() :TNode() {}
public:
   virtual void Codes(TSemantic &semantic, int mode);
   virtual bool null()  const  { return true; }
public:
   virtual const char* title() const  { return "TNodeNull"; }
};

class TNodeError : public TNode {
public:
   TNodeError() :TNode() {}
   TNodeError(const T_Lexeme& l) :TNode(l) {}
   ~TNodeError() {}
public:
   virtual bool error()   { return true; }
public:
   virtual const char* title() const  { return "TNodeError"; }
};

template <class C_ONE> class T_NodeOne : public TNode {
public:
   T_NodeOne() :TNode(), child(NULL) {}
   T_NodeOne(const T_Lexeme& l, C_ONE *c) :TNode(l) { SetChild(c); }
   ~T_NodeOne() {}
public:
   C_ONE *Child()           { return child; }
   void SetChild(C_ONE *c)  { child = c; if (child) child->SetOwner(this); } 
protected:
   C_ONE *child;
public:
   virtual void clear()     { CLEAR_NODE(child) TNode::clear(); }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { TNode::print(level, file, print_mode); PRINT_NODE(child) }
   virtual void write(FILE *file, int print_mode) const { TNode::write(file, print_mode); WRITE_NODE(child) }
};

template <class C_ONE, class C_TWO> class T_NodeTwo : public TNode {
public:
   T_NodeTwo() :TNode(), left(NULL), right(NULL) {}
   T_NodeTwo(const T_Lexeme& h, C_ONE *l, C_TWO *r) :TNode(h) { SetBoth(l,r); }
   ~T_NodeTwo() {}
public:
   C_ONE *Left()                    { return left; }
   void SetLeft(C_ONE *l)           { left = l; if (left) left->SetOwner(this); } 
   C_TWO *Right()                   { return right; }
   void SetRight(C_TWO *r)          { right = r; if (right) right->SetOwner(this); } 
   void SetBoth(C_ONE *l, C_TWO *r) { SetLeft(l); SetRight(r); } 
protected:
   C_ONE *left; C_TWO *right;
public:
   virtual void clear()                { CLEAR_NODE(left) CLEAR_NODE(right) TNode::clear(); }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { TNode::print(level, file, print_mode); PRINT_NODE(left) PRINT_NODE(right) }
   virtual void write(FILE *file, int print_mode) const { TNode::write(file, print_mode); WRITE_NODE(left) WRITE_NODE(right) }
};

template <class C_ONE, class C_TWO, class C_THREE> class T_NodeThree : public T_NodeTwo<C_ONE, C_TWO> {
public:
   T_NodeThree() :T_NodeTwo<C_ONE, C_TWO>(), mid(NULL) {}
   T_NodeThree(const T_Lexeme& h, C_ONE *l, C_THREE *m, C_TWO *r) :T_NodeTwo<C_ONE, C_TWO>(h,l,r), mid(m) { if (mid) mid->SetOwner(this); }
   ~T_NodeThree() {}
public:
   C_THREE *Mid()                     { return mid; }
   void SetMid(C_THREE *m)            { mid = m; if (mid) mid->SetOwner(this); } 
   void SetThree(C_ONE *l, C_THREE *m, C_TWO *r) { SetBoth(l,r); SetMid(m); } 
protected:
   C_THREE *mid;
public:
   virtual void clear()               { CLEAR_NODE(mid) T_NodeTwo<C_ONE, C_TWO>::clear(); }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { TNode::print(level, file, print_mode); PRINT_NODE(this->left) PRINT_NODE(this->mid) PRINT_NODE(this->right) }
   virtual void write(FILE *file, int print_mode) const { TNode::write(file, print_mode); WRITE_NODE(this->left) WRITE_NODE(this->mid) WRITE_NODE(this->right) }
};

template <class C_ONE, class C_TWO, class C_THREE, class C_FOUR> class T_NodeFour : public T_NodeThree<C_ONE, C_TWO, C_THREE> {
public:
   T_NodeFour() :T_NodeThree<C_ONE, C_TWO, C_THREE>(), four(NULL) {}
   T_NodeFour(const T_Lexeme& h, C_ONE *l, C_THREE *m, C_TWO *r, C_FOUR *f) :T_NodeThree<C_ONE, C_TWO, C_THREE>(h,l,m,r), four(f) { if (four) four->SetOwner(this); }
   ~T_NodeFour() {}
public:
   C_FOUR *Four()                     { return four; }
   void SetFour(C_FOUR *f)            { four = f; if (four) four->SetOwner(this); } 
   void SetAll(C_ONE *l, C_THREE *m, C_TWO *r, C_FOUR *f) { SetThree(l,m,r); SetFour(f); } 
protected:
   C_FOUR *four;
public:
   virtual void clear()               { CLEAR_NODE(four) T_NodeThree<C_ONE, C_TWO, C_THREE>::clear(); }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { TNode::print(level, file, print_mode); PRINT_NODE(this->left) PRINT_NODE(this->mid) PRINT_NODE(this->right) PRINT_NODE(four) }
   virtual void write(FILE *file, int print_mode) const { TNode::write(file, print_mode); WRITE_NODE(this->left) WRITE_NODE(this->mid) WRITE_NODE(this->right) WRITE_NODE(this->four) }
};

class T_NodeList : public TNode, public std::vector<TNode*> {
public:
   T_NodeList() :TNode() {}
   T_NodeList(const T_Lexeme& h) :TNode(h) {}
   ~T_NodeList() {}
public:
   TNode *Last()                    { if (empty()) return NULL; return back(); }
   void Add(TNode *r)               { r->SetOwner(this); push_back(r); } 
   void Insert(int i,TNode *r)      { r->SetOwner(this); insert(begin() + i, r); } 
   int  Count() const               { return (int)size(); }
   virtual bool IsNull() const;
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (!empty()) return back()->BaseType(); return btUnknown; } 
   virtual bool Search(TFinder& finder);
   virtual bool SearchInside(TFinder& finder);
public:
   virtual void clear();
   virtual const char* title() const   { return "T_NodeList"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual void write(FILE *file, int print_mode) const;
};

class TNodeUnary : public T_NodeOne<TNode> {
public:
   TNodeUnary() :T_NodeOne(), base_type(btUnknown), profile(NULL) {}
   TNodeUnary(const T_Lexeme& l, TNode *c) :T_NodeOne(l,c), base_type(btUnknown), profile(NULL) {}
public:
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return base_type; }
   virtual TNodeLogical* Logical(); 
   T_Symbol::T_Type Oper() const;
public:
   T_BaseType base_type; 
	const TOperProfile* profile;
public:
   virtual const char* title() const   { return "TNodeUnary"; }
};

class TNodeBinary : public T_NodeTwo<TNode,TNode> {
public:
   TNodeBinary() :T_NodeTwo(), base_type(btUnknown), profile(NULL), mode_oper(0) {}
   TNodeBinary(const T_Lexeme& h, TNode *l, TNode *r) :T_NodeTwo(h,l,r), base_type(btUnknown), profile(NULL), mode_oper(0) {}
public:
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return base_type; } 
   T_Symbol::T_Type Oper() const;
public:
   T_BaseType base_type;
	const TOperProfile* profile;
public:
   int mode_oper; // 0x01 - initialization
   virtual const char* title() const   { return "TNodeBinary"; }
};

class TNodeLogical : public T_NodeTwo<TNode,TNode> {
public:
   TNodeLogical() :T_NodeTwo(), base_type(btCInt), true_label(NULL), false_label(NULL), logical(0) {}
   TNodeLogical(const T_Lexeme& h, TNode *l, TNode *r) :T_NodeTwo(h,l,r), base_type(btCInt), true_label(NULL), false_label(NULL), logical(0) {}
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return base_type; } 
	virtual TNodeLogical* Logical() { return this; }
public:
   T_BaseType base_type;
   TNodeLabel *true_label, *false_label;
   int logical;
public:
   virtual const char* title() const   { return "TNodeLogical"; }
};

class TNodeTrio : public T_NodeThree<TNode,TNode,TNode> {
public:
   TNodeTrio() :T_NodeThree(), base_type(btUnknown) {}
   TNodeTrio(const T_Lexeme& h, TNode *l, TNode *m, TNode *r) :T_NodeThree(h,l,m,r), base_type(btUnknown) {}
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return base_type; } 
public:
   T_BaseType base_type;
public:
   virtual const char* title() const   { return "TNodeTrio"; }
};

class TNodeNumber : public TNode {
public:
   TNodeNumber() :TNode() {}
   TNodeNumber(const T_Lexeme& h) :TNode(h) {}
public:
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (lexeme.group == lexeme.grInteger) return btCInt; if (lexeme.group == lexeme.grNumber) return btCDouble; return btUnknown; } 
public:
   virtual const char* title() const   { return "TNodeNumber"; }
};

class TNodePrimary : public T_NodeOne<TNode> {
public:
   TNodePrimary() :T_NodeOne() {}
   TNodePrimary(const T_Lexeme& l, TNode *c) :T_NodeOne(l,c) {}
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return child ? child->BaseType() : btUnknown; } 
	virtual TNodeLogical* Logical() { return child ? child->Logical() : NULL; }
public:
   virtual const char* title() const   { return "TNodePrimary"; }
};

class TNodeType : public TNode {
public:
   TNodeType() :TNode(), base_type(btUnknown) {}
   TNodeType(const T_Lexeme& h) :TNode(h), base_type(btUnknown) {}
   TNodeType(const TNodeType& t) :TNode(t.lexeme), base_type(t.base_type) {}
public:
   bool Void() const { return (base_type == btVoid); }
   bool Const() const { return (base_type & btConst) != 0; }
   bool Static() const { return (base_type & btStatic) != 0; }
   bool Reference() const { return (base_type & btReference) != 0; }
   virtual T_BaseType BaseType() const { return base_type; } 
public:
   T_BaseType base_type; 
public:
   virtual const char* title() const   { return "TNodeType"; }
};

class TNodeCast : public T_NodeTwo<TNodeType,TNode> {
public:
   TNodeCast() :T_NodeTwo(), cast(T_CastType(0)), base_type(btUnknown) {}
   TNodeCast(const T_Lexeme& h, TNodeType *l, TNode *r) :T_NodeTwo(h,l,r), cast(T_CastType(0)), base_type(btUnknown) {}
   void SetType(TNodeType *t) { SetLeft(t); }
public:
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (left) return left->BaseType(); return base_type; }
   virtual TNodeLogical* Logical() { return right ? right->Logical() : NULL; }
public:
   T_CastType cast;
   T_BaseType base_type;
public:
   virtual const char* title() const   { return "TNodeCast"; }
};

class TNodeExpressions : public T_NodeList {
public:
   TNodeExpressions() :T_NodeList(), part(psNone) {}
   TNodeExpressions(const T_Lexeme& l) :T_NodeList(l), part(psNone) {}
   virtual void Codes(TSemantic &semantic, int mode);
   virtual TNodeLogical* Logical(); 
   virtual bool Search(TFinder& finder);
public:
   T_Part part;
public:
   virtual const char* title() const   { return "TNodeExpressions"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeList::print(level, file, print_mode); fprintf(file," part=%d ",part); }
};

class TNodeStatements : public T_NodeList, public TBlock {
public:
   TNodeStatements();
   virtual void Variables(TSemantic &semantic, int mode);
public:
   virtual const char* title() const   { return "TNodeStatements"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeList::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual T_BaseType BaseType() const { return btVoid; }
   virtual bool Search(TFinder& finder);
public:
   int step;
};

class TNodeDefVar : public T_NodeThree<TNodeType, TNode, T_NodeList> { 
public:
   TNodeDefVar() :T_NodeThree(), alloc(T_Alloc::taNone), offset(0), dimension(0), uninitialized(false), referenced(false) {}
   TNodeDefVar(const T_Lexeme& l) :T_NodeThree(l,NULL,NULL,NULL), alloc(T_Alloc::taNone), offset(0), dimension(0), uninitialized(false), referenced(false) {}
   TNodeDefVar(TNodeType *t, const T_Lexeme& l) :T_NodeThree(l,NULL,NULL,NULL), alloc(T_Alloc::taNone), offset(0), dimension(0), uninitialized(false), referenced(false) { SetType(t); }
public:
   TNodeType *Type()            { return left; }
   void SetType(TNodeType *t)   { SetLeft(t); }
   void SetAssign(TNode *a)     { SetRight(a); }
   void SetAssign(const T_Lexeme& lexeme, TNode* expr, TSemantic* semantic = NULL);
   void TreeOffset(TSemantic &semantic);
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return (left) ? left->BaseType() : btUnknown; } 
   virtual bool SearchInside(TFinder& finder);
public:
   T_Alloc alloc;
   int     offset, dimension;
	bool    uninitialized, referenced;
public:
   virtual const char* title() const   { return "TNodeDefVar"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
};

struct TDefArrRangeItem {
public:
   TDefArrRangeItem()  : range(0), volume(0), index(0), made(0) {}
   TDefArrRangeItem(int r)  : range(r), volume(0), index(0), made(0) {}
public:
   int range, volume, index, made;
};
struct TDefArrRange : public std::vector<TDefArrRangeItem> {
public:
   TDefArrRange() :level(0) {}
   int  calc();
   int  count() const { return (int)size(); }
   int  offset() const;
   bool variable_range() const;
   bool unknown_range() const { return (front().range == -1); }
   bool next();
   void jump(int level);
public:
   int  level;
};

class TNodeDefArr : public TNodeDefVar {
public:
   TNodeDefArr() :TNodeDefVar() {}
   TNodeDefArr(const T_Lexeme& l, T_NodeList *r) :TNodeDefVar(l) { SetRange(r); }
   TNodeDefArr(TNodeType *t, const T_Lexeme& l, T_NodeList *r) :TNodeDefVar(t,l) { SetRange(r); }
   virtual ~TNodeDefArr() {}
public:
   T_NodeList* Range() { return (T_NodeList*)mid; }
   void SetRange(T_NodeList *r) { SetMid(r); }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   bool parse_init(T_NodeList *items, int level);
public:
   TDefArrRange ranges;
protected:
   struct TDefArrInitItem {
   public:
      TDefArrInitItem() :offset(0), value(NULL) {}
      TDefArrInitItem(int o, TNode* v) :offset(o), value(v) {}
//      ~TDefArrInitItem() { if (value) value->clear(); }
   public:
      int offset; TNode* value;
   };
   std::vector<TDefArrInitItem> initializer;
public:
   virtual const char* title() const   { return "TNodeDefArr"; }
};

class TNodeDefine : public T_NodeList {
public:
   TNodeDefine() :T_NodeList(), left(NULL) {}
   TNodeDefine(const T_Lexeme& h) :T_NodeList(h), left(NULL) {}
   TNodeDefine(TNodeType *t) :T_NodeList(t ? t->Lexeme() : T_Lexeme()) { SetType(t); }
public:
   TNodeType *Type() { return left; }
   void SetType(TNodeType *l) { left = l; if (left) left->SetOwner(this); }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (left) return left->BaseType(); return btUnknown; }
   virtual bool Search(TFinder& finder);
   virtual bool SearchInside(TFinder& finder);
protected:
   TNodeType *left;
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeList::print(level, file, print_mode); }
   virtual const char* title() const { return "TNodeDefine"; }
};

class TNodeDefFunc : public T_NodeThree<TNodeType, TNodeDefine, TNode>, public TBlock {
public:
   TNodeDefFunc() :T_NodeThree(), TBlock(tbFunc), profile(NULL), number(0) {}
   TNodeDefFunc(const T_Lexeme& l) :T_NodeThree(l,NULL,NULL,NULL), TBlock(tbFunc), profile(NULL), number(0) {}
   TNodeDefFunc(TNodeType *t, const T_Lexeme& l, TNodeDefine *p, TNode *b) :T_NodeThree(l,t,b,p), TBlock(tbFunc), profile(NULL), number(0) {}
//   virtual ~TNodeDefFunc() {}
public:
   void SetType(TNodeType *t)    { SetLeft(t); }
   void SetParams(TNodeDefine*r) { SetRight(r); }
   TNode* Body()                 { return mid; }
   void SetBody(TNode *a)        { SetMid(a); }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (left) return left->BaseType(); return btUnknown; } 
   virtual bool Search(TFinder& finder);
public:
   TFuncProfile *profile;
	int  number;
public:
   virtual void clear();
   virtual const char* title() const   { return "TNodeDefFunc"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeThree::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual void write(FILE *file, int print_mode) const { T_NodeThree::write(file, print_mode); }
};

class TNodeVar : public T_NodeOne<TNodeDefVar> { // client def
public:
   TNodeVar() :T_NodeOne() {}
   TNodeVar(const T_Lexeme& h) :T_NodeOne() { SetLexeme(h); }
public:
   void SetType(TNodeDefVar *t) { SetChild(t); }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (child) return child->BaseType(); return btUnknown; } 
public:
	virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const   { return "TNodeVar"; }
   virtual void write(FILE *file, int print_mode) const;
};

class TNodeCall : public T_NodeTwo<TNodeDefFunc, T_NodeList> { // client def
public:
   TNodeCall() :T_NodeTwo(), profile(NULL) {}
   TNodeCall(const T_Lexeme& h) :T_NodeTwo(), profile(NULL) { SetLexeme(h); }
   TNodeCall(const T_Lexeme& h, T_NodeList *r) :T_NodeTwo(h,NULL,r), profile(NULL) {}
public:
   void SetType(TNodeDefFunc *t) { SetLeft(t); }
	TNodeDefFunc* Type()          { return left; }
   T_NodeList* Params()          { return right; }
   void SetList(T_NodeList *l)   { SetRight(l); } // params
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (left) return left->BaseType(); return btUnknown; } 
public:
   TFuncProfile *profile;
public:
   virtual void clear();
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const   { return "TNodeCall"; }
   virtual void write(FILE *file, int print_mode) const;
};

class TNodeIndex : public T_NodeTwo<TNodeDefArr, T_NodeList> { // client def
public:
   TNodeIndex() :T_NodeTwo() {}
   TNodeIndex(const T_Lexeme& h) :T_NodeTwo() { SetLexeme(h); }
   TNodeIndex(const T_Lexeme& h, T_NodeList *r) :T_NodeTwo(h,NULL,r) {}
public:
   void SetType(TNodeDefArr *t) { SetLeft(t); }
   T_NodeList* Ranges()         { return right;}
   void SetList(T_NodeList *l)  { SetRight(l); }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { if (left) return left->BaseType(); return btUnknown; } 
public:
	virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const   { return "TNodeIndex"; }
   virtual void write(FILE *file, int print_mode) const;
public:
};

class TNodeFor : public T_NodeFour<TNode,TNode,TNode,TNode>, public TBlock {
public:
   TNodeFor() :T_NodeFour(), TBlock(tbFor) {}
   TNodeFor(const T_Lexeme& l) :T_NodeFour(l,NULL,NULL,NULL,NULL), TBlock(tbFor) {}
public:
   void SetBeg(TNode *t)       { SetLeft(t); }
   void SetCondition(TNode *i) { SetMid(i); }
   void SetEnd(TNode *r)       { SetRight(r); }
   void SetBody(TNode *a)      { SetFour(a); }
   TNode* Body()               { return four;  }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual bool Search(TFinder& finder);
   virtual bool SearchInside(TFinder& finder);
public:
   virtual const char* title() const   { return "TNodeFor"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeFour::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual void write(FILE *file, int print_mode) const { T_NodeFour::write(file, print_mode); }
};

class TNodeWhile : public T_NodeTwo<TNode,TNode>, public TBlock {
public:
   TNodeWhile() :T_NodeTwo(), TBlock(tbWhile) {}
   TNodeWhile(const T_Lexeme& l) :T_NodeTwo(l,NULL,NULL), TBlock(tbWhile) {}
public:
   void SetCondition(TNode *c) { SetLeft(c); }
   void SetBody(TNode *b)      { SetRight(b); }
   TNode* Body()               { return right; }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual bool SearchInside(TFinder& finder);
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeTwo::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual const char* title() const   { return "TNodeWhile"; }
};

class TNodeDo : public T_NodeTwo<TNode,TNode>, public TBlock {
public:
   TNodeDo() :T_NodeTwo(), TBlock(tbDo) {}
   TNodeDo(const T_Lexeme& l) :T_NodeTwo(l,NULL,NULL), TBlock(tbDo) {}
public:
   void SetCondition(TNode *c) { SetLeft(c); }
   void SetBody(TNode *b)      { SetRight(b); }
   TNode* Body()               { return right; }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual bool SearchInside(TFinder& finder);
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeTwo::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual const char* title() const   { return "TNodeDo"; }
};

enum T_GoTo { 
   tgNone, tgIf, tgElse, tgGoTo
};

class TNodeLabel : public T_NodeOne<TNode> {
public:
   TNodeLabel(TSemantic* semantic);
   virtual ~TNodeLabel() {}
public:
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return btVoid; } 
   TNodeLabel* Label() { return reference ? Reference() : this; }
   TNodeLabel* Reference() const;
   void SetReference(TNodeLabel* r);
public:
   TNodeLabel* reference;
   int go_to, command;
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const   { return "TNodeLabel"; }
protected:
   TNodeLabel(const T_Lexeme& l);
};

struct T_UserGoToItem
{
   T_UserGoToItem() :block(0), offset(0) {}
   T_UserGoToItem(int b, int o) :block(b), offset(o) {}
   int block, offset;
};

class TBlockTable;
class T_UserGoToLabel : public std::vector<T_UserGoToItem> {
public:
   T_UserGoToLabel() {}
   virtual ~T_UserGoToLabel() {}
public:
   bool Compare(const T_UserGoToLabel &join) const;
public:
   void print(FILE *file = stdout, int print_mode = 0) const;
};

class TNodeUserLabel : public TNodeLabel, public T_UserGoToLabel {
public:
   TNodeUserLabel(TSemantic* semantic) :TNodeLabel(semantic) {}
   TNodeUserLabel(const T_Lexeme& l) :TNodeLabel(l) {}
   virtual ~TNodeUserLabel() {}
public:
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual bool SearchInside(TFinder& finder);
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const   { return "TNodeUserLabel"; }
};

class TNodeGoTo : public T_NodeOne<TNodeLabel> { // client label
public:
   TNodeGoTo() :T_NodeOne(), type(tgNone), del_count(0) {}
   TNodeGoTo(T_GoTo t, TNodeLabel *l = NULL) :T_NodeOne(), type(t), del_count(0) { SetLabel(l); }
   virtual ~TNodeGoTo() {}
public:
   void SetType(T_GoTo t) { type = t; }
   void SetLabel(TNodeLabel* l);
   TNodeLabel* GetLabel();
   virtual void Codes(TSemantic &semantic, int mode);
public:
   T_GoTo type; 
   int del_count;
protected:
   TNodeGoTo(const T_Lexeme& l) :T_NodeOne(l,NULL), type(tgGoTo) {}
public:
   virtual void clear() { child = NULL; /*T_NodeTwo::clear(); */ }
   virtual const char* title() const   { return "TNodeGoTo"; }
};

class TNodeUserGoTo : public TNodeGoTo, public T_UserGoToLabel {
public:
   TNodeUserGoTo() :TNodeGoTo() { SetType(tgGoTo); }
   TNodeUserGoTo(const T_Lexeme& l) :TNodeGoTo(l) {}
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual const char* title() const   { return "TNodeUserGoTo"; }
};

class TNodeBreakContinue : public TNodeGoTo {
public:
   TNodeBreakContinue(T_Block r) :TNodeGoTo(), rate(r) { SetType(tgGoTo); }
   TNodeBreakContinue(T_Block r, const T_Lexeme& l) :TNodeGoTo(l), rate(r) { SetType(tgGoTo); }
public:
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   bool FindLabel(TSemantic &semantic);
public:
   T_Block rate;
public:
   virtual const char* title() const   { return (rate == T_Block::tbBreak) ? "TNodeBreak" : "TNodeContinue"; }
};

class TNodeReturn : public T_NodeOne<TNode> {
public:
   TNodeReturn() :T_NodeOne(), base_type(btUnknown) {}
   TNodeReturn(const T_Lexeme& l) :T_NodeOne(l,NULL), base_type(btUnknown) {}
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
public:
   void SetValue(TNode *c) { SetChild(c); }
   T_BaseType base_type;
public:
   virtual const char* title() const   { return "TNodeReturn"; }
};

class TNodeIf : public T_NodeThree<TNode,TNode,TNode>, public TBlock {
public:
   TNodeIf() :T_NodeThree(), TBlock(tbIf), trunc(0), then_exec(0) {}
   TNodeIf(const T_Lexeme& h) :T_NodeThree(h,NULL,NULL,NULL), TBlock(tbIf), trunc(0), then_exec(0) {}
public:
   void SetCondition(TNode *c) { SetLeft(c); }
   void SetThen(TNode *b)      { SetMid(b); }
   void SetElse(TNode *b)      { SetRight(b); }
   TNode* Then()               { return mid; }
   TNode* Else()               { return right; }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
   virtual void Verify(TSemantic &semantic, int mode);
   virtual bool SearchInside(TFinder& finder);
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeThree::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual const char* title() const   { return "TNodeIf"; }
public:
   int trunc;
   int then_exec;
};

class TNodeSwitchCase : public T_NodeOne<TNode> {
public:
   TNodeSwitchCase() :T_NodeOne(), value(true) {}
   TNodeSwitchCase(const T_Lexeme& l) :T_NodeOne(l,NULL), value(true) {}
public:
   void SetValue(TNode *c) { SetChild(c); }
public:
   bool value;
public:
   virtual const char* title() const   { return "TNodeSwitchCase"; }
};

class TNodeSwitchItem : public T_NodeTwo<TNode,TNode>, public TBlock {
public:
   TNodeSwitchItem() :T_NodeTwo(), TBlock(tbSwitchItem) {}
   TNodeSwitchItem(const T_Lexeme& l) :T_NodeTwo(l,NULL,NULL), TBlock(tbSwitchItem) {}
public:
   void SetKey(T_NodeList *c)  { SetLeft(c); }
   void SetBody(T_NodeList *b) { SetRight(b); }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeTwo::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual const char* title() const   { return "TNodeSwitchItem"; }
};

class TNodeSwitch : public T_NodeTwo<TNode,TNode>, public TBlock {
public:
   TNodeSwitch() :T_NodeTwo(), TBlock(tbSwitch) {}
   TNodeSwitch(const T_Lexeme& l) :T_NodeTwo(l,NULL,NULL), TBlock(tbSwitch) {}
public:
   void SetKey(TNode *c)       { SetLeft(c); }
   void SetBody(T_NodeList *b) { SetRight(b); }
   virtual void Variables(TSemantic &semantic, int mode);
   virtual void Codes(TSemantic &semantic, int mode);
public:
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const { T_NodeTwo::print(level, file, print_mode); TBlock::print(file, print_mode); }
   virtual const char* title() const   { return "TNodeSwitch"; }
};

class TSerializer {
public:
   TSerializer() {}
};

void GarbageCollectorAdd(TNode* node, int mode_del);
void GarbageCollectorClear();

#endif

// TranGrammar.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Parse.h"
#include "GSyntax.h"
#include "MSyntax.h"
#include "TSemantic.h"
#include "InHelp.h"
#include "CGrammar.h"
#include "Grammar.h"

#include "C99_Lexer.h"

// --------------------------- C_Grammar_Syntax ---------------------------

class C_GrammarGSyntax : public GSyntax, public C_Grammar_Syntax
{
public:
   C_GrammarGSyntax(T_Scan *s, TGrammar* g) :GSyntax(s,g), C_Grammar_Syntax(this) {}
   virtual bool Translate();
   virtual bool Command(int command) { return C_Grammar_Syntax::Command(command); }
	virtual T_Lexeme::T_Group Lexeme(T_Lexeme &l);
   virtual bool VerifyAction(const GSymbol& sym) { return VerifyLR0(sym); }
};

bool C_GrammarGSyntax::Translate()
{
   blocks.Push(C_GrammarIdentTable::T_Block::Global); 
   bool ret = GSyntax::Translate();
   blocks.Pop();
   return ret;
}

T_Lexeme::T_Group C_GrammarGSyntax::Lexeme(T_Lexeme &l)
{
   A_Syntax::Lexeme(current_lexeme);
   UpdateLexeme(current_lexeme);
   l = current_lexeme;

   return l.group;
}

bool test(int type, int option, const char *file, const char *table_file)
{
   M_Syntax::M_Mode make_mode = M_Syntax::M_Mode(type & 0x0F);
   const int C_syntax = GSyntax::M_Mode::mmMade + 1, C99_syntax = GSyntax::M_Mode::mmMade + 2;
   int scan_type = (type & 0xF0) >> 4;
   if ((make_mode < 0) || (make_mode > C99_syntax)) {
      printf("\nmode error : %d", make_mode);
      return false;
   }
	T_SourceFile source;
   TGrammar     table;

	TScanArray  scan(&source);
   T_FlexLexer lexer(&source);

	GSyntax          parse_g(&scan,&table);
	C_GrammarGSyntax parse_C(&scan,&table);
	GSyntax*         parse;

   if ((make_mode == C_syntax) || (make_mode == C99_syntax)) { // C_Grammar
      parse = &parse_C;
   } else {
      parse = &parse_g;
   }
   parse->option = option;
	parse->line_is_space = true;
	
   if (scan_type) {
      if (!lexer.Open()) return false;
      parse->Scan(&lexer);
   }
   if (!parse->Source(source, file)) return false;

	TSemantic  semantic(parse);

   TData      data(&table, parse, &semantic); data.makers = &GMakerTable::maker_table;
              data.file = file;

   int table_type;
   A_Syntax::T_SyntaxMode syntax_type;
   if (!table.read(table_file,table_type,0x00)) return false;
 
   if (table_type & T_Grammar::gtLL) {
      table.Mtable.print(NULL,0x00);
      syntax_type = A_Syntax::smParseLL1;
   }
   if (table_type & T_Grammar::gtLR) {
      table.LRtable.print(NULL,0x00);
      syntax_type = A_Syntax::smParseLR0;
   }
   table.print(NULL,0x00);

   T_Grammar grammar_type = table.type;
   if ((make_mode == C_syntax) || (make_mode == C99_syntax)) { // C_Grammar
      table.type = T_SyntaxLexeme(table.type | T_SyntaxLexeme::slNoSave); // !SaveLexeme
      parse_C.Mask((make_mode == C_syntax) ? A_Symbol::mmC : A_Symbol::mmC_99);
      make_mode = GSyntax::M_Mode::mmTree;
   }
   if ((make_mode == M_Syntax::mmTree) && !(grammar_type & T_Grammar::mtTree) ||
       (make_mode == M_Syntax::mmCode) && !(grammar_type & T_Grammar::mtCode) ||
       ((make_mode == M_Syntax::mmNode) || (make_mode == M_Syntax::mmMade)) && !(grammar_type & T_Grammar::mtSNode)
      ) {
      make_mode = M_Syntax::mmNone;
   }

   parse->set_make_mode(make_mode);
   parse->set_semantic(&semantic);
   parse->syntax_mode = syntax_type;
   parse->syntax_lexeme = table.type;
   parse->look_ahead = table.look_ahead;

   bool gut = semantic.Translate();

   if (parse->option & T_OptionMode::omTrimUnit) {
      parse->unit.trim();
   }

   semantic.Result(file);

   parse->print_store(stdout);

	if (gut) { 
		printf("\ntrue\n");
   } else {
		printf("\nfalse\n");
   }
	parse->Cur().print(&scan);

	return true;
}

int main(int argc, const char* argv[])
{
   TInHelp in_help(TInHelp::Grammar);
   in_help.type = 0x007; // 0x010 + M_Syntax::mmCode; M_Syntax::mmTurn + 2; // GSyntax::M_Mode::mmTurn + 1;
   //   in_help.table = "NR_SN_LR1.tab"; 
   in_help.table = "NR_LR0.tab";
//   in_help.table = "LL_TC_LLk.tab";
//   in_help.table = "ETF_LR_LR0.tab";
//   in_help.table = "ETF_LL_LL1.tab";
//   in_help.table = "ETF_LL_LR0.tab";
//   in_help.table = "C_Grammar.tab";
   in_help.option = 0x0830;

//   in_help.file = "..\\TranBuilder\\FSyntax.y";
   in_help.file = "text.cpp";
//   in_help.file = "text_c.cpp";
//   in_help.option = 0x5FF8;

//   TranGrammar 6 000820 text.cpp NR_LR0_Auto.tab
   in_help.file = "text.cpp";
   in_help.type = 0;
   in_help.option = 0x0000;
   in_help.option |= T_OptionMode::omPrintTree;
   in_help.option |= T_OptionMode::omAutoTree;
   in_help.table = "NR_LR0_Auto.tab";

//   TranGrammar.exe 3 1830 text.cpp ..\Table\LL_SN_LL2.tab
//   TranGrammar.exe 3 1830 text.cpp ..\Table\LL_SN_LL1.tab
   in_help.type = 0x0011;
   in_help.file = "text.cpp";
   in_help.option = 0x00000830;
//   in_help.option |= T_OptionMode::omTreeTraversal;
   in_help.table = "..\\Table\\LR_TC_LR0.tab";

//   TranGrammar.exe 15 1830 text.cpp ..\Table\NR_SN_LR1.tab

//   TranGrammar.exe 11 0830 text.cpp ..\Table\LR_TC_LR0.tab

//   TranGrammar.exe 1 4FF8 Example_02.cpp Example\02_ETF_LL_TC_LL1.tab
   in_help.type = 0x0001;
   in_help.file = "Example_02.cpp";
   in_help.option = 0x00004FF8;
   in_help.table = "02_ETF_LL_TC_LL1.tab";
//   TranGrammar.exe 5 1830 text.cpp ..\Table\LL_SN_LL1.tab
   in_help.type = 0x0001;
   in_help.file = "text.cpp";
   in_help.option = 0x00001830;
//   in_help.option |= T_OptionMode::omPrintRule | T_OptionMode::omPrintStack;
   in_help.option |= T_OptionMode::omPrintMaker;
   in_help.option |= T_OptionMode::omAtOnce;
   in_help.table = "..\\Table\\LL_SN_LL1.tab";
//   TranGrammar.exe 15 1830 text.cpp ..\Table\NR_SN_LR1.tab
   in_help.table = "..\\Release64\\ETF_TC_Fi_.tab";
   in_help.file = "test.cpp";
   in_help.option = 0x00004FF8;

   if (!in_help.input(argc,argv)) return 0;
   test(in_help.type, in_help.option, in_help.file, in_help.table);

	return 0;
}
// TranParse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Parse.h"
#include "ASyntax.h"
#include "InHelp.h"

// --------------------------- main ---------------------------

int scan_control(A_Syntax &scan)
{
   enum T_Group { grNone, grOper, grSeparator, grInteger, grNumber, grString, grIdent, grReserv, grSpace, grLine, grError, grPriority, grSyntax, grEof };
   int counts[T_Lexeme::T_Group::grEof + 1] = { 0 };
   int count = 0;
	for (;; count++) {
      if        (scan.Match(T_Lexeme::grOper     )) { counts[T_Lexeme::grOper     ]++;
      } else if (scan.Match(T_Lexeme::grSeparator)) { counts[T_Lexeme::grSeparator]++; 
      } else if (scan.Match(T_Lexeme::grInteger  )) { counts[T_Lexeme::grInteger  ]++;
      } else if (scan.Match(T_Lexeme::grNumber   )) { counts[T_Lexeme::grNumber   ]++;
      } else if (scan.Match(T_Lexeme::grString   )) { counts[T_Lexeme::grString   ]++;
      } else if (scan.Match(T_Lexeme::grIdent    )) { counts[T_Lexeme::grIdent    ]++;
      } else if (scan.Match(T_Lexeme::grReserv   )) { counts[T_Lexeme::grReserv   ]++;
      } else if (scan.Match(T_Lexeme::grSpace    )) { counts[T_Lexeme::grSpace    ]++;
      } else if (scan.Match(T_Lexeme::grLine     )) { counts[T_Lexeme::grLine     ]++;
      } else if (scan.Match(T_Lexeme::grError    )) { counts[T_Lexeme::grError    ]++;
      } else if (scan.Match(T_Lexeme::grPriority )) { counts[T_Lexeme::grPriority ]++;
      } else if (scan.Match(T_Lexeme::grSyntax   )) { counts[T_Lexeme::grSyntax   ]++;
      } else if (scan.Match(T_Lexeme::grEof      )) { counts[T_Lexeme::grEof      ]++; break;
      } else {
        if (!scan.Next()) break;
      }
	}

   int g = 0;
   printf("\n");
   for (int item : counts) {
      printf("%s=%d", group_title(T_Lexeme::T_Group(g++)), item);
      if (g <= T_Lexeme::grEof) printf(", ");
   }
   printf("\ncount=%d\n\n", count);

   count = 0;
   for (int &item : counts) item = 0;
   scan.option = 0x0007;
   scan.Reset();

   T_Lexeme lexeme;
   T_Lexeme::T_Group group;
   do {
      count++;
      group = scan.Lex(lexeme);
      counts[lexeme.group]++;
   } while (group != T_Lexeme::grEof);

   g = 0;
   printf("\n");
   for (int item : counts) {
      printf("%s=%d", group_title(T_Lexeme::T_Group(g++)), item);
      if (g <= T_Lexeme::grEof) printf(", ");
   }
   printf("\n");

   return count;
}

int scan_lexeme(A_Syntax &scan)
{
	int count = 0;
	T_Lexeme lexeme;
	T_Lexeme::T_Group group = scan.Lexeme(lexeme);
	while (group != T_Lexeme::grEof) {
      count++;
		group = scan.Lexeme(lexeme);
	}
	return count;
}

int scan_next(A_Syntax &scan)
{
	int count = 0;
	while (scan.Next()) {
      count++;
	}
	return count;
}

int scan_store(A_Syntax &scan)
{
	int count = 0;
	for (;; count++) {
      T_ScanStore store;
      scan.Store(store);
      if (!scan.Next()) break;
      count++;
      scan.Restore(store);
      if (!scan.Next()) break;
	}
	return count;
}

int scan_write(T_Parse &scan, const char *file_name)
{
   char *file_lexeme = get_file_name(file_name,"lex");
   FILE *file; FOPEN(file, file_lexeme, "w");
   if (file == NULL) return -1;;

   int count = 0;
   T_Lexeme lexeme;
   T_Lexeme::T_Group group;
	do {
      count++;
      group = scan.Lex(lexeme);
      lexeme.write(&scan.Scan(), file);
   } while (group != T_Lexeme::grEof);

   free(file_lexeme);
   fclose(file);

   return count;
}

int scan_lexer(A_Syntax &parse, const char *file_name)
{
   int count = 0;
   while (parse.Next()) {
      count++;
   }
   return count;
}

// -------------------- ETF_Parse --------------------
#define RETURN_TRUE  { leave(p); return true;  }
#define RETURN_FALSE { leave(p, true); return false; }
#define ENTRY(P)     const char* p = #P; entry(#P);

class ETF_Parse : public T_Parse 
{
public:
   ETF_Parse(T_Scan *s) :T_Parse(s), level(0) { WordTable(&T_KeyWordTable::key_word_table); }
public:
   bool Z();
   bool E();
   bool T();
   bool F();
public:
   void entry(const char* p);
   void leave(const char* p, bool e = false);
public:
   int level;
};

bool ETF_Parse::Z()
{
   ENTRY(Z);
   if (!E() || !Match(T_Lexeme::T_Group::grEof)) RETURN_FALSE;
   RETURN_TRUE;
}

bool ETF_Parse::E()
{
   ENTRY(E);
   if (!T()) RETURN_FALSE;
   while (Match(T_Lexeme::grOper, T_Symbol::lxAdd) || Match(T_Lexeme::grOper, T_Symbol::lxSub)) {
      if (!T()) RETURN_FALSE;
   }
   RETURN_TRUE;
}

bool ETF_Parse::T()
{
   ENTRY(T);
   if (!F()) RETURN_FALSE;
   while (Match(T_Lexeme::grOper, T_Symbol::lxMulti) || Match(T_Lexeme::grOper, T_Symbol::lxDiv)) {
      if (!F()) RETURN_FALSE;
   }
   RETURN_TRUE;
}

bool ETF_Parse::F()
{
   ENTRY(F);
   if (Match(T_Lexeme::grIdent))   RETURN_TRUE;
   if (Match(T_Lexeme::grInteger)) RETURN_TRUE;
   if (Match(T_Lexeme::grNumber))  RETURN_TRUE;
   if (Match(T_Symbol::lxLeftBracket) && E() && Match(T_Symbol::lxRightBracket)) RETURN_TRUE;
   RETURN_FALSE;
}

void ETF_Parse::entry(const char* p)
{
   level++;
   printf("%*c", level * 2, ' ');
   printf("%s\n", p);
}

void ETF_Parse::leave(const char* p, bool e)
{
   printf("%*c~", level * 2 - 1, ' ');
   if (e) printf("!");
   printf("%s\n", p);
   level--;
}

#include "C99_Lexer.h"

bool test(int type, int option, const char *file)
{
	T_SourceFile source;
	if (!source.Open(file)) {
      printf("\nfile error : %s", file);
      return false;
   }
	
   if (option & T_OptionMode::omPrintSource) {
   	print_source(source);
	   source.Reset();
   }

	T_Scan scan(&source);
   T_FlexLexer lexer(&source);
   A_Syntax parse(&scan);
   parse.option = option;

   int count = 0;
   switch (type) {
   case 0 :
      count = print_source(source);
      break;
   case 1 :
   	count = scan_source(parse);
      break;
   case 2 :
   	count = scan_next(parse);
      break;
   case 3 :
   	count = scan_control(parse);
      break;
   case 4 :
      parse.syntax_lexeme = T_SyntaxLexeme::slNone;
   	count = scan_lexeme(parse);
      break;
   case 5 :
      parse.syntax_lexeme = T_SyntaxLexeme(T_SyntaxLexeme::slNone | T_SyntaxLexeme::slPrior | T_SyntaxLexeme::slPriorAssign);
   	count = scan_lexeme(parse);
      break;
   case 6 :
      parse.syntax_lexeme = T_SyntaxLexeme::slSyntax;
   	count = scan_lexeme(parse);
      break;
   case 7 :
   	count = scan_store(parse);
      break;
   case 8 : {
      ETF_Parse etf_parse(&scan);
      etf_parse.option = option;
      etf_parse.line_is_space = true;
      bool ret = etf_parse.Z();
      } break;
   case 9 : {
   	count = scan_write(parse, file);
      } break;
   case 0x0A: {
      if (!lexer.Open()) return false;
      parse.Scan(&lexer);
      count = scan_lexer(parse, file);
      } break;
   }
   printf("\ncount=%d\n", count);

	return true;
}

int main(int argc, const char* argv[])
{
   TInHelp in_help(TInHelp::Parse);
   in_help.type = 0x09;
   in_help.file = "test.cpp";
   in_help.option = 0x0007;

   if (!in_help.input(argc,argv)) return 0;
   test(in_help.type, in_help.option, in_help.file);

	return 0;
}

// TranRules.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Parse.h"
#include "ASyntax.h"
#include "RSyntax.h"
#include "TSemantic.h"
#include "Maker.h"
#include "InHelp.h"
#include "GrammarStock.h"
#include "Grammar.h"

// --------------------------- main ---------------------------

/*
   stack { smNone = 0x00, smParseStackRule = 0x0XX1, smParseStackFormula = 0x0XX2, smParseRule = 0x0XX3, smParseFormula = 0x0XX4 };
   mode  { 0x0XX - rules + LL, 0x1XX - rules + NL, 0x4XX - formula + LL, 0x5XX - formula + NL }
  
        0x01 0x02 0x03 0x04 - stack
   0x00 TC SN  TC   TC   TC
   0x10   T    T    T    T 
   0x40   -    TC   -    TC
   0x50   -    T    -    T
   mode
  
*/

char* get_file_name(const char*file, const char* ext);

bool test(int type, int option, const char *file, const char *table_file)
{
   M_Syntax::M_Mode make_mode = M_Syntax::M_Mode((type & 0x0F0) >> 4);
   A_Syntax::T_SyntaxMode syntax_mode = A_Syntax::T_SyntaxMode(type & 0x00F);
   int def_rule_mode = ((type & 0xF00) >> 8); // 0000 - LL(R), 0100 - NL(R), 1000 - LL(F), 1100 - NL(F)
   bool def_formula_mode = true, def_table_mode = ((type & 0xF000) == 0x2000);
   if (def_formula_mode && ((type & 0x03) == 0x03)) {
      return false;
   }

   T_SourceFile source;
   TGrammar   table;

	TScanArray scan(&source);
	RSyntax    parse(&scan,&table);

	parse.option = option;
	parse.line_is_space = true;
   if (!parse.Source(source,file)) return false;

   TSemantic  semantic(&parse);

   TData      data(&table, &parse, &semantic); data.makers = &GMakerTable::maker_table;
              data.file = file;

   bool ret;
   if (def_table_mode) {
      int table_type;
      ret = table.read(table_file,table_type,0x00);
   } else {
      ret = build_grammar(table,def_rule_mode, make_mode, (def_formula_mode ? 0x01 : 0x00));
      if (def_rule_mode & 0x01) { // NL
         parse.syntax_lexeme = T_SyntaxLexeme::slNone;
      }
   }
   if (!ret || (table.type & T_Grammar::gtLR)) return false;
   table.print(0x00);
   parse.set_make_mode(make_mode);
   parse.set_semantic(&semantic);
   parse.set_syntax_mode(syntax_mode);

   if ((syntax_mode == A_Syntax::smParseStackRule) && (option & T_OptionMode::omSelectProduce)) { // select_produce
      table.make_lexemes();
      table.make_FIRSTs();
      table.make_FIRSTsP();
//      table.FIRSTs.print("FIRSTs", "FIRSTs", 0x0702);
//      table.FIRSTsP.print("FIRSTsP", "FIRSTsP", 0x0702);
   }

// 0x0001 - other,      0x0002 - space,      0x0004 - line,       0x0008 - Lexeme, 
// 0x0010 - print_tree, 0x0020 - erase_code, 0x0040 - print_code, 0x0080 - print_operator, 
// 0x0100 - print_rule, 0x0200 - print_maker,0x0400 - print_stack,0x0800 - print_Code 

   bool gut = semantic.Translate();

   semantic.Result(file);

   parse.print_store(stdout);
	if (gut)  
		printf("\ntrue\n");
   else
		printf("\nfalse\n");
	parse.Cur().print(&scan);

	return true;
}

int main(int argc, const char* argv[])
{
   TInHelp in_help(TInHelp::Rules);
   in_help.type = (M_Syntax::M_Mode::mmMade << 4) | A_Syntax::smParseStackRule;
   in_help.type = 0x011;
   in_help.file = "text.cpp";
   in_help.option = 0x0820;
//   in_help.option = 0x1831;
   in_help.option = 0x8830;

//   TranRules.exe 031 1830 text.cpp
   in_help.type = 0x1031;
   in_help.option = 0x1938;
//   TranRules.exe 1031 1830 text.cpp


   if (!in_help.input(argc,argv)) return 0;
   test(in_help.type, in_help.option, in_help.file, in_help.table);

	return 0;
}
// Translator.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Parse.h"
#include "GrammarCFG.h"
#include "Grammar.h"
#include "InHelp.h"

//#define CSYNTAX 
//#define TSYNTAX
//#define SYNTAX
//#define RSYNTAX
//#define MSYNTAX
#define RULES

#ifdef CSYNTAX
#include "TSemantic.h"
#include "CSyntax.h"
#endif
#ifdef TSYNTAX
#include "TSyntax.h"
#include "TSemantic.h"
#endif
#ifdef SYNTAX
#include "Syntax.h"
#endif
#ifdef RSYNTAX
#include "RSyntax.h"
#include "TSemantic.h"
#endif
#ifdef MSYNTAX
#include "MSyntax.h"
#include "TSemantic.h"
#endif
#ifdef RULES
#include "GSyntax.h"
#include "MSyntax.h"
#include "PSyntax.h"
#include "FSyntax.h"
#include "TSemantic.h"
#endif

#include "GrammarStock.h"

T_Stock stock = T_Stock::msNone, stock_grammar = T_Stock::msNone, stock_media = T_Stock::msNone, stock_make = T_Stock::msNone;

// --------------------------- main ---------------------------

#include "Maker.h"
#include "SNodes.h"

#pragma optimize("", off)
#define FORMULA_MACRO_DEFINE
#include "RuleMacro.h"

static bool build_formulas(TGrammar &table, TRuleNames &names) 
{

   GFormulaTable& formulas = table.formulas;

#if defined(DEFINE_GRAMMAR_ETF_LL)

   stock_grammar = T_Stock::msETF_LL;

#elif defined(DEFINE_GRAMMAR_EXPR_LR)

   stock_grammar = T_Stock::msEXPR_LR;

#elif defined(DEFINE_GRAMMAR_ETF_LR)

   stock_grammar = T_Stock::msETF_LR;

#elif defined(DEFINE_GRAMMAR_EEE_LR)

   stock_grammar = T_Stock::msEEE;

#elif defined(DEFINE_GRAMMAR_EbEpE)

   stock_grammar = T_Stock::msEbEpE;

#elif defined(DEFINE_GRAMMAR_LL)
   stock_grammar = T_Stock::msLL; table.prefix = "LL_";
#elif defined(DEFINE_GRAMMAR_NL)
   stock_grammar = T_Stock::msNL; table.prefix = "NL_";
#elif defined(DEFINE_GRAMMAR_LR)
   stock_grammar = T_Stock::msLR; table.prefix = "LR_";
#elif defined(DEFINE_GRAMMAR_NR)
   stock_grammar = T_Stock::msNR; table.prefix = "NR_";
#endif
   stock_media = T_Stock::msMFormula;

   return table.count() != 0;
}
#pragma optimize("", on)

bool test()
{
   bool source_file = false;
#define TEXT_SOURCE_
#ifdef TEXT_SOURCE
//	T_Source source("i1 = i1[4] +=  1*(-(i12) + -i+3)*4+5*f(0.5-4.4)/(1.1 < i2++), ((i12)-- + -i+3)");
//	T_Source source("int i, j=i=12, arr[3];\n i = 5; j-=i++; arr[0]=2; arr[1]=arr[0]++; arr[2]=arr[0]+arr[1];");
//	T_Source source("int i,j,k=1; double i=j=k, f() { for(;;); } ;");
//	T_Source source("int a[]={10,11,12}; int b[2]={20,a[1]};");
//	T_Source source("int a[]={10,11,12}; int i=0, j; a[++i];");
//	T_Source source("int i,j=+--++i;"); // = 12 + 5 * 6, j = +i++; void f() { for (int i=0; i<4;i++) { int j; f(); break; continue; } }");
//	T_Source source("void f(int i) { i++; }; void main() { f(5.0); }");
//	T_Source source("static const int A[][3] = {{1,2,3},{4,5,6}}; int a[], i, b[7][8];");//int  g = 99; void u(); void f005() { int a[5]; a[1] = 1.2; }; int f() { return 12; }; void main005() { f005(); int i; i = g + 13; }");
//	T_Source source("int g = 99; void u(); void f() { int a[5]; a[1] = 1.2; }; int f() {}; void main() { f(); int i; i = g + 13; }");
//	T_Source source("int k; void f(int i, int j, int t) { if (!j) i++; else i--; int q,r,w,z; }; void main() { f(5,1,6); int w; }");
//	T_Source source("void f() { return; return 12; } int r() { return; return 1.2; }");
// T_Source source("void f() { if (12) 13; else 14; for(;;); for (int i=0; i<4; i++) {} }");
//	T_Source source("int  a[1], d[][3], c[11][22][33];");
//	T_Source source("void f() { int i=0,j=j; i=12; for(;j=i;1,2,3){} j+=i=i++; }");
//	T_Source source("void r() { return; } void f() { int i=0,j=i; L1:i=12; { int k; goto L15; L15: goto L2; } {{ int jjj; L2: ; }} }");
//	T_Source source("int i=(123 || 321,int((const int)12.2));");
//	T_Source source("void f() { int i; L1: L2: int g; goto L2; L3: L4:; }");
//	T_Source source("void r(int i, int j) { 1;2;3; 4,5,6; f(7,8); if (9,10) 11; else 12; for (21,22;23,24;25,26) {} }");
//	T_Source source("void f(int i, int j) { f(i=7-6,8+9); i=7-6; }");
// T_Source source("int a=33,b=33; int f(int i, int j) { int q,w,e,r; if (i) return 2.1; else { j = 13; return j; } } void f() {int aa=a,k,m; } ");
// T_Source source("void f008() { for (int i=0; i<4; i++) {} }"); // if (12) 13; else 14; for(;;); 
//	T_Source source("int j=5, a[3][4]; int i = a[2][3]; ");
//	T_Source source("int f(int a[3][4]=22, double b[][44]){int i=a[55][66]+b[77][88]+f(99,12.21); return i; };"); // int i = a[11,12 || 21,13][31,32,33 && 44]; ");
//	T_Source source("void i() { int i = (int(12 || 21,33,44)); for(4;7;9)11; do ; while(i>23); };");
//	T_Source source("void i() { int i = 11 || 12; 11 ? 12 || 21 : 22; };");
//	T_Source source("int i = (4 || 5) ? 6.3 : (7 && 8); ");
//	T_Source source("void f() { if ((11 || 1.2) && (13 || !21) && !(22 || 23)) 31; else 32; }");
// T_Source source("void f() { int i=12; i++; int &j = i; goto label; break; continue; return; return 123; {} { i = 24; } }");
// T_Source source("void f() { if (!(11 || 12)) 2+1; else 3-1; }");
// T_Source source("void f() { int i = (11 || 12); while (int j = 13) i++; }");
//	T_Source source("void f() { for (int i;33;i++) { continue; i--; break; i++; } }");
//	T_Source source("static const int A[][3] = {{1,2,3},{4,5,6}}; int a[], i, b[7][8]; void f() { } void F() { f(); } void main() { f(); F(); a[2,1] = 12; i = 33; i = i; } "); 
//	T_Source source("int a[] = { 11, 12.21,-55 }, b[2][3] = {{ 21, 22 }, { 31, 32 }};");
//	T_Source source("int a[1][1][1][1] = { 1111 };");
//	T_Source source("int a[] = { 21, 22 || 23 }, i = 12;");
// T_Source source("int i, k, t; void f() { for(;int k=87;); }"); //void f() { int i, a[5]; if (33); if(45) 57; else {} }
//	T_Source source("static const int A[][3] = {{1,2,3},{4,5,6}};");
//	T_Source source("int A[][3] = {1,2,3,4,5,6};");
//	T_Source source("int A[][3] = {{31,32},{43}};");
// T_Source source("void f() { if (111) -22; else 33; for (111;0;222)333; if (55) 66; }");
// T_Source source("void f(); void f() { for (;;222,333); } void v(int k=23, int m[]) { int i = 12; i+= 27; } void f(); ");
//	T_Source source("int a = 2, b = 3 + 6, c = a + b, A[a][b];");
//	T_Source source("i = (5 ? 6 : 7); ");//i = a[1][2] + f(6,7,8);");
// T_Source source("int i = (-double(5)+6.6)*(float)(8- -7); void f() { i++; }");
// T_Source source("int i = -7, d[3][4]; void f(int j) { i++; j--; d[3][2] = 32; }");
//	T_Source source("a[1]+b[22][33]+i-f()*ff(44)");
//	T_Source source("int i; double j; long k; i = (5); j = i + 5"); 
//	T_Source source("int static i[3] = {3,4,5} ,j=6,k[][4]={1,2,3,{4,5}{6,7,8}}; double d;"); // k = 5; d = j + k;");
//	T_Source source("int a[][2] = {{1,2},{3,(const int)4.5}}; double aa[2][1] = {23}; {} {int j; j++;}");
//	T_Source source("int A[3],AA[2][1]; void f() { int i = A[2] + AA[1][1]; }");
//	T_Source source("void f(int i, const double &d = 12.3) { {} i = 2; { d=2;i+=3;};} ");
//	T_Source source("- + --i++ + 5");//i = a[1][2] + f(6,7,8);");
//	T_Source source("void f(int i =23, int a[][2], int& b[][2] = a) { int a[][2]={{1,2},{3,4}}, &i = a[1,7][1]; }");
// T_Source source("int b[1][2]; void f(int a[][2] = b);");
// T_Source source("a[f(),-3];g(-1,+2);b[1][33],+2,(int)3,int(4),5;return;return 6;for(;;);while(7);do{}while(8);break;continue;goto l;"); //5+6*7;{;(8);}{};"); // id*id()+id[10]");
// T_Source source("if(1)i;else k; if(4)l; if(21) if(22) m; else n;");
// T_Source source("int a[][2][3], i[33] = {}, b[] = {1,2,3}, c[3][4] = {{1,2,3},2,{1,2}},i");
// T_Source source("int b[][2] = {{5,8},{1,3}};");
// T_Source source("void f(){ break; continue; goto l; return; return 99; if(77); if(55)66;else; }");
// T_Source source("int k(int i, int a[]=b); int a=8,j; void f(); int g(){do 23; while(32); while(45)54;}");
// T_Source source("3;continue; {4;break; goto l1; }{ return; } return 66;");//&&8,4,5,(55-3||3),-(int)(7*97,1.2);");
// T_Source source("int b[33], i = b[5]; int a[3][2]; void f(int i); void F(int i, int b[33]) { f(22); i = b[5]; }");
// T_Source source("void f(int i, double a[] = b, int c[][1], int d[1][2]); void F(int j = 12) { do; while(3); 5 + 6, 7 - 8; int i; i = 13; }"); // a[13] + A[14][15], i += +5 - f() + + F(1,2), 7+8*9/(3-4)");
// T_Source source("int  i=10, j, arr[3];void ffff() { i = 5; j-=i++; arr[0]=2; arr[1]=arr[0]++; arr[2]=arr[0]+arr[1];}");
// T_Source source("4+5+6*7*8");
   T_Source source("int a, b[] = {1,2,3}, B[a = 3] = {3,2,1}; static void f_s(int p = 33, int a[] = b) { static const int i = 12, k; int &j = i, &m; }");

// T_Source source(")i(+*()j+*)kl)(");

#else
	T_SourceFile source;
	if (!source.Open("text.cpp")) return false;
   source_file = true;
#endif
	
	print_source(source);
	source.Reset();

	TScanArray my_scan(&source);
//	T_Scan my_scan(&source);

#ifdef CSYNTAX
   CSyntax   parse(&my_scan);
	TSemantic semantic(&parse);
   parse.set_semantic(&semantic);
#endif
#ifdef TSYNTAX
	TSyntax   parse(&my_scan);
	TSemantic semantic(&parse);
#endif
#ifdef SYNTAX
	T_Syntax  parse(&my_scan);
#endif
#ifdef MSYNTAX
   TGrammar table;
	MSyntax  parse(&my_scan,&table);
	TSemantic semantic(&parse);
   parse.set_make_mode(parse.mmTree);
   table.makers = &GMakerTable::maker_table;
   parse.set_semantic(&semantic);
#endif
#ifdef RSYNTAX
   TGrammar  table;
   TRuleTable rules;
   bool ret = rules.make(&table);
   ret = ret && table.make(rules,&GMakerTable::maker_table);
   if (!ret) { return false; }
   table.print(0x00);
	R_Syntax  parse(&my_scan,&table);
	TSemantic semantic(&parse);
   TBaseType base_type;
//   parse.set_make_mode(parse.mmTree);
   TRule::Table.print();
#endif
#ifdef RULES
   TRuleNames names;
   TGrammar   table;
	GSyntax   parse(&my_scan,&table);
//	P_Syntax  parse(&my_scan,&table);
//	RSyntax   parse(&my_scan,&table);
   parse.syntax_mode = parse.smParseLR0;
   table.option = TGrammar::POption::opAssociation;
   int ret = false; //build_rules(rules,names,table.type,table.prefix) && rules.make(&table,names);
   if (!ret && (stock_grammar != T_Stock::msNone)) {
      ret = build_grammar(table, stock_grammar | ((stock_media != T_Stock::msNone) ? stock_media : T_Stock::msMFormula), 0x02);
   }
   if (!ret) { return false; }

	TSemantic semantic(&parse);
   TData     data(&table, &parse, &semantic); parse.data = &data;
             data.LLTable = &table.Mtable; data.LRTable = &table.LRtable; data.formulas = &table.formulas;
             parse.syntax_lexeme = T_SyntaxLexeme(table.type | T_SyntaxLexeme::slPriorAssign | T_SyntaxLexeme::mtTurn);
   parse.set_semantic(&semantic);
   parse.set_make_mode(parse.mmTree);
//   parse.syntax_mode = parse.smParseFormula;
#endif
   parse.option = 0;
	parse.option |= 0x0008; // lexeme
//   parse.option |= 0x0010; // print_tree
   parse.option |= 0x0020; // erase_code
//   parse.option |= 0x40; // print_code
   parse.option |= 0x0100; // print_rule
   parse.option |= 0x0200; // print_maker
   parse.option |= 0x0400; // print_stack
   parse.option |= 0x1000; // print_SNode
   parse.option = 0x0820;
	parse.line_is_space = true;
	
	source.Reset();
//	scan_source(scan);
/* */
	parse.Reset();
#if defined(TSYNTAX) || defined(CSYNTAX) || defined(MSYNTAX) || defined(RULES)
   T_Lexeme::print_scan = &my_scan;
   TBaseType base_type;
   bool gut = semantic.Translate();
   if (gut) {
//   	parse.FuncTable.print();
      if (parse.option & T_OptionMode::omPrintSemantic) semantic.print_tree("Semantic ");
      if ((parse.option & T_OptionMode::omPrintSNode) && parse.tree) { // print_SNode
         parse.tree->print(0x00);
      }
   	semantic.BlockTable.print();
   	semantic.IdentTable.print();
   	semantic.CodeTable.print(0x0800);
   	semantic.syntax->ErrorTable.print();
      semantic.UserLabelTable.print();
      semantic.UserGoToTable.print();
//    semantic.GarbageTable.print();
      }
//   parse.clear(parse.Program());
#else
   bool gut = parse.Translate();
   if (gut) {
      semantic.print();
      }
#endif
   if (parse.option & T_OptionMode::omPrintLexeme) { // Lexeme
      while (parse.CountLexemes()) {
         T_Lexeme lexeme = parse.PopLexeme();
   		lexeme.print(&parse.Scan());
      }
   }
   if (parse.option & T_OptionMode::omPrintSNode) { // print_SNode
      while (parse.CountSNodes()) {
         SNode* node = parse.SPop();
         node->print(0x00);
      }
   }
   parse.print_store(stdout);
   if (gut) {
      printf("\ntrue\n");
   } else {
		printf("\nfalse\n");
   }
   parse.forward.print(&my_scan);
   if (source_file) fclose(source.file);

	return true;
}

void test_formulas(int mode)
{
#ifdef RULES
   TGrammar table;
   TRuleNames names;
   int ret = build_formulas(table,names) && table.formulas.make(names,table.lexemes);
   if (!ret && (stock_grammar != T_Stock::msNone)) {
      ret = build_grammar(table, stock_grammar | ((stock_media != T_Stock::msNone) ? stock_media : T_Stock::msMFormula), !mode ? 0x02 : 0x00);
   }
   if (ret) {
//      table.print("table_formula_", 0x03);
      switch (mode) {
      case 0x00: {
         table.lexemes.print(0x00);
         table.make(&GMakerTable::maker_table);
         break;
      }
      case 0x01: {
         table.Used();
         int filter = 0;
         table.filter_makers(filter);
         table.make_FIRST_ks(2);
         break;
      }
      default:
         break;
      }
   }
//   table.MACRO("rule_def.txt",T_PrintMode::pmMacroMode);
//   table.print(NULL,0x01);
#endif
   return;
}

#include "SQLReserv.h"
#include "SQLReserv.cpp"

static T_WordTable sqlReserv[300];

class SQLGrammarSyntax : public GrammarSyntax
{
public:
   SQLGrammarSyntax(T_Scan *s, TGrammar* g) :GrammarSyntax(s, g) {}
public:
   virtual void LexemeToSymbol(T_Lexeme& lexeme, GSymbol& sym);
   void SQL(T_SyntaxNode* unit);
   void Push(GFormula* f) { stack.push(f); }
   GFormula* Pop() { GFormula* f = stack.top(); stack.pop(); return f; }
   GFormula* Top() { return stack.top(); }
   void AddItem(const GSymbol &sym) { Top()->back() << sym; }
   void beg_or_list();
   void end_or_list();
public:
   TGrammar sql_table;
   std::stack<GFormula*> stack;
};

void SQLGrammarSyntax::LexemeToSymbol(T_Lexeme& lexeme, GSymbol& current_sym)
{
   current_sym = GSymbol(lexeme);
   if (state == T_State::tsSQLProduce) {
      if ((lexeme.Match(A_Symbol::lxLeftCramp)) || (lexeme.Match(A_Symbol::lxRightCramp))) {
         current_sym.group = T_Lexeme::grMeta;
      } else if ((lexeme.Match(A_Symbol::lxLeftScrape)) || (lexeme.Match(A_Symbol::lxRightScrape))) {
         current_sym.group = T_Lexeme::grMeta;
      } else if (lexeme.Match(A_Symbol::lxOr) || lexeme.Match(A_Symbol::lxBNFSet) || lexeme.Match(A_Symbol::lxEllipsis) || lexeme.Match(A_Symbol::lxSemicolon)) {
         current_sym.group = T_Lexeme::grMeta;
      } else {
         current_sym.group = T_Lexeme::grSpace; current_sym.lexeme_type = 0;
      }
   }
}

enum T_SQL { S_, rules, rule, item_list, item, or_list };

void SQLGrammarSyntax::beg_or_list()
{
   GFormula* formula = new GFormula();
   GProduce prod(GSymbol(GSymbol::gsProduce, formula->head.formula, formula->count()));
   formula->Add(prod);
   Push(formula);
}

void SQLGrammarSyntax::end_or_list()
{
   GFormula* formula = Pop();
   if (formula->count() == 1) {
      Top()->back() << formula->front();
      formula->clear();
//      delete formula;
   } else {
      formula->head.formula = sql_table.count();
      sql_table.formulas.push_back(formula);
      for (GProduce& p : *formula) {
         p.head.formula = formula->head.formula;
      }
      Top()->back() << formula->head;
   }
}

void SQLGrammarSyntax::SQL(T_SyntaxNode* unit)
{
   TProduceNode* produce = (TProduceNode*)unit;
   SNode* node = NULL;
   switch (unit->symbol.formula) {
   case T_SQL::S_: {
      SQL(produce->Get(0));
      } break;
   case T_SQL::rules: {
      if (unit->symbol.produce == 0) {
         SQL(produce->Get(0)); // rules
         SQL(produce->Get(1)); // rule
      } else if (unit->symbol.produce == 1) {
         SQL(produce->Get(0)); // rule
      }
      } break;
   case T_SQL::rule: { // <Space> ::= item_list ;
      T_SyntaxNode* ident_unit = produce->Get(0);
      if (ident_unit->symbol.IsTerminal() && (ident_unit->symbol.group == T_Lexeme::grIdent)) {
         T_Lexeme& lexeme = ((TLexemeNode*)ident_unit)->lexeme;
         GFormula* formula = sql_table.FindFormula(lexeme.Text());
         if (!formula) {
            formula = sql_table.AddFormula(lexeme.Text());
            GProduce prod(GSymbol(GSymbol::gsProduce, formula->head.formula));
            formula->Add(prod);
            Push(formula);
            TProduceNode* item_list = (TProduceNode*)produce->Get(2);
            SQL(item_list);
            Pop();
         }
         lexeme.print(NULL, 0, stdout);
         fprintf(stdout, "\n");
      }
      } break;
   case T_SQL::item_list: {
      if (unit->symbol.produce == 0) {        // item_list item
         SQL(produce->Get(0)); // item_list
         SQL(produce->Get(1)); // item
      } else if (unit->symbol.produce == 1) { // item_list symbol
         SQL(produce->Get(0)); // item_list
         T_SyntaxNode* symbol_unit = produce->Get(1); // symbol
         AddItem(symbol_unit->symbol);
      } else if (unit->symbol.produce == 2) { // item
         SQL(produce->Get(0)); // item
      } else if (unit->symbol.produce == 3) { // symbol
         T_SyntaxNode* symbol_unit = produce->Get(0);
         AddItem(symbol_unit->symbol);
      }
      } break;
   case T_SQL::item: {
      if (unit->symbol.produce == 0) {        // [ or_list ]
         GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula, sql_table.count()));
         sql_table.formulas.push_back(formula);
         GProduce prod(GSymbol(GSymbol::gsProduce, formula->head.formula, formula->count()));
         formula->Add(prod);
         Push(formula);
         beg_or_list();
         SQL(produce->Get(1)); // or_list
         end_or_list();
         Pop();
         prod.head.produce++;
         formula->Add(prod);
         AddItem(formula->head);
      } else if (unit->symbol.produce == 1) { // [ or_list ]...
         GFormula* formula = new GFormula(GSymbol(GSymbol::gsFormula, sql_table.count()));
         sql_table.formulas.push_back(formula);
         GProduce prod(GSymbol(GSymbol::gsProduce, formula->head.formula, formula->count()));
         prod << formula->head;
         formula->Add(prod);
         Push(formula);
         beg_or_list();
         SQL(produce->Get(1)); // or_list
         end_or_list();
         Pop();
         prod.clear();
         prod.head.produce++;
         formula->Add(prod);
         AddItem(formula->head);
      } else if (unit->symbol.produce == 2) { // { or_list }
         beg_or_list();
         SQL(produce->Get(1)); // or_list
         end_or_list();
      }
      } break;
   case T_SQL::or_list: {
      if (unit->symbol.produce == 0) {        // or_list | item_list
         SQL(produce->Get(0)); // or_list
         GFormula* formula = Top();
         GProduce prod(GSymbol(GSymbol::gsProduce, formula->head.formula, formula->count()));
         formula->Add(prod);
         SQL(produce->Get(2)); // item_list
      } else if (unit->symbol.produce == 1) { // item_list
         SQL(produce->Get(0)); // item_list
      }
      } break;
   }
}

bool gif_to_sql_bnf()
{
   const char *file = "..\\SQL\\ETF.txt"; const char *table_file = "..\\SQL\\sql.tab";
   MakeSQLWordTable(sqlReserv);

   T_SourceFile source;

//   print_source(source);
//   source.Reset();

   TScanArray my_scan(&source);

   TRuleNames names;
   TGrammar   table;
   SQLGrammarSyntax parse(&my_scan, &table);
   parse.syntax_mode = parse.smParseLR0;
   table.option = TGrammar::POption::opNone;

   TSemantic semantic(&parse);
   TData     data(&table, &parse, &semantic); parse.data = &data; data.makers = &GMakerTable::maker_table;
   data.file = file;

   int table_type;
   A_Syntax::T_SyntaxMode syntax_type;
   if (!table.read(table_file, table_type, 0x00)) return false;

   if (table_type & T_Grammar::gtLL) {
      table.Mtable.print(NULL, 0x00);
      syntax_type = A_Syntax::smParseLL1;
   }
   if (table_type & T_Grammar::gtLR) {
      table.LRtable.print(NULL, 0x00);
      syntax_type = A_Syntax::smParseLR0;
   }
   table.print(NULL, 0x00);

   parse.syntax_lexeme = T_SyntaxLexeme::slNone;
   parse.state = parse.T_State::tsSQLProduce;
   parse.Mask(A_Symbol::M_Mask(A_Symbol::mmGrammar | A_Symbol::mmSQL));
   parse.WordTable(sqlReserv);
   parse.set_semantic(&semantic);
   parse.set_make_mode(parse.mmNone);
   parse.look_ahead = table.look_ahead;

   parse.option = 0;
   parse.option |= 0x0008; // lexeme
   parse.option |= 0x0010; // print_tree
   parse.option |= 0x0020; // erase_code
   parse.option |= 0x0040; // print_code
   parse.option |= 0x0100; // print_rule
   parse.option |= 0x0200; // print_maker
   parse.option |= 0x0400; // print_stack
   parse.option |= 0x1000; // print_SNode
//   parse.option  = 0x0000;
   parse.option |= T_OptionMode::omAutoTree;
   parse.option |= T_OptionMode::omPrintTree;
//   parse.option |= T_OptionMode::omTrimUnit;
   parse.line_is_space = true;

   if (!parse.Source(source, file, sqlReserv)) return false;
   source.Reset();
   parse.Reset();

   T_Lexeme::print_scan = &my_scan;
   TBaseType base_type;
   bool gut = semantic.Translate();
   if (parse.option & T_OptionMode::omTrimUnit) {
      parse.unit.trim();
   }

   if (parse.Auto()->root) {
      parse.SQL(parse.Auto()->root);
   }
   semantic.Result(file);

   int opton = T_PrintMode::pmGrammar | T_PrintMode::pmCompactGroup | T_PrintMode::pmBNF;
   char *file_table = get_file_name(file, "table");
   parse.sql_table.print(file_table, opton);
   free(file_table);

   return gut;
}

// ..\Release64\TableBuilder.exe 0x020B08 0x000B1801 SQLGrammar.tab SQLGrammar.bnf

extern bool grammar_reception(TGrammar& table, int type, int option, const char *file, const char *table_file, const T_WordTable* word_table = &T_KeyWordTable::key_word_table);

void make_sql_bnf()
{
   int type = 0x020B08, option = 0x000B1840;
   option |= TGrammar::POption::opGrammar;
//   const char *file = "..\\SQL\\SQLGrammar.tab"; const char *table_file = "..\\SQL\\SQLGrammar.bnf";
   const char *file = "..\\SQL\\ETF.tab"; const char *table_file = "..\\SQL\\ETF.table";

   M_Syntax::M_Mode make_mode = M_Syntax::M_Mode((type & 0x0F0) >> 4);
   A_Syntax::T_SyntaxMode syntax_mode = A_Syntax::T_SyntaxMode(type & 0x00F);
   int look_ahead = (type & 0x000F0000) >> 16;

   if ((syntax_mode == A_Syntax::T_SyntaxMode::smParseYACC) || (look_ahead > 1)) {
      option |= TGrammar::POption::opNoPriorAssign;
   }

   TGrammar table;
   TNameTable names; table.names = &names;
   MakeSQLWordTable(sqlReserv);
   if (!grammar_reception(table, type, option, file, table_file, sqlReserv)) return;

   table.Make(type, syntax_mode, make_mode, file);

}

void test_grammar(int k);
void token();

int _tmain(int argc, _TCHAR* argv[])
{
   TInHelp in_help(TInHelp::None);
//   test();
//   test_formulas(0x01);
//   token();
//   test_grammar(2);
//   printf("\n%s", gif_to_sql_bnf() ? "true" : "false");
   make_sql_bnf();

   printf("\n");
	return 0;
}

#define TOKEN_WORD(C,T)      { int t = T_Lexeme::T_Group::grReserv << 8 | T_Lexeme::W_Type::rw##T;    printf("\n%%token %-20s %5d // %04X",#C,t,t); }
#define TOKEN_OPER(C,T)      { int t = T_Lexeme::T_Group::grOper << 8 | A_Symbol::T_Type::lx##T;      printf("\n%%token %-20s %5d // %04X",#C,t,t); }
#define TOKEN_SEPORATOR(C,T) { int t = T_Lexeme::T_Group::grSeparator << 8 | A_Symbol::T_Type::lx##T; printf("\n%%token %-20s %5d // %04X",#C,t,t); }
#define TOKEN_LEXEME(C,G,T)  { int t = T_Lexeme::T_Group::gr##G << 8 | T;                             printf("\n%%token %-20s %5d // %04X",#C,t,t); }

void token()
{

TOKEN_LEXEME(IDENTIFIER    ,Ident        ,0        )
TOKEN_LEXEME(CONSTANT      ,Integer      ,0        )
TOKEN_LEXEME(STRING_LITERAL,String       ,0        )

TOKEN_OPER(INC_OP        ,PlusPlus    ) 
TOKEN_OPER(DEC_OP        ,MinusMinus  ) 
TOKEN_OPER(LEFT_OP       ,LShift      ) 
TOKEN_OPER(RIGHT_OP      ,RShift      ) 
TOKEN_OPER(LE_OP         ,LE          ) 
TOKEN_OPER(GE_OP         ,GE          ) 
TOKEN_OPER(EQ_OP         ,Equ         ) 
TOKEN_OPER(NE_OP         ,NotEqu      ) 
TOKEN_OPER(AND_OP        ,AndAnd      ) 
TOKEN_OPER(OR_OP         ,OrOr        ) 
TOKEN_OPER(MUL_ASSIGN    ,MultiAssign ) 
TOKEN_OPER(DIV_ASSIGN    ,DivAssign   ) 
TOKEN_OPER(MOD_ASSIGN    ,ModAssign   ) 
TOKEN_OPER(ADD_ASSIGN    ,AddAssign   ) 
TOKEN_OPER(SUB_ASSIGN    ,SubAssign   ) 
TOKEN_OPER(LEFT_ASSIGN   ,LShiftAssign) 
TOKEN_OPER(RIGHT_ASSIGN  ,RShiftAssign) 
TOKEN_OPER(AND_ASSIGN    ,AndAssign   ) 
TOKEN_OPER(XOR_ASSIGN    ,XOrAssign   ) 
TOKEN_OPER(OR_ASSIGN     ,OrAssign    ) 

TOKEN_SEPORATOR(ELLIPSIS ,Ellipsis    )
TOKEN_SEPORATOR(PTR_OP   ,Pointer     )
                                      
TOKEN_WORD(TYPEDEF       ,Typedef     )
TOKEN_WORD(EXTERN        ,Extern      )
TOKEN_WORD(STATIC        ,Static      )
TOKEN_WORD(AUTO          ,Auto        )
TOKEN_WORD(REGISTER      ,Register    )
TOKEN_WORD(CHAR          ,Char        )
TOKEN_WORD(SHORT         ,Short       )
TOKEN_WORD(INT           ,Int         )
TOKEN_WORD(LONG          ,Long        )
TOKEN_WORD(SIGNED        ,Signed      )
TOKEN_WORD(UNSIGNED      ,Unsigned    )
TOKEN_WORD(FLOAT         ,Float       )
TOKEN_WORD(DOUBLE        ,Double      )
TOKEN_WORD(CONST         ,Const       )
TOKEN_WORD(VOLATILE      ,Volatile    )
TOKEN_WORD(VOID          ,Void        )
TOKEN_WORD(STRUCT        ,Struct      )
TOKEN_WORD(UNION         ,Union       )
TOKEN_WORD(ENUM          ,Enum        )
TOKEN_WORD(SIZEOF        ,Sizeof      )
TOKEN_WORD(CASE          ,Case        )
TOKEN_WORD(DEFAULT       ,Default     )
TOKEN_WORD(IF            ,If          )
TOKEN_WORD(ELSE          ,Else        )
TOKEN_WORD(SWITCH        ,Switch      )
TOKEN_WORD(WHILE         ,While       )
TOKEN_WORD(DO            ,Do          )
TOKEN_WORD(FOR           ,For         )
TOKEN_WORD(GOTO          ,GoTo        )
TOKEN_WORD(CONTINUE      ,Continue    )
TOKEN_WORD(BREAK         ,Break       )
TOKEN_WORD(RETURN        ,Return      )
                                      
TOKEN_WORD(TYPE_NAME     ,Define      )

}

void test_cpp()
{
/*
   int i = 0; do ; while(i);
   int i; i = (int const) 12.3 + (int const(32.4) + 13);
   int aa[3] = {}; int i = aa[3,2,1];
   int i = 0; ++ -- ++ i; 
   i ++;

   int i = 5 + (1,fv(),3); i = int (4.4) + (const int (3.3));
   return 1 == 0;
   int i = 0;
   {
   int i = i + 5;
   }

   int i = 0; i = (int)i+=12; i = int(i=12); i = (int)f()+i+13;

   int i = 12;

   if (int jj = 12) int i = 13 + jj; else int i = 14 - jj;

   switch (i = 14, 12, i) {
      case 1: int m = i;
   }

   switch (int j = 15) {
      case 1: int m = j;
   }

   while (int j = 14) {
      int m = j;
   }
   int a[2] = { 1, 2 };
   for (int i=0, j = 12; int k = a[1]; j = 0, k = i++) {}
   int b[2] = {};
   while (1,2,3);
*/
}

/*
int const &ff();;;;
int aa = 5 + aa;
void ff(int e[] = a) {};
int f() { int i = 0; int j = -- ++ -- i; double d = 0.0, n = !d; int k = !d; return 10;}
void w(int i) {}
void v(const short &s) { w(s); int ii = (const int)s + int(s); } 

int a[3] = { 1, a[2] }, b[2][2] = {{1,2},{}};
static const int A[][3] = {{1,2,3},{4,5,6}};
int b2[3][2] = { {1,2}, {3,4}, {5} };

void g() { int i = 0; goto l1; { l0:i++; l4: int y = 0; y++; goto l4; } for (int i = 0;;) { int j = 0; l1:i=0, 12; goto l0;} }

int j = 12;
void f(const int &i = j) { int k = i; j++; int m = i; }

int i = (1,2,3);

*/

// TranSyntax.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Parse.h"
#include "ASyntax.h"
#include "Syntax.h"
#include "CSyntax.h"
#include "TSyntax.h"
#include "MSyntax.h"
#include "TSemantic.h"
#include "Grammar.h"
#include "InHelp.h"

// --------------------------- main ---------------------------

char* get_file_name(const char*file, const char* ext);

enum TYPE_SYNTAX { NONE, SYNTAX, TSYNTAX, CSYNTAX, MSYNTAX_T, MSYNTAX_C };

bool test(TYPE_SYNTAX syntax_type, int option, const char *file)
{
	T_SourceFile source;

	TSemantic semantic(NULL);
   TGrammar  table;
   TBaseType base_type;

	TScanArray scan(&source);
	T_Syntax   tparse(&scan);
	CSyntax   c_parse(&scan);
	TSyntax   t_parse(&scan);
	MSyntax   m_parse(&scan,&table);
   A_Syntax* parse = NULL;

   switch (syntax_type) {
   case SYNTAX : 
      parse = &tparse;
      break;
   case TSYNTAX : 
      parse = &t_parse;
      break;
   case CSYNTAX : 
      parse = &c_parse;
      c_parse.set_semantic(&semantic);
      break;
   case MSYNTAX_T : 
   case MSYNTAX_C : 
      parse = &m_parse;
      m_parse.set_semantic(&semantic);
      m_parse.set_make_mode((syntax_type == MSYNTAX_T) ? m_parse.mmTree : m_parse.mmCode);
      table.makers = &GMakerTable::maker_table;
      break;
   default : 
      parse = &tparse;
      break;
   }

	parse->option = option;
	parse->line_is_space = true;
   semantic.syntax = parse;
   if (!parse->Source(source,file)) return false;

// 0x0001 - other,      0x0002 - space,      0x0004 - line,       0x0008 - eof, 
// 0x0010 - print_tree, 0x0020 - erase_code, 0x0040 - print_code, 0x0080 - print_operator, 
// 0x0100 - print_rule, 0x0200 - print_maker,0x0400 - print_stack,0x0800 - print_Code 
	
   TData      data(&table, parse, &semantic); data.makers = &GMakerTable::maker_table;
   data.file = file;

   bool gut = semantic.Translate();

   semantic.Result(file);

   parse->print_store(stdout);
	if (gut)  
		printf("\ntrue\n");
   else
		printf("\nfalse\n");
	parse->Cur().print(&scan);

	return true;
}

int main(int argc, const char* argv[])
{
   TInHelp in_help(TInHelp::Syntax);
   in_help.type = MSYNTAX_C;
//   in_help.file = "Class_02_ERROR.c";
   in_help.file = "text.cpp";
   in_help.option = 0x0830;
   in_help.option |= T_OptionMode::omAtOnce;
   in_help.option |= T_OptionMode::omPrintSyntax;
   in_help.option |= T_OptionMode::omPrintSemantic;

//   in_help.option |= T_OptionMode::omQuadruple;
//   TranSyntax.exe 2 0830 Example_09.cpp
//   in_help.type = TSYNTAX;
   in_help.file = "test_L.cpp";
   in_help.type = MSYNTAX_T;

//   if (!in_help.input(argc,argv)) return 0;
   test((TYPE_SYNTAX)in_help.type, in_help.option, in_help.file);

	return 0;
}
// TranYACC.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "Parse.h"
#include "ASyntax.h"
#include "TSemantic.h"
#include "Maker.h"
#include "InHelp.h"
#include "Grammar.h"

// --------------------------- PSyntax ---------------------------
#include "PSyntax.h"

#define MAKE_(FUNC,P,M)   {static GSymbol maker(GSymbol::gsMaker,GMakerTable::maker_table.Find(#FUNC),P,0,M);\
                           if (!Maker(maker)) return false; }
#define MAKE(FUNC)         MAKE_(FUNC,0,GSymbol::Tree | GSymbol::Code)
#define MAKE_TREE(FUNC)    MAKE_(FUNC,0,GSymbol::Tree);
#define MAKE_CODE(FUNC)    MAKE_(FUNC,0,GSymbol::Code);
#define PARAM(FUNC,P)      MAKE_(FUNC,P,GSymbol::Tree | GSymbol::Code) 
#define PARAM_TREE(FUNC,P) MAKE_(FUNC,P,GSymbol::Tree) 
#define PARAM_CODE(FUNC,P) MAKE_(FUNC,P,GSymbol::Code) 

namespace LL_TC_PROG {
#include "LL_TC_PROG.h"
#include "LL_TC_PROG.cpp"
}

namespace NL_TC_PROG {
#include "NL_TC_PROG.h"
#include "NL_TC_PROG.cpp"
}

namespace ETF_LL_TC_PROG {
#include "ETF_LL_TC_PROG.h"
#include "ETF_LL_TC_PROG.cpp"
}

// --------------------------- GSyntax ---------------------------
#include "GSyntax.h"

#pragma optimize("", off)
namespace LL_TC_LL1 {
#include "LL_TC_LL1.cpp"
}

namespace LR_UR_LR0 {
#include "LR_UR_LR0.cpp"
}

namespace NR_SN_LALR {
#include "NR_SN_LALR.cpp"
}
#pragma optimize("", on)

#pragma warning( disable : 4065 )
// --------------------------- YSyntax ---------------------------
#include "YSyntax.h"

int yylex (void *yylval, void *param);
void yyerror(const char* mess);

#define yy_tc_lex yylex
#define yy_tc_error yyerror

#include "UndefYACC.cpp"
namespace LL_TC {
#include "LL_TC_YACC.tab.c"
}

#include "UndefYACC.cpp"
namespace LR_TC {
#include "LR_TC_YACC.tab.c"
}

#include "UndefYACC.cpp"
namespace NR_TC {
#include "NR_TC_YACC.tab.c"
}

#define yy_sn_lex yylex
#define yy_sn_error yyerror

#include "UndefYACC.cpp"
namespace NR_SN {
#include "NR_SN_YACC.tab.c"
}

#define CHAR_LEX(G,T,S)  case (T_Lexeme::gr##G << 8) | T_Symbol::lx##T : return S;

#define yy_C_lex   yylex
#define yy_C_error yyerror

#include "UndefYACC.cpp"
namespace C_Grammar {
#include "C_Grammar.tab.cpp"
}

static void test_yacc(int type, int option, YSyntax& parse, TGrammar& table)
{
   M_Syntax::M_Mode make_mode = M_Syntax::M_Mode((type & 0x0F0) >> 4);
   A_Syntax::T_SyntaxMode syntax_mode = A_Syntax::T_SyntaxMode(type & 0x00F);
   int def_rule_mode = ((type & 0xF00) >> 8); // 0 - LL, 1 - NL, 2 - LR, 3 - NR
   bool print_rule = (option & T_OptionMode::omPrintRule) != 0;

   if (def_rule_mode == 0x00) {
      table.type = T_Grammar::gtLL; table.prefix = "LL_";
      parse.syntax_lexeme = T_SyntaxLexeme(table.type | T_SyntaxLexeme::slPrior | T_SyntaxLexeme::slSyntax);
      if ((make_mode == M_Syntax::mmTree) || (make_mode == M_Syntax::mmCode)) {
         parse.yy_parse = LL_TC::yy_tc_parse;
         if (print_rule) { 
            LL_TC::yy_tc_debug = 1; 
         }
      }
   } else if (def_rule_mode == 0x02) {
      table.type = T_Grammar::gtLR; table.prefix = "LR_";
      parse.syntax_lexeme = T_SyntaxLexeme(table.type | T_SyntaxLexeme::slPrior | T_SyntaxLexeme::slSyntax);
      if ((make_mode == M_Syntax::mmTree) || (make_mode == M_Syntax::mmCode)) {
         parse.yy_parse = LR_TC::yy_tc_parse;
         if (print_rule) { 
            LR_TC::yy_tc_debug = 1; 
         }
      }
   } else if (def_rule_mode == 0x03) {
      table.type = T_Grammar::gtLR; table.prefix = "NR_";
      parse.syntax_lexeme = T_SyntaxLexeme(table.type);
      if ((make_mode == M_Syntax::mmTree) || (make_mode == M_Syntax::mmCode)) {
         parse.yy_parse = NR_TC::yy_tc_parse;
         if (print_rule) { 
            NR_TC::yy_tc_debug = 1; 
         }
      } else if ((make_mode == M_Syntax::mmNode) || (make_mode == M_Syntax::mmMade)) {
         parse.yy_parse = NR_SN::yy_sn_parse;
         if (print_rule) { 
            NR_SN::yy_sn_debug = 1; 
         }
      } else if (make_mode == M_Syntax::mmNone) {
         parse.yy_parse = NR_TC::yy_tc_parse;
         if (print_rule) { 
            NR_TC::yy_tc_debug = 1; 
         }
      }
   } else if (def_rule_mode == 0x0C) {
      table.type = T_Grammar::gtLR; table.prefix = "C_";
      parse.syntax_lexeme = T_SyntaxLexeme(table.type | T_SyntaxLexeme::slNoDefType);
      if (make_mode == M_Syntax::mmTree) {
         parse.yy_parse = C_Grammar::yy_C_parse;
         if (print_rule) { 
            C_Grammar::yy_C_debug = 1; 
         }
      }
   }
}

char* get_file_name(const char*file, const char* ext);

bool test(int type, int option, const char *file)
{
   M_Syntax::M_Mode make_mode = M_Syntax::M_Mode((type & 0x0F0) >> 4);
   A_Syntax::T_SyntaxMode syntax_mode = A_Syntax::T_SyntaxMode(type & 0x00F);
   int def_rule_mode = ((type & 0xF00) >> 8); // 0 - LL, 1 - NL, 2 - LR, 3 - NR

   T_SourceFile source;

   TGrammar   table;
   TBaseType  base_type;

	TScanArray scan(&source);

	YSyntax             parse_Y(&scan,&table);
   C_GrammarYSyntax    parse_C(&scan,&table);

   GSyntax             parse_G(&scan,&table);

   LL_TC_PROG::PSyntax     parse_LL(&scan,&table);
   NL_TC_PROG::PSyntax     parse_NL(&scan,&table);
   ETF_LL_TC_PROG::PSyntax parse_ETF_LL(&scan,&table);

   MC_Syntax* parse = NULL;
   YSyntax*   parse_YACC = NULL;

   if (syntax_mode == A_Syntax::smParseYACC) { // YACC
      if (def_rule_mode == 0x0C) {
        parse = parse_YACC = &parse_C;
        parse_C.Mask(A_Symbol::mmC);
      } else {
        parse = parse_YACC = &parse_Y;
      }
      test_yacc(type, option, *parse_YACC, table);
   } else if (syntax_mode == A_Syntax::smParseFormula) { // PROG
      if (def_rule_mode == 0x00) {
         parse = &parse_LL;
         table.type = T_Grammar::gtLL; table.prefix = "LL_";
         parse->syntax_lexeme = T_SyntaxLexeme::slSyntax;
      } else if (def_rule_mode == 0x01) {
         parse = &parse_NL;
         table.type = T_Grammar::gtLL; table.prefix = "NL_";
         parse->syntax_lexeme = T_SyntaxLexeme::slNone;
      } else if (def_rule_mode == 0x05) {
         parse = &parse_ETF_LL;
         table.type = T_Grammar::gtLL; table.prefix = "ETF_LL_";
         parse->syntax_lexeme = T_SyntaxLexeme::slNone;
      }
   } else if (syntax_mode == A_Syntax::smParseRule) { // Table
      void (*make_grammar)(TGrammar& grammar) = NULL;
      if (def_rule_mode == 0x00) {
         parse = &parse_G; make_grammar = LL_TC_LL1::make_grammar;
         table.prefix = "LL_";
         syntax_mode = A_Syntax::smParseLL1;
      } else if (def_rule_mode == 0x02) {
         parse = &parse_G; make_grammar = LR_UR_LR0::make_grammar;
         table.prefix = "LR_";
         syntax_mode = A_Syntax::smParseLR0;
      } else if (def_rule_mode == 0x03) {
         parse = &parse_G; make_grammar = NR_SN_LALR::make_grammar;
         table.prefix = "NR_";
         syntax_mode = A_Syntax::smParseLR0;
      }
      if (make_grammar != NULL) {
         make_grammar(table);
         parse->syntax_lexeme = table.type;
         table.Used();
      }
   }
   if (!parse) return false;
	parse->option = option;
	parse->line_is_space = true;
   if (!parse->Source(source,file)) return false;

	TSemantic  semantic(parse);

   TData      data(&table, parse, &semantic); data.makers = &GMakerTable::maker_table;
              data.file = file;

   parse->set_make_mode(make_mode);
   parse->set_semantic(&semantic);
   parse->syntax_mode = syntax_mode;

// 0x0001 - other,      0x0002 - space,      0x0004 - line,       0x0008 - Lexeme, 
// 0x0010 - print_tree, 0x0020 - erase_code, 0x0040 - print_code, 0x0080 - print_operator, 
// 0x0100 - print_rule, 0x0200 - print_maker,0x0400 - print_stack,0x0800 - print_Code,
// 0x1000 - print_SNode

   bool gut = (parse != NULL) && semantic.Translate();

   semantic.Result(file);

   parse->print_store(stdout);
	if (gut)  
		printf("\ntrue\n");
   else
		printf("\nfalse\n");
	parse->Cur().print(&scan);

	return true;
}

int main(int argc, const char* argv[])
{
   TInHelp in_help(TInHelp::YACC);
   in_help.type = 0x0C1E; // C_Grammar, Tree, YACC
//   in_help.type = 0x0243; // LL, Code, PROG
//   TranYACC.exe 01E 0838 text.cpp
   in_help.file = "text.cpp";
   in_help.option = 0x0838;
   in_help.type = 0x001E;

   if (!in_help.input(argc,argv)) return 0;
   test(in_help.type, in_help.option, in_help.file);

	return 0;
}
// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "TSemantic.h"
#include "RSyntax.h"
#include "SNodes.h"
#include "Maker.h"

// --------------------------- TSemantic---------------------------

TOperTable& OperTable() 
{ 
   static TOperTable *table = NULL; if (!table) table = new TOperTable(); return *table; 
}

TSemantic::TSemantic(A_Syntax *s) : syntax(s), ExecStack(), function(NULL),
   IdentTable(this), BlockTable(this), FuncTable(this), CodeTable(this),
   UserLabelTable(this), UserGoToTable(this), level(0), print_mode(0), block_number(0),
   AddInt(0), MultiInt(0), code_count(0), quad_count(0)
{
   OperTable();
   MakeOperTable();
}

T_Alloc TSemantic::Alloc() const
{
   if (BlockTable.size() == 1) return T_Alloc::taGlobal;
   const TBlock* block = BlockTable.Block();
   if (block->type == tbFunc) return T_Alloc::taParam;
   return T_Alloc::taLocal;
}

int TSemantic::AddDef(TNodeDefVar* var)
{
   TBlock* block = BlockTable.Block();
   if (!block) {
      return 0;
   }
   var->alloc = Alloc();
   const T_Lexeme& lexeme = var->Lexeme();
   if (lexeme.len) {
      TNodeDefVar* old = FindIdent(lexeme);
      if (old && (old->alloc == var->alloc) && (old->offset >= block->offset)) {
         AddError(var,erDuplicateIdent);
      }
   }
   IdentTable.Add(var);
   block->size++;
   return 0;
}

TNodeDefVar* TSemantic::GetDef()
{
   return (IdentTable.empty()) ? NULL : IdentTable.back();
}

TNodeDefVar* TSemantic::FindIdent(const T_Lexeme &l) const
{
   return IdentTable.find(l);
}

int TSemantic::AddFunc(TNodeDefFunc* func)
{
   const TFuncProfile *profile = func->profile;
   int index = 0, already_index = 0;
   bool body = func->Body() != NULL, already_body = false, already_func = false;
   TNodeDefFunc* already;
   while (already = FuncTable.find(*profile,index)) {
      already_func = true; already_index = index;
      if (already->Body()) { already_body = true; break; }
      index++;
   }
   if (body && already_body) {
      AddError(func,erDuplicateBody);
      FuncTable.Add(func);
   } else if (body && already_index) {
      FuncTable[already_index].func = func;
   } else if (!already_index) {
      FuncTable.Add(func);
   }
   return 0;
}

bool TSemantic::VerifyFunc()
{
   bool ret = true;
   for (int i = 0; i < (int)FuncTable.size(); i++) {
      TNodeDefFunc* func = FuncTable[i].func;
      if (!func->Body()) {
         int index = 0;
         bool already_body = false;
         TNodeDefFunc* already;
         while (already = FuncTable.find(*func->profile,index)) {
            if (already->Body()) { already_body = true; break; }
            index++;
         }
         if (!already_body) {
            AddError(func,erUnknownBody);
            ret = false;
         }
      }
   }
   return ret;
}

bool TSemantic::Search(TFinder& finder)
{
   finder.semantic = this;
   if (finder.mode == TFinder::mfVar) {
      if (IsStack()) {
         finder.is_stack = true;
         mode = (T_Mode)(mode & ~tmStack | tmTree);
         S_Syntax *g_syntax = dynamic_cast<S_Syntax*> (syntax);
         int index = g_syntax->filled() - 1;
         for (; index >= 0; index--) {
            TStackRuleItem& stack_item = g_syntax->stack_item(index);
            if (stack_item.lexeme_node.tree) {
               finder.Reset(finder.mode);
               finder.place = stack_item.lexeme_node.tree;
               finder.place->SearchInside(finder);
               if (finder.result) {
                  break;
               }
            }
         }
         mode = (T_Mode)(mode & ~tmTree | tmStack);
      } else if (IsTree()) {
         finder.place->Search(finder);
      } else if (IsBlock()) {
         finder.result = FindIdent(*finder.lexeme);
      }
   } else if (finder.mode == TFinder::mfFunctionType) {
      TNodeDefFunc* func = NULL;
      if (IsStack()) {
      } else if (IsTree()) {
         finder.mode = TFinder::mfFunction;
         if (finder.place->Search(finder)) {
            func = (TNodeDefFunc*)finder.result;
            finder.result = func->Left();
         }
      } else if (IsBlock()) {
         func = dynamic_cast<TNodeDefFunc*>(Block(T_Block::tbFunc));
         finder.result = func->Left();
      }
   }
   return finder.result != NULL;
}

TCodeTable& TSemantic::Code()
{
   if (function == NULL) return CodeTable; else return *FuncTable[function->number].code;
}

void TSemantic::AddCode(TNode* code, int counter)
{
   Code().Add(code,counter); code_count++;
   if (!(syntax->option & T_OptionMode::omPrintCode) || !code) return;
   if (dynamic_cast<TNodeCommand*>(code) || dynamic_cast<TNodeLabel*>(code) || dynamic_cast<TNodeGoTo*>(code)) { 
      code->print(0); 
   } else {
      code->TNode::print(0); 
   }
   int ip;
   if (counter < 0) ip = (int)Code().size() - 1; else ip = counter;
   printf(" -->> %05d\n", ip);
}

void TSemantic::WriteCode(const char* title, int print_mode)
{
   PRINT_FILE_OPEN(file, title, "w");
   for (TFuncTableItem& item : FuncTable) {
      item.func->TNode::print(-1, file, print_mode); fprintf(file, "\n");
      item.code->write(file, print_mode);
      fprintf(file, "\n");
   }
   CodeTable.write(file, print_mode);
   WriteConst(file, print_mode);
   if (title) fclose(file);
}

void TSemantic::AddError(TNode* node, T_Error error)
{
   syntax->ErrorTable.Add(error,node->Lexeme());
   if (node->error_code == T_Error::erNone) {
      node->SetError(error);
   }
}

void TSemantic::BlockBegin(TBlock* block)
{
   block->size = 0;
   block->offset = (int)IdentTable.size();
   BlockTable.Add(block);
   if (syntax->make_mode == A_Syntax::mmCode) {
      TNode *node_block = dynamic_cast<TNode*>(block);
      TNodeDefFunc* func = dynamic_cast<TNodeDefFunc*>(node_block);
      if (func) {
         function = func;
      }
   }
}

int  TSemantic::BlockSize() const
{
   if (!BlockTable.size()) return 0;
   const TBlock* block = BlockTable.Block();
   return block->size;
}

void TSemantic::BlockTrunc(int trunc)
{
   TBlock* block = BlockTable.Block();
   while (trunc > block->size) {
      IdentTable.DelBack(); block->size--;
   }
}

void TSemantic::BlockEnd(TNode *node, bool del)
{
   TBlock* block = BlockTable.back();
   while ((int)IdentTable.size() > block->offset) {
      IdentTable.DelBack();
   }
   if ((block->size) && (block->type != T_Block::tbFunc)) {
      if (node) {
         TNodeDel* del_pop = new TNodeDel();
         del_pop->count = block->size;
         node->InsertAfter(del_pop); 
      } else if (del) {
         GenPop(block->size);
      }
   }
   if (syntax->make_mode == A_Syntax::mmCode) {
      TNode *node_block = dynamic_cast<TNode*>(block);
      TNodeDefFunc* func = dynamic_cast<TNodeDefFunc*>(node_block);
      if (node_block && !func) {
         delete node_block;
      }
      if (func) {
         if (syntax->option & T_OptionMode::omEraseCode) Code().Erase(true);
         Code().Gotos();
         Code().Labels(true);
         function = NULL;
      }
   }
   BlockTable.pop_back();
}

void TSemantic::BreakContinueLabel(TNodeLabel* label_break, TNodeLabel* label_continue)
{
    BlockTable.back()->BreakContinueLabel(label_break, label_continue);
}

void TBlock::BlockBegin(TSemantic& semantic)
{
   number = semantic.block_number++;
   if (semantic.IsBlock()) {
      semantic.BlockBegin(this); 
   } else if (semantic.IsStack()) {
   } else if (semantic.IsTree()) {
      if (type != T_Block::tbFunc) {
         TNode *node = dynamic_cast<TNode*> (this);
         TBlock *owner_block = dynamic_cast<TBlock*> (node->Owner());
         if (owner_block && (owner_block->type != T_Block::tbFunc)) {
            offset = owner_block->offset + owner_block->size;
         }
      }
   }
}

void TBlock::BlockEnd(TSemantic& semantic, bool del)
{
   TNode* node = dynamic_cast<TNode*> (this);
   if (semantic.IsBlock()) { 
      semantic.BlockEnd(node, del); 
   } else if (semantic.IsStack()) {
   } else if (semantic.IsTree()) {
      if ((size) && (type != T_Block::tbFunc)) {
         TNodeDel* del_pop = new TNodeDel();
         del_pop->count = size;
         node->InsertAfter(del_pop); 
      }
   }
}

bool TBlock::LabelDelVar(TNodeLabel* &label, int &del, int rate) const
{
   if ((type != T_Block::tbFor) || (rate != T_Block::tbContinue)) {
      del += size;
   }
   if (type & rate) {
      if (rate == tbBreak) {
         label = break_label;
      } else if (rate == tbContinue) {
         label = continue_label;
      }
      return true;
   }
   return false;
}

void TBlock::BreakContinueLabel(TNodeLabel* label_break, TNodeLabel* label_continue)
{
   break_label = label_break; continue_label = label_continue;
}

void TBlock::print(FILE *file, int print_mode) const
{
   fprintf(file, " number=%d, size=%d", number, size);
}

#define TCI TCastItem

const TCastItem CastableTable[24][24] = {
//                 Void         Short          Int          Long           Float        Double        CVoid         CShort         CInt          CLong        CFloat       CDouble         RVoid        RShort         RInt          RLong        RFloat       RDouble       CRVoid         CRShort        CRInt        CRLong        CRFloat      CRDouble 
/*Void    */{TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*Void    */
/*Short   */{TCI( -1,_______),TCI(  0,_______),TCI(  1,S___I__),TCI(  2,S___L__),TCI(  3,S___F__),TCI(  4,S___D__),TCI( -1,_______),TCI(  0,S___SC_),TCI(  1,S___IC_),TCI(  2,S___LC_),TCI(  3,S___FC_),TCI(  4,S___DC_),TCI( -1,_______),TCI(  0,S___SR_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,S___SCR),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*Short   */
/*Int     */{TCI( -1,_______),TCI( 10,I___S__),TCI(  0,_______),TCI(  1,I___L__),TCI(  2,I___F__),TCI(  3,I___D__),TCI( -1,_______),TCI( 10,I___SC_),TCI(  0,I___IC_),TCI(  1,I___LC_),TCI(  2,I___FC_),TCI(  3,I___DC_),TCI( -1,_______),TCI( -1,_______),TCI(  0,I___IR_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,I___ICR),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*Int     */
/*Long    */{TCI( -1,_______),TCI( 20,L___S__),TCI( 10,L___I__),TCI(  0,_______),TCI(  1,L___F__),TCI(  2,L___D__),TCI( -1,_______),TCI( 20,L___SC_),TCI( 10,L___IC_),TCI(  0,L___LC_),TCI(  1,L___FC_),TCI(  2,L___DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,L___LR_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,L___LCR),TCI( -1,_______),TCI( -1,_______)},/*Long    */
/*Float   */{TCI( -1,_______),TCI(100,F___S__),TCI(100,F___I__),TCI(100,F___L__),TCI(  0,_______),TCI(  1,F___D__),TCI( -1,_______),TCI(100,F___SC_),TCI(100,F___IC_),TCI(100,F___LC_),TCI(  0,F___FC_),TCI(  1,F___DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,F___FR_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,F___FCR),TCI( -1,_______)},/*Float   */
/*Double  */{TCI( -1,_______),TCI(200,D___S__),TCI(200,D___I__),TCI(200,D___L__),TCI( 10,D___F__),TCI(  0,_______),TCI( -1,_______),TCI(200,D___SC_),TCI(200,D___IC_),TCI(200,D___LC_),TCI( 10,D___FC_),TCI(  0,D___DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,D___DR_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,D___DCR)},/*Double  */
/*CVoid   */{TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CVoid   */
/*CShort  */{TCI( -1,_______),TCI(  0,SC__S__),TCI(  1,SC__I__),TCI(  2,SC__L__),TCI(  3,SC__F__),TCI(  4,SC__D__),TCI( -1,_______),TCI(  0,_______),TCI(  1,SC__IC_),TCI(  2,SC__LC_),TCI(  3,SC__FC_),TCI(  4,SC__DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CShort  */
/*CInt    */{TCI( -1,_______),TCI( 10,IC__S__),TCI(  0,IC__I__),TCI(  1,IC__L__),TCI(  2,IC__F__),TCI(  3,IC__D__),TCI( -1,_______),TCI( 10,IC__SC_),TCI(  0,_______),TCI(  1,IC__LC_),TCI(  2,IC__FC_),TCI(  3,IC__DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CInt    */
/*CLong   */{TCI( -1,_______),TCI( 20,LC__S__),TCI( 10,LC__I__),TCI(  0,LC__L__),TCI(  1,LC__F__),TCI(  2,LC__D__),TCI( -1,_______),TCI( 20,LC__SC_),TCI( 10,LC__IC_),TCI(  0,_______),TCI(  1,LC__FC_),TCI(  2,LC__DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CLong   */
/*CFloat  */{TCI( -1,_______),TCI(100,FC__S__),TCI(100,FC__I__),TCI(100,FC__L__),TCI(  0,FC__F__),TCI(  1,FC__D__),TCI( -1,_______),TCI(100,FC__SC_),TCI(100,FC__IC_),TCI(100,FC__LC_),TCI(  0,_______),TCI(  1,FC__DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CFloat  */
/*CDouble */{TCI( -1,_______),TCI(200,DC__S__),TCI(200,DC__I__),TCI(200,DC__L__),TCI( 10,DC__F__),TCI(  0,DC__D__),TCI( -1,_______),TCI(200,DC__SC_),TCI(200,DC__IC_),TCI(200,DC__LC_),TCI( 10,DC__FC_),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CDouble */
/*RVoid   */{TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*RVoid   */
/*RShort  */{TCI( -1,_______),TCI(  0,SR__S__),TCI(  1,SR__I__),TCI(  2,SR__L__),TCI(  3,SR__F__),TCI(  4,SR__D__),TCI( -1,_______),TCI(  0,SR__SC_),TCI(  1,SR__IC_),TCI(  2,SR__LC_),TCI(  3,SR__FC_),TCI(  4,SR__DC_),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*RShort  */
/*RInt    */{TCI( -1,_______),TCI( 10,IR__S__),TCI(  0,IR__I__),TCI(  1,IR__L__),TCI(  2,IR__F__),TCI(  3,IR__D__),TCI( -1,_______),TCI( 10,IR__SC_),TCI(  0,IR__IC_),TCI(  1,IR__LC_),TCI(  2,IR__FC_),TCI(  3,IR__DC_),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*RInt    */
/*RLong   */{TCI( -1,_______),TCI( 20,LR__S__),TCI( 10,LR__I__),TCI(  0,LR__L__),TCI(  1,LR__F__),TCI(  2,LR__D__),TCI( -1,_______),TCI( 20,LR__SC_),TCI( 10,LR__IC_),TCI(  0,LR__LC_),TCI(  1,LR__FC_),TCI(  2,LR__DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______)},/*RLong   */
/*RFloat  */{TCI( -1,_______),TCI(100,FR__S__),TCI(100,FR__I__),TCI(100,FR__L__),TCI(  0,FR__F__),TCI(  1,FR__D__),TCI( -1,_______),TCI(100,FR__SC_),TCI(100,FR__IC_),TCI(100,FR__LC_),TCI(  0,FR__FC_),TCI(  1,FR__DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______)},/*RFloat  */
/*RDouble */{TCI( -1,_______),TCI(200,DR__S__),TCI(200,DR__I__),TCI(200,DR__L__),TCI( 10,DR__F__),TCI(  0,DR__D__),TCI( -1,_______),TCI(200,DR__SC_),TCI(200,DR__IC_),TCI(200,DR__LC_),TCI( 10,DR__FC_),TCI(  0,DR__DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______)},/*RDouble */
/*CRVoid  */{TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CRVoid  */
/*CRShort */{TCI( -1,_______),TCI(  0,SCR_S__),TCI(  1,SCR_I__),TCI(  2,SCR_L__),TCI(  3,SCR_F__),TCI(  4,SCR_D__),TCI( -1,_______),TCI(  0,SCR_SC_),TCI(  1,SCR_IC_),TCI(  2,SCR_LC_),TCI(  3,SCR_FC_),TCI(  4,SCR_DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CRShort */
/*CRInt   */{TCI( -1,_______),TCI( 10,ICR_S__),TCI(  0,ICR_I__),TCI(  1,ICR_L__),TCI(  2,ICR_F__),TCI(  3,ICR_D__),TCI( -1,_______),TCI( 10,ICR_SC_),TCI(  0,ICR_IC_),TCI(  1,ICR_LC_),TCI(  2,ICR_FC_),TCI(  3,ICR_DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______)},/*CRInt   */
/*CRLong  */{TCI( -1,_______),TCI( 20,LCR_S__),TCI( 10,LCR_I__),TCI(  0,LCR_L__),TCI(  1,LCR_F__),TCI(  2,LCR_D__),TCI( -1,_______),TCI( 20,LCR_SC_),TCI( 10,LCR_IC_),TCI(  0,LCR_LC_),TCI(  1,LCR_FC_),TCI(  2,LCR_DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______),TCI( -1,_______)},/*CRLong  */
/*CRFloat */{TCI( -1,_______),TCI(100,FCR_S__),TCI(100,FCR_I__),TCI(100,FCR_L__),TCI(  0,FCR_F__),TCI(  1,FCR_D__),TCI( -1,_______),TCI(100,FCR_SC_),TCI(100,FCR_IC_),TCI(100,FCR_LC_),TCI(  0,FCR_FC_),TCI(  1,FCR_DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______),TCI( -1,_______)},/*CRFloat */
/*CRDouble*/{TCI( -1,_______),TCI(200,DCR_S__),TCI(200,DCR_I__),TCI(200,DCR_L__),TCI( 10,DCR_F__),TCI(  0,DCR_D__),TCI( -1,_______),TCI(200,DCR_SC_),TCI(200,DCR_IC_),TCI(200,DCR_LC_),TCI( 10,DCR_FC_),TCI(  0,DCR_DC_),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI( -1,_______),TCI(  0,_______)},/*CRDouble*/
};

const TCastItem& Castable(T_BaseType from, T_BaseType to) 
{
   if ((from == btUnknown) || (to == btUnknown))  return CastableTable[0][1];
   from = TBaseType::Tilda(from,btStatic); to = TBaseType::Tilda(to,btStatic);
   return CastableTable[TBaseType::Index(from)][TBaseType::Index(to)];
}

T_BaseType CastableBetween(T_BaseType one, T_BaseType two)
{
   T_BaseType ret = btUnknown;
   const TCastItem &cast_one_two = Castable(one,two);
   const TCastItem &cast_two_one = Castable(two,one);
	if ((cast_one_two.weight >= 0) && (cast_two_one.weight >= 0)) {
      ret = (cast_one_two.weight >= cast_two_one.weight) ? one : two;
   } else if (cast_one_two.weight >= 0) {
      ret = one;
   } else if (cast_two_one.weight >= 0) {
      ret = two;
   }
   return ret;
}

const TOperProfile* TOperTable::Oper(T_Symbol::T_Type oper, T_BaseType left, T_BaseType right) const
{
   const T_Symbol& symbol = symbol_table().Symbol(oper);
   if (!symbol.oper_count) return NULL;
	T_Profile join; join.Add(left); if (right != btUnknown) join.Add(right);
   int weight_gut = 1000000;
	const TOperProfile *profile_gut = NULL;
   for (int i = 0; i < symbol.oper_count; i++) {
      const TOperProfile& profile = (*this)[symbol.oper_index + i];
		int weight = profile.Match(join);
		if (weight < 0) continue;
		if (weight < weight_gut) {
			weight_gut = weight; profile_gut = &profile;
		}
		if (weight == 0) break;
   }
   return profile_gut;
}

void TOperTable::Clear()
{
   iterator ip = begin();
   while (ip != end()) {
      ip = erase(ip);
   }
   delete this;
}

int  T_Profile::Match(const T_Profile &join) const
{
	int weight = 0;
	if (size() != join.size()) return -1;
   for (int i = 0; i < (int)size(); i++) {
		const TCastItem &cast = Castable(join[i],(*this)[i]);
		if (cast.weight == -1) return -1;
		weight += cast.weight;
	}
	return weight;
}

bool T_Profile::match(const T_Profile &join) const
{
	if (size() != join.size()) return false;
   for (int i = 0; i < (int)size(); i++) {
		if (join[i] != (*this)[i]) return false;
	}
	return true;
}

int  T_Profile::Cast(const T_Profile &join, TCastables &castables) const
{
   castables.clear();
	int weight = 0;
	if (size() != join.size()) return -1;
   for (int i = 0; i < (int)size(); i++) {
		const TCastItem &cast = Castable(join[i],(*this)[i]);
		if (cast.weight == -1) return -1;
      castables.push_back(cast.cast);
		if (cast.cast != T_CastType::None) weight++;
	}
	return weight;
}

T_CastType TSemantic::GetCastable(T_BaseType from, T_BaseType to)
{
   const TCastItem &cast = Castable(from,to);
	if (cast.weight >= 0) {
      return cast.cast;
   }
   return T_CastType::Illegal;
}

bool TSemantic::GenCastable(TNode* &node, T_BaseType type, int mode) // 0x01 - code, 0x02 - const
{
   T_BaseType from_type = node->BaseType();
   if (mode & 0x02) { // initialization
      from_type = TBaseType::Tilda(from_type,T_BaseType::btConst);
   }
   const TCastItem &cast = Castable(from_type,type);
	if (cast.weight >= 0) {
      if (cast.cast != T_CastType::None) {
         TNodeCast* cast_node = new TNodeCast();
         cast_node->cast = cast.cast; cast_node->base_type = type;
         cast_node->SetOwner(node->Owner()); node->SetOwner();
         cast_node->SetRight(node); node = cast_node;
      }
      return true;
   }
   return false;
}

bool TSemantic::GenCastable(T_BaseType from, T_BaseType to, int& made)
{ 
   const TCastItem &cast = Castable(from,to);
	if (cast.weight >= 0) {
      if (cast.cast != T_CastType::None) {
         TNodeCommand* command = new TNodeCommand(T_Command::command_Cast,cast.cast,0,to);
         AddCode(command,made++);
      }
      return true;
   }
   return false;
}

void TSemantic::GenCommand(T_Command command, int param, int mode, T_BaseType type, int made)
{
   AddCode(new TNodeCommand(command,param,mode,type), made);
}

void TSemantic::GenNumber(const T_Lexeme &lexeme)
{
   T_BaseType base_type = (lexeme.group == lexeme.grInteger) ? btCInt : ((lexeme.group == lexeme.grNumber) ? btCDouble : btUnknown);
   if (lexeme.group == lexeme.grInteger)
      GenCommand(T_Command::command_PushInt, syntax->Integer(lexeme), base_type);
   else
      GenCommand(T_Command::command_PushNum, lexeme.value/*syntax->Scan().Number(lexeme)*/, base_type);
}

TNode* TSemantic::GetCommand(int counter)
{
   return Code()[counter];
}

bool TSemantic::MakeLogical(TNode* &node, TNodeLabel* &true_label, TNodeLabel* &false_label)
{
   bool ret = true;
	TNodeLogical* logical = node->Logical();
   if (!logical) {
	   if (!GenCastable(node, T_BaseType::btCInt)) {
         AddError(node,erUnknownCast);
         ret = false;
	   }
      true_label = new TNodeLabel(this); false_label = new TNodeLabel(this);
      TNodeGoTo* go_true  = new TNodeGoTo(T_GoTo::tgIf  ,true_label );
      TNodeGoTo* go_false = new TNodeGoTo(T_GoTo::tgGoTo,false_label);
      node->InsertAfter(go_true); node->InsertAfter(go_false);
	} else {
		true_label = logical->true_label; false_label = logical->false_label;
      logical->logical = 1;
   }
   return ret;
}

void TSemantic::MakeValue(TNodeLabel* true_label, TNodeLabel* false_label, int &made)
{
   AddCode(true_label,made); if (made >= 0) made++;
   AddCode(new TNodeCommand(T_Command::command_PushInt,1,0,btCInt),made); if (made >= 0) made++; 
   TNodeLabel* label_end = new TNodeLabel(this);
   TNodeGoTo* go_end = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
   AddCode(go_end,made); if (made >= 0) made++;
   AddCode(false_label,made); if (made >= 0) made++;
   AddCode(new TNodeCommand(T_Command::command_PushInt,0,0,btCInt),made); if (made >= 0) made++; 
   AddCode(label_end,made); if (made >= 0) made++;
}

const TOperProfile* TSemantic::Oper(const T_Lexeme &lexeme, T_BaseType left, T_BaseType right) const
{
   T_Symbol::T_Type oper;
   if (lexeme.group == T_Lexeme::grPriority) {
      const T_Symbol& symbol = symbol_table().Symbol(lexeme.value);
      oper = T_Symbol::T_Type(symbol.type);
   } else {
      oper = T_Symbol::T_Type(lexeme.type);
   }
   return OperTable().Oper(oper, left, right);
}

void TSemantic::MakeBinaryOper(const char* oper, T_BaseType result, T_BaseType left, T_BaseType right)
{
   const T_Symbol* symbol = symbol_table().Symbol(oper);
   if (!symbol) return;
   MakeBinaryOper(symbol->type,result,left,right);
}
void TSemantic::MakeBinaryOper(T_Symbol::T_Type oper, T_BaseType result, T_BaseType left, T_BaseType right)
{
   int index = OperTable().count();
   TOperProfile profile(oper, result, left, right);
   OperTable().push_back(profile);
   symbol_table().Symbol(oper).MakeOper(index);
}
void TSemantic::MakeUnaryOper(T_Symbol::T_Type oper, T_BaseType result, T_BaseType param)
{
   int index = OperTable().count();
   TOperProfile profile(oper, result, param);
   OperTable().push_back(profile);
   symbol_table().Symbol(oper).MakeOper(index);
}

//#define MAKE_BINARY(OPER, RESULT, LEFT, RIGHT) MakeBinaryOper(T_Symbol::lx##OPER, T_BaseType::bt##RESULT, T_BaseType::bt##LEFT, T_BaseType::bt##RIGHT);
#define MAKE_BINARY(OPER, RESULT, LEFT, RIGHT) \
   MakeUnaryOper(T_Symbol::lx##OPER, T_BaseType::bt##RESULT, T_BaseType::bt##LEFT); \
   OperTable().back().Add(T_BaseType::bt##RIGHT);
#define MAKE_UNARY(OPER, RESULT, PARAM) MakeUnaryOper(T_Symbol::lx##OPER, T_BaseType::bt##RESULT, T_BaseType::bt##PARAM);

void TSemantic::MakeOperTable()
{
//   static bool make = false; if (make) return; make = true;
   AddInt = OperTable().count(); 
   MAKE_BINARY(Add          ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(Add          ,CDouble,CDouble,CDouble)
   MAKE_BINARY(Sub          ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(Sub          ,CDouble,CDouble,CDouble)
   MultiInt = OperTable().count();
   MAKE_BINARY(Multi        ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(Multi        ,CDouble,CDouble,CDouble)
   MAKE_BINARY(Div          ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(Div          ,CDouble,CDouble,CDouble)
   MAKE_BINARY(Mod          ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(Or           ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(And          ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(OrOr         ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(AndAnd       ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(XOr          ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(Equ          ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(Equ          ,CInt   ,CDouble,CDouble)
   MAKE_BINARY(NotEqu       ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(NotEqu       ,CInt   ,CDouble,CDouble)
   MAKE_BINARY(LT           ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(LT           ,CInt   ,CDouble,CDouble)
   MAKE_BINARY(LE           ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(LE           ,CInt   ,CDouble,CDouble)
   MAKE_BINARY(GT           ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(GT           ,CInt   ,CDouble,CDouble)
   MAKE_BINARY(GE           ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(GE           ,CInt   ,CDouble,CDouble)
   MAKE_BINARY(LShift       ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(RShift       ,CInt   ,CInt   ,CInt   )
   MAKE_BINARY(LShiftAssign ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(RShiftAssign ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(ModAssign    ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(AndAssign    ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(OrAssign     ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(XOrAssign    ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(Assign       ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(Assign       ,CDouble,RDouble,CDouble)
   MAKE_BINARY(AddAssign    ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(AddAssign    ,CDouble,RDouble,CDouble)
   MAKE_BINARY(SubAssign    ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(SubAssign    ,CDouble,RDouble,CDouble)
   MAKE_BINARY(MultiAssign  ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(MultiAssign  ,CDouble,RDouble,CDouble)
   MAKE_BINARY(DivAssign    ,CInt   ,RInt   ,CInt   )
   MAKE_BINARY(DivAssign    ,CDouble,RDouble,CDouble)
   MAKE_UNARY (UnaryAdd     ,CInt   ,CInt   )
   MAKE_UNARY (UnaryAdd     ,CDouble,CDouble)
   MAKE_UNARY (UnarySub     ,CInt   ,CInt   )
   MAKE_UNARY (UnarySub     ,CDouble,CDouble)
   MAKE_UNARY (Not          ,CInt   ,CInt   )
   MAKE_UNARY (Not          ,CInt   ,CDouble)
   MAKE_UNARY (Tilda        ,CInt   ,CInt   )
   MAKE_UNARY (PlusPlus     ,RInt   ,RInt   )
   MAKE_UNARY (PlusPlus     ,RDouble,RDouble)
   MAKE_UNARY (MinusMinus   ,RInt   ,RInt   )
   MAKE_UNARY (MinusMinus   ,RDouble,RDouble)
   MAKE_UNARY (PostInc      ,CInt   ,RInt   )
   MAKE_UNARY (PostInc      ,CDouble,RDouble)
   MAKE_UNARY (PostDec      ,CInt   ,RInt   )
   MAKE_UNARY (PostDec      ,CDouble,RDouble)
}

bool TSemantic::Translate()
{
   print_mode = syntax->option;
   if (syntax->make_mode == A_Syntax::mmCode) {
      Mode(T_Mode::tmBlock);
   } else if (syntax->option & T_OptionMode::omAtOnce) {
      Mode(T_Mode::tmStack);
      Mode(T_Mode::tmDirect);
   }
   if (!syntax->Translate()) {
         return false;
      }
   TNode* program = syntax->Program();
   if (!program && syntax->Tree()) {
      if (syntax->option & T_OptionMode::omPrintSNode) {
//         printf("\n--- SNodeTree ----\n");
//         syntax->Tree()->print(0x00); // print_SNode
      }
      M_Syntax* my_syntax = (M_Syntax*)syntax;
      if (my_syntax->make_mode == M_Syntax::M_Mode::mmNode) program = syntax->Tree()->Create(syntax);
      if (my_syntax->make_mode == M_Syntax::M_Mode::mmTurn) program = syntax->Tree()->Make(syntax);
      my_syntax->program = program;
//      if (program) program->print(0x00);
   }
   if (syntax->option & T_OptionMode::omPrintSyntax) {
      print_tree("Syntax ");
   }
   if (program) {
      if (!IsStack()) {
         T_Mode mode = (syntax->option & T_OptionMode::omTreeTraversal) ? T_Mode::tmTree : T_Mode::tmBlock;
         if (syntax->option & T_OptionMode::omQuadruple) mode = (T_Mode)(mode | T_Mode::tmQuad);
         Mode(mode);
         if (!IsDirect()) {
            program->Variables(*this, 0);
         }
         program->Verify(*this, 0);
         //      program->Codes(*this,T_VerifyMode::mvNoFunction);
         program->Codes(*this, T_VerifyMode::mvNone);
         VerifyFunc();
         //      FuncTable.Codes();
         if (!IsQuad()) {
            if (syntax->option & T_OptionMode::omEraseCode) CodeTable.Erase();
            CodeTable.Labels();
         }
      } else {
      }
   } else {
      VerifyFunc();
      if (syntax->option & T_OptionMode::omEraseCode) CodeTable.Erase(true);
      CodeTable.Gotos();
      CodeTable.Labels(true);
   }
   if (syntax->option & T_OptionMode::omPrintSemantic) {
      print_tree("Semantic ");
   }
   return true;
}

void TSemantic::print_tree(const char* title) const
{
	printf("\n--- %sTree ----\n",title);
   TNode* program = syntax->Program();  
   if (program) {
      program->print(0);
   }
}

char* get_file_name(const char*file, const char* ext);

void TSemantic::Result(const char* file)
{
// parse.FuncTable.print();
   if (BlockTable.size()) BlockTable.print();
   if (IdentTable.size()) IdentTable.print();
   if (syntax->ErrorTable.size()) syntax->ErrorTable.print();
   if (UserLabelTable.size()) UserLabelTable.print();
   if (UserGoToTable.size()) UserGoToTable.print();
// GarbageTable.print();
// parse.clear(parse.Program());
   if ((syntax->option & T_OptionMode::omPrintCodes) && code_count) {
      char *file_code  = get_file_name(file,"code");
      WriteCode(file_code, 0x00);
      free(file_code);
   }
   if ((syntax->option & T_OptionMode::omPrintCodes) && quad_count) {
      char *file_quad = get_file_name(file, "quad");
      WriteQuad(file_quad, 0x00);
      free(file_quad);
   }
   if (syntax->option & T_OptionMode::omPrintTree) {
      TNode* program = syntax->Program();  
      if (program) {
         char *file_tree  = get_file_name(file,"tree");
         program->print(file_tree, 0x00);
         free(file_tree);
      }
   }
   if (syntax->option & T_OptionMode::omPrintSNode) { // print_SNode
      SNode* tree = syntax->Tree();
      if (tree) {
         char *file_node  = get_file_name(file,"node");
         tree->print(file_node, 0x00);
         free(file_node);
      }
   }
   if (syntax->option & T_OptionMode::omPrintTree) {
      TSyntaxTree* unit = syntax->Auto();
      if (unit && unit->root) {
         char *file_unit = get_file_name(file, "auto");
         unit->print(file_unit, 0x00);
         free(file_unit);
      }
   }

   syntax->ClearProgram();
   CodeTable.Clear();
   FuncTable.Clear();
   OperTable().Clear();
   GMakerTable::maker_table.Clear();
   TBaseType::Clear();
   GarbageCollectorClear();
}

// --------------------------- Tables ---------------------------
TNodeDefVar* TIdentTable::find(const T_Lexeme &l) const 
{
   for (const_reverse_iterator r = rbegin(); r < rend(); r++) {
      if (semantic->Compare((*r)->Lexeme(),l)) return (*r);
      }
   return NULL;
}

void TIdentTable::Add(TNodeDefVar* var)
{
   if (var->alloc == T_Alloc::taGlobal) {
      var->offset = (int)size();
   } else if (var->alloc == T_Alloc::taParam) {
      const TBlock* block = semantic->BlockTable.Block();
      var->offset = block->size;
   } else if (var->alloc == T_Alloc::taLocal) {
      int offset = 0;
      if (!empty()) {
         TNodeDefVar* def = back();
         if ((def->alloc != T_Alloc::taGlobal) && (def->alloc != T_Alloc::taParam)) {
            offset = def->offset + 1;
         }
      }
      var->offset = offset;
   }
   push_back(var);
   if (var->Owner() == NULL) {
      int i = 0;
   }
   var->SetOwner(this);
}

void TIdentTable::DelBack()
{
   if (back()->Owner() == this) {
      back()->clear(); delete back();
   }
   pop_back();
}

void TIdentTable::print()
{
	printf("\n--- IdentTable ---- %d ----\n",(int)size());
   for (const TNodeDefVar* var : (*this)) { var->print(0,stdout); }
}

void TFuncTable::Add(TNodeDefFunc* func)
{
   TFuncTableItem item(func, NULL); 
   if (semantic->IsQuad()) item.quad = new TQuadTable();
   item.code = new TCodeTable(semantic);
   push_back(item);
	func->number = (int)size() - 1;
   if (semantic->syntax->make_mode == A_Syntax::mmCode) {
      func->SetOwner(this);
   }
}

TNodeDefFunc* TFuncTable::Find(const TFuncProfile &profile) const
{
   int weight_gut = 1000000;
	TNodeDefFunc *function_gut = NULL;
   for (const TFuncTableItem& item : (*this)) {
      TNodeDefFunc* func = item.func;
      if (!semantic->Compare(func->Lexeme(),profile.ident)) continue;
		int weight = func->profile->Match(profile);
		if (weight < 0) continue;
		if (weight < weight_gut) {
			weight_gut = weight; function_gut = func;
		}
		if (weight == 0) break;
   }
   return function_gut;
}

TNodeDefFunc* TSemantic::FindFunc(const TFuncProfile &profile) const
{
   if (IsBlock()) return FuncTable.Find(profile);

   T_NodeList* global_block = NULL;
   if (IsTree()) {
      global_block = dynamic_cast<T_NodeList*> (syntax->Program());
   } else {
      S_Syntax *g_syntax = dynamic_cast<S_Syntax*> (syntax);
      for (int index = 0; index < g_syntax->filled(); index++) {
         TStackRuleItem& stack_item = g_syntax->stack_item(index);
         if (stack_item.lexeme_node.tree) {
            global_block = dynamic_cast<T_NodeList*> (stack_item.lexeme_node.tree);
            break;
         }
      }
   }
   int weight_gut = 1000000;
	TNodeDefFunc *function_gut = NULL;
   if (!global_block) return function_gut;
   for (TNode* node : *global_block) {
      TNodeDefFunc* func = dynamic_cast<TNodeDefFunc*>(node);
      if (!func || !func->profile) continue;
      if (!Compare(func->Lexeme(),profile.ident)) continue;
		int weight = func->profile->Match(profile);
		if (weight < 0) continue;
		if (weight < weight_gut) {
			weight_gut = weight; function_gut = func;
		}
		if (weight == 0) break;
   }
   return function_gut;
}

TNodeDefFunc* TFuncTable::find(const TFuncProfile &profile, int &i) const
{
   for (; i < (int)size(); i++) {
      TNodeDefFunc* func = (*this)[i].func;
      if (!semantic->Compare(func->Lexeme(),profile.ident)) continue;
		if (func->profile->match(profile)) return func;
   }
   return NULL;
}

TFuncTable::~TFuncTable()
{
   Clear();
}
void TFuncTable::Clear()
{

   if (semantic->syntax->make_mode == A_Syntax::mmCode) {
      iterator ip = begin();
      while (ip != end()) { 
         TNodeDefFunc* func = (*ip).func;
         ClearNode(func);
         TQuadTable* quad = (*ip).quad;
         if (quad) delete quad;
         ip = erase(ip); 
      }
   }
}

void TFuncTable::Codes()
{
   for (TFuncTableItem& item : (*this)) { item.func->Codes(*semantic, T_VerifyMode::mvNone); }
}

void TFuncTable::print()
{
	printf("\n--- FuncTable ----\n");
   for (const TFuncTableItem& item : (*this)) { item.func->print(0); }
}

void TBlockTable::Add(TBlock* block)
{
   TNode *node = dynamic_cast<TNode*>(block);
   if (node && !((semantic->syntax->make_mode == A_Syntax::mmCode) && (block->type == T_Block::tbFunc))) {
      node->SetOwner(this);
   }
   push_back(block);
}

TNodeLabel* TBlockTable::BreakContinueLabel(T_Block type) const
{
   TNodeLabel* label = NULL;
   for (const_reverse_iterator r = rbegin(); r < rend(); r++) {
      const TBlock* block = (*r);
      if (type == tbBreak) {
         label = block->break_label;
      } else if (type == tbContinue) {
         label = block->continue_label;
      }
      if (label) return label;
   }
   return label;
}

bool TNodeBreakContinue::FindLabel(TSemantic &semantic)
{
   int del = 0;
   TNodeLabel* label = NULL;
   if (semantic.IsTree()) {
      TNode* node = this;
      while (node) {
         TBlock* block = dynamic_cast<TBlock*> (node);
         if (block && (block->LabelDelVar(label, del, rate))) break;
         node = node->Owner();
      }
   } else if (semantic.IsBlock()) {
      for (TBlockTable::const_reverse_iterator r = semantic.BlockTable.rbegin(); r < semantic.BlockTable.rend(); r++) {
         const TBlock* block = (*r);
         if (block->LabelDelVar(label, del, rate)) break;
      }
   }
   if (label) {
      SetLabel(label);
      del_count = del;
      return true;
   } else {
      semantic.AddError(this,(rate == T_Block::tbBreak) ? erBreak : erContinue);
      return false;
   }
}

TBlock* TBlockTable::Block(T_Block type) const
{
   if (empty()) return NULL;
   if (type == T_Block::tbNone) return back();
   for (const_reverse_iterator r = rbegin(); r < rend(); r++) {
      TBlock* block = (*r);
      if ((type < tbBlock) && (block->type & type) || (block->type == type)) return block;
   }
   return NULL;
}

void TBlockTable::print()
{
	printf("\n--- BlockTable ---- %d ----\n",(int)size());
	for (const TBlock* block : (*this)) { block->print(stdout); }
}

void TLabelTable::print()
{
	printf("\n--- LabelTable ---- %d ----\n",(int)size());
   for (const TNodeLabel* label : (*this)) { label->print(0); }
}

bool T_UserGoToLabel::Compare(const T_UserGoToLabel &join) const
{
// this - label, join - goto
   int count_label = (int)size(), count_goto = (int)join.size(), count = MIN(count_label,count_goto);
   for (int i = 0; i < count; i++) {
      if (((*this)[i].block != join[i].block) || ((*this)[i].offset > join[i].offset)) return false;
   }
   for (int i = count + 1; i < count_label; i++) {
      if ((*this)[i].offset) return false;
   }
   return true;
}

void TSemantic::MakeGoToLabel(T_UserGoToLabel* item)
{
   if (IsTree()) {
      TNode* node = dynamic_cast<TNode*> (item);
      while (node) {
         const TBlock* block = dynamic_cast<TBlock*> (node);
         if (block) {
            if (block->type == tbFunc) break;
            item->insert(item->begin(), T_UserGoToItem(block->number, block->size));
         }
         node = node->Owner();
      }
   } else if (IsBlock()) {
      bool yes_local = false;
      for (const TBlock *block : BlockTable) {
         if (yes_local) {
            item->push_back(T_UserGoToItem(block->number, block->size));
         }
         if (block->type == tbFunc) yes_local = true;
      }
   }
}

void T_UserGoToLabel::print(FILE *file, int print_mode) const
{
   for (const T_UserGoToItem& item : *this) {
      fprintf(file, " (%d,%d)", item.block, item.offset);
   }
}

void TUserLabelTable::Add(TNodeUserLabel* label)
{
   TNodeUserLabel* old_label = Find(label->Lexeme());
   if (old_label) {
      semantic->AddError(label,erDuplicateLabel);
   } else {
      push_back(label);
   }
}

TNodeUserLabel* TUserLabelTable::Find(const T_Lexeme& ident)
{
   for (TNodeUserLabel* label : (*this)) {
      if (semantic->Compare(label->Lexeme(),ident)) return label;
   }
   return NULL;
}

bool TUserLabelTable::Find(TNodeUserGoTo* go_to)
{
   TNodeUserLabel* label = semantic->UserLabelTable.Find(go_to->Lexeme());
   if (label) {
      if (!label->Compare(*go_to)) {
         semantic->AddError(go_to,erErrorLabel);
      }
      go_to->SetLabel(label);
      return true;
   }
   return false;
}

void TUserLabelTable::Verify()
{
   for (TNodeUserLabel* label : (*this)) {
      if (!label->go_to) {
         semantic->AddError(label,erUnusedLabel);
      }
   }
}

void TUserLabelTable::print()
{
	printf("\n--- UserLabelTable ---- %d ----\n",(int)size());
   for (const TNodeUserLabel* label : (*this)) { label->print(0); }
}

void TUserGoToTable::Add(TNodeUserGoTo* go_to)
{
   if (!semantic->UserLabelTable.Find(go_to)) {
      push_back(go_to);
   }
}

void TUserGoToTable::Verify()
{
   for (TNodeUserGoTo* go_to : (*this)) {
      if (!semantic->UserLabelTable.Find(go_to)) {
         semantic->AddError(go_to,erUnknownLabel);
      }
   }
}

void TUserGoToTable::print()
{
	printf("\n--- UserGoToTable ---- %d ----\n",(int)size());
   for (const TNodeUserGoTo* go_to : (*this)) { go_to->print(0); }
}

// ------------------------- TCodeTable -------------------------
TCodeTable::~TCodeTable()
{
   Clear();
}

void TCodeTable::Clear()
{
   iterator ip = begin();
   while (ip != end())
   {
      TNodeDefFunc* def_func = dynamic_cast<TNodeDefFunc*>((*ip));
      if (!def_func) {
         GarbageCollectorAdd(*ip,0x01);
      }
      ip = erase(ip);
   }
}

void TCodeTable::Add(TNode* code, int counter)
{
   if (!code || !counter) {
      int i = 12; i++;
   }
   if (counter < 0)
      push_back(code);
   else
      insert(begin() + counter,code);
}

void TCodeTable::Erase(bool del)
{
   bool yes_erase = true;
   while(yes_erase) {
      yes_erase = false;
		iterator ip = begin();
      while (ip != end()) { 
         TNodeLabel* label = dynamic_cast<TNodeLabel*>(*ip);
         if (label && !label->go_to) {
            GarbageCollectorAdd(*ip, del);
            ip = erase(ip); yes_erase = true; 
            continue;
         }
         if (label && (ip > (begin() + 1))) { // go_if l1; go_to l2; label l1; -> go_else l2; label l1;
            TNodeGoTo* go_one = dynamic_cast<TNodeGoTo*>(*(ip - 2));
            TNodeGoTo* go_two = dynamic_cast<TNodeGoTo*>(*(ip - 1));
            if (go_one && (go_one-> GetLabel() == label) && go_two && (go_two->type == T_GoTo::tgGoTo)) {
               go_two->type = (go_one->type == T_GoTo::tgIf) ? T_GoTo::tgElse : T_GoTo::tgIf;
               go_one->SetLabel(NULL);
               yes_erase = true; 
               continue;
            }
         }
         if (label && (ip < (end() - 1))) {
            TNodeLabel* label_after = dynamic_cast<TNodeLabel*>(*(ip + 1)); // label l1; label l2; - l2 -> l1
            if (label_after) {
               semantic->Reference(label_after,label);
               ip++; 
               yes_erase = true; 
               continue;
            }
            TNodeGoTo* go_after = dynamic_cast<TNodeGoTo*>(*(ip + 1)); // label l1; go_to l2; - l1 -> l2
            if (go_after && (go_after->type == T_GoTo::tgGoTo) && (go_after->GetLabel() != label)) {
               semantic->Reference(label,go_after->GetLabel());
               ip++; 
               yes_erase = true; 
               continue;
            }
         }
         TNodeGoTo* go_to = dynamic_cast<TNodeGoTo*>((*ip));
         if (go_to && !go_to->GetLabel()) {
            GarbageCollectorAdd(*ip, del);
            ip = erase(ip); yes_erase = true; 
            continue;
         }
         if (go_to && ((ip + 1) != end())) { // go_xx l1; label l1; ->
            TNodeLabel* label = dynamic_cast<TNodeLabel*>(*(ip + 1));
            if (label && (go_to->GetLabel() == label)) {
               go_to->SetLabel(NULL);
               if (go_to->type == tgGoTo) { // go_to l1; label l1; -> label l1;
                  GarbageCollectorAdd(*ip, del);
                  ip = erase(ip); 
               } else { // go_<if,else> l1; label l1; -> pop; label l1;
                  TNodeCommand* command = new TNodeCommand(T_Command::command_Pop,1,0,btVoid);
                  GarbageCollectorAdd(*ip, del);
                  (*ip) = command;
               }
               yes_erase = true; 
               continue;
            } 
         }
         TNodeCommand* command_prev = NULL;
         if (ip != begin()) {
            command_prev = dynamic_cast<TNodeCommand*>(*(ip - 1));
         }
         if (go_to && ((go_to->type == T_GoTo::tgIf) || (go_to->type == T_GoTo::tgElse)) && command_prev) {
            if (command_prev->command == T_Command::command_PushInt) {
               int value = command_prev->param;
               command_prev->command = T_Command::command_None;
               if (value && (go_to->type == T_GoTo::tgIf) || !value && (go_to->type == T_GoTo::tgElse)) {
                  go_to->type = T_GoTo::tgGoTo;
               } else {
                  go_to->SetLabel(NULL);
                  GarbageCollectorAdd(*ip, del);
                  ip = erase(ip); 
               } 
               yes_erase = true; 
               continue;
            }
         }
         bool yes_return = false;
         TNodeCommand* command = dynamic_cast<TNodeCommand*>((*ip));
         if (command) {
            if (command->command == T_Command::command_Pop) {
               if ((command->param == -1) && ((ip + 1) != end())) {
                  int del_count = 0;
                  if (TNodeUserGoTo* go_to = dynamic_cast<TNodeUserGoTo*>(*(ip + 1))) {
                     if (TNodeUserLabel *label = (TNodeUserLabel*)go_to->GetLabel()) {
                        del_count = go_to->back().offset - label->back().offset;
                     }
                  }
                  command->param = del_count;
               } else if ((command->param == 1) && command_prev && (command_prev->command == T_Command::command_Oper)) {
                  command_prev->mode = 1; command_prev->base_type = btVoid;
                  command->param = 0;
               }
               if (!command->param) {
                  command->command = T_Command::command_None;
               }
            }
            if (command->command == T_Command::command_None) {
               GarbageCollectorAdd(*ip, del);
               ip = erase(ip); yes_erase = true; 
               continue;
            }
            if ((command->command == T_Command::command_Pop) && (command->param == 1) && command_prev) {
               if ((command_prev->command == T_Command::command_PushInt) || (command_prev->command == T_Command::command_PushNum)) {
                  command_prev->command = command->command = T_Command::command_None; yes_erase = true; 
                  continue;
               }
            }
            yes_return = (command->command == T_Command::command_Return);
         }
         ip++; 
         if (go_to && (go_to->type == tgGoTo) || yes_return) {
            while ((ip != end()) && (!(label   = dynamic_cast<TNodeLabel*>(*ip))   || !label->go_to) &&
                                    (!(command = dynamic_cast<TNodeCommand*>(*ip)) || (command->command != T_Command::command_Exit)) &&
                                    !(dynamic_cast<TNodeDefFunc*>(*ip))) {
               TNodeGoTo* go_to = dynamic_cast<TNodeGoTo*>(*ip);
               if (go_to) go_to->SetLabel(NULL);
               GarbageCollectorAdd(*ip, del);
               ip = erase(ip); yes_erase = true;
            }
         }
      }
   }
}

void TCodeTable::Gotos()
{
   int count = (int)size();
   for (int ip = 1; ip < count; ip++) {
      TNodeCommand* command = dynamic_cast<TNodeCommand*>((*this)[ip - 1]);
      if (command && (command->command == T_Command::command_Pop) && (command->param == -1)) {
         int del_count = 0;
         if (TNodeUserGoTo* go_to = dynamic_cast<TNodeUserGoTo*>((*this)[ip])) {
            if (TNodeUserLabel *label = (TNodeUserLabel*)go_to->GetLabel()) {
               del_count = go_to->back().offset - label->back().offset;
            }
         }
         command->param = del_count;
      }
   }
}

void TCodeTable::Labels(bool del)
{
   int count = (int)size();
   for (int ip = 0; ip < count; ip++) {
      TNodeLabel* label = dynamic_cast<TNodeLabel*>((*this)[ip]);
      if (label) {
         label->command = ip;
         TNodeCommand* command = new TNodeCommand(T_Command::command_Label,ip,label->go_to,btVoid);
         GarbageCollectorAdd((*this)[ip], del);
         (*this)[ip] = command;
      }
   }
   for (int ip = 0; ip < count; ip++) {
      TNodeGoTo* go_to = dynamic_cast<TNodeGoTo*>((*this)[ip]);
      if (go_to) {
         TNodeLabel* label = go_to->GetLabel();
         if (label) {
            TNodeCommand* command = new TNodeCommand(T_Command::command_GoTo,label->command,go_to->type,btUnknown);
            GarbageCollectorAdd((*this)[ip], del);
            (*this)[ip] = command;
      	} else {
            semantic->AddError(go_to,erUnknownLabel);
         }
      }
   }
}

void TCodeTable::write(FILE* file, int print_mode) const
{
   const_iterator p = begin();
   int ip = 0;
   while (p != end()) {
      if (TNodeCommand *command = dynamic_cast<TNodeCommand*>((*p))) {
         command->write(file, print_mode);
         //         fprintf(file," -->> %05d", ip);
      } else {
         if (*p) (*p)->TNode::write(file, print_mode);
      }
      p++; ip++;
      fprintf(file, "\n");
   }
}

void TCodeTable::write(const char* title, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   write(file, print_mode);
   if (title) fclose(file);
}

void TCodeTable::print(int print_mode) const
{
	printf("\n--- CodeTable ---- %d ----\n",(int)size());
   if ((print_mode & T_OptionMode::omPrintCodes) == 0) return;
	const_iterator p = begin(); 
   int ip = 0;
   while (p != end()) { 
      if (TNodeCommand *command = dynamic_cast<TNodeCommand*>((*p))) {
         command->print(0);
         printf(" -->> %05d", ip);
      } else {
         (*p)->TNode::print(-1); 
      }
      p++; ip++;
   }
}

// ------------------------- TQuadruple -------------------------

const char* title_cast_type(T_CastType cast);
const char* title_command_mode_goto(int mode);

void TQuadruple::write(FILE *file, TSemantic* semantic, int print_mode) const
{
   fprintf(file, "%-10s", quadruple_title(quad));
   if (quad == TQuadruple::T_Quad::qtNone) return;
   fprintf(file, " "); value_number.write(file, print_mode);
   fprintf(file, " "); arg_one.write(file, print_mode);
   fprintf(file, " "); arg_two.write(file, print_mode);
   fprintf(file, " "); result.write(file, print_mode);
   if ((quad == TQuadruple::T_Quad::qtUnary) || (quad == TQuadruple::T_Quad::qtBinary)) {
      fprintf(file, ", oper  = %-14s", lexeme_type_title((T_Symbol::T_Type)oper));
      if (node) fprintf(file, ", type = %-10s", TBaseType::Title(node->BaseType()));
   } else if (quad == TQuadruple::T_Quad::qtCast) {
      fprintf(file, ", cast  = %-14s", title_cast_type((T_CastType)oper));
      if (node) fprintf(file, ", type = %-10s", TBaseType::Title(node->BaseType()));
   } else if (quad == TQuadruple::T_Quad::qtIndex) {
      fprintf(file, ",                       ");
      if (node) fprintf(file, ", type = %-10s", TBaseType::Title(node->BaseType()));
   } else if (quad == TQuadruple::T_Quad::qtCall)
      fprintf(file, ", func  = %-14s", (oper >= 0) ? semantic->FuncTable[oper].func->Lexeme().Text() : "unknown");
   else if (quad == TQuadruple::T_Quad::qtGoto)
      fprintf(file, ", goto  = %-14s", title_command_mode_goto(oper));
   else if (quad == TQuadruple::T_Quad::qtLabel) {
      TNodeUserLabel* label = dynamic_cast<TNodeUserLabel*> (node);
      if (label) {
         fprintf(file, ", label = %-14s", label->Lexeme().Text());
      }
   }
}

TQuadTable& TSemantic::Quad()
{
   if (function == NULL) return QuadTable; else return *FuncTable[function->number].quad;
}

TQuadTable::TQuadTable()
{
   for (int &item : value_numbar_maker) {
      item = 0;
   }
}

void TQuadTable::Add(TQuadruple* quad, int counter) 
{ 
   if (counter == 0) {
      push_back(quad);
   } else if (counter < 0) {
      insert(end() + counter, quad);
   } else {
      insert(begin() + counter, quad);
   }
}

void TQuadTable::AddLabel(TQuadruple* quad, int counter)
{
   int label = quad->value_number.number;
   if ((int)label_quad.size() < label + 1) {
      label_quad.resize(label + 1, -1);
   }
   label_quad[label] = counter;
}

void TQuadTable::ValueNumber(TAddress& value_number)
{
   switch (value_number.alloc) {
   case taGlobal:
   case taLocal:
   case taParam:
   case taOper:
   case taLabel:
      value_number.number = value_numbar_maker[value_number.alloc]++;
      break;
   default:
      break;
   }

}

void TQuadTable::Reset()
{
   value_numbar_maker[T_Alloc::taLocal  ] = 0;
   value_numbar_maker[T_Alloc::taParam  ] = 0;
   value_numbar_maker[T_Alloc::taOper   ] = 0;
   value_numbar_maker[T_Alloc::taLabel  ] = 0;
   value_numbar_maker[T_Alloc::taCommand] = 0;
}

bool TQuadTable::Verify()
{
   int current = 0;
   int change_count = 0;
   while (int ret = GoToGoToLabel(current) >= 0) {
      if (ret == 1) { change_count++; }
   }
   current = 0;
   while (int ret = GoToLabel(current) >= 0) {
      if (ret == 1) { change_count++; }
   }
   current = 0;
   while (int ret = LabelGoTo(current) >= 0) {
      if (ret == 1) { change_count++; }
   }
   current = 0;
   while (int ret = Label(current) >= 0) {
      if (ret == 1) { change_count++; }
   }
   return true;
}

int  TQuadTable::Label(int& current)
{
   if (current > Count() - 1) { return -1; }
   TQuadruple& one = *(*this)[current];
   if (one.quad != TQuadruple::qtLabel) { current++; return 0; }
   TNodeLabel* label = dynamic_cast<TNodeLabel*> (one.node);
   if (label) {
      if (!label->go_to) {
         one.quad = TQuadruple::qtNone;
      }
   }
   current += 1; return 1;
}

int  TQuadTable::LabelGoTo(int& current)
{
   if (current > Count() - 2) { return -1; }
   TQuadruple& one = *(*this)[current + 1];
   TQuadruple& two = *(*this)[current];
   if ((one.quad != TQuadruple::qtGoto) || (one.oper != T_GoTo::tgGoTo)) { current++; return 0; }
   if (two.quad != TQuadruple::qtLabel) { current++; return 0; }
   if (!(one.arg_one == two.value_number)) { current += 2; return 0; }
   one.quad = TQuadruple::qtNone;
   TNodeLabel* label = dynamic_cast<TNodeLabel*> (two.node);
   if (label) {
      if (!--label->go_to) {
         two.quad = TQuadruple::qtNone;
      }
   }
   current += 2; return 1;
}

int  TQuadTable::GoToLabel(int& current)
{
   if (current > Count() - 2) { return -1; }
   TQuadruple& one = *(*this)[current];
   TQuadruple& two = *(*this)[current + 1];
   if ((one.quad != TQuadruple::qtGoto) || (one.oper != T_GoTo::tgGoTo)) { current++; return 0; }
   if (two.quad != TQuadruple::qtLabel) { current++; return 0; }
   if (!(one.arg_one == two.value_number)) { current += 2; return 0; }
   one.quad = TQuadruple::qtNone;
   TNodeLabel* label = dynamic_cast<TNodeLabel*> (two.node);
   if (label) {
      if (!--label->go_to) {
         two.quad = TQuadruple::qtNone;
      }
   }
   current += 2; return 1;
}

int  TQuadTable::GoToGoToLabel(int& current)
{
   if (current > Count() - 3) { return -1; }
   TQuadruple& one   = *(*this)[current];
   TQuadruple& two   = *(*this)[current + 1];
   TQuadruple& three = *(*this)[current + 2];
   if ((one.quad != TQuadruple::qtGoto) || (one.oper != T_GoTo::tgIf)) { current++; return 0; }
   if (two.quad != TQuadruple::qtGoto) { current += 2; return 0; }
   if (two.oper != T_GoTo::tgGoTo) { current++; return 0; }
   if (three.quad != TQuadruple::qtLabel) { current++; return 0; }
   if (!(one.arg_one == three.value_number)) { current += 3; return 0; }
   one.oper = T_GoTo::tgElse; one.arg_one = two.arg_one;
   three.quad = two.quad = TQuadruple::qtNone;
   TNodeLabel* label = dynamic_cast<TNodeLabel*> (three.node);
   if (label) {
      label->go_to--;
   }
   current += 3; return 1;
}

void TQuadTable::write(FILE* file, TSemantic* semantic, int print_mode) const
{
   const_iterator p = begin();
   for (const TQuadruple* quad : (*this)) {
      quad->write(file, semantic, print_mode);
      fprintf(file, "\n");
   }
}

void TQuadTable::write_label(FILE* file, TSemantic* semantic, int print_mode) const
{
   for (int l = 0; l < (int)label_quad.size(); l++) {
      int quad_label = label_quad[l];
      if (quad_label >= 0) {
         const TQuadruple* quadruple_label = (const TQuadruple*)((*this)[quad_label]);
         quadruple_label->value_number.write(file, print_mode);
         TNodeLabel* label = dynamic_cast<TNodeLabel*> (quadruple_label->node);
         fprintf(file, " refer = %5d", label->go_to);
      }
      fprintf(file, " %5d\n", quad_label);
   }
}

void TQuadTable::write(const char* title, TSemantic* semantic, int print_mode) const
{
   PRINT_FILE_OPEN(file, title, "w");
   write(file, semantic, print_mode);
   if (title) fclose(file);
}

void TSemantic::WriteQuad(const char* title, int print_mode)
{
   PRINT_FILE_OPEN(file, title, "w");
   for (TFuncTableItem& item : FuncTable) {
      item.quad->Verify();
      item.func->TNode::print(-1, file, print_mode); fprintf(file, "\n");
      item.quad->write(file, this, print_mode);
      fprintf(file, "\n");
      item.quad->write_label(file, this, print_mode);
      fprintf(file, "\n");
   }
   QuadTable.Verify();
   QuadTable.write(file, this, print_mode);
   if (!QuadTable.label_quad.empty()) {
      fprintf(file, "\n");
   }
   QuadTable.write_label(file, this, print_mode);
   WriteConst(file, print_mode);
   if (title) fclose(file);
}

void TSemantic::AddQuad(TQuadruple* quad, int counter) 
{ 
   int size = (int)Quad().size();
   if (counter < 0) {
      size += counter;
   } else if (counter > 0) {
      size = counter;
   }
   if ((quad->quad == TQuadruple::T_Quad::qtUnary) || (quad->quad == TQuadruple::T_Quad::qtBinary) || (quad->quad == TQuadruple::T_Quad::qtCast) || 
       (quad->quad == TQuadruple::T_Quad::qtSet)   || (quad->quad == TQuadruple::T_Quad::qtIndex)) {
      quad->value_number.number = size; 
      quad->value_number.alloc = T_Alloc::taOper;
   } else if ((quad->quad == TQuadruple::qtGoto) || (quad->quad == TQuadruple::qtReturn) || (quad->quad == TQuadruple::qtParam) || (quad->quad == TQuadruple::qtCall)){
      quad->value_number.number = size;
      quad->value_number.alloc = T_Alloc::taCommand;
   } 
   Quad().Add(quad, counter); quad_count++; 
   if (quad->quad == TQuadruple::qtLabel) {
      Quad().AddLabel(quad, size);
   }
}

void TSemantic::WriteConst(FILE* file, int print_mode) const
{
   TAddress address;
   fprintf(file, "\n");
   address.alloc = T_Alloc::taInteger;
   for (const int& item : syntax->Scan().integers) {
      address.write(file, print_mode);
      fprintf(file, " %d\n", item);
      address.number++;
   }
   fprintf(file, "\n");
   address.alloc = T_Alloc::taNumber; address.number = 0;
   for (const double& item : syntax->Scan().numbers) {
      address.write(file, print_mode);
      fprintf(file, " %f\n", item);
      address.number++;
   }
}

void TAddress::write(FILE *file, int print_mode) const
{
   if (alloc != T_Alloc::taNone) {
      fprintf(file, "%-10s %5d", title_alloc(alloc), number);
   } else {
      fprintf(file, "                ");
   }
}

static const char* quadruple_type[] = {
   "None", "Const", "Binary", "Unary", "Cast", "Set", "Goto", "If", "Param", "Call", "Return", "Index", "Range", "Variable", "Array", "Referense", "Pointer", "Refer", "Label"
};

const char* quadruple_title(TQuadruple::T_Quad quad) { return quadruple_type[quad]; }

// ------------------------- TGarbage -------------------------
TGarbageTable GarbageCollector;

void GarbageCollectorAdd(TNode* node, int mode_del)
{
   GarbageCollector.Add(node, mode_del);
}
void GarbageCollectorClear()
{
   GarbageCollector.Clear();
}

TGarbageTable::~TGarbageTable()
{
   Clear();
}

void TGarbageTable::Add(TNode* node, int mode_del)
{ 
   if (!(mode_del & 0x01)) {
      if (dynamic_cast<TNodeGoTo*>(node)) {
         if (!dynamic_cast<TNodeUserGoTo*>(node) && !dynamic_cast<TNodeBreakContinue*>(node)) {
            mode_del |= 0x01;
         }
      } else if (dynamic_cast<TNodeLabel*>(node)) {
         if (!dynamic_cast<TNodeUserLabel*>(node)) {
            mode_del |= 0x01;
         }
      } else if (dynamic_cast<TNodeCommand*>(node)) {
         mode_del |= 0x01;
      }
   }
   if ((mode_del & 0x01) || !node->Owner()) {
      std::set<TNode*> ::iterator ip = find(node);
      if (ip != end()) {
         return;
      }
      node->SetOwner();
      insert(node);
   }
}

void TGarbageTable::Clear()
{
   iterator ip = begin();
   while (ip != end()) {
      delete *ip; ip = erase(ip);
   }
}

void TGarbageTable::print()
{
	printf("\n--- GarbageTable ---- %d ----\n",(int)size());
   for (const TNode* node : (*this)) { node->print(0); }
}
#ifndef TRN_TREE_SEMANTIC_H
#define TRN_TREE_SEMANTIC_H

#include <stack>
#include "Parse.h"
#include "ASyntax.h"
#include "TNodes.h"
 
#include "define_enum.h"
#include <set>

// --------------------------- Tables ---------------------------
class TSemantic;

class TIdentTable : public TNode, public std::vector<TNodeDefVar*> {
public:
   TIdentTable(TSemantic *s) : semantic(s) {}
public:
   TNodeDefVar* find(const T_Lexeme &l) const;
   void Add(TNodeDefVar* var);
   void DelBack();
public:
   void print();
protected:
   TSemantic *semantic;
};

class TBlockTable : public TNode, public std::vector<TBlock*> {
public:
   TBlockTable(TSemantic *s) : semantic(s) {}
public:
   void Add(TBlock* block);
   TBlock* Block(T_Block type = T_Block::tbNone) const;
   TNodeLabel* BreakContinueLabel(T_Block type) const;
public:
   void print();
protected:
   TSemantic *semantic;
};

class TQuadTable;
class TCodeTable;
struct TFuncTableItem {
public:
   TFuncTableItem() :func(NULL), quad(NULL), code(NULL) {}
   TFuncTableItem(TNodeDefFunc* f, TQuadTable* q = NULL) :func(f), quad(q), code(NULL) {}
public:
   TNodeDefFunc* func;
   TQuadTable*   quad;
   TCodeTable*   code;
};

class TFuncTable : public TNode, public std::vector<TFuncTableItem> {
public:
   TFuncTable(TSemantic *s) : semantic(s) {}
   ~TFuncTable();
public:
   void Add(TNodeDefFunc* func);
   TNodeDefFunc *Find(const TFuncProfile &profile) const;
   TNodeDefFunc *find(const TFuncProfile &profile, int &index) const;
   void Codes();
   void Clear();
public:
   void print();
protected:
   TSemantic *semantic;
};

class TLabelTable : public std::vector<TNodeLabel*> {
public:
   TLabelTable(TSemantic *s) : semantic(s) {}
public:
   void Push(TNodeLabel* label) { push_back(label); }
   void Pop()                   { pop_back(); }
   TNodeLabel* Top() const      { return back(); }
public:
   void print();
protected:
   TSemantic *semantic;
};

class TUserLabelTable : public std::vector<TNodeUserLabel*> {
public:
   TUserLabelTable(TSemantic *s) : semantic(s) {}
public:
   void Add(TNodeUserLabel* label);
   TNodeUserLabel* Find(const T_Lexeme& ident);
   bool Find(TNodeUserGoTo* go_to);
   void Verify();
public:
   void print();
protected:
   TSemantic *semantic;
};

class TUserGoToTable : public std::vector<TNodeUserGoTo*> {
public:
   TUserGoToTable(TSemantic *s) : semantic(s) {}
public:
   void Add(TNodeUserGoTo* go_to);
   void Verify();
public:
   void print();
protected:
   TSemantic *semantic;
};

class TNodeDel : public TNode {
public:
   TNodeDel() :TNode(), count(0) {}
   TNodeDel(int c) :TNode(), count(c) {}
   virtual void Codes(TSemantic &semantic, int mode);
public:
   int count;
public:
   virtual const char* title() const   { return "TNodeDel"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
};

class TCodeTable : public std::vector<TNode*> {
public:
   TCodeTable(TSemantic *s) : semantic(s) {}
   ~TCodeTable();
public:
   void Add(TNode* code, int counter = -1);
   void Gotos();
   void Labels(bool del = false);
   void Erase(bool del = false);
   void Clear();
public:
   void write(FILE* file, int print_mode) const;
   void write(const char* title, int print_mode) const;
   void print(int print_mode = 0x00) const;
protected:
   TSemantic *semantic;
};

class TGarbageTable : public std::set<TNode*> {
public:
   TGarbageTable(TSemantic *s = NULL) : semantic(s) {}
   ~TGarbageTable();
public:
   void Add(TNode* node, int mode_del);
   void Clear();
public:
   void print();
protected:
   TSemantic *semantic;
};

enum T_ExecMode { meNone = 0x00, meImpossible = 0x01, meRestituer = 0x02
};

class T_ExecStack : public std::vector<int> {
public:
   void Push()     { push_back(meNone); }
   void GoTo()     { back() |= meImpossible; }
   void Label()    { back() &= ~meImpossible; }
   void Return()   { back() |= meImpossible | meRestituer; }
   void Down()     { int up = back(); pop_back(); back() |= up; /* back() &= ~meImpossible | (up & meImpossible);*/ }
   int  Pop()      { int ret = back(); pop_back(); return ret; }
   void Up(int up) { if (empty()) return; back() &= ~meImpossible; back() |= (up & meImpossible); back() |= (up & meRestituer); }
};

enum T_Command {
   command_None, command_Cast, command_Oper, command_Call, command_GoTo, command_Label, 
   command_NewVar, command_NewArr, command_PushVar, command_PushVal, command_PushArr, command_PushAal, 
   command_PushInt, command_PushNum, command_Pop,
   command_Return, command_Exit, command_InitArr
};

class TNodeCommand : public TNode {
public:
   TNodeCommand() :command(command_None), param(0), mode(0), base_type(btUnknown) {}
   TNodeCommand(T_Command c, int p) :command(c), param(p), mode(0), base_type(btUnknown) {}
   TNodeCommand(T_Command c, int p, int m, T_BaseType b) :command(c), param(p), mode(m), base_type(b) {}
public:
   virtual void Codes(TSemantic &semantic, int mode);
   virtual T_BaseType BaseType() const { return base_type; } 
public:
   T_Command command;
   int param, mode;
   T_BaseType base_type; 
public:
   virtual const char* title() const   { return "TNodeCommand"; }
   virtual void print(int level, FILE *file = stdout, int print_mode = 0) const;
   virtual void write(FILE *file, int print_mode) const;
};

class TQuadruple {
public:
   enum T_Quad {
      qtNone, qtConst, qtBinary, qtUnary, qtCast, qtSet, qtGoto, qtIf, qtParam, qtCall, qtReturn, qtIndex, qtRange, qtVariable, qtArray, qtReferense, qtPointer, qtRefer, qtLabel
   };
public:
   TQuadruple(T_Quad q = qtNone, TNode* n = NULL) :quad(q), value_number(this), param(0), oper(0), mode(0), node(n) {}
public:
   void write(FILE *file = stdout, TSemantic* semantic = NULL, int print_mode = 0) const;
public:
   T_Quad quad;
   TAddress value_number, arg_one, arg_two, result;
   int oper;
   int param, mode;
public:
   TNode* node;
};

const char* quadruple_title(TQuadruple::T_Quad quad);

class TQuadTable : public std::vector<TQuadruple*> {
public:
   TQuadTable();
   void Add(TQuadruple* quad, int counter = 0);
   void AddLabel(TQuadruple* quad, int counter);
public:
   bool Verify();
   int  Label(int& current);
   int  LabelGoTo(int& current);
   int  GoToLabel(int& current);
   int  GoToGoToLabel(int& current);
public:
   void write(FILE* file = stdout, TSemantic* semantic = NULL, int print_mode = 0) const;
   void write_label(FILE* file = stdout, TSemantic* semantic = NULL, int print_mode = 0) const;
   void write(const char* title, TSemantic* semantic = NULL, int print_mode = 0) const;
public:
   void ValueNumber(TAddress& value_number);
   void Reset();
   int  Count() const { return (int)size(); }
protected:
   int value_numbar_maker[T_Alloc::taCommand + 1];
public:
   std::vector<int> label_quad;
};

enum T_VerifyMode { mvNone = 0x00, mvOffBefore = 0x01, mvOnAfter = 0x02, mvNoFunction = 0x04
};

#include "define_cast.h"

struct TCastItem {
public:
   TCastItem() :weight(-2), cast(_______) {}
   TCastItem(int w, T_CastType c) :weight(w), cast(c) {}
public:
   int weight;
   T_CastType cast;
};

class TCastables : public std::vector<T_CastType> {
public:
   TCastables() {}
	T_CastType Cast(int i) const { return (*this)[i]; } 
public:
};

const TCastItem& Castable(T_BaseType from, T_BaseType to);
T_BaseType CastableBetween(T_BaseType one, T_BaseType two);

class T_Profile : public std::vector<T_BaseType> {
public:
   T_Profile() :result(btUnknown) {}
   T_Profile(T_BaseType r) :result(r) {}
   virtual ~T_Profile() {}
public:
   void Add(T_BaseType p) { push_back(p); }
	int  Match(const T_Profile &join) const;
	bool match(const T_Profile &join) const;
	int  Cast(const T_Profile &join, TCastables &castables) const;
public:
   T_BaseType result;
};

class TFuncProfile : public T_Profile {
public:
   TFuncProfile() :T_Profile() {}
public:
   T_Lexeme ident;
};

class TOperProfile : public T_Profile {
public:
   TOperProfile() :oper(T_Symbol::T_Type::lxNone), T_Profile() {}
   TOperProfile(T_Symbol::T_Type o, T_BaseType e, T_BaseType l) :oper(o), T_Profile(e) { Add(l); }
   TOperProfile(T_Symbol::T_Type o, T_BaseType e, T_BaseType l, T_BaseType r) :oper(o), T_Profile(e) { Add(l); Add(r); }
public:
   T_Symbol::T_Type oper;
};

class TOperTable : public std::vector<TOperProfile> {
public:
   TOperTable() {}
   const TOperProfile* Oper(T_Symbol::T_Type oper, T_BaseType left, T_BaseType right = btUnknown) const;
public:
   void Clear();
   int count() const { return (int)size(); }
};

// --------------------------- TSemantic ---------------------------

class TSemantic
{
public:
	TSemantic(A_Syntax *s);
public:
   T_Alloc Alloc() const;
   int  AddFunc(TNodeDefFunc* func);
   int  AddDef(TNodeDefVar* var);
   TNodeDefVar* GetDef();
public:
   void AddCode(TNode* code, int counter = -1);
   TCodeTable& Code();
   void WriteCode(const char* title, int print_mode);
public:
   void AddQuad(TQuadruple* quad, int counter = 0);
   TQuadruple& LastQuad() { return *Quad().back(); }
   void ValueNumber(TAddress& value_number) { Quad().ValueNumber(value_number); }
   TQuadTable& Quad();
   void WriteQuad(const char* title, int print_mode);
   void WriteConst(FILE* file, int print_mode) const;
public:
   void AddError(TNode* node, T_Error error = T_Error::erNone);
   int  yes_error() { return (int)syntax->ErrorTable.size(); } 
   void clear(TNode* node) { syntax->clear(node); }

   TNodeDefFunc* FindFunc(const TFuncProfile &profile) const;
   TNodeDefVar*  FindIdent(const T_Lexeme &l) const;

   bool Search(TFinder& finder);

   TBlock* Block(T_Block type = T_Block::tbNone) const      { return BlockTable.Block(type); }
   TNodeLabel* BreakContinueLabel(T_Block type) const       { return BlockTable.BreakContinueLabel(type); }
   void BreakContinueLabel(TNodeLabel* label_break, TNodeLabel* label_continue);
   void BlockBegin(TBlock* block);
   void BlockTrunc(int trunc);
   void BlockEnd(TNode *node, bool del = false);
   int  BlockSize() const;

   const TOperProfile* Oper(const T_Lexeme &lexeme, T_BaseType left, T_BaseType right = btUnknown) const;
   void MakeBinaryOper(const char* oper, T_BaseType result, T_BaseType left, T_BaseType right);
   void MakeBinaryOper(T_Symbol::T_Type oper, T_BaseType result, T_BaseType left, T_BaseType right);
   void MakeUnaryOper(T_Symbol::T_Type oper, T_BaseType result, T_BaseType param);
   void MakeOperTable();

   void MakeGoToLabel(T_UserGoToLabel* item);
	bool Compare(const T_Lexeme &l, const T_Lexeme &r) const { return syntax->Compare(l,r); }

   bool Translate();
   bool VerifyFunc();

   T_CastType GetCastable(T_BaseType from, T_BaseType to);
   bool GenCastable(TNode* &node, T_BaseType type, int mode = 0x00); // 0x01 - code, 0x02 - const
   bool GenCastable(T_BaseType from, T_BaseType to) { int made = -1; return GenCastable(from, to, made); }
   bool GenCastable(T_BaseType from, T_BaseType to, int& made);
   void GenCommand(T_Command command, int param, int mode, T_BaseType type, int made = -1);
   void GenCommand(T_Command command, int param, T_BaseType type = btUnknown, int made = -1) { GenCommand(command,param,0,type,made); }
   void GenPop(int count, int made = -1) { if (count) GenCommand(T_Command::command_Pop,count,T_BaseType::btVoid,made); }
   void GenNumber(const T_Lexeme &lexeme);
   TNode* GetCommand(int counter);

   TNodeLabel* Merge(TNodeLabel* l1, TNodeLabel* l2);
   void Reference(TNodeLabel* label, TNodeLabel* refer);
   bool MakeLogical(TNode* &node, TNodeLabel* &true_label, TNodeLabel* &false_label);
   void MakeValue(TNodeLabel* true_label, TNodeLabel* false_label, int &made);
public:
   void print_tree(const char* title = NULL) const;
   void Result(const char* file = NULL);

public:
   enum T_Mode { tmNone = 0x000, tmVariable = 0x0001, tmCode = 0x0004, tmDefinition = 0x0008, 
      tmDirect = 0x0010, tmTree = 0x0020, tmBlock = 0x0040, tmQuad = 0x0080, 
      tmStack  = 0x0100 
   };
   bool IsTree() const { return (mode & tmTree) != 0; }
   bool IsBlock() const { return (mode & tmBlock) != 0; }
   bool IsStack() const { return (mode & tmStack) != 0; }
   bool IsVariable() const { return (mode & tmVariable) != 0; }
   bool IsDefinition() const { return (mode & tmDefinition) != 0; }
   bool IsQuad() const { return (mode & tmQuad) != 0; }
   bool IsDirect() const { return (mode & tmDirect) != 0; }
   void Mode(T_Mode m) { mode = m; }
public:
   T_Mode mode;
   TNodeDefFunc* function;
public:
   TQuadTable  QuadTable;
   T_ExecStack ExecStack;
   TIdentTable IdentTable;
   TBlockTable BlockTable;
   TFuncTable  FuncTable;
   TCodeTable  CodeTable;
   TUserGoToTable   UserGoToTable;
   TUserLabelTable  UserLabelTable;
public:
   A_Syntax* syntax;
   int       level;
   int       print_mode;
   int       block_number;
public:
   int AddInt, MultiInt;
   int code_count, quad_count;
};

TOperTable& OperTable();

class VEntry
{
public:
   VEntry(TSemantic* s, TNode* node);
   ~VEntry();
public:
   TSemantic* semantic;
};
#endif

// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "TNodes.h"
#include "TSyntax.h"

#define PARSE_EXPRESSION(NAME,FUNC,CLEAR) TNode *NAME = FUNC; if (NAME->error()) { CLEAR; return NAME; }

#define NATCH_MUST(SYM,CLEAR) if (!MatchMust(SYM)) { CLEAR; return error(); }

// --------------------------- TSyntax ---------------------------

TSyntax::TSyntax(T_Scan *s) : A_Syntax(s), program(NULL), current_error(NULL) 
{
   make_mode = mmNode;
}

TNodeError* TSyntax::error(T_Error code, const T_Lexeme &l, int value)
{
   TNodeError* err = new TNodeError();
   err->SetLexeme(l);
   Error.error(code,l,value);
   return err;
}

void TSyntax::clear(TNode* node)
{
   if (node) { node->clear(); delete node; } 
}

bool TSyntax::MatchMust(T_Symbol::T_Type t)
{
	if (Match(t)) return true;
   current_error = error(T_Error::erSymbol,t);
	return false;
}

TNode* TSyntax::Assign()
{
   TNode* left = Question(); if (left->error()) return left;
	if (Match(T_Symbol::prAssign)) {
      T_Lexeme lexeme = forward;
      PARSE_EXPRESSION(right,Assign(),clear(left))
      TNodeBinary *assign = new TNodeBinary(lexeme, left, right);
	   return assign;
	}
   return left;
}

TNode* TSyntax::Question()
{
   PARSE_EXPRESSION(expr,Binary(T_Symbol::prOrOr),)
	if (!Match(T_Symbol::prQuestion)) return expr;
   T_Lexeme lexeme = forward;
   PARSE_EXPRESSION(left,Question(),clear(expr))
   NATCH_MUST(T_Symbol::lxColon,clear(expr))
   PARSE_EXPRESSION(right,Question(),clear(expr); clear(left))
   TNodeTrio *question = new TNodeTrio(lexeme, expr, left, right);
   return question;
}

TNode* TSyntax::Unary()
{
	if (Match(T_Symbol::prUnary) || Match(T_Symbol::prTerm) || Match(T_Symbol::prIncDec)) {
      T_Lexeme lexeme = forward;
      ChangeUnary(lexeme,true);
      TNode *expr = Unary(); if (expr->error()) return expr;
      TNodeUnary *unary = new TNodeUnary(lexeme, expr);
	   return unary;
	}
   T_ScanStore store; Store(store);
   if (Match(T_Symbol::lxLeftBracket)) { // ([const] int) unary
   	int detail = Match(T_Lexeme::W_Type::rwConst) ? 0x02 : 0x00;
      if (Match(T_Lexeme::W_Type::rwDefine)) {
         T_Lexeme lexeme = forward;
         if (Match(T_Symbol::lxRightBracket)) {
            TNode *expr = Unary(); if (expr->error()) return expr;
            TNodeType *type = BaseType(lexeme,detail);
            TNodeCast *cast = new TNodeCast(lexeme, type, expr);
      	   return cast;
         }
      } else {
         if (detail) return error(erUnknownCast);
      } 
	}
   Restore(store);
   TNode *expr = Primary(); if (expr->error()) return expr;
	while (Match(T_Symbol::prIncDec)) {
      T_Lexeme lexeme = forward;
      ChangeUnary(lexeme,false);
      TNodeUnary *unary = new TNodeUnary(lexeme, expr);
      expr = unary;
   }
   return expr;
}

TNode* TSyntax::Primary()
{
   if (Match(T_Lexeme::grIdent)) {
      T_Lexeme lexeme = forward;
		if (Match(T_Symbol::lxLeftBracket)) {
         TNodeCall *call = new TNodeCall(lexeme,NULL);
			if (!Match(T_Symbol::lxRightBracket)) {
            PARSE_EXPRESSION(expr,Expressions(psValueList),clear(call))
            call->SetList((T_NodeList*)expr);
			   NATCH_MUST(T_Symbol::lxRightBracket,clear(call))
			}
			return call;
		}
		if (MatchSpot(T_Symbol::lxLeftScrape)) {
         T_NodeList *list = new T_NodeList(forward);
         TNodeIndex *index = new TNodeIndex(lexeme,list);
			while (Match(T_Symbol::lxLeftScrape)) {
            PARSE_EXPRESSION(expr,Expressions(psValue),clear(index))
				list->Add(expr);
			   NATCH_MUST(T_Symbol::lxRightScrape,clear(index))
			}
			return index;
		}
      TNodeVar *var = new TNodeVar(lexeme);
      return var;
	}
   if (Match(T_Lexeme::grInteger) || Match(T_Lexeme::grNumber)) {
      TNodeNumber *expr = new TNodeNumber(forward);
      return expr;
   }
   if (Match(T_Symbol::lxLeftBracket)) {
      T_Lexeme lexeme = forward;
      PARSE_EXPRESSION(expr,Expressions(),)
      TNodePrimary *primary = new TNodePrimary(lexeme, expr);
      NATCH_MUST(T_Symbol::lxRightBracket,clear(primary))
		return primary;
   }
   if (Match(T_Lexeme::W_Type::rwDefine)) {
      T_Lexeme lexeme = forward;
      NATCH_MUST(T_Symbol::lxLeftBracket, )
      PARSE_EXPRESSION(expr,Expressions(psValue),)
      TNodeType *type = BaseType(lexeme,0);
      TNodeCast *cast = new TNodeCast(lexeme, type, expr);
      NATCH_MUST(T_Symbol::lxRightBracket,clear(cast))
	   return cast;
   }
   return error(erPrimary);
}

TNode* TSyntax::Binary(T_Symbol::T_Priority priority)
{
   TNode *left;
   if ((priority + 1) < T_Symbol::prUnary) {
      left = Binary(T_Symbol::T_Priority(priority + 1));
   } else {
      left = Unary(); 
   }
   if (left->error()) return left;
   while (Match(priority)) {
      T_Lexeme lexeme = forward;
      TNode *right;
      if ((priority + 1) < T_Symbol::prUnary) {
         right = Binary(T_Symbol::T_Priority(priority + 1));
      } else {
         right = Unary(); 
      }
      if (right->error()) { clear(left); return right; }
      if ((priority == T_Symbol::prOrOr ) || (priority == T_Symbol::prAndAnd)) {
         left = new TNodeLogical(lexeme, left, right);
      } else {
         left = new TNodeBinary(lexeme, left, right);
      }
   }
   return left;
}

TNode* TSyntax::Expressions(T_Part part)
{
   TNodeExpressions *expression = new TNodeExpressions(forward);
   expression->part = part;
   do {
      PARSE_EXPRESSION(expr,Assign(),clear(expression))
      expression->Add(expr);
   } while (Match(T_Symbol::lxComma));
   return expression;
}

TNode* TSyntax::Compaund()
{
   TNodeStatements *compaund = new TNodeStatements();
   while (!Match(T_Symbol::lxRightCramp)) {
      PARSE_EXPRESSION(statement,Statement(T_Part::psBody),clear(compaund))
      if (!statement->null())
         compaund->Add(statement);
      else
         clear(statement);
   }
   return compaund;
}

TNode* TSyntax::Statements(T_Part part)
{
   TNodeStatements *statements = new TNodeStatements();
   while (!Match(T_Lexeme::grEof)) {
      PARSE_EXPRESSION(statement,Statement(part),clear(statements))
      if (!statement->null())
         statements->Add(statement);
      else
         clear(statement);
   }
   return statements;
}

bool TSyntax::Translate()
{
   program = Statements(T_Part::psMain);
   return !program->error();
}

TNode* TSyntax::Statement(T_Part part)
{

	if (Match(T_Symbol::lxSemicolon)) {
      if ((part & T_Part::psNoSemicolon)) return error(erSymbol);
      return new TNodeNull();
   }
   if (part & T_Part::psDefine) {
      T_Lexeme l;
      int def = SCDefine(l,0x26); // -1 - error, 0, 0x01 - define, 0x02 - const, 0x04 - static, 0x20 - void
		if (def < 0) return error(erDefine);
 		if (def) {
         if (def) forward = l;
		   return Define(part,def);
		}
	}

   if (part & T_Part::psStatement) {
      T_Lexeme lexeme;
      T_ScanStore store; Store(store);
      if (Match(lexeme,T_Lexeme::grIdent) && Match(T_Symbol::lxColon)) {
         T_NodeList *compaund = new T_NodeList();
			TNodeUserLabel* label = new TNodeUserLabel(lexeme);
         compaund->Add(label);
         PARSE_EXPRESSION(approval,Statement(T_Part::psLabel),clear(compaund))
         if (!approval->null())
            compaund->Add(approval);
         else
            clear(approval);
         return compaund;
      } 
      Restore(store);
      if (Match(T_Lexeme::W_Type::rwIf))       return If();
      if (Match(T_Lexeme::W_Type::rwFor))      return For();
      if (Match(T_Lexeme::W_Type::rwWhile))    return While();
      if (Match(T_Lexeme::W_Type::rwDo))       return Do();
      if (Match(T_Lexeme::W_Type::rwGoTo))     return GoTo();
      if (Match(T_Lexeme::W_Type::rwContinue)) return BreakContinue(T_Block::tbContinue);
      if (Match(T_Lexeme::W_Type::rwBreak))    return BreakContinue(T_Block::tbBreak);
      if (Match(T_Lexeme::W_Type::rwReturn))   return Return();
      if (Match(T_Lexeme::W_Type::rwSwitch))   return Switch();
	}

   if (part & T_Part::psCompaund) {
      if (Match(T_Symbol::lxLeftCramp)) return Compaund();
	}

   if (part & T_Part::psExpression) {
      PARSE_EXPRESSION(expr,Expressions(part),)
      if (!(part & T_Part::psNoSemicolon)) {
         NATCH_MUST(T_Symbol::lxSemicolon,clear(expr))
         }
      return expr;
	}

   return error(erStatement);
}

TNode* TSyntax::DefineParam()
{
   T_Lexeme lexeme;
   int def = SCDefine(lexeme, 0x0A); // -1 - error, 0, 0x01 - define, 0x02 - const, 0x08 - &
	if (def < 0) return error(erDefine);
   if (!def) return error(erDefine);
   T_Lexeme ident = (Match(T_Lexeme::grIdent) ? forward : empty_ident);
   TNodeType *type = BaseType(lexeme,def);
	if (MatchSpot(T_Symbol::lxLeftScrape)) {
      if (def & 0x08) { return error(erDefArr); } // reference
      T_NodeList *range = new T_NodeList(forward);
      TNodeDefArr *param = new TNodeDefArr(type,ident,range);
      int scrape = 0;
		while (Match(T_Symbol::lxLeftScrape)) {
		   if (!scrape++ && Match(T_Symbol::lxRightScrape)) {
            range->Add(new TNodeNull());
            continue;
         }
         PARSE_EXPRESSION(expr,Assign(),clear(param))
         range->Add(expr);
		   NATCH_MUST(T_Symbol::lxRightScrape,clear(param))
		}
      if (Match(T_Symbol::lxAssign)) {
         PARSE_EXPRESSION(expr,Assign(),clear(param))
         param->SetAssign(expr);
      } else if (param->BaseType() & T_BaseType::btReference) {
         error(erUninitialized);
      }
      return param;
   }
   TNodeDefVar *param = new TNodeDefVar(type,ident);
   if (Match(T_Symbol::lxAssign)) {
      PARSE_EXPRESSION(expr,Assign(),clear(param))
      param->SetAssign(expr);
   } else if (param->BaseType() & T_BaseType::btReference) {
      error(erUninitialized);
   }
   return param;
}

TNode* TSyntax::DefineParams()
{
   TNodeDefine *params = new TNodeDefine(forward);
   do {
      PARSE_EXPRESSION(param,DefineParam(),clear(params))
      TNodeDefVar *par = (TNodeDefVar*)param;
      params->Add(param);
   } while (Match(T_Symbol::lxComma));
   return params;
}

TNode* TSyntax::InitializerItem()
{
   if (MatchSpot(T_Symbol::lxLeftCramp)) return Initializer();
   return Assign();
}

TNode* TSyntax::Initializer()
{
   if (!MatchMust(T_Symbol::lxLeftCramp)) return error();
   T_NodeList *list = new T_NodeList(forward);
   if (Match(T_Symbol::lxRightCramp)) return list;
   do {
      PARSE_EXPRESSION(item,InitializerItem(),clear(list))
      list->Add(item);
   } while (Match(T_Symbol::lxComma));
   NATCH_MUST(T_Symbol::lxRightCramp,clear(list))
   return list;
}

TNode* TSyntax::DefineItem(const T_Lexeme &lexeme, T_Part part, int detail)
{
	if (Match(T_Symbol::lxAnd)) detail |= 0x08; // reference
   if (!Match(T_Lexeme::grIdent)) return error(erNoIdent);
   TNodeType *type = BaseType(lexeme,detail);
   T_Lexeme ident = forward;

   if (Match(T_Symbol::lxLeftBracket)) {
      if (!(part & psDefFunc)) { return error(erDefFunc); }
      TNodeDefFunc *func = new TNodeDefFunc(type,ident,NULL,NULL);
		if (!Match(T_Symbol::lxRightBracket)) {
         PARSE_EXPRESSION(params,DefineParams(),clear(func))
         func->SetParams((TNodeDefine*)params);
		   NATCH_MUST(T_Symbol::lxRightBracket,clear(func))
         }
      return func;
   }

   if (type->Void()) { return error(erDefVoid); }
	if (MatchSpot(T_Symbol::lxLeftScrape)) {
		if ((detail & 0x08) || (part & T_Part::psOneDef)) { return error(erDefArr); }
      T_NodeList *range = new T_NodeList();
      TNodeDefArr *arr = new TNodeDefArr(type, ident, range);
      int scrape = 0;
		while (Match(T_Symbol::lxLeftScrape)) {
		   if (!scrape++ && Match(T_Symbol::lxRightScrape)) {
            range->Add(new TNodeNull());
            continue;
         }
         PARSE_EXPRESSION(expr,Assign(),clear(arr))
         range->Add(expr);
		   NATCH_MUST(T_Symbol::lxRightScrape,clear(arr))
		}
      if (Match(T_Symbol::lxAssign)) {
         PARSE_EXPRESSION(assign,Initializer(),clear(arr))
         arr->SetAssign(assign);
      } else if (arr->BaseType() & T_BaseType::btConstReference) {
         error(erUninitialized);
      }
      return arr;
   }
   TNodeDefVar *var = new TNodeDefVar(type, ident);
   if (Match(T_Symbol::lxAssign)) {
      T_Lexeme lexeme = forward;
      PARSE_EXPRESSION(expr,Assign(),clear(var))
      var->SetAssign(lexeme,expr);
   } else if (var->BaseType() & T_BaseType::btConstReference) {
      error(erUninitialized);
   }
   if (part & T_Part::psOneDef) { // condition
      T_NodeList *list = new T_NodeList();
      list->Add(var);
	   TNodeVar *push_var = new TNodeVar(ident);
      list->Add(push_var);
      return list;
   }
   return var;
}

TNode* TSyntax::Define(T_Part part, int constant)
{
   T_Lexeme lexeme = forward;
   int count = 0, func = 0;
   TNodeType *type = BaseType(lexeme,constant);
   TNodeDefine *def = new TNodeDefine(type);
   TNodeDefFunc *function = NULL;
   do {
      PARSE_EXPRESSION(var,DefineItem(lexeme, part, constant),clear(def))
      def->Add(var);
      function = dynamic_cast<TNodeDefFunc*>(var);
      if (function) func = -1;
      count++;
      if (part & T_Part::psOneDef) break;
   } while (Match(T_Symbol::lxComma));
   if ((count == 1) && (func == -1)) {
      if (Match(T_Symbol::lxLeftCramp)) {
         PARSE_EXPRESSION(body,Compaund(),clear(def))
         function->SetBody(body);
         func = -2;
      }
   }
   if (!(part & T_Part::psNoSemicolon) && !Match(T_Symbol::lxSemicolon) && (func != -2)) { clear(def); return error(erDefine); }
   return def;
}

TNode* TSyntax::For()
{
   TNodeFor *cycle = new TNodeFor(forward);
   NATCH_MUST(T_Symbol::lxLeftBracket,clear(cycle))
   PARSE_EXPRESSION(beg,Statement(T_Part::psForBeg),clear(cycle))  // prefix
   cycle->SetBeg(beg);
   PARSE_EXPRESSION(condition,Statement(T_Part::psForExpr),clear(cycle)) // condition
   cycle->SetCondition(condition);
   if (!Match(T_Symbol::lxRightBracket)) {
      PARSE_EXPRESSION(end,Expressions(psExpression),clear(cycle)) // postfix
      cycle->SetEnd(end);
      NATCH_MUST(T_Symbol::lxRightBracket,clear(cycle))
   } else {
      cycle->SetEnd(new TNodeNull()); 
   }
   PARSE_EXPRESSION(body,Statement(T_Part::psBody),clear(cycle))   // body
   cycle->SetBody(body);
   return cycle;
}

TNode* TSyntax::While()
{
   TNodeWhile *cycle = new TNodeWhile(forward);
   NATCH_MUST(T_Symbol::lxLeftBracket,clear(cycle))
   PARSE_EXPRESSION(condition,Statement(T_Part::psCondition),clear(cycle))
   cycle->SetCondition(condition);
   NATCH_MUST(T_Symbol::lxRightBracket,clear(cycle))
   PARSE_EXPRESSION(body,Statement(T_Part::psBody),clear(cycle))
   cycle->SetBody(body);
   return cycle;
}

TNode* TSyntax::Do()
{
   TNodeDo *cycle = new TNodeDo(forward);
   PARSE_EXPRESSION(body,Statement(T_Part::psBody),clear(cycle))
   cycle->SetBody(body);
   if (!Match(T_Lexeme::W_Type::rwWhile)) { clear(cycle); return error(erStatement); }
   NATCH_MUST(T_Symbol::lxLeftBracket,clear(cycle))
   PARSE_EXPRESSION(condition,Statement(T_Part::psCondition),clear(cycle))
   cycle->SetCondition(condition);
   NATCH_MUST(T_Symbol::lxRightBracket,clear(cycle))
   NATCH_MUST(T_Symbol::lxSemicolon,clear(cycle))
   return cycle;
}

TNode* TSyntax::GoTo()
{
   if (!Match(T_Lexeme::grIdent)) return error(erNoIdent);
   T_Lexeme lexeme = forward;
   TNodeUserGoTo *statement = new TNodeUserGoTo(lexeme);
   NATCH_MUST(T_Symbol::lxSemicolon,clear(statement))
   return statement;
}

TNode* TSyntax::BreakContinue(T_Block rate)
{
   TNodeBreakContinue *statement = new TNodeBreakContinue(rate,forward);
   NATCH_MUST(T_Symbol::lxSemicolon,clear(statement))
   return statement;
}

TNode* TSyntax::If()
{
   TNodeIf *statement = new TNodeIf(forward);
   NATCH_MUST(T_Symbol::lxLeftBracket,clear(statement))
   PARSE_EXPRESSION(condition,Statement(T_Part::psCondition),clear(statement))
   statement->SetCondition(condition);
   NATCH_MUST(T_Symbol::lxRightBracket,clear(statement))
   PARSE_EXPRESSION(then_body,Statement(T_Part::psBody),clear(statement))
   statement->SetThen(then_body);
   if (Match(T_Lexeme::W_Type::rwElse)) {
      PARSE_EXPRESSION(then_else,Statement(T_Part::psBody),clear(statement))
      statement->SetElse(then_else);
   } else {
      statement->SetElse(new TNodeNull()); 
   }
   return statement;
}

TNode* TSyntax::Return()
{
   TNodeReturn *ret = new TNodeReturn(forward);
	if (Match(T_Symbol::lxSemicolon)) return ret;
   PARSE_EXPRESSION(value,Expressions(psValue),clear(ret))
   ret->SetValue(value);
   NATCH_MUST(T_Symbol::lxSemicolon,clear(ret))
   return ret;
}

TNode* TSyntax::Switch()
{
   TNodeSwitch *statement = new TNodeSwitch(forward);
   NATCH_MUST(T_Symbol::lxLeftBracket,clear(statement))
   PARSE_EXPRESSION(key,Statement(T_Part::psCondition),clear(statement))
   statement->SetKey(key);
   NATCH_MUST(T_Symbol::lxRightBracket,clear(statement))
   NATCH_MUST(T_Symbol::lxLeftCramp,clear(statement))
   T_NodeList *body = new T_NodeList();
   statement->SetBody(body);
   int case_count = 0, default_count = 0;
   do {
      TNodeSwitchItem *item = new TNodeSwitchItem();  body->Add(item);
      T_NodeList *key_item = new T_NodeList();        item->SetKey(key_item);
      T_NodeList *body_item = new T_NodeList();       item->SetBody(body_item);
      while (Match(T_Lexeme::W_Type::rwCase) || Match(T_Lexeme::W_Type::rwDefault)) {
         TNodeSwitchCase *val = new TNodeSwitchCase(forward); key_item->Add(val);
         if (forward.Match(T_Lexeme::W_Type::rwCase)) {
            case_count++; 
	         PARSE_EXPRESSION(item_val,Question(),clear(statement))
            val->SetValue(item_val);
         } else {
            if (default_count++) { clear(statement); return error(erSwitch); }
            val->value = false;
         } 
         NATCH_MUST(T_Symbol::lxColon,clear(statement))
      }
      while (!MatchSpot(T_Lexeme::W_Type::rwCase) && !MatchSpot(T_Lexeme::W_Type::rwDefault) && !MatchSpot(T_Symbol::lxRightCramp)) {
         PARSE_EXPRESSION(item_body,Statement(T_Part::psCase),clear(statement))
         body_item->Add(item_body);
      }
   } while (!Match(T_Symbol::lxRightCramp));
   if (!case_count || (default_count > 1)) { clear(statement); return error(erSwitch); }
   return statement;
}

#ifndef TRN_TREE_SYNTAX_H
#define TRN_TREE_SYNTAX_H

#include "Parse.h"
#include "ASyntax.h"
#include <stack>
 
// --------------------------- TSyntax ---------------------------
class TNode     ;
class T_NodeList;
class TNodeError;
class TNodeType ;

class TSyntax : public A_Syntax
{
public:
	TSyntax(T_Scan *s);

	TNode* Assign();	
	TNode* Question();
	TNode* Unary();
	TNode* Primary();

	TNode* Binary(T_Symbol::T_Priority priority);

	TNodeError* error() { return current_error; }
	TNodeError* error(T_Error code, int value = 0) { return error(code,lex,value); }
	TNodeError* error(T_Error code, const T_Lexeme &l, int value);
	virtual bool MatchMust(T_Symbol::T_Type t);
   virtual void clear(TNode* node);

	TNode* Expressions(T_Part part = T_Part::psNone);
   TNode* Compaund();

   TNode* Statement(T_Part part);
   TNode* Statements(T_Part part);

	TNode* Define(T_Part part, int constant); // 0x02 - static, 0x01 - const
	TNode* DefineItem(const T_Lexeme &l, T_Part part, int constant);  // 0x02 - static, 0x01 - const
   TNode* DefineParam();
   TNode* DefineParams();
   TNode* Initializer();
   TNode* InitializerItem();

	TNode* For();
	TNode* If();
	TNode* While();
	TNode* Do();
	TNode* GoTo();
	TNode* BreakContinue(T_Block rate);
	TNode* Return();
	TNode* Switch();

public:
   virtual bool Translate();
   virtual TNode* Program() { return program; }

protected:
   TNode      *program;
   TNodeError *current_error;
};

#endif
#undef YYERROR_VERBOSE
#undef YYSTACK_FREE
#undef YYNTOKENS
#undef YYMAXUTOK
#undef YYFINAL
#undef YYLAST
#undef YYNNTS
#undef YYNRULES
#undef YYNSTATES
#undef YYPACT_NINF
#undef YYTABLE_NINF
#undef yypact_value_is_default

#undef yyparse 
#undef yylex   
#undef yyerror 
#undef yylval  
#undef yychar  
#undef yydebug 
#undef yynerrs 
// Parse.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include "TSemantic.h"

// --------------------------- Variables ---------------------------

#define VARIABLES(NODE) if (NODE && !semantic.IsStack() && !semantic.IsDirect()) NODE->Variables(semantic, mode);

void TNode::After(TSemantic &semantic, int mode)
{
   if (after) {
      after->Codes(semantic, mode);
      after->After(semantic, mode & ~T_VerifyMode::mvOnAfter);
   }
}
void TNode::Before(TSemantic &semantic, int &mode)
{
   if (mode & T_VerifyMode::mvOffBefore) { mode &= ~T_VerifyMode::mvOffBefore; return; }
   if (before) {
      before->Before(semantic, mode);
      before->Codes(semantic, mode | T_VerifyMode::mvOffBefore);
   }
}

void TNodeNull::Codes(TSemantic &semantic, int mode)
{  
   Before(semantic, mode);
   After(semantic, mode);
}

bool T_NodeList::IsNull() const
{ 
   for (const TNode *node : (*this)) {
      if (!node->IsNull()) return false;
   }
   return true; 
}
void T_NodeList::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   for (TNode *node : (*this)) {
      node->Variables(semantic, mode);
   }
}
void T_NodeList::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   for (TNode *node : (*this)) {
      node->Codes(semantic, mode);
   }
   After(semantic, mode);
}
void T_NodeList::Verify(TSemantic &semantic, int mode)
{
	for (TNode *node : (*this)) {
      node->Verify(semantic, mode);
   }
}

void TNodeExpressions::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
	iterator p = begin(); 
   while (p != end()) {
      TNode *item = (*p); p++; 
      bool last = (p == end()), condition = last && (part & psIfGoTo), value = (part & psValueList) || last && (part & psValue);
      bool pop = !last && !value || last && part && !(value || condition);
      TNodeLogical* logic = item->Logical();
      if (logic) {
         if (pop) 
            logic->logical = -1;
         else if (value) 
            logic->logical = 0;
         else if (condition) 
            logic->logical = 1;
      }
      item->Codes(semantic, mode);
      if (semantic.IsQuad()) {
         if (last && !(part & psValueList)) {
            quad = item->quad;
         }
      } else {
         if (pop && !logic) {
            T_BaseType item_type = item->BaseType();
            if ((item_type != btUnknown) && (item_type != btVoid)) {
               semantic.GenPop(1);
            }
         }
      }
   }
   After(semantic, mode);
}

TNodeLogical* TNodeExpressions::Logical()
{
   return !empty() ? Last()->Logical() : NULL;
}

void TNodeUnary::Variables(TSemantic &semantic, int mode)
{  
   VEntry entry(&semantic,this);
   if (child) {
      TNodeLogical* logical = child->Logical();
      bool logic = (logical && lexeme.Match(T_Symbol::lxNot));
      if (logic) {
         logical->logical = 1;
	   } 
		VARIABLES(child); 
      if (!logic) {
         T_BaseType type = (logical) ? btCInt : child->BaseType(); 
         profile = semantic.Oper(lexeme, type);
	   	if (profile) {
	   		base_type = profile->result;
            if (profile) semantic.GenCastable(child, (*profile)[0], 0x01);
         } else {
            semantic.AddError(this,erUnknownOper);
	   	}
      }
	}
}
void TNodeUnary::Codes(TSemantic &semantic, int mode)
{  
   Before(semantic, mode);
   if (child) child->Codes(semantic, mode); 
   TNodeLogical* logical = Logical();
   if (!logical) {
      if (semantic.IsQuad()) {
         TQuadruple* quadruple = new TQuadruple(TQuadruple::qtUnary, this);
         quadruple->oper = Oper();
         quadruple->arg_one = child->quad;
         semantic.AddQuad(quadruple);
         quad = quadruple->value_number;
      } else {
         semantic.GenCommand(T_Command::command_Oper, Oper(), 0, BaseType());
      }
   }
   After(semantic, mode);
}
T_Symbol::T_Type TNodeUnary::Oper() const 
{ 
   if (profile) return profile->oper; return T_Symbol::T_Type::lxNone; 
}

TNodeLogical* TNodeUnary::Logical()
{
	return (child && lexeme.Match(T_Symbol::lxNot)) ? child->Logical() : NULL;
}

void TNodeBinary::Variables(TSemantic &semantic, int mode)
{  
   VEntry entry(&semantic,this);
   VARIABLES(left); 
   VARIABLES(right); 
	if (!left || !right) return;
   T_BaseType left_type = left->BaseType();
   if (mode_oper & 0x01) { // initialization
      left_type = TBaseType::Tilda(left_type,T_BaseType::btConst);
   }
   profile = semantic.Oper(lexeme, left_type, right->BaseType());
	if (profile && (profile->size() == 2)) {
		base_type = profile->result;
      semantic.GenCastable(left, (*profile)[0], 0x01 | ((mode_oper & 0x01) ? 0x02 : 0x00));
      semantic.GenCastable(right, (*profile)[1], 0x01);
   } else {
      profile = NULL;
      semantic.AddError(this,erUnknownOper);
	}
}
void TNodeBinary::Codes(TSemantic &semantic, int mode)
{  
   Before(semantic, mode);
   if (left) left->Codes(semantic, mode);

   if (right) right->Codes(semantic, mode);
   if (semantic.IsQuad()) {
      TQuadruple* quadruple = new TQuadruple(TQuadruple::qtBinary, this);
      quadruple->oper = Oper();
      quadruple->arg_one = left->quad;
      quadruple->arg_two = right->quad;
      semantic.AddQuad(quadruple);
      quad = quadruple->value_number;
   } else {
      semantic.GenCommand(T_Command::command_Oper,Oper(),0,BaseType());
   }
   After(semantic, mode);
}
T_Symbol::T_Type TNodeBinary::Oper() const 
{ 
   if (profile) return profile->oper; return T_Symbol::T_Type::lxNone; 
}

void TNodeTrio::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   VARIABLES(left);  // condition
   VARIABLES(mid);   // then
   VARIABLES(right); // else
   base_type = CastableBetween(mid->BaseType(),right->BaseType());
	if (base_type == btUnknown) {
      semantic.AddError(this,erUnknownCast);
   }
   TNodeLabel *true_label, *false_label, *label_end = new TNodeLabel(&semantic);
   semantic.MakeLogical(left, true_label, false_label);
   mid->InsertBefore(true_label);
   semantic.GenCastable(mid, base_type);
   TNodeGoTo* go_end = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
   mid->InsertAfter(go_end);
   right->InsertBefore(false_label);
   semantic.GenCastable(right, base_type);
   InsertAfter(label_end);
}

void TNodeTrio::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   left->Codes(semantic, mode);   // condition 
   mid->Codes(semantic, mode);    // then
   TQuadruple* quadruple = NULL;
   if (semantic.IsQuad()) {
      quadruple = new TQuadruple(TQuadruple::qtSet, this);
      semantic.AddQuad(quadruple, -1); // before go_end
      semantic.LastQuad().value_number.number++; // go_end
      quad = quadruple->value_number;
      quadruple->arg_one = quad;
      quadruple->arg_two = mid->quad;
   }
   right->Codes(semantic, mode);  // else
   After(semantic, mode);
   if (semantic.IsQuad()) {
      TQuadruple& label_end = semantic.LastQuad(); // before label_end
      int label_number = label_end.value_number.number;
      semantic.Quad().label_quad[label_number]++;
      quadruple = new TQuadruple(TQuadruple::qtSet, this);
      semantic.AddQuad(quadruple, -1); // before label_end
      quadruple->arg_one = quad;
      quadruple->arg_two = right->quad;
   }
}

void TNodeLogical::Variables(TSemantic &semantic, int mode)
{  
   VEntry entry(&semantic,this);
   VARIABLES(left); 
   VARIABLES(right); 
	bool oper_or = Lexeme().Match(T_Symbol::lxOrOr);
	TNodeLabel* left_true_label, *left_false_label;
   semantic.MakeLogical(left , left_true_label, left_false_label);
   semantic.MakeLogical(right,      true_label,      false_label);
	if (oper_or) {
      semantic.Reference(left_true_label,true_label);
   	right->InsertBefore(left_false_label);
	} else {
      semantic.Reference(left_false_label,false_label);
   	right->InsertBefore(left_true_label);
	}
   if (logical) {
      TNodeLabel *label = true_label; true_label = false_label; false_label = label;
   }
}
void TNodeLogical::Codes(TSemantic &semantic, int mode)
{  
   Before(semantic, mode);
   left->Codes(semantic, mode); 
   right->Codes(semantic, mode);
   if (logical == 0) {
      int made = -1;
      semantic.MakeValue(true_label,false_label,made);
      base_type = btCInt;
   } else if (logical == -1) {
      semantic.AddCode(false_label); semantic.AddCode(true_label);
      base_type = btVoid;
   }
   After(semantic, mode);
}

void TNodePrimary::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   VARIABLES(child); 
}
void TNodePrimary::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   child->Codes(semantic, mode); 
   if (semantic.IsQuad()) {
      quad = child->quad;
   }
   After(semantic, mode);
}

void TNodeCast::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   if (right) {
      VARIABLES(right); 
      cast = semantic.GetCastable(right->BaseType(), BaseType());
		if (cast == T_CastType::Illegal) {
         semantic.AddError(this,erUnknownCast);
      }
   }
}
void TNodeCast::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (right) right->Codes(semantic, mode);
   if (semantic.IsQuad()) {
      TQuadruple* quadruple = new TQuadruple(TQuadruple::qtCast, this);
      quadruple->oper = cast;
      quadruple->arg_one = right->quad;
      semantic.AddQuad(quadruple);
      quad = quadruple->value_number;
   } else {
      semantic.GenCommand(T_Command::command_Cast, cast, 0, BaseType());
   }
   After(semantic, mode);
}

void TNodeCall::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   profile = new TFuncProfile();
   profile->ident = lexeme;
   bool yes_error = false, yes_param = right && !right->IsNull();
   if (yes_param) {
      VARIABLES(right); // params
      T_NodeList *params = (T_NodeList*)right;
      for (TNode *param : (*params)) {
         T_BaseType param_type = param->BaseType();
         if ((param_type == btUnknown) || (param_type == btVoid)) {
            semantic.AddError(this,erUnknownParam);
            yes_error = true;
         }
         profile->Add(param_type);
      }
   }
   if (!yes_error) {
      TNodeDefFunc* func = semantic.FindFunc(*profile);
      if (func) {
         SetType(func);
         profile->result = func->profile->result;
         if (yes_param) {
            T_NodeList *params = (T_NodeList*)right;
 	         T_NodeList::iterator p = params->begin(); 
            int i = 0;
            while (p != params->end()) {
               TNode* &param = (*p); p++; 
               semantic.GenCastable(param, (*func->profile)[i++]);
            }
         }
      } else {
         semantic.AddError(this,erUnknownFunc);
      }
   }
}
void TNodeCall::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (right) right->Codes(semantic, mode); // params
	int number = -1;
	TNodeDefFunc *type = Type();
	if (type) number = type->number;
   if (semantic.IsQuad()) {
      T_NodeList* params = Params();
      int param_count = 0;
      if (params) {
         param_count = params->Count();
         for (TNode* param : (*params)) {
            TQuadruple* quadruple = new TQuadruple(TQuadruple::qtParam, param);
            quadruple->arg_one = param->quad;
            semantic.AddQuad(quadruple);
         }
      }
      TQuadruple* quadruple = new TQuadruple(TQuadruple::qtCall, this);
      quadruple->oper = number;
      quadruple->param = param_count;
      semantic.AddQuad(quadruple);
   } else {
      semantic.GenCommand(T_Command::command_Call,number,0,BaseType());
   }
   After(semantic, mode);
}

void TNodeVar::Variables(TSemantic &semantic, int mode)
{ 
   VEntry entry(&semantic,this);
   TNodeDefVar *type = NULL; 
   TFinder finder(this, TFinder::mfVar); finder.lexeme = &lexeme;
   semantic.Search(finder);
   type = (TNodeDefVar*)finder.result;
   if (type) {
      SetType(type); 
      quad = type->quad;
   } else {
      semantic.AddError(this,erUnknownIdent);
   }
}
void TNodeVar::Codes(TSemantic &semantic, int mode)
{ 
   Before(semantic, mode);
   TNodeDefVar *def_var = dynamic_cast<TNodeDefVar*>(child);
   if (def_var && !semantic.IsQuad()) {
      semantic.GenCommand(T_Command::command_PushVar,def_var->offset,def_var->alloc,def_var->BaseType()); 
   }
   After(semantic, mode);
}

void TNodeNumber::Variables(TSemantic &semantic, int mode)
{ 
   VEntry entry(&semantic,this);
}
void TNodeNumber::Codes(TSemantic &semantic, int mode)
{ 
   Before(semantic, mode);
   if (semantic.IsQuad()) {
      quad.alloc = (lexeme.group == lexeme.grInteger) ? taInteger : taNumber;
      quad.number = lexeme.value;
   } else {
      semantic.GenNumber(lexeme);
   }
   After(semantic, mode);
}

void TNodeIndex::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   TNodeDefVar* ident = NULL;
   TFinder finder(this, TFinder::mfVar); finder.lexeme = &lexeme;
   semantic.Search(finder);
   ident = (TNodeDefVar*)finder.result;
   if (ident) {
      TNodeDefArr *type = dynamic_cast<TNodeDefArr*> (ident);
      if (type) {
         SetType(type); 
         quad = type->quad;
      } else {
         semantic.AddError(this,erInvalidType);
      }
   } else {
      semantic.AddError(this,erUnknownIdent);
   }
   VARIABLES(right); // range
   for (TNode *&range : (*Ranges())) {
      semantic.GenCastable(range, btCInt, 0x00);
   }
}
void TNodeIndex::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   TNodeDefArr *def_var = dynamic_cast<TNodeDefArr*>(left);
   if (def_var) {
      if (semantic.IsQuad()) {
         TNode *range = (*Ranges())[0];
         range->Codes(semantic, mode);
         TQuadruple* quadruple = new TQuadruple(TQuadruple::qtSet, NULL);
         semantic.AddQuad(quadruple);
         TAddress index = quadruple->value_number;
         quadruple->arg_one = index;
         quadruple->arg_two = range->quad;
         for (int r = 1; r < (int)Ranges()->size(); r++) {
            range = (*Ranges())[r];
            range->Codes(semantic, mode);
            quadruple = new TQuadruple(TQuadruple::qtBinary, NULL);
            quadruple->oper = T_Symbol::lxMultiAssign;
            quadruple->arg_one = index;
            quadruple->arg_two = def_var->quad; quadruple->arg_two.number += r;
            semantic.AddQuad(quadruple);
            quadruple = new TQuadruple(TQuadruple::qtBinary, NULL);
            quadruple->oper = T_Symbol::lxAddAssign;
            quadruple->arg_one = index;
            quadruple->arg_two = range->quad;
            semantic.AddQuad(quadruple);
         }
         quadruple = new TQuadruple(TQuadruple::qtIndex, this);
         semantic.AddQuad(quadruple);
         quad = quadruple->value_number;
         T_CastType result_type = semantic.GetCastable(Owner()->BaseType(), T_BaseType(Owner()->BaseType() | T_BaseType::btReference));
         if (result_type == T_CastType::None) {
            quadruple->arg_one = index;
            quadruple->arg_two = def_var->quad;
            quadruple->result = def_var->quad;
         } else {
            quadruple->arg_one = def_var->quad;
            quadruple->arg_two = index;
            quadruple->result = quad;
         }
      } else {
         if (right) right->Codes(semantic, mode); // range
         semantic.GenCommand(T_Command::command_PushArr, def_var->offset, def_var->alloc, def_var->BaseType());
      }
   }
   After(semantic, mode);
}

// --------------------------- Define ---------------------------

void TNodeDefVar::SetAssign(const T_Lexeme& lexeme, TNode* expr, TSemantic* semantic)
{
	TNodeVar *lvar = new TNodeVar(this->Lexeme());
   TNodeExpressions *expression = new TNodeExpressions();
   expression->Add(expr);
   expression->part = psValue;
   TNodeBinary *assign = new TNodeBinary(lexeme, lvar, expression);
   assign->mode_oper = 0x01;// initialization
   expression = new TNodeExpressions();
   expression->Add(assign);
   expression->part = psExpression;
   SetAssign(expression);
   if (semantic && semantic->IsStack()) {
      lvar->SetType(this);
      expression->Variables(*semantic, 0x00);
   }
}

void TNodeDefVar::TreeOffset(TSemantic &semantic)
{
   TFinder finder(semantic, TFinder::mfDuplicateSearch); finder.lexeme = &lexeme;
   if (Search(finder)) {
      semantic.AddError(this, erDuplicateIdent);
   }

   TNode* node = this;
   while (node) {
      TBlock* block = dynamic_cast<TBlock*> (node);
      if (block) {
         offset = block->offset + block->size;
         block->size += dimension + 1;
         break;
      }
      node = node->Owner();
   }
}

void TNodeDefVar::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   if (semantic.IsBlock()) {
      semantic.AddDef(this);
   } else if (semantic.IsTree()) {
      TreeOffset(semantic);
   }

   quad.alloc = alloc; quad.number = offset;
   VARIABLES(right); // assign
}
void TNodeDefVar::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (semantic.IsQuad()) {
   } else {
      semantic.GenCommand(T_Command::command_NewVar, offset, alloc, BaseType());
   }
   if (right) right->Codes(semantic, mode); // assign
   After(semantic, mode);
}
void TNodeDefVar::Verify(TSemantic &semantic, int mode)
{
   T_BaseType type = BaseType();
   bool must_initial = (alloc == T_Alloc::taNone) || 
                       (alloc != T_Alloc::taParam) && (type & T_BaseType::btConstReference) ||
                       (alloc == T_Alloc::taParam) && (type & T_BaseType::btReference);
   if (!right && must_initial) {
      semantic.AddError(this,erUninitialized);
   }
}

int TDefArrRange::calc()
{
   int volume = 1;
   for (int r = (int)size() - 1; r >= 0; r--) {
      TDefArrRangeItem &item = (*this)[r];
      if (r && (item.range < 1)) return 0;
      volume *= item.range;
      item.volume = volume;
      if (r == ((int)size() - 1)) item.index = -1;
   }
//   printf("\ncalc: level=%d, volume=%d", level, volume);
   return volume;
}

int TDefArrRange::offset() const
{
   int offset_ = 0, volume = 1;
   for (int r = (int)size() - 1; r >= 0; r--) {
      const TDefArrRangeItem &item = (*this)[r];
      offset_ += volume * item.index;
      volume *= item.range;
   }
//   printf("\noffset: level=%d, offset=%d", level, offset_);
   return offset_;
}

bool TDefArrRange::next()
{
//   printf("\nnext: level=%d", level);
   for (int r = (int)size() - 1; r >= 0; r--) {
      TDefArrRangeItem &item = (*this)[r];
      if ((++item.index < item.range) || (!r && (item.range < 0))) return true;
      for (int p = r; p < (int)size(); p++) {
         (*this)[p].index = 0;
      }
   }
   return false;
}

void TDefArrRange::jump(int level)
{
//   printf("\njump: p_level=%d, t_level=%d", level, this->level);
   if (!level) return;
   int r = (int)size() - 1;
   (*this)[r--].index = -1;
   for (; r > level; r--) {
      TDefArrRangeItem &item = (*this)[r];
      item.index = 0;
   }
   for (; r >= 0; r--) {
      TDefArrRangeItem &item = (*this)[r];
      if ((++item.index < item.range) || (!r && (item.range < 0))) break;
      item.index = 0;
   }
}

bool TDefArrRange::variable_range() const
{
   for (int r = 0; r < (int)size(); r++) {
      const TDefArrRangeItem &item = (*this)[r];
      if (item.range < -1) return true;
   }
   return false;
}

bool TNodeDefArr::parse_init(T_NodeList *items, int level)
{
   for (unsigned int item = 0; item < items->size(); item++) {
      T_NodeList *list = dynamic_cast<T_NodeList*> ((*items)[item]);
      if (list) {
         if ((level + 1) >= ranges.count()) return false;
         if (!parse_init(list,level + 1)) return false; 
      } else {
         if (!ranges.next()) return false;
         TDefArrInitItem init(ranges.offset(), (*items)[item]);
         initializer.push_back(init);
      }
   }
   ranges.jump(level);
   return true;
}

void TNodeDefArr::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   dimension = (int)Range()->size();
   if (semantic.IsBlock()) {
      semantic.AddDef(this);
   } else if (semantic.IsTree()) {
      TreeOffset(semantic);
   }
   quad.alloc = alloc; quad.number = offset;
   VARIABLES(mid); // range
   bool unknown_range = false, variable_range = false;
   for (TNode *&node : (*Range())) {
      if (ranges.empty() && node->IsNull()) {
         ranges.push_back(-1);
         unknown_range = true;
      } else {
         const TNodeNumber *number = dynamic_cast<const TNodeNumber*>(node);
         if (number && (number->BaseType() == btCInt)) {
            int value = semantic.syntax->Integer(number->Lexeme());
            if (value > 0) {
               ranges.push_back(value);
            } else {
               semantic.AddError(this,erRanges);
            }
         } else {
            ranges.push_back(-2);
            variable_range = true;
            semantic.GenCastable(node, btCInt, 0x00);
         }
      }
   }
   if (right && variable_range) {
      semantic.AddError(this,erInvalidInit);
   }
   if (error()) return;
   ranges.calc();

   if (right) {
      VARIABLES(right); // assign
      T_NodeList* init_list = dynamic_cast<T_NodeList*>(right);
      if (init_list) {
         if (parse_init(init_list, 0)) {
            if (unknown_range) {
               ranges[0].range = ranges[0].index;
               if (ranges.count() == 1) ranges[0].range++;
            }
         } else {
            semantic.AddError(this, erInvalidInit);
         }
      }
      for (unsigned int item = 0; item < initializer.size(); item++) {
         TDefArrInitItem& init = initializer[item];
         if (!semantic.GenCastable(init.value, TBaseType::Const(BaseType()), 0x00)) {
            semantic.AddError(this, erUnknownCast);
         }
      }
   }
   if (unknown_range) {
      TNode *range =  new TNodeCommand(T_Command::command_PushInt,ranges[0].range,0,btCInt); 
      GarbageCollectorAdd((*Range())[0], 0x01);
      (*Range())[0] = range;
   }
}
void TNodeDefArr::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   Range()->Codes(semantic, mode); // range
   int count = ranges.count();
   semantic.GenCommand(T_Command::command_NewArr,count,alloc,BaseType()); 
   if (right) { // assign
      for (unsigned int item = 0; item < initializer.size(); item++) {
         TDefArrInitItem& init = initializer[item];
         init.value->Codes(semantic, mode);
         semantic.GenCommand(T_Command::command_PushInt,init.offset,0,btCInt);
         semantic.GenCommand(T_Command::command_InitArr,offset,alloc,BaseType()); 
      }
   }
   After(semantic, mode);
}

void TNodeDefFunc::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   semantic.function = this;
   BlockBegin(semantic);
   profile = new TFuncProfile();
   profile->result = left->BaseType();
   profile->ident = Lexeme();
   if (right && !right->IsNull()) {
      VARIABLES(right); // params
      for (TNode *node : (*right)) {
         TNodeDefVar *param = (TNodeDefVar*)node;
         profile->Add(param->BaseType());
      }
   }
   semantic.AddFunc(this);
   if (mid) {
      int exec_mode = T_ExecMode::meNone;
      semantic.ExecStack.Push();
      VARIABLES(mid); // body
      exec_mode = semantic.ExecStack.Pop();
      if (!(exec_mode & T_ExecMode::meRestituer)) {
         if ((TBaseType::Tilda(BaseType(),T_BaseType::btStatic) != T_BaseType::btVoid) && (BaseType() != T_BaseType::btUnknown)) {
            semantic.AddError(this,erNoReturn);
         }
      }
   
      if (semantic.IsBlock()) {
         semantic.UserGoToTable.Verify();
         semantic.UserLabelTable.Verify();
         semantic.UserGoToTable.clear();
         semantic.UserLabelTable.clear();
      }

      if (!semantic.IsQuad()) {
         TNodeCommand* command = new TNodeCommand(T_Command::command_Exit, number, 0, T_BaseType::btVoid);
         InsertAfter(command);
      }
   }
   BlockEnd(semantic);
   semantic.function = NULL;
}
void TNodeDefFunc::Codes(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic, this);
   semantic.function = this;
   if ((mode & T_VerifyMode::mvNoFunction)/* || !mid*/) return;
   Before(semantic, mode);
//   if (right) right->Codes(semantic, mode); // params
   if (mid) mid->Codes(semantic, mode); // body
   After(semantic, mode);
   if (!semantic.IsQuad()) {
      if (semantic.syntax->option & T_OptionMode::omEraseCode) semantic.Code().Erase();
      semantic.Code().Labels();
   }
   semantic.function = NULL;
}
void TNodeDefFunc::Verify(TSemantic &semantic, int mode)
{
   if (right) right->Verify(semantic, mode); // params
   if (mid) mid->Verify(semantic, mode); // body
}

void TNodeDefine::Variables(TSemantic &semantic, int mode)
{
   T_Alloc alloc = T_Alloc::taLocal;
   if (semantic.IsTree()) {
      if (dynamic_cast<TNodeDefFunc*>(owner)) {
         alloc = T_Alloc::taParam;
      } else if (!owner->Owner()) {
         alloc = T_Alloc::taGlobal;
      }
   }
   TNodeType *define_type = Type();
   for (TNode *node : (*this)) {
      if (TNodeDefVar* var = dynamic_cast<TNodeDefVar*>(node)) {
         TNodeType* type = var->Type();
         if (!type) type = define_type;
         if (var->referenced) {
            type = TBaseType::Or(type, T_BaseType::btReference);
         }
         var->SetType(type);
         if (semantic.IsTree()) var->alloc = alloc;
      }
      node->Variables(semantic, mode);
   }
}
void TNodeDefine::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   T_NodeList::Codes(semantic, mode); 
   After(semantic, mode);
}

// --------------------------- Label, GoTo ---------------------------

TNodeLabel* TNodeLabel::Reference() const 
{ 
   if (!reference) return NULL;
   TNodeLabel* ref = reference; 
   while (ref->reference) {
      if (ref == ref->reference) {
         return NULL; 
      }
      ref = ref->reference;
   }
   return ref; 
}
void TNodeLabel::SetReference(TNodeLabel* r) 
{
   if (r) { r = r->Label(); r->go_to += go_to; go_to = 0; } reference = r; 
}

TNodeLabel* TNodeGoTo::GetLabel()
{
   TNodeLabel* l = (TNodeLabel*)child; if (l) l = l->Label();
   return l;
}

TNodeLabel* TSemantic::Merge(TNodeLabel* l1, TNodeLabel* l2)
{
   TNodeLabel* l = new TNodeLabel(this); l1->SetReference(l); l2->SetReference(l);
   GarbageCollectorAdd(l1, 0x01);  GarbageCollectorAdd(l2, 0x01);
   return l;
}
void TSemantic::Reference(TNodeLabel* label, TNodeLabel* refer)
{
   label->SetReference(refer);  GarbageCollectorAdd(label, 0x01);
}

void TNodeGoTo::SetLabel(TNodeLabel* l) 
{ 
   TNodeLabel* label = child; if (label) { label = label->Label(); label->go_to--; }
   if (l) { l = l->Label(); l->go_to++; } child = l;
}

TNodeLabel::TNodeLabel(TSemantic* semantic) :T_NodeOne(), reference(NULL), go_to(0), command(-1)
{
   if (semantic && semantic->IsQuad()) {
      quad.alloc = T_Alloc::taLabel;
      semantic->ValueNumber(quad);
   }
}

TNodeLabel::TNodeLabel(const T_Lexeme& l) :T_NodeOne(l, NULL), reference(NULL), go_to(0), command(-1)
{
}

void TNodeLabel::Codes(TSemantic &semantic, int mode)
{
   if (!Reference()) {
      if (semantic.IsQuad()) {
         TQuadruple* quadruple = new TQuadruple(TQuadruple::qtLabel, this);
         quadruple->value_number = quad;
         semantic.AddQuad(quadruple);
      } else {
         semantic.AddCode(this);
      }
   }
}
void TNodeGoTo::Codes(TSemantic &semantic, int mode)
{
   if (semantic.IsQuad()) {
      TNodeLabel *label = GetLabel();
      if (label) {
         TQuadruple* quadruple = new TQuadruple(TQuadruple::qtGoto, this);
         quadruple->oper = type;
         quadruple->arg_one = label->quad;
         if ((type == T_GoTo::tgIf) || (type == T_GoTo::tgElse)) {
            quadruple->arg_two = Owner()->quad;
         }
         semantic.AddQuad(quadruple);
      }
   } else {
      if (del_count) semantic.GenPop(del_count);
      semantic.AddCode(this);
   }
}

void TNodeUserGoTo::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   semantic.MakeGoToLabel(this);
   if (semantic.IsTree()) {
      TFinder finder(semantic, TFinder::mfLabel); finder.lexeme = &lexeme;
      if (Search(finder)) {
         SetLabel((TNodeLabel*)finder.result);
      } else {
         semantic.AddError(this, erUnknownLabel);
      }
   } else if (semantic.IsBlock()) {
      semantic.UserGoToTable.Add(this);
   }
   semantic.ExecStack.GoTo();
}
void TNodeUserGoTo::Verify(TSemantic &semantic, int mode)
{
   if (semantic.IsTree()) {
      const TNodeUserLabel* label = (const TNodeUserLabel*)GetLabel();
      if (label && !label->Compare(*this)) {
         semantic.AddError(this, erErrorLabel);
      }
   }
}
void TNodeUserGoTo::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   TNodeUserLabel *label = (TNodeUserLabel*)GetLabel();
   if (label) {
      int label_offset = 0, goto_offset = 0;
      for (const T_UserGoToItem& item : (*label)) { label_offset += item.offset; }
      for (const T_UserGoToItem& item : (*this))  { goto_offset  += item.offset; }
      del_count = goto_offset - label_offset;
	   TNodeGoTo::Codes(semantic, mode);
   }
   After(semantic, mode);
}

void TNodeUserLabel::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   if (semantic.IsQuad() && (quad.alloc == T_Alloc::taNone)) {
      quad.alloc = T_Alloc::taLabel;
      semantic.ValueNumber(quad);
   }
   semantic.MakeGoToLabel(this);
   if (semantic.IsTree()) {
      TFinder finder(semantic, TFinder::mfLabel); finder.lexeme = &lexeme;
      if (Search(finder)) {
         semantic.AddError(this, erDuplicateLabel);
      }
   } else if (semantic.IsBlock()) {
      semantic.UserLabelTable.Add(this);
   }
   semantic.ExecStack.Label();
}
void TNodeUserLabel::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (semantic.IsQuad()) {
      TQuadruple* quadruple = new TQuadruple(TQuadruple::qtLabel, this);
      quadruple->value_number = quad;
      semantic.AddQuad(quadruple);
   } else {
      semantic.AddCode(this);
   }
   After(semantic, mode);
}
void TNodeUserLabel::Verify(TSemantic &semantic, int mode)
{
   if (semantic.IsTree() && !go_to) {
      semantic.AddError(this, erUnusedLabel);
   }
}

void TNodeBreakContinue::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   FindLabel(semantic);
   semantic.ExecStack.GoTo();
}
void TNodeBreakContinue::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   TNodeGoTo::Codes(semantic, mode);
   After(semantic, mode);
}

void TNodeReturn::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   TFinder finder(this, TFinder::mfFunctionType); finder.lexeme = &lexeme;
   if (semantic.Search(finder)) {
      if (TNodeType* type = (TNodeType*)finder.result) {
         base_type = type->BaseType();
      }
   }
   if (child) {
      VARIABLES(child); 
      if (!semantic.GenCastable(child, base_type, 0x00)) {
         semantic.AddError(this, erUnknownCast);
      }
   } else {
      if ((base_type != T_BaseType::btVoid) && (base_type != T_BaseType::btUnknown)) {
         semantic.AddError(this, erNoValue);
      }
   }
   semantic.ExecStack.Return();
}
void TNodeReturn::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (child) {
      child->Codes(semantic, mode); 
   }
   if (semantic.IsQuad()) {
      TQuadruple* quadruple = new TQuadruple(TQuadruple::qtReturn, this);
      if (child) quadruple->arg_one = child->quad;
      semantic.AddQuad(quadruple);
   } else {
      semantic.GenCommand(T_Command::command_Return, 0, base_type);
   }
   After(semantic, mode);
}

// --------------------------- Statements ---------------------------

#define FOR_CODE_1243_
void TNodeFor::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   BlockBegin(semantic);
   VARIABLES(left);  // prefix
   VARIABLES(mid);   // condition
   VARIABLES(right); // postfix
   TNodeLabel *label_condition = new TNodeLabel(&semantic), *label_body = NULL, *label_end;
   TNodeLabel *label_continue = new TNodeLabel(&semantic), *&label_break = label_end;
   mid->InsertBefore(label_condition);
   if (!mid->IsNull()) {
      semantic.MakeLogical(mid, label_body, label_end);
      four->InsertBefore(label_body);
   } else  {
#if !defined(FOR_CODE_1243)
      label_body = new TNodeLabel(&semantic);
      four->InsertBefore(label_body);
#endif
      label_end = new TNodeLabel(&semantic);
   }

   semantic.ExecStack.Push();
   BreakContinueLabel(label_break, label_continue);

   VARIABLES(four);   // body

#if !defined(FOR_CODE_1243)
   TNodeGoTo* go_continue = new TNodeGoTo(T_GoTo::tgGoTo,label_continue); 
   four->InsertAfter(go_continue);
#endif
    
   semantic.ExecStack.Down();

   right->InsertBefore(label_continue); // postfix
   TNodeGoTo* go_cycle = new TNodeGoTo(T_GoTo::tgGoTo,label_condition); 
   right->InsertAfter(go_cycle);
   InsertAfter(label_end);
   BlockEnd(semantic);
}
void TNodeFor::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   left->Codes(semantic, mode);   // prefix
   mid->Codes(semantic, mode );   // condition
#if defined(FOR_CODE_1243)
   four->Codes(semantic, mode);   // body
   right->Codes(semantic, mode);  // postfix
#else
   right->Codes(semantic, mode);  // postfix
   four->Codes(semantic, mode);   // body
#endif
   After(semantic, mode);
}
void TNodeFor::Verify(TSemantic &semantic, int mode)
{
   left ->Verify(semantic, mode);  // prefix
   mid  ->Verify(semantic, mode ); // condition
   right->Verify(semantic, mode);  // postfix
   four ->Verify(semantic, mode);  // body
}

void TNodeWhile::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   BlockBegin(semantic);
   TNodeLabel *label_body, *label_end;
   VARIABLES(left); // condition 
   semantic.MakeLogical(left, label_body, label_end);

   TNodeLabel *label_while = new TNodeLabel(&semantic);
   left->InsertBefore(label_while);
   
   semantic.ExecStack.Push();

   BreakContinueLabel(label_end, label_while);
   VARIABLES(right); // body 
    
   semantic.ExecStack.Down();
   
   right->InsertBefore(label_body);
   TNodeGoTo* go_cycle = new TNodeGoTo(T_GoTo::tgGoTo,label_while);
   right->InsertAfter(go_cycle);
   InsertAfter(label_end);

   BlockEnd(semantic);
}
void TNodeWhile::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   left->Codes(semantic, mode); 
   if (right) right->Codes(semantic, mode); // body 
   After(semantic, mode);
}
void TNodeWhile::Verify(TSemantic &semantic, int mode)
{
   left->Verify(semantic, mode); 
   if (right) right->Verify(semantic, mode); // body 
}

void TNodeDo::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   BlockBegin(semantic);
   TNodeLabel *label_do, *label_end;
   VARIABLES(left); // condition 
   semantic.MakeLogical(left, label_do, label_end);
   
   InsertBefore(label_do);
   TNodeLabel *label_while = new TNodeLabel(&semantic);
   left->InsertBefore(label_while);
   InsertAfter(label_end);

   semantic.ExecStack.Push();

   BreakContinueLabel(label_end, label_while);
   VARIABLES(right); // body 
    
   semantic.ExecStack.Down();
   
   BlockEnd(semantic);
}
void TNodeDo::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (right) right->Codes(semantic, mode); // body 
   left->Codes(semantic, mode); 
   After(semantic, mode);
}
void TNodeDo::Verify(TSemantic &semantic, int mode)
{
   if (right) right->Verify(semantic, mode); // body 
   left->Verify(semantic, mode); 
}

void TNodeIf::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   BlockBegin(semantic);
   TNodeLabel *true_label, *false_label;
   VARIABLES(left);    // condition
   TNode* *my_left = &left; 
   if (T_NodeList* condition_def = dynamic_cast<T_NodeList*>(left)) {
      my_left = &condition_def->back();
   }
   semantic.MakeLogical(*my_left, true_label, false_label);

   trunc = size;
   int then_exec = 0, else_exec = 0;
   semantic.ExecStack.Push();
   VARIABLES(mid);    // then
   then_exec = semantic.ExecStack.Pop();

   semantic.ExecStack.Push();
   if (semantic.IsBlock()) semantic.BlockTrunc(trunc);
   VARIABLES(right);  // else
   else_exec = semantic.ExecStack.Pop();
   semantic.ExecStack.Up(then_exec & else_exec);

   TNodeLabel *label_end = new TNodeLabel(&semantic);
   mid->InsertBefore(true_label);     // then
   TNodeGoTo* go_then = new TNodeGoTo(T_GoTo::tgGoTo,label_end);
   mid->InsertAfter(go_then);
   right->InsertBefore(false_label);  // else
   InsertAfter(label_end);
   BlockEnd(semantic);
}
void TNodeIf::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   left->Codes(semantic, mode);// condition
   if (mid) mid->Codes(semantic, mode); // then
   if (right) right->Codes(semantic, mode);  // else
   After(semantic, mode);
}
void TNodeIf::Verify(TSemantic &semantic, int mode)
{
   left->Verify(semantic, mode);// condition
   if (mid) mid->Verify(semantic, mode); // then
   if (right) right->Verify(semantic, mode);  // else
}

void TNodeSwitchItem::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   BlockBegin(semantic);
   VARIABLES(right); // body 
   BlockEnd(semantic);
}
void TNodeSwitchItem::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (right) right->Codes(semantic, mode); // body 
   After(semantic, mode);
}

void TNodeSwitch::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   BlockBegin(semantic);
   VARIABLES(right); // body 
   BlockEnd(semantic);
}
void TNodeSwitch::Codes(TSemantic &semantic, int mode)
{
   Before(semantic, mode);
   if (right) right->Codes(semantic, mode); // body 
   After(semantic, mode);
}

void TNodeStatements::Variables(TSemantic &semantic, int mode)
{
   VEntry entry(&semantic,this);
   BlockBegin(semantic);
   T_NodeList::Variables(semantic, mode);
   BlockEnd(semantic);
};

// --------------------------- Search ---------------------------

bool TFinder::Compare(const T_Lexeme& l)
{
   return semantic->Compare(*lexeme, l);
}

void TFinder::Reset(int m)
{
   mode = m; level = 0; count = 0;
   result = NULL;
}

bool TNode::Search(TFinder& finder)
{
   if (!owner) return false;
   finder.place = this;
   finder.level++;
   return owner->Search(finder);  
}

bool TNode::SearchInside(TFinder& finder)
{
   return false;
}

bool T_NodeList::Search(TFinder& finder)
{
   TNode* skip = finder.place;
   for (const_reverse_iterator r = rbegin(); r < rend(); r++) {
      TNode* child = (*r);
      if (skip) {
         if (finder.mode == TFinder::mfLabel) {
            if (skip == child) continue;
         } else {
            if (skip == child) skip = NULL;
            continue;
         }
      }
      if (child->SearchInside(finder)) return true;
   }
   if ((finder.mode & TFinder::mfDuplicateSearch) && dynamic_cast<TBlock*> (this)) return false;
   return TNode::Search(finder);
}

bool T_NodeList::SearchInside(TFinder& finder)
{
   if ((finder.mode == TFinder::mfLabel) || (finder.mode == TFinder::mfVar) && finder.IsStack()) {
      for (TNode* child : (*this)) {
         if (child->SearchInside(finder)) return true;
      }
   }
   return false;
}

bool TNodeStatements::Search(TFinder& finder)
{
   return T_NodeList::Search(finder);
}

bool TNodeDefFunc::Search(TFinder& finder)
{
   if (finder.mode & TFinder::mfFunction) {
      finder.result = this;
      return true;
   }
   if (finder.mode & TFinder::mfOffset) return false;
   if (right && (right != finder.place)) {
      if (right->SearchInside(finder)) return true;
   }
   if (finder.mode & TFinder::mfDuplicateSearch) return false;
   return TNode::Search(finder);
}

bool TNodeExpressions::Search(TFinder& finder)
{
   return TNode::Search(finder);
}

bool TNodeDefVar::SearchInside(TFinder& finder)
{
   if (finder.mode & TFinder::mfOffset) finder.count++;
   if (!(finder.mode & TFinder::mfVar) && !(finder.mode & TFinder::mfDuplicateSearch) || !finder.Compare(lexeme)) return false;
   finder.result = this;
   return true;
}

bool TNodeDefine::Search(TFinder& finder)
{
   for (TNode* child : (*this)) {
      if ((finder.mode & (TFinder::mfDuplicateSearch | TFinder::mfOffset)) && (child == finder.place)) break;
      if (child->SearchInside(finder)) return true;
      if (child == finder.place) break;
   }
   return TNode::Search(finder);
}

bool TNodeDefine::SearchInside(TFinder& finder)
{
   for (TNode* child : (*this)) {
      if (child->SearchInside(finder)) return true;
   }
   return false;
}

bool TNodeFor::Search(TFinder& finder)
{
   if (left && (left != finder.place)) {
      if (left->SearchInside(finder)) return true;
   }
   if (finder.mode & TFinder::mfDuplicateSearch) return false;
   return TNode::Search(finder);
}

bool TNodeFor::SearchInside(TFinder& finder)
{
   if ((finder.mode == TFinder::mfLabel) && Body()) return Body()->SearchInside(finder);
   return false;
}

bool TNodeWhile::SearchInside(TFinder& finder)
{
   if ((finder.mode == TFinder::mfLabel) && Body()) return Body()->SearchInside(finder);
   return false;
}

bool TNodeDo::SearchInside(TFinder& finder)
{
   if ((finder.mode == TFinder::mfLabel) && Body()) return Body()->SearchInside(finder);
   return false;
}

bool TNodeIf::SearchInside(TFinder& finder)
{
   if (finder.mode == TFinder::mfLabel) {
      if (Then() && Then()->SearchInside(finder)) return true;
      if (Else()) return Else()->SearchInside(finder);
   }
   return false;
}

bool TNodeUserLabel::SearchInside(TFinder& finder)
{
   if ((finder.mode != TFinder::mfLabel) || !finder.Compare(lexeme)) return false;
   finder.result = this;
   return true;
}

// --------------------------- Command ---------------------------

void TNodeCommand::Codes(TSemantic &semantic, int mode)
{
   semantic.AddCode(this); 
}

#include "define_title.cpp"

static const char* command_title[] = { "None", "Cast", "Oper", "Call", "GoTo", "Label", "NewVar", "NewArr", 
                                       "PushVar", "PushVal", "PushArr", "PushAal", "PushInt", "PushNum", "Pop", "Return", "Exit", "InitArr" };
static const char* command_title_mode_goto[] = { "None", "If", "Else", "GoTo" };
static const char* command_title_alloc[] = { "None", "Global", "Local", "Param" };

const char* title_cast_type(T_CastType cast) { return cast_type_title[cast]; }
const char* title_command_mode_goto(int mode) { return command_title_mode_goto[mode]; }

void TNodeCommand::print(int level, FILE *file, int print_mode) const
{
   TNode::print(level,file,print_mode);
   print_offset(level + 1,false,file); 
   fprintf(file,"command = %-10s",command_title[command]);
   if (command == T_Command::command_Oper)
      fprintf(file,", oper  = %-14s",lexeme_type_title((T_Symbol::T_Type)param));
   else if (command == T_Command::command_Cast)
      fprintf(file,", cast  = %-14s",cast_type_title[param]);
   else if (command == T_Command::command_GoTo)
      fprintf(file,", label = %03d, %-4s ",param,title_command_mode_goto(mode));
   else if (command == T_Command::command_NewArr)
      fprintf(file,", range = %03d, %-6s ",param,command_title_alloc[mode]);
   else if ((command >= T_Command::command_PushVar) && (command <= T_Command::command_PushAal) || (command == T_Command::command_InitArr) || (command == T_Command::command_NewVar))
      fprintf(file,", addr  = %03d, %-6s ",param,command_title_alloc[mode]);
   else 
      fprintf(file,", param = %03d",param);
   fprintf(file,", mode = %03d, type = %-10s",mode,TBaseType::Title(base_type));
}

void TNodeCommand::write(FILE *file, int print_mode) const
{
   fprintf(file,"command = %-10s",command_title[command]);
   if (command == T_Command::command_Oper)
      fprintf(file,", oper  = %-14s",lexeme_type_title((T_Symbol::T_Type)param));
   else if (command == T_Command::command_Cast)
      fprintf(file,", cast  = %-14s",cast_type_title[param]);
   else if (command == T_Command::command_GoTo)
      fprintf(file,", label = %03d, %-4s ",param,command_title_mode_goto[mode]);
   else if (command == T_Command::command_NewArr)
      fprintf(file,", range = %03d, %-6s ",param,command_title_alloc[mode]);
   else if ((command >= T_Command::command_PushVar) && (command <= T_Command::command_PushAal) || (command == T_Command::command_InitArr) || (command == T_Command::command_NewVar))
      fprintf(file,", addr  = %03d, %-6s ",param,command_title_alloc[mode]);
   else 
      fprintf(file,", param = %03d",param);
   fprintf(file,", mode = %03d, type = %-10s",mode,TBaseType::Title(base_type));
}

void TNodeDel::Codes(TSemantic &semantic, int mode)
{
   if (!semantic.IsQuad()) {
      if (count) semantic.GenPop(count);
   }
   GarbageCollectorAdd(this, 0x01);
}

void TNodeDel::print(int level, FILE *file, int print_mode) const
{
   TNode::print(level, file, print_mode);
   print_offset(level + 1, false, file); fprintf(file, "delete=%02d", count);
}


VEntry::VEntry(TSemantic* s, TNode* node) 
   :semantic(s) 
{ 
   if (semantic->print_mode & 0x0000) { // T_OptionMode::omPrintTree
      node->TNode::print(semantic->level);
   }
   semantic->level++; 
}
VEntry::~VEntry() 
{ 
   semantic->level--; 
}

#include "stdafx.h"

#include "YSyntax.h"
#include "TSemantic.h"

// --------------------------- YSyntax ---------------------------

bool YSyntax::MakerYACC(const GSymbol& sym, T_Lexeme_SNode* S0, T_Lexeme_SNode* S1, int maker_index)
{
   const int S_count = 15;
   T_Lexeme_SNode* data_stack[S_count] = {};
   for (int s = 1; s < S_count; s++) {
      data_stack[s] = S1 + s - 1;
   }
   data_stack[0] = S0;
   return MakerSyntaxNode(sym,data_stack,maker_index);
}

void YSyntax::print_symbol(const GSymbol& symbol, int print_mode)
{
   symbol.print(grammar,print_mode);
}

bool YSyntax::Translate()
{
   bool ret = false;
   if (!Match(T_Lexeme::grEof)) {
//      syntax_lexeme = T_SyntaxLexeme::slNone;
      ret = ParseYACC();
   } else {
      ret = true;
   }
   return ret;
}

// --------------------------- ParseYACC ---------------------------
int yylex (void *yylval, void *param)
{
   YSyntax* syntax = (YSyntax*)param; 
   T_Lexeme current_lexeme;
   syntax->Lexeme(current_lexeme);
   (*(T_Lexeme_SNode*)yylval).lexeme = current_lexeme;
   int token = !current_lexeme.Match(T_Lexeme::grEof) ? ((current_lexeme.group << 8) | current_lexeme.type) : 0;
   return token;
}

void yyerror(const char* mess)
{
   printf("%s\n",mess);
}

bool YSyntax::ParseYACC()
{
   int ret = 1; 
   if (!yy_parse) return !ret;
   if ((make_mode == mmTree) || (make_mode == mmCode)) {
      ret = yy_parse(this);
   } else if ((make_mode == mmNode) || (make_mode == mmMade)) {
      ret = yy_parse(this);
   } else if (make_mode == mmNone) {
      ret = yy_parse(this);
   }

   return !ret;
}

#define CHAR_LEX(G,T,S)  case (T_Lexeme::gr##G << 8) | T_Symbol::lx##T : current_lexeme.set(T_Lexeme::grNone,S); break;

T_Lexeme::T_Group C_GrammarYSyntax::Lexeme(T_Lexeme &l)
{
   T_Lexeme& current_lexeme = l;
   A_Syntax::Lexeme(current_lexeme);
   UpdateLexeme(current_lexeme);

   int token = !current_lexeme.Match(T_Lexeme::grEof) ? ((current_lexeme.group << 8) | current_lexeme.type) : 0;
   switch (token) {
	CHAR_LEX(Oper,      Or,          '|');
	CHAR_LEX(Oper,      And,         '&');
	CHAR_LEX(Oper,      XOr,         '^');
	CHAR_LEX(Oper,      Tilda,       '~');
	CHAR_LEX(Oper,      Multi,       '*'); 
	CHAR_LEX(Oper,      Div,         '/');
	CHAR_LEX(Oper,      Mod,         '%');
	CHAR_LEX(Oper,      Add,         '+');
	CHAR_LEX(Oper,      Sub,         '-');
	CHAR_LEX(Oper,      Assign,      '=');
	CHAR_LEX(Oper,      Not,         '!');
	CHAR_LEX(Oper,      LT,          '<');
	CHAR_LEX(Oper,      GT,          '>');
	CHAR_LEX(Oper,      Question,    '?');
	CHAR_LEX(Separator, LeftCramp   ,'{');
	CHAR_LEX(Separator, RightCramp  ,'}');
	CHAR_LEX(Separator, LeftBracket ,'(');
	CHAR_LEX(Separator, RightBracket,')');
	CHAR_LEX(Separator, LeftScrape  ,'[');
	CHAR_LEX(Separator, RightScrape ,']');
	CHAR_LEX(Separator, Point,       '.');
	CHAR_LEX(Separator, Semicolon,   ';');
	CHAR_LEX(Separator, Colon,       ':');
	CHAR_LEX(Separator, Comma,       ',');
   }
   return l.group;
}
#ifndef TRN_YSYNTAX_H
#define TRN_YSYNTAX_H

#include "Maker.h"
#include "CGrammar.h"

// --------------------------- YSyntax ---------------------------
class YSyntax : public MC_Syntax, public S_Syntax
{
public:
   YSyntax(T_Scan *s, TGrammar* g) :S_Syntax(g), MC_Syntax(s), tree(NULL), yy_parse(NULL) {}

   bool MakerYACC(const GSymbol& sym, T_Lexeme_SNode* S0, T_Lexeme_SNode* S1, int maker_index = -1);
	virtual bool error_code(T_Error code, int value = 0) { return A_Syntax::error(code,value); }
   virtual void print_symbol(const GSymbol& symbol, int print_mode = 0x01);

   virtual bool ParseYACC();
   virtual void Tree(SNode* node) { tree = node; }
   virtual SNode* Tree()          { return tree; }

   virtual bool Translate();
public:
   SNode* tree;
   int (*yy_parse)(void *YYPARSE_PARAM);
};

int syn_tree(int s1);
int syn_tree(int s1, int s2);
int syn_tree(int s1, int s2, int s3);
int syn_tree(int s1, int s2, int s3, int s4);
int syn_tree(int s1, int s2, int s3, int s4, int s5);

#define L         syn_tree

// --------------------------- ParseYACC ---------------------------
#undef MAKE
#define MAKE(F,P) \
   YSyntax* syntax = (YSyntax*)YYPARSE_PARAM; \
   GSymbol maker(GSymbol::gsMaker,(int)T_Maker::F,P,0,GSymbol::Tree | GSymbol::Code); \
   if (!syntax->Maker(maker)) { \
   }

#define TREE(F,P) \
   YSyntax* syntax = (YSyntax*)YYPARSE_PARAM; \
   GSymbol maker(GSymbol::gsMaker,(int)T_Maker::F,P,0,GSymbol::Tree); \
   if (!syntax->Maker(maker)) { \
   }

#define CODE(F,P) \
   YSyntax* syntax = (YSyntax*)YYPARSE_PARAM; \
   GSymbol maker(GSymbol::gsMaker,(int)T_Maker::F,P,0,GSymbol::Code); \
   if (!syntax->Maker(maker)) { \
   }

#define NODE(T,K,P,S0_,S1_) \
   YSyntax* syntax = (YSyntax*)YYPARSE_PARAM; \
   GSymbol maker(GSymbol::gsMaker,(int)S_Node::T,P,K,GSymbol::SNode); \
   if (!syntax->MakerYACC(maker,&S0_,&S1_,1)) { \
   }

#define YACC(F,P,S0_,S1_) \
   YSyntax* syntax = (YSyntax*)YYPARSE_PARAM; \
   GSymbol maker(GSymbol::gsMaker,(int)T_Maker::F,P,0,GSymbol::Yacc); \
   if (!syntax->MakerYACC(maker,&S0_,&S1_)) { \
   }

#define SAVE(L) \
   YSyntax* syntax = (YSyntax*)YYPARSE_PARAM; \
   syntax->push_lexeme(*(T_Lexeme*)&L);

// --------------------------- C_Grammar_Syntax ---------------------------

class C_GrammarYSyntax : public YSyntax, public C_Grammar_Syntax
{
public:
   C_GrammarYSyntax(T_Scan *s, TGrammar* g) :YSyntax(s,g), C_Grammar_Syntax(this) {}
   virtual bool Command(int command) { return C_Grammar_Syntax::Command(command); }
	virtual T_Lexeme::T_Group Lexeme(T_Lexeme &l);
};

#endif

